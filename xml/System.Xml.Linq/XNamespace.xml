<Type Name="XNamespace" FullName="System.Xml.Linq.XNamespace">
  <TypeSignature Language="C#" Value="public sealed class XNamespace" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit XNamespace extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNamespace" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen XML-Namespace dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt das XML-Konstrukt eines Namespaces.  
  
 Jede <xref:System.Xml.Linq.XName> enthält eine <xref:System.Xml.Linq.XNamespace>. Auch wenn sich ein Element nicht in einem Namespace befindet, enthält der <xref:System.Xml.Linq.XName> des Elements einen Namespace, und zwar <xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType>. Es ist gewährleistet, dass die <xref:System.Xml.Linq.XName.Namespace%2A?displayProperty=nameWithType>-Eigenschaft nicht `null` ist.  
  
## <a name="creating-an-xnamespace-object"></a>Erstellen eines XNamespace-Objekts  
 Die gängigste Methode zum Erstellen einer <xref:System.Xml.Linq.XNamespace> Objekt ist lediglich eine Zeichenfolge zuweisen. Sie können dann den Namespace mit einem lokalen Namen kombinieren, mit der Außerkraftsetzung von den Addition-Operator. Das folgende Beispiel zeigt dieses Technik:  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "Content");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim aw As XNamespace = "http://www.adventure-works.com"  
Dim root As XElement = New XElement(aw + "Root", "Content")  
Console.WriteLine(root)  
```  
  
 Allerdings würde in Visual Basic, Sie in der Regel einen globalen Standardnamespace wie folgt deklariert:  
  
```vb  
  
                Imports <xmlns='http://www.adventure-works.com'>  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = _  
            <Root>Content</Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
  
<Root xmlns="http://www.adventure-works.com">Content</Root>  
```  
  
 Eine Zeichenfolge zum Zuweisen einer <xref:System.Xml.Linq.XNamespace> verwendet die implizite Konvertierung von <xref:System.String>.  
  
 Finden Sie unter [Vorgehensweise: Erstellen eines Dokuments mit Namespaces (c#) (LINQ to XML)](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c) für Weitere Informationen und Beispiele.  
  
 Finden Sie unter [Namespaces in Visual Basic (LINQ to XML)](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc) für Weitere Informationen zur Verwendung von Namespaces in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
## <a name="controlling-namespace-prefixes"></a>Steuern der Namespace-Präfixe  
 Wenn Sie ein Attribut, das einen Namespace deklariert erstellen, wird das im Attribut angegebene Präfix im serialisierten XML beibehalten. Beim Erstellen eines Attributs, das einen Namespace mit einem Präfix deklariert, erstellen Sie ein Attribut, bei dem der Namespace des Namens des Attributs <xref:System.Xml.Linq.XNamespace.Xmlns%2A> lautet und der Name des Attributs das Namespacepräfix ist. Der Wert des Attributs ist der URI des Namespace. Das folgende Beispiel zeigt dieses Technik:  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    "Content");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim aw As XNamespace = "http://www.adventure-works.com"  
Dim root As XElement = New XElement(aw + "Root", _  
    New XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"), _  
    "Content")  
Console.WriteLine(root)  
```  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], statt einen Namespaceknoten zum Steuern von Namespacepräfixen, in der Regel verwenden Sie eine globalen Standardnamespace-Deklaration:  
  
```vb  
  
                Imports <xmlns:aw='http://www.adventure-works.com'>  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = _  
            <aw:Root>Content</aw:Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<aw:Root xmlns:aw="http://www.adventure-works.com">Content</aw:Root>  
```  
  
 Weitere Informationen finden Sie unter [Vorgehensweise: Control-Namespace Präfixen (c#) (LINQ to XML)](http://msdn.microsoft.com/library/a40d4479-f1b9-4d8b-8623-445648caed28).  
  
## <a name="creating-a-default-namespace"></a>Erstellen einen Standard-Namespace  
 Beim Erstellen eines Attributs, die einen Namespace verfügt im Namen des Attributs den speziellen Wert "xmlns" wird Klicken Sie dann bei der Serialisierung der XML-Struktur ist der Namespace als Standard-Namespace deklariert werden. Das spezielle Attribut mit dem Namen "xmlns" selbst ist nicht in allen Namespaces. Der Wert des Attributs ist der Namespace-URI.  
  
 Das folgende Beispiel erstellt eine XML-Struktur, die ein Attribut enthält, die so deklariert ist, dass der Namespace der Standardnamespace ist:  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute("xmlns", "http://www.adventure-works.com"),  
    new XElement(aw + "Child", "content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim aw As XNamespace = "http://www.adventure-works.com"  
Dim root As XElement = New XElement(aw + "Root", _  
    New XAttribute("xmlns", "http://www.adventure-works.com"), _  
    New XElement(aw + "Child", "content") _  
)  
Console.WriteLine(root)  
```  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], statt einen Namespaceknoten, um einen Standardnamespace zu erstellen, verwenden Sie in der Regel eine globalen Standardnamespace-Deklaration:  
  
```vb  
  
                Imports <xmlns='http://www.adventure-works.com'>  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = _  
            <Root>  
                <Child>content</Child>  
            </Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xmlns="http://www.adventure-works.com">  
  <Child>content</Child>  
</Root>  
```  
  
## <a name="xnamespace-atomization"></a>XNamespace Atomisierung  
 Es ist gewährleistet, dass <xref:System.Xml.Linq.XNamespace>-Objekte atomisiert werden, d. h., wenn zwei <xref:System.Xml.Linq.XNamespace>-Objekte exakt denselben URI besitzen, verwenden sie dieselbe Instanz. Gleichheits-und Vergleich werden explizit zu diesem Zweck bereitgestellt.  
  
## <a name="using-expanded-names"></a>Verwenden von erweiterten Namen  
 Eine weitere Möglichkeit zum Angeben eines Namespaces und einen lokalen Namen ist die Verwendung einen erweiterten Namen im Format `{namespace}name`:  
  
```csharp  
XElement e = new XElement("{http://www.adventure-works.com}Root",  
     new XAttribute("{http://www.adventure-works.com}Att", "content")  
);  
Console.WriteLine(e);  
```  
  
```vb  
  
                Dim e As XElement = New XElement("{http://www.adventure-works.com}Root", _  
     New XAttribute("{http://www.adventure-works.com}Att", "content") _  
)  
Console.WriteLine(e)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root p1:Att="content" xmlns:p1="http://www.adventure-works.com" xmlns="http://www.adventure-works.com" />  
```  
  
 Dieser Ansatz wirkt sich aber negativ auf die Leistung aus. Jedes Mal, wenn Sie eine Zeichenfolge, die einen erweiterten Namen enthält, an [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] übergeben, muss der Name analysiert und nach dem atomisierten Namespace und dem atomisierten Namen gesucht werden. Dieser Prozess nimmt CPU-Zeit in Anspruch. Wenn die Leistung wichtig ist, empfiehlt es sich um einen anderen Ansatz.  
  
 Mit Visual Basic wird empfohlen, XML-Literale, verwenden die nicht mit die Verwendung von erweiterten Namen beinhaltet.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die <see cref="T:System.Xml.Linq.XNamespace" /> zum Vergleichen mit der aktuellen <see cref="T:System.Xml.Linq.XNamespace" />.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Xml.Linq.XNamespace" /> und das aktuelle <see cref="T:System.Xml.Linq.XNamespace" /> gleich sind.</summary>
        <returns>Ein <see cref="T:System.Boolean" /> , der angibt, ob das angegebene <see cref="T:System.Xml.Linq.XNamespace" /> ist gleich dem aktuellen <see cref="T:System.Xml.Linq.XNamespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für zwei <xref:System.Xml.Linq.XNamespace> Objekte sind gleich, müssen sie denselben URI aufweisen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Namespaces, die auf der gleichen URI verweisen.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
Console.WriteLine(aw == "http://www.adventure-works.com");  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Console.WriteLine(GetXmlNamespace(aw) = "http://www.adventure-works.com")  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNamespace Get (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNamespace Get(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.Get(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">Ein <see cref="T:System.String" /> , einen Namespace-URI enthält.</param>
        <summary>Ruft eine <see cref="T:System.Xml.Linq.XNamespace" /> für den angegebenen Uniform Resource Identifier (URI).</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XNamespace" /> erstellt aus den angegebenen URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Xml.Linq.XNamespace> Objekt wird sichergestellt, dass es sich um atomar zu sein (d. h. es ist die einzige im System für diesen bestimmten URI).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Xml.Linq.XNamespace> aus einem angegebenen URI.  
  
```csharp  
  
                XNamespace aw = XNamespace.Get("http://www.adventure-works.com");  
  
// This is the preferred form.  
XNamespace aw2 = "http://www.adventure-works.com";  
Console.WriteLine(aw);  
Console.WriteLine(aw2);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = XNamespace.Get("http://www.adventure-works.com")  
  
        ' This is the preferred form.  
        Dim aw2 As XNamespace = GetXmlNamespace(aw)  
        Console.WriteLine(aw)  
        Console.WriteLine(aw2)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
http://www.adventure-works.com  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für diese <see cref="T:System.Xml.Linq.XNamespace" /> ab.</summary>
        <returns>Ein <see cref="T:System.Int32" /> , enthält den Hashcode für die <see cref="T:System.Xml.Linq.XNamespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient als Hashfunktion für <xref:System.Xml.Linq.XNamespace>. Sie können <xref:System.Xml.Linq.XNamespace.GetHashCode%2A> in Hashalgorithmen und Datenstrukturen wie Hashtabellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName GetName (string localName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XName GetName(string localName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.GetName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Ein <see cref="T:System.String" /> , einen lokalen Namen enthält.</param>
        <summary>Gibt eine <see cref="T:System.Xml.Linq.XName" /> daraus erstellte Objekt <see cref="T:System.Xml.Linq.XNamespace" /> und dem angegebenen lokalen Namen.</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XName" /> erstellt, die von diesem <see cref="T:System.Xml.Linq.XNamespace" /> und dem angegebenen lokalen Namen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Xml.Linq.XName> Objekt wird sichergestellt, dass es sich um atomar zu sein (d. h. es ist die einzige im System für einen bestimmten erweiterten Namen).  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft zum Abrufen einer <xref:System.Xml.Linq.XName>.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XName name = aw.GetName("Root");  
Console.WriteLine("{0}", name);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace(aw)  
        Dim name As XName = aw.GetName("Root")  
        Console.WriteLine("{0}", name)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
{http://www.adventure-works.com}Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceName">
      <MemberSignature Language="C#" Value="public string NamespaceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNamespace.NamespaceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Uniform Resource Identifier (URI) dieses Namespaces ab.</summary>
        <value>Ein <see cref="T:System.String" /> , die den URI des Namespaces enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie diese Eigenschaft verwendet wird:  
  
```csharp  
  
                string markup =  
@"<aw:Root  
    xmlns:aw='http://www.adventure-works.com'/>";  
XElement root = XElement.Parse(markup);  
Console.WriteLine(root.Name.Namespace.NamespaceName);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace(aw)  
        Dim root As XElement = <aw:Root/>  
        Console.WriteLine(root.Name.Namespace.NamespaceName)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNamespace None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNamespace None" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNamespace.None" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xml.Linq.XNamespace" /> -Objekt, das keinem Namespace entspricht.</summary>
        <value>Die <see cref="T:System.Xml.Linq.XNamespace" /> , die nicht in einem Namespace entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element oder Attribut in keinem Namespace befindet, wird dessen Namespace für den Namespace, die von dieser Eigenschaft zurückgegebene festgelegt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt diese Eigenschaft, um zu bestimmen, welche Elemente werden in keinem Namespace verwendet.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
  
XElement root = new XElement("Root",  
    new XElement(aw + "ChildInNamespace", "content"),  
    new XElement("ChildInNoNamespace", "content")  
);  
  
if (root.Name.Namespace == XNamespace.None)  
    Console.WriteLine("Root element is in no namespace");  
else  
    Console.WriteLine("Root element is in a namespace");  
  
if (root.Element(aw + "ChildInNamespace").Name.Namespace == XNamespace.None)  
    Console.WriteLine("ChildInNamespace element is in no namespace");  
else  
    Console.WriteLine("ChildInNamespace element is in a namespace");  
  
if (root.Element("ChildInNoNamespace").Name.Namespace == XNamespace.None)  
    Console.WriteLine("ChildInNoNamespace element is in no namespace");  
else  
    Console.WriteLine("ChildInNoNamespace element is in a namespace");  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = _  
            <Root>  
                <aw:ChildInNamespace>content</aw:ChildInNamespace>  
                <ChildInNoNamespace>content</ChildInNoNamespace>  
            </Root>  
  
        If (root.Name.Namespace Is XNamespace.None) Then  
            Console.WriteLine("Root element is in no namespace")  
        Else  
            Console.WriteLine("Root element is in a namespace")  
        End If  
  
        If (root.Element(GetXmlNamespace(aw) + "ChildInNamespace") _  
                .Name.Namespace Is XNamespace.None) Then  
            Console.WriteLine("ChildInNamespace element is in no namespace")  
        Else  
            Console.WriteLine("ChildInNamespace element is in a namespace")  
        End If  
  
        If (root.Element("ChildInNoNamespace") _  
                .Name.Namespace Is XNamespace.None) Then  
            Console.WriteLine("ChildInNoNamespace element is in no namespace")  
        Else  
            Console.WriteLine("ChildInNoNamespace element is in a namespace")  
        End If  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
Root element is in no namespace  
ChildInNamespace element is in a namespace  
ChildInNoNamespace element is in no namespace  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName operator + (System.Xml.Linq.XNamespace ns, string localName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Xml.Linq.XName op_Addition(class System.Xml.Linq.XNamespace ns, string localName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.op_Addition(System.Xml.Linq.XNamespace,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.Xml.Linq.XNamespace" />
        <Parameter Name="localName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ns">Eine <see cref="T:System.Xml.Linq.XNamespace" /> , die den Namespace enthält.</param>
        <param name="localName">Ein <see cref="T:System.String" /> , die den lokalen Namen enthält.</param>
        <summary>Kombiniert ein <see cref="T:System.Xml.Linq.XNamespace" /> Objekt mit einem lokalen Namen zum Erstellen einer <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>Die neue <see cref="T:System.Xml.Linq.XName" /> aus dem Namespace und lokalen Namen erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Operator können die allgemeine Vorgehensweise einer Kombination aus Namespace und einen lokalen Namen, die zur Erstellung eines Elements oder Attributs. Diese Technik bietet einige ergeben sich folgende Vorteile Namespace-Präfixe, da Sie verweisen können, um einen Namespace mit einer Variablen, die kurz ist. Diese Auswertung eliminiert syntaktische Störungen in den Code, der XML-Strukturen erstellt.  
  
 Ist die entsprechende Methode für diesen Operator? QualifyHint = "true" & AutoUpgrade = "false"  
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung von der `+` Operator zum Erstellen einer <xref:System.Xml.Linq.XName> aus einer <xref:System.Xml.Linq.XNamespace> und einem lokalen Namen.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim aw As XNamespace = "http://www.adventure-works.com"  
Dim root As XElement = New XElement(aw + "Root", _  
    New XElement(aw + "Child") _  
)  
Console.WriteLine(root)  
```  
  
 Dies ist die bevorzugte Sprache, in Visual Basic:  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace()  
        Dim root As XElement = _  
            <Root>  
                <Child/>  
            </Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xmlns="http://www.adventure-works.com">  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xml.Linq.XNamespace left, System.Xml.Linq.XNamespace right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xml.Linq.XNamespace left, class System.Xml.Linq.XNamespace right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.op_Equality(System.Xml.Linq.XNamespace,System.Xml.Linq.XNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XNamespace" />
        <Parameter Name="right" Type="System.Xml.Linq.XNamespace" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Xml.Linq.XNamespace" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Xml.Linq.XNamespace" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen von <see cref="T:System.Xml.Linq.XNamespace" /> gleich sind.</summary>
        <returns>Ein <see cref="T:System.Boolean" /> , der angibt, ob <paramref name="left" /> und <paramref name="right" /> gleich sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die überladenen `==` und `!=` werden bereitgestellt, um Vergleiche zwischen <xref:System.Xml.Linq.XNamespace> und Zeichenfolge (z. B. `element.Name.Namespace == "http://www.adventure-works.com"`). Die vordefinierten Gleichheitsoperatoren in c# erfordern einen Operanden in den Typ der anderen über verweiskonvertierungen nur konvertierbar sein und sollten nicht die implizite Konvertierung von String in <xref:System.Xml.Linq.XNamespace>.  
  
 Ist die entsprechende Methode für diesen Operator? QualifyHint = "true" & AutoUpgrade = "false"  
  
## Examples  
 Das folgende Beispiel zeigt den Vergleich von einer <xref:System.Xml.Linq.XNamespace> und eine Zeichenfolge.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
Console.WriteLine(aw == "http://www.adventure-works.com");  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace()  
        Console.WriteLine(aw = "http://www.adventure-works.com")  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Xml.Linq.XNamespace (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Xml.Linq.XNamespace op_Implicit(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.op_Implicit(System.String)~System.Xml.Linq.XNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xml.Linq.XNamespace left, System.Xml.Linq.XNamespace right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xml.Linq.XNamespace left, class System.Xml.Linq.XNamespace right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.op_Inequality(System.Xml.Linq.XNamespace,System.Xml.Linq.XNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XNamespace" />
        <Parameter Name="right" Type="System.Xml.Linq.XNamespace" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Xml.Linq.XNamespace" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Xml.Linq.XNamespace" />.</param>
        <summary>Gibt einen Wert, der angibt, ob zwei Instanzen der <see cref="T:System.Xml.Linq.XNamespace" /> ungleich sind.</summary>
        <returns>Ein <see cref="T:System.Boolean" /> , der angibt, ob <paramref name="left" /> und <paramref name="right" /> ungleich sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die überladenen `==` und `!=` werden bereitgestellt, um Vergleiche zwischen <xref:System.Xml.Linq.XNamespace> und Zeichenfolge (z. B. `element.Name.Namespace == "http://www.adventure-works.com"`). Die vordefinierten Gleichheitsoperatoren in c# erfordern einen Operanden in den Typ der anderen über verweiskonvertierungen nur konvertierbar sein und sollten nicht die implizite Konvertierung von String in <xref:System.Xml.Linq.XNamespace>.  
  
 Ist die entsprechende Methode für diesen Operator? QualifyHint = "true" & AutoUpgrade = "false"  
  
## Examples  
 Das folgende Beispiel zeigt einen Vergleich eine <xref:System.Xml.Linq.XNamespace> in eine Zeichenfolge.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
Console.WriteLine(aw != "http://www.adventure-works.com");  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace()  
        Console.WriteLine(aw <> "http://www.adventure-works.com")  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNamespace.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den URI dieses <see cref="T:System.Xml.Linq.XNamespace" />.</summary>
        <returns>Der URI dieses <see cref="T:System.Xml.Linq.XNamespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird diese Methode einen Namespace in der Konsole gedruckt.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
Console.WriteLine("{0}", aw.ToString());  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim aw As XNamespace = GetXmlNamespace()  
        Console.WriteLine("{0}", aw)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNamespace Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNamespace Xml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNamespace.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xml.Linq.XNamespace" /> -Objekt, das an den XML-URI entspricht (<c>http://www.w3.org/XML/1998/namespace</c>).</summary>
        <value>Die <see cref="T:System.Xml.Linq.XNamespace" /> , entspricht dem XML-URI (<c>http://www.w3.org/XML/1998/namespace</c>).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Attribute, z. B. standardisiert `space`, befinden sich in der `http://www.w3.org/XML/1998/namespace` Namespace. Die W3C-Standard gibt an, dass dieser Namespace nicht als Attribut in der XML-Struktur deklariert werden. Es ist einem reservierten Namespace, der immer automatisch in der XML-Parser verfügbar ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer `xml:space="preserve"` Attribut in einer XML-Struktur:  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute(XNamespace.Xml + "space", "preserve"),  
    new XElement("Child", "content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root xml:space="preserve">  
        <Child>content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xml:space="preserve">  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xmlns">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNamespace Xmlns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNamespace Xmlns" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNamespace.Xmlns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xml.Linq.XNamespace" /> -Objekt, das dem Xmlns-URI entspricht (<c>http://www.w3.org/2000/xmlns/</c>).</summary>
        <value>Die <see cref="T:System.Xml.Linq.XNamespace" /> , entspricht der **Xmlns** URI (<c>http://www.w3.org/2000/xmlns/</c>).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Namespaces deklarieren, befinden sich die Namespaceattribute selbst in die **Xmlns** Namespace. Die W3C-Standard gibt an, dass dieser Namespace nicht als Attribut in der XML-Struktur deklariert werden. Es ist einem reservierten Namespace, der immer automatisch in der XML-Parser verfügbar ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie eine XML-Struktur einen Namespace hinzugefügt. Der Namespace für das Attribut, das den Namespace deklariert ist, der von dieser Eigenschaft zurückgegebene Namespace.  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Child", "content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root = <aw:Root xmlns:aw="http://www.adventure-works.com">  
               <aw:Child>content</aw:Child>  
           </aw:Root>  
Console.WriteLine(root)  
```  
  
 In Visual Basic ist die bevorzugte Sprache:  
  
```vb  
Imports <xmlns:aw='http://www.adventure-works.com'>  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = _  
            <aw:Root>  
                <aw:Child>content</aw:Child>  
            </aw:Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
  <aw:Child>content</aw:Child>  
</aw:Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
