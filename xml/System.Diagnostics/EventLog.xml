<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Interaktion mit Windows-Ereignisprotokollen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>ermöglicht Ihnen Zugriff auf oder Anpassen von Windows-Ereignisprotokollen, die Informationen über wichtige Software- oder Hardwarefehlern Ereignisse aufzeichnen. Mithilfe von <xref:System.Diagnostics.EventLog>, Sie können aus vorhandenen Protokolle lesen, Einträge in Protokolle schreiben, erstellen oder Löschen von Ereignisquellen, Protokolle löschen und reagieren, um Einträge zu protokollieren. Sie können auch neue Protokolle erstellen, wenn eine Ereignisquelle erstellen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
 Zusätzlich zu den Zugriff auf einzelne Ereignisprotokolle und deren Einträge dem <xref:System.Diagnostics.EventLog> Klasse ermöglicht den Zugriff auf die Auflistung sämtlicher Ereignisprotokolle. Sie können die `static` Mitglieder der <xref:System.Diagnostics.EventLog> zum Löschen von Protokollen Protokolllisten abrufen, erstellen oder löschen eine Quelle oder zu bestimmen, ob ein Computer bereits eine bestimmte Quelle enthält.  
  
 Es gibt drei Standard-Ereignisprotokolle: Anwendung, System und Sicherheit. Sicherheitsprotokoll ist schreibgeschützt. Andere Anwendungen und Dienste, die Sie, die z. b. Active Directory installieren möglicherweise zusätzliche Ereignisprotokolle.  
  
 Es sind Sicherheitsaspekte zu, bei Verwendung der <xref:System.Diagnostics.EventLog> Klasse. <xref:System.Diagnostics.EventLog>erfordert <xref:System.Diagnostics.EventLogPermission> Berechtigungen für bestimmte Aktionen in der .NET Framework 2.0 und höheren Versionen oder voll vertrauenswürdig in .NET Framework 1.0 und 1.1. Es wird empfohlen, die <xref:System.Diagnostics.EventLogPermission> nicht teilweise vertrauenswürdigem Code erteilt werden.  Übergeben Sie ein Ereignisprotokoll-Objekt, einschließlich <xref:System.Diagnostics.EventLogEntryCollection> und <xref:System.Diagnostics.EventLogEntry> Objekte an weniger vertrauenswürdigen Code. Erstellen Sie z. B. ein <xref:System.Diagnostics.EventLog> -Objekt, das Schreiben eines Eintrags und deren Übergabe der <xref:System.Diagnostics.EventLog> Objekt teilweise vertrauenswürdigem Code kann ein Sicherheitsproblem erstellen, da die Möglichkeit zum Lesen und Schreiben in das Ereignisprotokoll schreiben Code zum Ausführen von Aktionen, z. B. die Ausgabe kann ereignisprotokollmeldungen für den Namen einer anderen Anwendung.  
  
 Ab Windows Vista, bestimmt Benutzerkontensteuerung (UAC), die Anmeldeinformationen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Anmeldeinformationen von Standardbenutzer auf Administrator erhöhen. Sie können dies geschieht, wenn Sie eine Anwendung starten, indem Sie das Kontextmenü für die Anwendung öffnen (Wenn Sie eine Maus verwenden, rechtsklicken Sie das Symbol "Anwendung") und angeben, die Sie als Administrator ausführen möchten.  
  
 Sie können <xref:System.Diagnostics.EventLog> benutzerdefinierten Ereignisprotokolle zu erstellen, die Sie über den Server anzeigen können die Ereignisanzeige. Verwenden der <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Methode, um einen lokalisierten Namen für das Ereignisprotokoll in der Ereignisanzeige anzeigen. Verwenden der <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Methode, um das Verhalten des Ereignisprotokolls konfigurieren, wenn sie die maximale Protokollgröße erreicht.  
  
 Um aus einem Ereignisprotokoll lesen zu können, geben Sie den Protokollnamen (<xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft) und den Computernamen des Servers (<xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft für das Ereignisprotokoll. Wenn Sie den Namen des Servers, des lokalen Computers angeben ".", wird angenommen. Es ist nicht notwendig, dass die Ereignisquelle angeben (<xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft), da eine Quelle nur für das Schreiben in Protokolle erforderlich ist. Die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft wird automatisch mit der Liste der Einträge des Ereignisprotokolls aufgefüllt.  
  
 Klicken Sie zum Schreiben in ein Ereignisprotokoll angeben, oder erstellen Sie eine Ereignisquelle (<xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft). Sie benötigen Administratoranmeldeinformationen auf dem Computer eine neue Ereignisquelle erstellen. Die Ereignisquelle registriert die Anwendung im Ereignisprotokoll als gültige Quelle für Einträge. Sie können die Ereignisquelle verwenden, zu einem Zeitpunkt in nur ein Protokoll zu schreiben. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft kann eine beliebige Zeichenfolge sein, aber der Name muss sich von anderen Quellen auf dem Computer sein. Die Ereignisquelle ist in der Regel der Name der Anwendung oder eine andere identifizierende Zeichenfolge. Beim Erstellen eines Duplikats <xref:System.Diagnostics.EventLog.Source%2A> Wert löst eine Ausnahme aus. Allerdings kann ein einzelnes Ereignisprotokoll mehrere Quellen zugeordnet sein.  
  
 Wenn die Ereignisquelle für das Ereignisprotokoll zugeordnet der <xref:System.Diagnostics.EventLog> Instanz ist nicht vorhanden, wird eine neue Ereignisquelle erstellt. Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie die administrative Anmeldeinformationen verfügen.  
  
 Diese Anforderung ist, da alle Ereignisprotokolle, einschließlich von Sicherheitsprotokollen, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista, verfügen Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zuzugreifen; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
  
> [!IMPORTANT]
>  Das Erstellen oder Löschen einer Ereignisquelle erfordert Synchronisierung des zugrunde liegenden Codes über einen benannten Mutex. Wenn eine Anwendung mit weit reichenden Berechtigungen den benannten Mutex gesperrt wurde, wird das Erstellen oder löschen eine Ereignisquelle möchten die Anwendung nicht mehr reagiert, bis die Sperre aufgehoben wird. Um dieses Problem zu vermeiden, gewähren Sie niemals <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung an nicht vertrauenswürdigen Code. Darüber hinaus <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung potenziell ermöglicht anderen Berechtigungen zu umgehen und sollte nur für hoch vertrauenswürdigen Code erteilt werden.  
  
 Anwendungen und Dienste sollten in das Anwendungsprotokoll oder in ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten im Systemprotokoll schreiben. Wenn Sie nicht explizit festlegen der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, das Ereignisprotokoll verwendet standardmäßig Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Es ist nichts zu verhindern, dass eine Anwendung schreiben, die als Quelle für alle registrierten.  Wenn eine Anwendung erteilt werden <xref:System.Diagnostics.EventLogPermissionAccess.Write> Berechtigung, Schreiben sie Ereignisse für jede gültige Quelle auf dem Computer registriert ist.  
  
 Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methoden, Ereignisse in ein Ereignisprotokoll schreiben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem noch nicht seine Liste der Ereignisquellen aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können eine neue Datenquelle konfigurieren, mithilfe einer <xref:System.Diagnostics.EventLogInstaller> Objekt oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratoranmeldeinformationen auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann Ihre Anwendung mehreren Quellen verwenden, um mehrere Ereignisprotokolle geschrieben. Ihre Anwendung erfordert z. B. möglicherweise mehrere Quellen für unterschiedliche Ereignisprotokolle oder Ressourcendateien konfiguriert. Um die Einzelheiten der Konfiguration einer vorhandenen Datenquelle zu ändern, müssen Sie der Quelle löschen und dann mit die neue Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration anstelle die vorhandene Quelle wird gelöscht.  
  
 Sie können die Ereignisquelle mit lokalisierten Ressourcen für die Ereignis-Zeichenfolgen für Eigenschaftenkategorien und Nachricht registrieren. Die Anwendung kann die Einträge im Ereignisprotokoll schreiben, mithilfe der Ressourcen-IDs die tatsächlichen Zeichenfolgenwerte angeben, statt. Finden Sie in der <xref:System.Diagnostics.EventLogInstaller> und <xref:System.Diagnostics.EventSourceCreationData> Klassen für Weitere Informationen zum Konfigurieren der Quelle mit Ressourcendateien.  
  
 Wenn Ihre Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt, müssen Sie keinen der Dateieigenschaften für die Quelle der Ressourcensatz. Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
 Beim Schreiben von Ereignissen, müssen Sie mindestens eine Meldungszeichenfolge oder den Ressourcenbezeichner für eine Meldungszeichenfolge angeben. Andere Ereigniseigenschaften sind optional. Die folgenden: Beispiele für optionale ereigniseinstellungen  
  
-   Sie können festlegen, die <xref:System.Diagnostics.EventLogEntryType> auf das Symbol angeben, in dem die Ereignisanzeige für den Eintrag angezeigt.  
  
-   Sie können eine Kategorie-ID für das Ereignis angeben, wenn Ihre Anwendung Kategorien, der zum Filtern der Ereignisse verwendet.  
  
-   Sie können Ihre Ereigniseintrag binäre Daten anfügen, wenn zusätzliche Informationen mit einem bestimmten Ereignis zugeordnet werden soll.  
  
> [!IMPORTANT]
>  Protokollieren von Ereignissen beansprucht Speicherplatz, Prozessorzeit und andere Systemressourcen. Es ist wichtig, nur wichtige Informationen protokollieren. Es wird empfohlen, dass Sie Aufrufe des Ereignisprotokolls in einem Fehlerpfad platzieren, anstatt im Haupt-Codepfad, sodass sie nicht Leistung beeinträchtigen.  
  
 Eine Liste der anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>, finden Sie unter der <xref:System.Diagnostics.EventLog.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Ereignisquelle `MySource` , wenn er bereits vorhanden ist, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
> [!NOTE]
>  Ab Windows Vista, müssen Sie diese Anwendung als Administrator ausführen.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Die Instanz wird keinem Protokoll zugeordnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft von der <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll können alternativ Geben Sie nur die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der lokale Computer (".").|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem lokalen Computer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem lokalen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` Parameter. Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft von der <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll können alternativ Geben Sie nur die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen. Diese Überladung des Konstruktors gibt die <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, aber Sie können ändern, dies vor dem Lesen der <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft.  
  
 Wenn Sie die Quelle im Angeben der <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft ist aus anderen Quellen auf dem Computer, ein nachfolgender Aufruf von eindeutigen <xref:System.Diagnostics.EventLog.WriteEntry%2A> erstellt ein Protokoll mit dem angegebenen Namen, wenn sie nicht bereits vorhanden ist.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Die `logName` Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der lokale Computer (".").|  
  
   
  
## Examples  
 Das folgende Beispiel liest die Einträge in das Ereignisprotokoll "MyNewLog" auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Name des Protokolls ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` Parameter und die <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaft, um die `machineName` Parameter. Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft von der <xref:System.Diagnostics.EventLog>. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll können alternativ Geben Sie nur die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Diese Überladung des Konstruktors gibt die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften, aber Sie können ändern, entweder vor dem Lesen der <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Die `logName` Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Die `machineName` Parameter.|  
  
   
  
## Examples  
 Im folgende Beispiel werden die Einträge in das Ereignisprotokoll "MyNewLog" auf dem Computer "MyServer" gelesen.  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Name des Protokolls ist ungültig.  
  
 - oder -   
  
 Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <param name="source">Die Quelle für Ereignisprotokolleinträge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu und erstellt die angegebene Quelle bzw. weist diese dem <see cref="T:System.Diagnostics.EventLog" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` Parameter, die <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaft, um die `machineName` Parameter, und die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft, um die `source` Parameter. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft ist erforderlich, wenn Sie in ein Ereignisprotokoll schreiben. Jedoch, wenn Sie nur das Lesen aus einem Ereignisprotokoll nur sind die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften erforderlich sind, (solange das Ereignisprotokoll auf dem Server eine Quelle, die bereits zugeordnet ist). Wenn Sie nur das Lesen aus dem Ereignisprotokoll sind, möglicherweise eine andere Überladung des Konstruktors ausreichen.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Die `source` Parameter.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Die `logName` Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Die `machineName` Parameter.|  
  
   
  
## Examples  
 Das folgende Beispiel schreibt einen Eintrag in ein Ereignisprotokoll "MyNewLog", auf dem lokalen Computer, die mit der Quelle "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Name des Protokolls ist ungültig.  
  
 - oder -   
  
 Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.Diagnostics.EventLog" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf Umgebung verwendet diese Methode, um die Initialisierung einer Komponente in einem Formular oder von einer anderen Komponente verwendet zu starten. Die <xref:System.Diagnostics.EventLog.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> Methoden verhindern, dass das Steuerelement verwendet wird, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" />wurde bereits initialisiert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Einträge aus dem Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisprotokolle werden mit einer maximalen Größe festgelegt, die bestimmt, wie viele Einträge sie enthalten können. Wenn ein Ereignisprotokoll voll ist, beendet die Aufzeichnung von neuen Ereignisinformationen oder beginnt, frühere Einträge werden überschrieben. Wenn die Aufzeichnung von Ereignissen beendet wird, können Sie diese Methode verwenden, löschen Sie das Protokoll des bereits vorhandenen Einträge und ermöglichen es zum Aufzeichnen von Ereignissen erneut zu starten. Sie benötigen Administratorberechtigungen auf dem Computer, auf denen sich das Protokoll zum Löschen der Einträge im Ereignisprotokoll befindet.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A>Schließt das Ereignisprotokoll, die Ereignishandles frei, ruft neue Lese- und Schreibhandles, und das Ereignisprotokoll wird daraufhin wieder geöffnet. Nach dem Aufruf der Methode empfangene Ereignisse werden nicht zusammen mit der vorhandenen Ereignisse gelöscht.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Ereignisprotokoll gelöscht.  
  
> [!CAUTION]
>  Da Anwendung, System, Sicherheit und andere nicht benutzerdefinierte Protokolle wichtige Informationen enthalten können; Achten Sie darauf, dass Sie ein benutzerdefiniertes Protokoll vor dem Ausführen dieses Beispiels den Code angeben. Dieses Beispiel löscht das benutzerdefinierte Protokoll `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -   
  
 Das Protokoll kann nicht geöffnet werden. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">Wird kein Wert angegeben, für die <see cref="P:System.Diagnostics.EventLog.Log" /> Eigenschaft. Stellen Sie sicher, dass der Name des Protokolls nicht um eine leere Zeichenfolge ist.</exception>
        <exception cref="T:System.InvalidOperationException">Das Protokoll ist nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das Ereignisprotokoll und gibt Lese- und Schreibhandles frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.Close%2A> Methode wird aufgerufen, indem Sie den geschützten <xref:System.ComponentModel.Component.Dispose%2A> Methode. Sie müssen nicht aufrufen <xref:System.Diagnostics.EventLog.Close%2A> vor dem Aufruf <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Lesen des Ereignisprotokolls oder Schreibhandle wurde nicht erfolgreich freigegeben.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Die Konfigurationseigenschaften für die Ereignisquelle und ihr Zielereignisprotokoll.</param>
        <summary>Richtet mit den angegebenen Konfigurationseigenschaften für die Ereignisquelle und dem entsprechenden Ereignisprotokoll als gültige Ereignisquelle zum Schreiben lokalisierter Ereignismeldungen ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Datenquelle für das Schreiben von Einträgen in ein Ereignisprotokoll auf dem lokalen Computer oder einem Remotecomputer zu konfigurieren. Es ist nicht notwendig, diese Methode zum Lesen aus einem Ereignisprotokoll verwenden.  
  
 Die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode verwendet die Eingabe `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> und <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> Eigenschaften Registrierungswerte auf dem Zielcomputer für die neue Quelle und das zugeordnete Ereignisprotokoll erstellen. Ein neuen Quellennamen kann nicht mit den Datenquellennamen einer vorhandenen oder einen vorhandenen Ereignisprotokollnamen auf dem Zielcomputer übereinstimmen. Wenn die <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> Eigenschaft nicht festgelegt ist, wird die Quelle für das Anwendungsereignisprotokoll registriert. Wenn die <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> ist nicht festgelegt ist, wird die Quelle auf dem lokalen Computer registriert ist.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista, verfügen Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zuzugreifen; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
>   
>  Ab Windows Vista, bestimmt Benutzerkontensteuerung (UAC), die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Ereignisse in ein Ereignisprotokoll schreiben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Datenquelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Dateinamenerweiterung ".evt".  
  
 Jede Quelle kann nur jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann Ihre Anwendung mehreren Quellen verwenden, um mehrere Ereignisprotokolle geschrieben. Ihre Anwendung erfordert z. B. möglicherweise mehrere Quellen für unterschiedliche Ereignisprotokolle oder Ressourcendateien konfiguriert.  
  
 Sie können die Ereignisquelle mit lokalisierten Ressourcendatei für die Ereignis-Zeichenfolgen für Eigenschaftenkategorien und Nachricht registrieren. Schreiben der Anwendung kann Einträge im Ereignisprotokoll mithilfe der Ressourcen-IDs, anstatt die tatsächliche Zeichenfolge anzugeben. Die Ereignisanzeige verwendet den Ressourcenbezeichner suchen und Anzeigen der entsprechenden Zeichenfolge aus der lokalisierten Ressourcendatei basierend auf der aktuellen spracheinstellungen. Sie können eine separate Datei für Ereigniskategorien, Nachrichten und Einfügung Parameterzeichenfolgen registrieren, oder Sie können die gleichen Ressourcendatei für alle drei Typen von Zeichenfolgen. Verwenden der <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, und <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> Eigenschaften zur Konfiguration der Quelle zum Schreiben lokalisierter Einträge in das Ereignisprotokoll geschrieben. Wenn Ihre Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt, müssen Sie nicht zum Festlegen dieser Eigenschaften.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
 Um die Einzelheiten der Konfiguration einer vorhandenen Datenquelle zu ändern, müssen Sie der Quelle löschen und dann mit die neue Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration an, anstatt durch das Löschen der vorhandenen Quelle.  
  
> [!NOTE]
>  Wenn eine Quelle für ein Ereignisprotokoll konfiguriert ist und Sie für ein anderes Ereignisprotokoll konfigurieren, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Ereignisquelle benannt `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignisquelle nicht vorhanden ist, wird im Beispiel legt die Nachricht Ressourcendatei für die Quelle und die neue Ereignisquelle erstellt. Im Beispiel wird schließlich den lokalisierten Anzeigenamen für das Ereignisprotokoll, wobei die Ressourcen-ID-Wert in `DisplayNameMsgId` und den Pfad der Ressource in `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen. Ressourcenbezeichner 5001 wird insbesondere für den lokalisierten Namen des Ereignisprotokolls definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Computername, der im angegebenen <paramref name="sourceData" /> ist ungültig.  
  
 \- oder –  
  
 Der Quellenname, die im angegebenen <paramref name="sourceData" /> ist <see langword="null" />.  
  
 \- oder –  
  
 Der Protokollname im angegebenen <paramref name="sourceData" /> ist ungültig. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und darf die Zeichen nicht enthalten ' * ','?', oder "\\".  
  
 \- oder –  
  
 Der Protokollname im angegebenen <paramref name="sourceData" /> gilt nicht für Benutzer Protokoll erstellen. Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
 \- oder –  
  
 Der Protokollname entspricht einem vorhandenen Name der Ereignisquelle.  
  
 \- oder –  
  
 Der Quellenname, die im angegebenen <paramref name="sourceData" /> führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.  
  
 \- oder –  
  
 Die ersten 8 Zeichen des Protokollnamens, der im angegebenen <paramref name="sourceData" /> sind nicht eindeutig.  
  
 \- oder –  
  
 Der Quellenname, die im angegebenen <paramref name="sourceData" /> ist bereits registriert.  
  
 \- oder –  
  
 Der Quellenname, die im angegebenen <paramref name="sourceData" /> entspricht dem Namen einer vorhandenen Ereignisprotokoll.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Quellenname, unter dem die Anwendung auf dem lokalen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem lokalen Computer ein. Diese Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem lokalen Computer erstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder zu erstellen und registrieren Sie einen <xref:System.Diagnostics.EventLog.Source%2A> in ein vorhandenes Protokoll auf dem lokalen Computer.  
  
 Wenn `logName` ist `null` oder eine leere Zeichenfolge ("") beim Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll. Wenn das Protokoll auf dem lokalen Computer nicht vorhanden ist, wird das System ein benutzerdefiniertes Protokoll erstellt und registriert die Anwendung als eine <xref:System.Diagnostics.EventLog.Source%2A> für dieses Protokoll.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista, verfügen Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zuzugreifen; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Sie müssen nur eine Ereignisquelle erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle im Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A> das entsprechende Protokoll, in dem der Eintrag gefunden. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder Angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie eine Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A> beim Lesen aus einem Protokoll oder des lokalen Computers (".") wird angenommen.  
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Ereignisse in ein Ereignisprotokoll schreiben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Datenquelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Dateinamenerweiterung ".evt".  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein; ein neuen Quellennamen kann nicht mit den Datenquellennamen einer vorhandenen oder einen vorhandenen Ereignisprotokollnamen übereinstimmen. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann Ihre Anwendung mehreren Quellen verwenden, um mehrere Ereignisprotokolle geschrieben. Ihre Anwendung erfordert z. B. möglicherweise mehrere Quellen für unterschiedliche Ereignisprotokolle oder Ressourcendateien konfiguriert.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
 Um die Einzelheiten der Konfiguration einer vorhandenen Datenquelle zu ändern, müssen Sie der Quelle löschen und dann mit die neue Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration an, anstatt durch das Löschen der vorhandenen Quelle.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie ein neues Protokoll zuordnen, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />ist eine leere Zeichenfolge ("") oder <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="logName" />ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und darf die Zeichen nicht enthalten ' * ','?', oder "\\".  
  
 \- oder –  
  
 <paramref name="logName" />gilt nicht für Benutzer Protokoll erstellen. Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
 \- oder –  
  
 Der Protokollname entspricht einem vorhandenen Name der Ereignisquelle.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.  
  
 \- oder –  
  
 Die ersten 8 Zeichen des <paramref name="logName" /> Übereinstimmung mit den ersten 8 Zeichen des Namens einer vorhandenen Ereignisprotokoll.  
  
 \- oder –  
  
 Die Quelle kann nicht registriert werden, da sie bereits auf dem lokalen Computer vorhanden ist.  
  
 \- oder –  
  
 Der Quellenname entspricht dem Namen einer vorhandenen Ereignisprotokoll.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht auf dem lokalen Computer geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll. Wenn Sie einen Wert nicht angeben <c>LogName</c> standardmäßig auf die Anwendung.</param>
        <param name="machineName">Der Name des Computers, auf dem diese Ereignisquelle registriert wird, oder "." für den lokalen Computer.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem angegebenen Computer ein. Mit dieser Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem angegebenen Computer erstellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder zu erstellen und registrieren Sie einen <xref:System.Diagnostics.EventLog.Source%2A> in ein vorhandenes Protokoll auf dem angegebenen Computer.  
  
 Wenn `logName` ist `null` oder eine leere Zeichenfolge ("") beim Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll. Wenn das Protokoll auf dem angegebenen Computer nicht vorhanden ist, wird das System ein benutzerdefiniertes Protokoll erstellt und registriert die Anwendung als eine <xref:System.Diagnostics.EventLog.Source%2A> für dieses Protokoll.  
  
 Sie müssen nur eine Ereignisquelle erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle im Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A> das entsprechende Protokoll, in dem der Eintrag gefunden. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder Angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. In Windows Vista und höher, haben Benutzer keine Zugriffsberechtigung für das Sicherheitsprotokoll; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Ereignisse in ein Ereignisprotokoll schreiben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Datenquelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Dateinamenerweiterung ".evt".  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein; ein neuen Quellennamen kann nicht mit den Datenquellennamen einer vorhandenen oder einen vorhandenen Ereignisprotokollnamen übereinstimmen. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann Ihre Anwendung mehreren Quellen verwenden, um mehrere Ereignisprotokolle geschrieben. Ihre Anwendung erfordert z. B. möglicherweise mehrere Quellen für unterschiedliche Ereignisprotokolle oder Ressourcendateien konfiguriert.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
 Um die Einzelheiten der Konfiguration einer vorhandenen Datenquelle zu ändern, müssen Sie der Quelle löschen und dann mit die neue Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration an, anstatt durch das Löschen der vorhandenen Quelle.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie ein neues Protokoll zuordnen, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` auf dem Computer `MyServer`, und schreibt einen Eintrag im Ereignisprotokoll `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> ist kein gültiger Computername.  
  
 \- oder –  
  
 <paramref name="source" />ist eine leere Zeichenfolge ("") oder <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="logName" />ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und darf die Zeichen nicht enthalten ' * ','?', oder "\\".  
  
 \- oder –  
  
 <paramref name="logName" />gilt nicht für Benutzer Protokoll erstellen. Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
 \- oder –  
  
 Der Protokollname entspricht einem vorhandenen Name der Ereignisquelle.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.  
  
 \- oder –  
  
 Die ersten 8 Zeichen des <paramref name="logName" /> benennen Sie die ersten 8 Zeichen von einer vorhandenen Ereignisprotokoll auf dem angegebenen Computer übereinstimmen.  
  
 \- oder –  
  
 Die Quelle kann nicht registriert werden, da sie bereits auf dem angegebenen Computer vorhanden ist.  
  
 \- oder –  
  
 Der Quellenname entspricht einem vorhandenen Name der Ereignisquelle.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden, auf dem angegebenen Computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Zu den möglichen Werten gehören das Anwendungs-, Sicherheits- bzw. Systemprotokoll und alle benutzerdefinierten Ereignisprotokolle auf dem Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn das Protokoll, die, das Sie löschen möchten, auf dem lokalen Computer ist. Sie können ein Protokoll auf dem Computer löschen, sofern Sie die entsprechenden Berechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>Entfernt das angegebene von `logName` vom lokalen Computer. Wenn Sie löschen möchten, nur die Quelle in ein Protokoll registriert, rufen Sie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie für die Klasse selbst aufgerufen werden können. Es ist nicht notwendig, erstellen Sie eine neue Instanz der <xref:System.Diagnostics.EventLog> einer dieser Methoden aufrufen.  
  
 Die <xref:System.Diagnostics.EventLog.Delete%2A> Methode löscht zuerst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift auf die Registrierung und entfernt alle Ereignisquellen, die für dieses Protokoll registriert. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignisquellen erneut registrieren, werden wiederverwendet werden. Wenn Sie nicht die Ereignisquellen registrieren und anderen Benutzern, die auf eine Ereignisquelle ohne Angabe eines Namens für die Protokolldatei schreiben, wird die Ereignisquelle im Ereignisprotokoll Anwendung erstellt werden. Daher werden Anwendungen, die zuvor Einträge in das Protokoll zu schreiben, gelöscht und neu erstellt, wurden in das Anwendungsprotokoll stattdessen schreiben, da sie jetzt die Ereignisquelle enthält.  
  
> [!NOTE]
>  Neuerstellen eines Ereignisprotokolls kann schwierig sein. Löschen eine der vom System erstellten Ereignisprotokolle, z. B. Windows-Anwendungsprotokoll zu vermeiden.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen in dieses Protokoll registriert. Dadurch kann andere Anwendungen verwenden dieses Protokoll nicht funktionierende vornehmen.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Protokoll auf dem lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt.  
  
> [!NOTE]
>  Mehrere Datenquellen kann in ein Ereignisprotokoll schreiben. Vor dem Löschen eines benutzerdefinierten Protokolls, stellen Sie sicher, dass es keine andere Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />ist eine leere Zeichenfolge ("") oder <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht auf dem lokalen Computer geöffnet werden.  
  
 \- oder –  
  
 Das Protokoll ist auf dem lokalen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -   
  
 Das Protokoll kann nicht geöffnet werden. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Zu den möglichen Werten gehören das Anwendungs-, Sicherheits- bzw. Systemprotokoll und alle benutzerdefinierten Ereignisprotokolle auf dem angegebenen Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn das Protokoll, die, das Sie löschen möchten, auf einem Remotecomputer befindet. Sie können ein Protokoll auf dem Computer löschen, sofern Sie die entsprechenden Berechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>Entfernt das angegebene von `logName` aus dem angegebenen Computer `machineName`. Wenn Sie löschen möchten, nur die Quelle in ein Protokoll registriert, rufen Sie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz des <xref:System.Diagnostics.EventLog> einer dieser Methoden aufrufen.  
  
 Diese Methode löscht zuerst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift auf die Registrierung und entfernt alle Ereignisquellen, die für dieses Protokoll registriert. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignisquellen erneut registrieren, werden wiederverwendet werden. Wenn Sie nicht die Ereignisquellen registrieren und anderen Benutzern, die auf eine Ereignisquelle ohne Angabe eines Namens für die Protokolldatei schreiben, wird die Ereignisquelle im Ereignisprotokoll Anwendung erstellt werden. Daher werden Anwendungen, die zuvor Einträge in das Protokoll zu schreiben, gelöscht und neu erstellt, wurden in das Anwendungsprotokoll stattdessen schreiben, da sie jetzt die Ereignisquelle enthält.  
  
> [!NOTE]
>  Neuerstellen eines Ereignisprotokolls kann schwierig sein. Löschen eine der vom System erstellten Ereignisprotokolle, z. B. Windows-Anwendungsprotokoll zu vermeiden.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen in dieses Protokoll registriert. Dadurch kann andere Anwendungen verwenden dieses Protokoll nicht funktionierende vornehmen.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Protokoll aus dem angegebenen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt.  
  
> [!NOTE]
>  Mehrere Datenquellen kann in ein Ereignisprotokoll schreiben. Vor dem Löschen eines benutzerdefinierten Protokolls, stellen Sie sicher, dass es keine andere Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />ist eine leere Zeichenfolge ("") oder <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="machineName" />ist kein gültigen Computernamen ein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden, auf dem angegebenen Computer.  
  
 \- oder –  
  
 Das Protokoll ist auf dem angegebenen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -   
  
 Das Protokoll kann nicht geöffnet werden. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <summary>Entfernt die Registrierung der Ereignisquelle aus dem Ereignisprotokoll auf dem lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie die Registrierung entfernen einer <xref:System.Diagnostics.EventLog.Source%2A> vom lokalen Computer. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>greift auf die Registrierung auf dem lokalen Computer, und entfernt die Registrierung der Anwendung als gültige Quelle von Ereignissen.  
  
 Sie können die Komponente als gültige Quelle von Ereignissen entfernen, wenn Sie ihn zum Schreiben von Einträgen in dieses Protokoll nicht mehr benötigen. Dies kann beispielsweise tun, wenn Sie die Komponente aus einem Protokoll in einen anderen ändern müssen. Da eine Quelle nur in ein Protokoll zu einem Zeitpunkt registriert werden kann, erfordert das Ändern des Protokolls Sie die aktuelle Registrierung zu entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>entfernt nur die Quelle in ein Protokoll registriert. Wenn Sie das Protokoll selbst entfernen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Delete%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz des <xref:System.Diagnostics.EventLog> einer dieser Methoden aufrufen.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen in dieses Protokoll registriert. Dadurch kann andere Anwendungen verwenden dieses Protokoll nicht funktionierende vornehmen.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie ein neues Protokoll zuordnen, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt und löscht dann das Protokoll.  
  
> [!NOTE]
>  Mehrere Datenquellen kann in ein Ereignisprotokoll schreiben. Vor dem Löschen eines benutzerdefinierten Protokolls, stellen Sie sicher, dass es keine andere Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Parameter in der Registrierung des lokalen Computers nicht vorhanden.  
  
 \- oder –  
  
 Sie haben keinen Schreibzugriff Zugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <param name="machineName">Der Name des Computers, auf dem der Registrierungseintrag gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt die Registrierung der Ereignisquellen einer Anwendung auf dem angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, die Registrierung einer <xref:System.Diagnostics.EventLog.Source%2A> von einem Remotecomputer aus. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>greift auf die Registrierung auf dem angegebenen Computer `machineName` und entfernt die Registrierung der Anwendung als gültige Quelle von Ereignissen.  
  
 Sie können die Komponente als gültige Quelle von Ereignissen entfernen, wenn Sie ihn zum Schreiben von Einträgen in dieses Protokoll nicht mehr benötigen. Dies kann beispielsweise tun, wenn Sie die Komponente aus einem Protokoll in einen anderen ändern müssen. Da eine Quelle nur in ein Protokoll zu einem Zeitpunkt registriert werden kann, erfordert das Ändern des Protokolls Sie die aktuelle Registrierung zu entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>entfernt nur die Quelle in ein Protokoll registriert. Wenn Sie das Protokoll selbst entfernen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Delete%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz des <xref:System.Diagnostics.EventLog> einer dieser Methoden aufrufen.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen in dieses Protokoll registriert. Dadurch kann andere Anwendungen verwenden dieses Protokoll nicht funktionierende vornehmen.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie ein neues Protokoll zuordnen, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel löscht eine Quelle aus dem angegebenen Computer an. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt und löscht dann das Protokoll.  
  
> [!NOTE]
>  Mehrere Datenquellen kann in ein Ereignisprotokoll schreiben. Vor dem Löschen eines benutzerdefinierten Protokolls, stellen Sie sicher, dass es keine andere Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter ist ungültig.  
  
 \- oder –  
  
 Die <paramref name="source" /> Parameter in der Registrierung der dem angegebenen Computer nicht vorhanden.  
  
 \- oder –  
  
 Sie haben keinen Schreibzugriff Zugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />kann nicht gelöscht werden, da in der Registrierung der übergeordnete Schlüssel für <paramref name="source" /> enthält keine Eigenschaft mit dem gleichen Namen.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Diagnostics.EventLog" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Diagnostics.EventLog> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Diagnostics.EventLog" /> Benachrichtigungen über <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisse erhält, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Diagnostics.EventLog" /> beim Schreiben eines Eintrags in das Protokoll benachrichtigt wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Eigenschaft bestimmt, ob die <xref:System.Diagnostics.EventLog> Ereignisse auslöst, wenn Einträge in das Protokoll geschrieben werden. Wenn die Eigenschaft den Wert `true`, Komponenten, die die <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis benachrichtigt, sobald ein Eintrag in das Protokoll, das im angegebenen geschrieben erhalten die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft. Wenn <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> ist `false`, werden keine Ereignisse ausgelöst.  
  
> [!NOTE]
>  Sie können ereignisbenachrichtigungen erhalten, nur, wenn Einträge auf dem lokalen Computer geschrieben werden. Sie können keine Benachrichtigungen für Einträge, die auf Remotecomputern geschrieben.  
  
   
  
## Examples  
 Das folgende Beispiel verarbeitet ein <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Ereignisprotokoll ist auf einem Remotecomputer befindet.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung eines <see cref="T:System.Diagnostics.EventLog" />, das in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf Umgebung verwendet diese Methode beendet die Initialisierung einer Komponente in einem Formular oder von einer anderen Komponente verwendet. Die <xref:System.Diagnostics.EventLog.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des Ereignisprotokolls ab.</summary>
        <value>Eine <see cref="T:System.Diagnostics.EventLogEntryCollection" /> mit den Einträgen im Ereignisprotokoll. Jeder Eintrag ist einer Instanz der <see cref="T:System.Diagnostics.EventLogEntry" />-Klasse zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.EventLog.Entries%2A> Member beim Lesen aus dem Ereignisprotokoll.  
  
 Da die Eigenschaft schreibgeschützt ist, keinen Eintrag ändern oder Schreiben in das Protokoll mit <xref:System.Diagnostics.EventLog.Entries%2A>. Geben Sie stattdessen eine <xref:System.Diagnostics.EventLog.Source%2A> , und rufen Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A> einen neuen Protokolleintrag geschrieben. Sie können <xref:System.Diagnostics.EventLog.Entries%2A> zum zählen der Anzahl der Einträge im Ereignisprotokoll, und zeigen Sie jedes <xref:System.Diagnostics.EventLogEntry> in der Auflistung. Verwenden Sie die indizierte <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> Member, wie z. B. Abrufen von Informationen über einen bestimmten Eintrag <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, oder <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Es ist nicht erforderlich, geben Sie eine <xref:System.Diagnostics.EventLog.Source%2A> beim nur aus einem Protokoll lesen. Sie können angeben, nur der <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Name des Computers)-Eigenschaften für die <xref:System.Diagnostics.EventLog> Instanz. In beiden Fällen die <xref:System.Diagnostics.EventLog.Entries%2A> Member wird automatisch mit der Liste der Einträge des Ereignisprotokolls aufgefüllt. Sie können den entsprechenden Index für ein Element in dieser Liste zum Lesen der einzelnen Einträge auswählen.  
  
 Ein wichtiger Unterschied zwischen Lesen und Schreiben von Protokolleinträgen ist, dass es nicht notwendig, explizit eine read-Methode aufrufen. Nach der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angegeben sind, die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft wird automatisch aufgefüllt. Wenn Sie den Wert der Ändern der <xref:System.Diagnostics.EventLog.Log%2A> oder <xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft wird beim nächsten Lesevorgang aufgefüllt.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer ".", wird angenommen.  
  
   
  
## Examples  
 Das folgende Beispiel liest Einträge im Ereignisprotokoll "MyNewLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Schreiben eines Eintrags in das Ereignisprotokoll auf dem lokalen Computer ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ereignisbenachrichtigungen zu erhalten, müssen Sie festlegen <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> auf `true`. Ereignisbenachrichtigungen können nur empfangen werden, wenn Einträge auf dem lokalen Computer geschrieben werden. Sie können keine Benachrichtigungen für Einträge, die auf Remotecomputern geschrieben.  
  
 Beim Erstellen eines <xref:System.Diagnostics.EventLog.EntryWritten>-Delegaten geben Sie die Methode für die Ereignisbehandlung an. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird aufgerufen, wenn das Ereignis tritt auf, bis der Delegat nicht entfernt. Weitere Informationen zur Behandlung von Ereignissen mit Delegaten finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Das System reagiert auf <xref:System.Diagnostics.EventLog.WriteEntry%2A> nur, wenn das letzte mindestens sechs Sekunden Schreibereignis. Dies bedeutet, Sie erhalten nur <xref:System.Diagnostics.EventLog.EntryWritten> ereignisbenachrichtigung innerhalb eines Zeitintervalls sechs Sekunden auch, wenn mehr als ein Ereignis protokolländerung auftritt. Wenn Sie ein genügend langes Ruheintervall (ca. 10 Sekunden) zwischen den Aufrufen einfügen <xref:System.Diagnostics.EventLog.WriteEntry%2A>, Sie sind weniger wahrscheinlich, dass Sie ein Ereignis verpasst haben. Wenn Ereignisse häufig auftreten, können Sie die ereignisbenachrichtigung bis zum nächsten Intervall nicht erhalten. In der Regel ausgelassenen ereignisbenachrichtigungen sind nicht verloren geht, aber verzögert.  
  
   
  
## Examples  
 Im folgende Beispiel verarbeitet einen Ereignis geschriebenen Eintrag.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu suchenden Protokolls. Folgende Werte sind möglich: Anwendungs-, Sicherheits-, System- oder andere anwendungsspezifische Protokolle, z. B. im Zusammenhang mit Active Directory, oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem lokalen Computer vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn das Protokoll auf dem lokalen Computer vorhanden ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um festzustellen, ob ein Protokoll auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen, ob eine Quelle vorhanden, auf dem lokalen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie die entsprechenden Berechtigungen auf dem lokalen Computer haben; andernfalls, die Abfrage gibt `false`.  
  
 Da Sie einem neuen Protokoll nicht den Namen eines vorhandenen Protokolls auf dem gleichen Computer geben können, verwenden Sie diese Methode vor dem Erstellen eines neuen Protokolls zum bestimmen, ob das angegebene `logName` bereits auf dem lokalen Computer vorhanden ist. Die `logName` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>ist eine `static` Methode, sodass es für die Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, zum Erstellen einer Instanz des <xref:System.Diagnostics.EventLog> Aufrufen <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">LogName ist <see langword="null" /> oder der Wert ist leer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Das zu suchende Protokoll. Folgende Werte sind möglich: Anwendungs-, Sicherheits-, System- oder andere anwendungsspezifische Protokolle, z. B. im Zusammenhang mit Active Directory, oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem angegebenen Computer vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn das Protokoll auf dem angegebenen Computer vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um festzustellen, ob ein Protokoll auf einem Remotecomputer vorhanden ist. Wenn Sie bestimmen, ob eine Quelle vorhanden, auf einem Remotecomputer verwenden ist möchten <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie die entsprechenden Berechtigungen auf dem angegebenen Computer haben; andernfalls, die Abfrage gibt `false`.  
  
 Da Sie einem neuen Protokoll nicht den Namen eines vorhandenen Protokolls auf dem gleichen Computer geben können, verwenden Sie diese Methode vor dem Erstellen eines neuen Protokolls, um zu bestimmen, ob mit dem angegebenen `logName` bereits auf dem Server gemäß der `machineName` Parameter. Die `logName` und `machineName` Parameter sind nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>ist eine `static` Methode, sodass es für die Klasse selbst aufgerufen werden kann. Es ist nicht notwendig, erstellen Sie eine neue Instanz der <xref:System.Diagnostics.EventLog> Aufrufen <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter ist ein ungültiges Format. Stellen Sie sicher, dass Sie richtige Syntax für den Computer verwendet haben, auf dem Sie suchen möchten.  
  
 - oder -   
  
 Die <paramref name="logName" /> ist <see langword="null" /> oder der Wert ist leer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach allen Ereignisprotokollen auf dem lokalen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem lokalen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog> Objekte ist eine Momentaufnahme aller Ereignisprotokolle auf dem lokalen Computer bei dem Aufruf von <xref:System.Diagnostics.EventLog.GetEventLogs%2A> erfolgt. Dies ist keiner dynamischen Sammlung, damit sie nicht das Löschen und Erstellen von Protokollen in Echtzeit widerspiegeln. Sie sollten sicherstellen, dass ein Protokoll im Array vorhanden ist, bevor Sie zu lesen oder zu schreiben. Das Array enthält in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem lokalen Computer erstellt haben, werden sie in das Array ebenfalls angezeigt.  
  
 Zum Abrufen einer Liste der Ereignisprotokolle benötigen Sie die entsprechenden Berechtigungen. Diese Berechtigungen sind identisch mit denen aufrufen erforderlichen <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf dem lokalen Computer definiert, und zeigt Konfigurationsdetails für jedes Ereignis-Protokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Sie haben nicht Lesezugriff auf die Registrierung.  
  
 - oder -   
  
 Es ist kein Ereignisprotokoll-Dienst auf dem Computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, auf dem nach Ereignisprotokollen gesucht werden soll.</param>
        <summary>Sucht nach allen Ereignisprotokollen auf dem angegebenen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem angegebenen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog> Objekte ist eine Momentaufnahme aller Ereignisprotokolle auf dem Computer, die gemäß der `machineName` Parameter beim Aufruf <xref:System.Diagnostics.EventLog.GetEventLogs%2A> erfolgt. Dies ist keiner dynamischen Sammlung, damit sie nicht das Löschen und Erstellen von Protokollen in Echtzeit widerspiegeln. Sie sollten sicherstellen, dass ein Protokoll im Array vorhanden ist, bevor Sie zu lesen oder zu schreiben. Das Array enthält in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem angegebenen Computer erstellt haben, werden sie in das Array ebenfalls angezeigt.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>ist eine `static` Methode, sodass es für aufgerufen werden kann die <xref:System.Diagnostics.EventLog> selbst dar. Es ist nicht erforderlich, zum Erstellen einer Instanz von einem <xref:System.Diagnostics.EventLog> Objekt um einen Aufruf der Methode.  
  
 Zum Abrufen einer Liste der Ereignisprotokolle benötigen Sie die entsprechenden Berechtigungen. Diese Berechtigungen sind identisch mit denen aufrufen erforderlichen <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Liste der Protokolle auf dem Computer "MyServer". Anschließend gibt er den Namen des jedes Protokoll.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter ist ein ungültiger Computername.</exception>
        <exception cref="T:System.InvalidOperationException">Sie haben nicht Lesezugriff auf die Registrierung.  
  
 - oder -   
  
 Es ist kein Ereignisprotokoll-Dienst auf dem Computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Protokolls ab, aus dem gelesen bzw. in das geschrieben werden soll, oder legt diesen fest.</summary>
        <value>Der Name des Protokolls. Dies kann das Anwendungs-, das System- bzw. das Sicherheitsprotokoll oder ein benutzerdefinierter Protokollname sein. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drei Protokolldateien vorhanden sind, standardmäßig auf dem Server: Anwendung, System und Sicherheit. Verwenden die Protokolldatei der Anwendung, Anwendungen und Dienste. Gerätetreiber verwenden die Systemprotokolldatei. Das System Überwachungsereignisse für Erfolg und Fehler in das Sicherheitsprotokoll generiert, wenn die Überwachung aktiviert ist. Andere Anwendungen installiert werden, wie Active Directory auf Windows-Servern sind möglicherweise andere Standard-Protokolldateien. Darüber hinaus können Sie benutzerdefinierte Protokolldateien auf einem lokalen Computer oder Remotecomputer erstellen. Benutzerdefinierte Protokolle helfen Ihrem Einträge auf als zulässig ist, wenn Ihre Komponenten Schreiben von Ereignissen in das Standardanwendungsprotokoll ausführlichere Weise zu organisieren.  
  
> [!NOTE]
>  Protokollnamen sind auf acht Zeichen beschränkt. Gemäß dem System sind bezeichnen MyLogSample1 und MyLogSample2 das gleiche Protokoll.  
  
 Wenn Sie in ein Ereignisprotokoll schreiben, es genügt nicht an die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft. Sie müssen das Zuordnen einer <xref:System.Diagnostics.EventLog.Source%2A> die Ereignisprotokoll-Ressource in ein bestimmtes Protokoll eine Verbindung mit dieser Eigenschaft. Es ist nicht erforderlich, geben Sie einen <xref:System.Diagnostics.EventLog.Source%2A> Wenn nur das Lesen aus einem Protokoll, aber eine Ereignisquelle muss die Ereignisprotokoll-Ressource in der Registrierung des Servers zugeordnet. Sie können angeben, nur die <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Server-Computername) lesen.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Wenn die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft nicht angegeben wurde, einen Aufruf von <xref:System.Diagnostics.EventLog.Log%2A> eine leere Zeichenfolge zurückgegeben, wenn <xref:System.Diagnostics.EventLog.Log%2A> nicht explizit festgelegt wurde (durch Festlegen der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, oder durch den Konstruktor). Wenn die <xref:System.Diagnostics.EventLog.Source%2A> angegeben wurde, <xref:System.Diagnostics.EventLog.Log%2A> gibt den Namen des Protokolls für die Quelle registriert wurde.  
  
 Eine Quelle kann jeweils nur ein Protokoll registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaftensatz wurde für eine Instanz von <xref:System.Diagnostics.EventLog>, kann nicht geändert werden die <xref:System.Diagnostics.EventLog.Log%2A> für diese Eigenschaft <xref:System.Diagnostics.EventLog> ohne Änderung des Werts der <xref:System.Diagnostics.EventLog.Source%2A> oder zum Aufrufen von <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> erste. Wenn Sie ändern die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft nach der <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft festgelegt wurde, wird das Schreiben ein Protokolleintrags löst eine Ausnahme aus.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Dateinamenerweiterung ".evt".  
  
 Sie können nicht erstellt, ein neues Protokoll mit der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft allein (ohne Angabe einer Quelle für das Protokoll an). Sie können Aufrufen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, in einen neuen Protokollnamen als Parameter übergeben, und rufen dann <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Allerdings wird in der Regel entweder erstellen (und Schreiben von Einträgen) neue anwendungsspezifische Protokolle, und zum Lesen aus vorhandenen Protokolle.  
  
 Wenn die <xref:System.Diagnostics.EventLog.Log%2A> geändert wird, im Ereignisprotokoll wird geschlossen, und alle Ereignishandles werden freigegeben.  
  
> [!CAUTION]
>  Wenn Sie festlegen, die <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft auf den Namen eines Protokolls, die nicht vorhanden ist, fügt das System die <xref:System.Diagnostics.EventLog> in das Anwendungsprotokoll jedoch nicht warnt Sie, dass es ein Protokoll als die verwendet wird, wenn Sie angegeben haben.  
  
   
  
## Examples  
 Das folgende Beispiel liest Einträge im Ereignisprotokoll "NewEventLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen des Ereignisprotokolls ab.</summary>
        <value>Ein Name, der das Ereignisprotokoll in der Ereignisanzeige des Systems darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  In Windows Vista und höher verfügen Benutzer nicht die Berechtigung für das Sicherheitsprotokoll zugreifen. Wenn Sie Windows Vista oder höher als Benutzer, Sie erhalten eine <xref:System.Security.SecurityException> beim Versuch, den Anzeigenamen für ein Ereignis in das Sicherheitsprotokoll zugreifen.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf dem lokalen Computer definiert, und zeigt die <xref:System.Diagnostics.EventLog.LogDisplayName%2A> für jedes Ereignis-Protokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="P:System.Diagnostics.EventLog.Log" /> in der Registrierung für diesen Computer nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf den angegebenen Registrierungsschlüssel, wenn ist es eine remote-Schlüssel. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Ruft den Namen des Protokolls ab, in der die angegebene Quelle registriert ist.</summary>
        <returns>Der Name des Protokolls, das der angegebenen Quelle in der Registrierung zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisquelle gibt an, was das Ereignis protokolliert. Es ist häufig der Name der Anwendung oder den Namen der Unterkomponente der Anwendung, wenn die Anwendung sehr groß ist. Anwendungen und Dienste sollten auf Windows-Anwendungsprotokoll oder ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten im Systemprotokoll schreiben.  
  
 Wenn Sie eine neue Datenquelle, die nur in einem Protokoll das zu einem Zeitpunkt schreiben können erstellen, registriert das System die Anwendung im Ereignisprotokoll als gültige Quelle für Einträge. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft kann eine beliebige Zeichenfolge sein, aber der Name darf nicht mit anderen Datenquellen auf dem Computer verwendet werden. Beim Erstellen einer duplizierten <xref:System.Diagnostics.EventLog.Source%2A> Wert löst eine Ausnahme aus. Allerdings kann ein Ereignisprotokoll vielen verschiedene Quellen, die darauf schreiben müssen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt und löscht dann das Protokoll.  
  
> [!NOTE]
>  Mehrere Datenquellen kann in ein Ereignisprotokoll schreiben. Vor dem Löschen eines benutzerdefinierten Protokolls, stellen Sie sicher, dass es keine andere Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem Ereignisse gelesen oder geschrieben werden sollen, oder legt diesen fest.</summary>
        <value>Der Name des Servers, auf dem das Ereignisprotokoll gespeichert ist. Der Standardwert ist der lokale Computer (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie in ein Ereignisprotokoll schreiben, müssen Sie Zuordnen einer <xref:System.Diagnostics.EventLog.Source%2A> Ereignisprotokoll-Objekt für die Verbindung mit einem bestimmten Protokoll. Es ist nicht erforderlich, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft, wenn Sie nur aus einem Protokoll gelesen. Sie können angeben, nur die <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Name des Computers).  
  
> [!NOTE]
>  Sie müssen nicht angeben der <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Eine Quelle kann jeweils nur ein Protokoll registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaftensatz wurde für eine Instanz von <xref:System.Diagnostics.EventLog>, kann nicht geändert werden die <xref:System.Diagnostics.EventLog.MachineName%2A> für diese Eigenschaft <xref:System.Diagnostics.EventLog> ohne Änderung des Werts der <xref:System.Diagnostics.EventLog.Source%2A> oder zum Aufrufen von <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> erste. Wenn Sie ändern die <xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog> alle Handles zu schließen und erneut angefügt wird, um das Protokoll und die Quelle auf dem neuen Computer.  
  
 Die <xref:System.Diagnostics.EventLog.MachineName%2A> Wert darf keine leere Zeichenfolge sein. Wenn sie nicht explizit festgelegt ist, wird standardmäßig auf dem lokalen Computer (".").  
  
   
  
## Examples  
 Das folgende Beispiel liest Einträge im Ereignisprotokoll "NewEventLog", auf einem angegebenen Computer an.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Ereignisprotokollgröße in Kilobyte ab oder legt diese fest.</summary>
        <value>Die maximale Ereignisprotokollgröße in Kilobyte. Der Standardwert lautet 512 und gibt eine maximale Dateigröße von 512 Kilobyte an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Eigenschaft darstellt, die größenbeschränkung für die Ereignis-Protokolldatei. Wenn das Ereignisprotokoll erreicht die maximale Größe, die den konfigurierten <xref:System.Diagnostics.EventLog.OverflowAction%2A> Wert bestimmt, ob neue Einträge verworfen werden, oder, ob das neue Einträge ältere Einträge überschreiben.  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Einstellung für das Ereignisprotokoll, die von dieser Instanz dargestellten dar. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie vom Betriebssystem neue Einträge, die durch alle Ereignisquellen für das Ereignisprotokoll registriert geschrieben behandelt.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf dem lokalen Computer definiert, und zeigt Konfigurationsdetails für jedes Ereignis-Protokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner oder größer als 4194240 oder kein ganzzahliges Vielfaches von 64-64.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.EventLog.Log" /> Wert ist kein gültiger Name.  
  
 \- oder –  
  
 Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden, auf dem Zielcomputer installiert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Tagen ab, für die Einträge im Ereignisprotokoll beibehalten werden sollen.</summary>
        <value>Die Anzahl von Tagen, für die Einträge im Ereignisprotokoll beibehalten werden. Der Standardwert ist 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Eigenschaft, um die aktuelle Einstellung für ein Ereignisprotokoll überprüfen. Verwendung <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> so ändern Sie die minimale Anzahl von Tagen, die jeder Eintrag im Ereignisprotokoll beibehalten werden muss.  
  
 Die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert hängt von der konfigurierten Überlaufverhalten des Ereignisprotokolls. Wenn die <xref:System.Diagnostics.OverflowAction> -Eigenschaft für ein Ereignisprotokoll auf festgelegt ist <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert ist 0. Wenn die <xref:System.Diagnostics.OverflowAction> -Eigenschaft für ein Ereignisprotokoll auf festgelegt ist <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert ist 1. Wenn die <xref:System.Diagnostics.OverflowAction> -Eigenschaft für ein Ereignisprotokoll auf festgelegt ist <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert größer als 0 (null) ist, und gibt die Anzahl von Tagen, um Einträge im Ereignisprotokoll beibehalten werden sollen, wenn das Ereignisprotokoll voll ist.  
  
 Das Überlaufverhalten tritt nur auf, wenn ein Ereignisprotokoll seine maximale Größe erreicht hat. Wenn ein <xref:System.Diagnostics.EventLog> hat seine <xref:System.Diagnostics.EventLog.OverflowAction%2A> festgelegt <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, im Ereignisprotokoll die maximale Größe erreicht, und neue Einträge werden nur geschrieben, wenn sie Einträge ersetzen können, deren Alter überschreitet, die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Zeitraum. Ereigniseinträge für einen Mindestzeitraum beibehalten eignet sich, wenn das Ereignisprotokoll regelmäßig archiviert wird. Andernfalls riskieren Sie neue Einträge im Ereignisprotokoll das Limit erreicht. Um zu vermeiden, verlieren neue Ereignisinformationen, legen Sie die minimale Aufbewahrungstage für Ereignisse basierend auf Ihrer Archivierungsplan für ein bestimmtes Ereignisprotokoll.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf dem lokalen Computer definiert, und zeigt Konfigurationsdetails für jedes Ereignis-Protokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Das Überlaufverhalten für das Schreiben neuer Einträge in das Ereignisprotokoll.</param>
        <param name="retentionDays">Die Mindestanzahl von Tagen, für die jeder Ereignisprotokolleintrag beibehalten wird. Dieser Parameter wird nur verwendet, wenn <c>Aktion</c> festgelegt ist, um <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Ändert das konfigurierte Verhalten zum Schreiben neuer Einträge, wenn die maximale Dateigröße des Ereignisprotokolls erreicht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Überlaufverhalten für ein Ereignisprotokoll gibt an, was geschieht, wenn neue Einträge werden in ein Protokoll geschrieben werden, die die maximale Dateigröße erreicht wurde.  
  
> [!NOTE]
>  Das Überlaufverhalten wird wirksam, nur, wenn ein Ereignisprotokoll die maximale Dateigröße erreicht wird. Das Überlaufverhalten wirkt sich nicht auf einen neuen Eintrag in ein Protokoll schreiben, die zusätzliche Ereignisprotokolleinträge aufnehmen kann.  
  
 Die <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Methode konfiguriert das Überlaufverhalten eines Ereignisprotokolls. <xref:System.Diagnostics.EventLog>-Instanz. Nach dem Aufrufen dieser Methode für das Ereignisprotokoll, die gemäß der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog.OverflowAction%2A> und <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Eigenschaftswerte geben die neu konfigurierte Überlaufverhalten.  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Einstellung für das Ereignisprotokoll, die von dieser Instanz dargestellten dar. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie vom Betriebssystem neue Einträge, die durch alle Ereignisquellen für das Ereignisprotokoll registriert geschrieben behandelt.  
  
 Festlegen der `action` Parameter <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> um anzugeben, dass ein neuer Eintrag den ältesten Eintrag überschreibt bei der <xref:System.Diagnostics.EventLog> die maximale Größe erreicht. Wenn die `action` Parametersatz auf <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, die `retentionDays` Parameterwert wird ignoriert.  
  
 Festlegen der `action` Parameter <xref:System.Diagnostics.OverflowAction.OverwriteOlder> , um anzugeben, dass jeder neuer Eintrag, ältere Einträge überschreibt bei der <xref:System.Diagnostics.EventLog> die maximale Größe erreicht. Geben Sie die Anzahl der Tage, die Ereignisse aufbewahrt werden müssen in das Protokoll mithilfe der `retentionDays` Parameter. Innerhalb des Aufbewahrungszeitraums festgehaltenen Ereignisse werden durch neue Einträge nicht überschrieben.  
  
 Legen Sie die `action` Parameter <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> verwerfen neue Ereignisse aus, wenn die maximale Protokollgröße erreicht ist. Wenn die `action` Parametersatz auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, die `retentionDays` Parameterwert wird ignoriert.  
  
> [!CAUTION]
>  Festlegen der Überlaufrichtlinie auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> gibt an, dass neue Einträge verworfen werden, wenn das Ereignisprotokoll voll ist. Wenn Sie diese Einstellung verwenden, stellen Sie sicher, das Ereignisprotokoll regelmäßig archiviert und gelöscht werden, um zu vermeiden, Limit für die maximale Größe erreicht.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die konfigurierten Überlaufrichtlinie für eine angegebene Ereignisprotokoll, und ermöglicht es dem Benutzer eine neue Einstellung für das Ereignisprotokoll Überlauf auswählen.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> ist kein gültiger <see cref="P:System.Diagnostics.EventLog.OverflowAction" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" />ist kleiner als 1 oder größer als 365.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.EventLog.Log" /> Wert ist kein gültiger Name.  
  
 \- oder –  
  
 Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden, auf dem Zielcomputer installiert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Speichern neuer Einträge bei Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten ab.</summary>
        <value>Der <see cref="T:System.Diagnostics.OverflowAction" />-Wert, der das zum Speichern neuer Einträge beim Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten angibt. Die Standardeinstellung ist <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisprotokolle größer als neue Ereignisse in sie geschrieben werden. Jede Ereignisprotokoll hat die maximal konfigurierte maximale Größe; die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Eigenschaft definiert die maximale Anzahl der Kilobytes, die für die Dateigröße des Ereignisprotokolls zulässig.  
  
 Verwenden der <xref:System.Diagnostics.EventLog.OverflowAction%2A> Eigenschaftswert angibt, überprüfen Sie die konfigurierten Überlaufverhalten für ein Ereignisprotokoll seine maximale Größe erreicht. Verwenden der <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Methode, um das Überlaufverhalten für ein Ereignisprotokoll zu ändern.  
  
> [!NOTE]
>  Das Überlaufverhalten wird wirksam, nur, wenn ein Ereignisprotokoll die maximale Dateigröße erreicht wird. Das Überlaufverhalten wirkt sich nicht auf einen neuen Eintrag in ein Protokoll schreiben, die zusätzliche Ereignisprotokolleinträge aufnehmen kann.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf dem lokalen Computer definiert, und zeigt Konfigurationsdetails für jedes Ereignis-Protokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Der vollständig angegebene Pfad einer lokalisierten Ressourcendatei.</param>
        <param name="resourceId">Der Ressourcenbezeichner, der eine lokalisierte Zeichenfolge in der Ressourcendatei indiziert.</param>
        <summary>Gibt den lokalisierten Namen des Ereignisprotokolls an, der in der Ereignisanzeige des Servers angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> zu registrieren und einen lokalisierten Name in der Ereignisanzeige für benutzerdefinierte Ereignisprotokolle anzeigen.  
  
 Der Bezeichner für die angegebene Ressource muss eine lokalisierte Zeichenfolge, die in der Ressourcendatei definierten entsprechen. Die Ereignisanzeige zeigt des benutzerdefinierten Ereignisprotokollnamens eingeben, die die lokalisierte Zeichenfolge mit der aktuellen kultureinstellungen an. Beispielsweise können Sie mehrere für andere Kulturen in Ihrer Ressourcendatei lokalisierte Ereignisprotokollnamen definieren. Die Ereignisanzeige werden die lokalisierte Zeichenfolge für die länderspezifischen Einstellungen des aktuellen Benutzers angezeigt.  
  
 Wenn es sich bei der Ereignisanzeige die lokalisierte Zeichenfolge aus der Ressourcendatei kann nicht geladen werden, oder wenn kein Name für das Ereignisprotokoll registriert wurde, klicken Sie dann die Ereignisanzeige des Ereignisprotokollnamens eingeben, die zeigt in definierten <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Sie müssen nicht um einen Anzeigenamen für die vordefinierten Ereignisprotokolle zu registrieren. Das Betriebssystem registriert den lokalisierten Anzeigenamen für die Ereignisprotokolle Anwendung, System und Sicherheit.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Ereignisquelle benannt `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignisquelle nicht vorhanden ist, wird im Beispiel legt die Nachricht Ressourcendatei für die Quelle und die neue Ereignisquelle erstellt. Im Beispiel wird schließlich den lokalisierten Anzeigenamen für das Ereignisprotokoll, wobei die Ressourcen-ID-Wert in `DisplayNameMsgId` und den Pfad der Ressource in `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen. Ressourcenbezeichner 5001 wird insbesondere für den lokalisierten Namen des Ereignisprotokolls definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.EventLog.Log" /> Wert ist kein gültiger Name.  
  
 \- oder –  
  
 Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden, auf dem Zielcomputer installiert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zu registrierenden Namen der Quelle ab, die zum Schreiben in das Ereignisprotokoll verwendet werden soll, oder legt diesen fest.</summary>
        <value>Der Name, der im Ereignisprotokoll als Quelle für Einträge registriert ist. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisquelle gibt an, was das Ereignis protokolliert. Es ist häufig der Name der Anwendung oder den Namen der Unterkomponente der Anwendung, wenn die Anwendung sehr groß ist. Anwendungen und Dienste sollten auf Windows-Anwendungsprotokoll oder ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten im Systemprotokoll schreiben.  
  
 Sie müssen nur eine Ereignisquelle angeben, wenn Sie in ein Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle im Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft das entsprechende Protokoll, in dem der Eintrag gefunden. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder Angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie eine Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Ereignisse in ein Ereignisprotokoll schreiben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Datenquelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein; ein neuen Quellennamen kann nicht mit den Datenquellennamen einer vorhandenen oder einen vorhandenen Ereignisprotokollnamen übereinstimmen. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann Ihre Anwendung mehreren Quellen verwenden, um mehrere Ereignisprotokolle geschrieben. Ihre Anwendung erfordert z. B. möglicherweise mehrere Quellen für unterschiedliche Ereignisprotokolle oder Ressourcendateien konfiguriert.  
  
 Wenn Sie ändern die <xref:System.Diagnostics.EventLog.Source%2A> Wert, der <xref:System.Diagnostics.EventLog> , die er registriert wurde geschlossen, und alle Ereignishandles freigegeben werden.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
 Um die Einzelheiten der Konfiguration einer vorhandenen Datenquelle zu ändern, müssen Sie der Quelle löschen und dann mit die neue Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration an, anstatt durch das Löschen der vorhandenen Quelle.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie ein neues Protokoll zuordnen, müssen Sie den Computer, damit die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf dem lokalen Computer registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die Ereignisquelle auf dem lokalen Computer registriert ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob eine Ereignisquelle auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen, ob ein Protokoll vorhanden, auf dem lokalen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie die entsprechenden Berechtigungen auf dem lokalen Computer haben; andernfalls ein <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um für eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista, verfügen Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zuzugreifen; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
>   
>  Ab Windows Vista, bestimmt Benutzerkontensteuerung (UAC), die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf Leistungsindikatoren zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
> [!NOTE]
>  Ein Dienst, der ausgeführt wird die <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto verfügt nicht über die erforderlichen Berechtigungen für diese Methode ausgeführt werden. Die Lösung besteht darin, überprüfen Sie, ob die Ereignisquelle in vorhanden ist die <xref:System.ServiceProcess.ServiceInstaller>, und wenn es nicht vorhanden, um die Quelle in das Installationsprogramm zu erstellen,.  
  
 Da Sie einer neuen Datenquelle den Namen einer vorhandenen Datenquelle auf demselben Computer geben können, verwenden Sie diese Methode vor dem Aufrufen <xref:System.Diagnostics.EventLog.CreateEventSource%2A> eine Quelle mit dem Namen angegeben werden, indem Sie sicherstellen, dass `source` ist bereits auf dem lokalen Computer nicht vorhanden. Die `source` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />wurde nicht gefunden, aber einige oder alle der Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf einem angegebenen Computer registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die Ereignisquelle auf dem angegebenen Computer registriert ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob eine Ereignisquelle auf dem angegebenen Computer vorhanden ist die `machineName` Parameter. Wenn Sie bestimmen, ob ein Protokoll vorhanden, auf dem angegebenen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie die entsprechenden Berechtigungen auf dem betreffenden Server haben; andernfalls ein <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um für eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista, verfügen Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zuzugreifen; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst wird.  
>   
>  Ab Windows Vista, bestimmt Benutzerkontensteuerung (UAC), die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf Leistungsindikatoren zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
> [!NOTE]
>  Ein Dienst, der ausgeführt wird die <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto verfügt nicht über die erforderlichen Berechtigungen für diese Methode ausgeführt werden. Die Lösung besteht darin, überprüfen Sie, ob die Ereignisquelle in vorhanden ist die <xref:System.ServiceProcess.ServiceInstaller>, und wenn es nicht vorhanden, um die Quelle in das Installationsprogramm zu erstellen,.  
  
 Da Sie einer neuen Datenquelle den Namen einer vorhandenen Datenquelle auf demselben Computer geben können, verwenden Sie diese Methode vor dem Aufrufen <xref:System.Diagnostics.EventLog.CreateEventSource%2A> eine Quelle mit dem Namen angegeben werden, indem Sie sicherstellen, dass `source` ist nicht auf dem Computer bereits vorhanden. Die `source` und `machineName` Parameter sind nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A>ist eine `static` Methode, sodass es für die Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, zum Erstellen einer Instanz des <xref:System.Diagnostics.EventLog> Aufrufen <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` auf dem Computer `MyServer`, und schreibt einen Eintrag im Ereignisprotokoll `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" />ist ein ungültiger Computername.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />wurde nicht gefunden, aber einige oder alle der Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt für das Marshallen der Ereignishandleraufrufe ab, die aufgrund eines Ereignisses für das Schreiben eines <see cref="T:System.Diagnostics.EventLog" />-Eintrags ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> für das Marshallen von Ereignishandleraufrufen, die aufgrund eines <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisses im Ereignisprotokoll ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> ist `null`, Methoden für die Behandlung der <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis in einem Thread aus dem Threadpool System aufgerufen werden. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis von visuellen Windows Forms Komponente, wie z. B. eine Schaltfläche, die Zugriff auf die Komponente über den Threadpool System funktioniert möglicherweise nicht oder wird unter Umständen eine Ausnahme behandelt wird. Vermeiden Sie dies, indem <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> an eine Windows Forms-Komponente, durch die die Methoden zur Behandlung der <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis im selben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.EventLog> dient in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement mit der <xref:System.Diagnostics.EventLog>. Angenommen, Sie Platzieren einer <xref:System.Diagnostics.EventLog> für Form1-Designer (geerbt von <xref:System.Windows.Forms.Form>) der <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Eigenschaft <xref:System.Diagnostics.EventLog> mit der Instanz von Form1 festgelegt ist.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie einen Informationseintrag in das Ereignisprotokoll zugeordnet schreiben <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie alle anderen angeben möchten <xref:System.Diagnostics.EventLogEntryType>, verwenden Sie eine andere Überladung der <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Müssen die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihrer <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Protokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Wenn in die Quelle angegebenen der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System registrieren muss der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> Instanz, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von Fehlern, die ausgelöst wird, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information, eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags eines angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll geschrieben. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Müssen die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihrer <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Protokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Wenn in die Quelle angegebenen der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System registrieren muss der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> Instanz, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von Fehlern, die ausgelöst wird, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt einen Warnungseintrag in ein Ereignisprotokoll "MyNewLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode schreiben Sie einen Informationseintrag in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert ist. Wenn Sie alle anderen angeben möchten <xref:System.Diagnostics.EventLogEntryType>, verwenden Sie eine andere Überladung der <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag in das Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit einer von der Anwendung definierten `eventID` in das Ereignisprotokoll geschrieben. Die `eventID` zusammen mit der Quelle ein Ereignisses eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, denen die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Sie können zusätzlich zu den Ereignisbezeichner angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Müssen die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihrer <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Protokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Wenn in die Quelle angegebenen der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System registrieren muss der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> Instanz, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von Fehlern, die ausgelöst wird, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information oder eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags eines angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll, verwenden eine Datenquelle bereits als Ereignisquelle für das entsprechende Protokoll registriert. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt einen Warnungseintrag in ein Ereignisprotokoll "MyNewLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit einer von der Anwendung definierten `category` in das Ereignisprotokoll geschrieben. Mithilfe der Ereignisanzeige die Kategorie zu Filtern von Ereignissen von einer Ereignisquelle geschrieben wurde. Der Ereignisanzeige können die Kategorie einen numerischen Wert anzeigen können, oder es die Kategorie als eine Ressourcen-ID um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Event Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird-10 als 65.526 und-1 als 65.535 angezeigt.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einem Ressourcenbezeichner in der Kategorie-Ressourcendatei. Wenn die Ereignisquelle eine Ressourcendatei konfigurierten Kategorie verwendet werden soll, oder das angegebene keinen `category` index eine Zeichenfolge in der Kategorieressourcendatei nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren Sie die Kategorie-Ressourcendatei, sowie die Anzahl der Kategoriezeichenfolgen in der Ressourcendatei mit der <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Geben Sie neben der Kategorie einen Ereignisbezeichner für das Ereignis in das Ereignisprotokoll geschrieben wird. Ereignis-IDs, zusammen mit der Ereignisquelle verwendet wurden, wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, denen die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Müssen die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihrer <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Protokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Wenn in die Quelle angegebenen der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System registrieren muss der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> Instanz, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von Fehlern, die ausgelöst wird, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit einer von der Anwendung definierten `eventID` in das Ereignisprotokoll, verwenden eine Datenquelle bereits als Ereignisquelle für das entsprechende Protokoll registriert. Die `eventID`, zusammen mit der Quelle ein Ereignisses eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignisanzeigen Anpassungen diese Zeichenfolgen für die Benutzer, die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
 Zusätzlich zu den Ereignisbezeichner dieser Überladung von <xref:System.Diagnostics.EventLog.WriteEntry%2A> ermöglicht die Angabe einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um anwendungsspezifische ereignisspezifische Daten in das Ereignisprotokoll zu schreiben. Die Ereignisanzeige interpretiert diese Daten nicht; Es zeigt die unformatierte Daten nur in einem kombinierten Hexadezimal- und Text-Format. Verwenden Sie die ereignisspezifische Daten nur selten, einschließlich es nur, wenn Sie sicher, dass er kann an eine Person Debuggen des Problems hilfreich sind. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Sie konnten z. B. einen Viewer speziell für Ereignisse schreiben oder schreiben ein Programm, das die Protokolldatei scannt und erstellt Berichte, die Informationen aus den ereignisspezifische Daten enthalten.  
  
 Zusätzlich zu den binären Daten können Sie eine Kategorie und eine Anwendung definierten Ereignisbezeichner angeben. Mithilfe der Ereignisanzeige die Kategorie zu Filtern von Ereignissen von einer Ereignisquelle geschrieben wurde. Der Ereignisanzeige können die Kategorie einen numerischen Wert anzeigen können, oder es die Kategorie als eine Ressourcen-ID um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Event Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird-10 als 65.526 und-1 als 65.535 angezeigt.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einem Ressourcenbezeichner in der Kategorie-Ressourcendatei. Wenn die Ereignisquelle eine Ressourcendatei konfigurierten Kategorie verwendet werden soll, oder das angegebene keinen `category` index eine Zeichenfolge in der Kategorieressourcendatei nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren Sie die Kategorie-Ressourcendatei, sowie die Anzahl der Kategoriezeichenfolgen in der Ressourcendatei mit der <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Ereignis-IDs, zusammen mit der Ereignisquelle verwendet wurden, wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, denen die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Müssen die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihrer <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Protokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Wenn in die Quelle angegebenen der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System registrieren muss der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> Instanz, das Protokoll wird standardmäßig auf Windows-Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von Fehlern, die ausgelöst wird, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird. Anhand der <paramref name="category" /> kann die Ereignisanzeige Ereignisse im Protokoll filtern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit einer von der Anwendung definierten `category` in das Ereignisprotokoll verwenden Sie eine Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert ist. Mithilfe der Ereignisanzeige die Kategorie zu Filtern von Ereignissen von einer Ereignisquelle geschrieben wurde. Der Ereignisanzeige können die Kategorie einen numerischen Wert anzeigen können, oder es die Kategorie als eine Ressourcen-ID um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Event Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird-10 als 65.526 und-1 als 65.535 angezeigt.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einem Ressourcenbezeichner in der Kategorie-Ressourcendatei. Wenn die Ereignisquelle eine Ressourcendatei konfigurierten Kategorie verwendet werden soll, oder das angegebene keinen `category` index eine Zeichenfolge in der Kategorieressourcendatei nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren Sie die Kategorie-Ressourcendatei, sowie die Anzahl der Kategoriezeichenfolgen in der Ressourcendatei mit der <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Geben Sie neben der Kategorie einen Ereignisbezeichner für das Ereignis in das Ereignisprotokoll geschrieben wird. Ereignis-IDs, zusammen mit der Ereignisquelle verwendet wurden, wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, denen die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird, und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben der Anwendung definierte ereignisspezifische Daten in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert. Die Ereignisanzeige interpretiert diese Daten nicht; Es zeigt die unformatierte Daten nur in einem kombinierten Hexadezimal- und Text-Format. Verwenden Sie nur selten ereignisspezifische Daten; Fügen Sie ihn nur, wenn Sie sind sicher, dass es sinnvoll sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Sie konnten z. B. einen Viewer speziell für Ereignisse schreiben oder schreiben ein Programm, das die Protokolldatei scannt und erstellt Berichte, die Informationen aus den ereignisspezifische Daten enthalten.  
  
 Zusätzlich zu den binären Daten können Sie eine Kategorie und eine Anwendung definierten Ereignisbezeichner angeben. Mithilfe der Ereignisanzeige die Kategorie zu Filtern von Ereignissen von einer Ereignisquelle geschrieben wurde. Der Ereignisanzeige können die Kategorie einen numerischen Wert anzeigen können, oder es die Kategorie als eine Ressourcen-ID um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Event Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird-10 als 65.526 und-1 als 65.535 angezeigt.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einem Ressourcenbezeichner in der Kategorie-Ressourcendatei. Wenn die Ereignisquelle eine Ressourcendatei konfigurierten Kategorie verwendet werden soll, oder das angegebene keinen `category` index eine Zeichenfolge in der Kategorieressourcendatei nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren Sie die Kategorie-Ressourcendatei, sowie die Anzahl der Kategoriezeichenfolgen in der Ressourcendatei mit der <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Ereignis-IDs, zusammen mit der Ereignisquelle verwendet wurden, wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, eine eigene nummerierte Ereignisse und die Beschreibungszeichenfolgen, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, denen die Benutzer verstehen, welcher Fehler vorliegt und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Informationen, Erfolgs- oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Meldungsressourcendatei werden nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldungsressourcendatei.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter ein NUL-Zeichen enthält, wird die Meldung im Ereignisprotokoll das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="eventID" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 Die Meldungszeichenfolge ist länger als 31,839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen lokalisierten Eintrag in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll zu schreiben. Sie geben die Ereigniseigenschaften Ressourcenbezeichner anstelle von Zeichenfolgenwerten. Mithilfe der Ereignisanzeige zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für den Ressourcen-IDs der <xref:System.Diagnostics.EventLog.Source%2A>. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen, die mithilfe der Ressourcen-IDs.  
  
 Die Eingabe `instance` Instanz angibt, die in der ereignismeldung wird und die Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe für die definierten Nachricht in der Meldungsressourcendatei der Quelle. Optional können Sie festlegen der <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags zu definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den lokalisierten Meldungstext angeben. Legen Sie `values` zu `null` , wenn die ereignismeldung keine Formatierung Platzhalter für Ersatzzeichenfolgen enthält.  
  
 Sie müssen festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihre <xref:System.Diagnostics.EventLog> Komponente vor der Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge in das Protokoll. die Quelle muss mindestens eine Nachricht Ressourcendatei definiert werden.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag in einem Remotecomputer befindet, den Wert der Schreiben der `message` Zeichenfolge möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird. Darüber hinaus die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt zwei Überwachungseinträge in das Ereignisprotokoll `myNewLog`. Im Beispiel wird eine neue Ereignisquelle und ein neues Ereignisprotokoll erstellt, wenn sie nicht auf dem lokalen Computer vorhanden sind. Der Text der Ereignis wird mit einem Ressourcenbezeichner in einer Ressourcendatei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 <paramref name="instance.InstanceId" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 <paramref name="values" />verfügt über mehr als 256 Elemente.  
  
 \- oder –  
  
 Eines der <paramref name="values" /> Elemente ist länger als 32.766 Bytes.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifische Daten in das Ereignisprotokoll zu schreiben. Sie geben die Ereigniseigenschaften Ressourcenbezeichner anstelle von Zeichenfolgenwerten. Mithilfe der Ereignisanzeige zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für den Ressourcen-IDs der <xref:System.Diagnostics.EventLog.Source%2A>. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen, die mithilfe der Ressourcen-IDs.  
  
 Die Eingabe `instance` Instanz angibt, die in der ereignismeldung wird und die Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe für die definierten Nachricht in der Meldungsressourcendatei der Quelle. Optional können Sie festlegen der <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags zu definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den lokalisierten Meldungstext angeben. Legen Sie `values` zu `null` , wenn die ereignismeldung keine Formatierung Platzhalter für Ersatzzeichenfolgen enthält.  
  
 Geben Sie Binärdaten mit einem ausgelösten Ereignis bei Bedarf zusätzliche Details für das Ereignis bereit. Verwenden Sie z. B. die `data` Parameter, um Informationen zu einem bestimmten Fehler enthalten. Die Ereignisanzeige interpretiert die Daten für das zugeordnete Ereignis nicht; Es zeigt die Daten in einem kombinierten Hexadezimal- und Text-Format. Verwenden Sie nur selten ereignisspezifische Daten; Fügen Sie ihn nur, wenn Sie sind sicher, dass es sinnvoll sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für Ereignisse schreiben oder ein Programm schreiben, überprüft das Ereignisprotokoll und erstellt Berichte, die Informationen aus den ereignisspezifische Daten enthalten.  
  
 Sie müssen festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft auf Ihre <xref:System.Diagnostics.EventLog> -Komponente vor der Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge in das Protokoll. die Quelle muss mindestens eine Nachricht Ressourcendatei definiert werden.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEvent%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag in einem Remotecomputer befindet, den Wert der Schreiben der `message` Zeichenfolge möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird. Darüber hinaus die `message` Zeichenfolge darf keine % enthalten*n*, wobei * n * Ganzzahlwert (z. B. %1) ist, da es sich bei die Ereignisanzeige als eine Einfügezeichenfolge behandelt. Da Zeichenfolge für eine Internetprotokoll Version 6 (IPv6)-Adresse dieser enthalten kann, können Sie eine ereignismeldung protokollieren, eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt zwei Überwachungseinträge in das Ereignisprotokoll `myNewLog`. Im Beispiel wird eine neue Ereignisquelle und ein neues Ereignisprotokoll erstellt, wenn sie nicht auf dem lokalen Computer vorhanden sind. Der Text der Ereignis wird mit einem Ressourcenbezeichner in einer Ressourcendatei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" /> Eigenschaft von der <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
 - oder -   
  
 Die Methode hat versucht, eine neue Ereignisquelle, aber den Computernamen im registrieren <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist ungültig.  
  
 \- oder –  
  
 Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
 \- oder –  
  
 <paramref name="instance.InstanceId" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 <paramref name="values" />verfügt über mehr als 256 Elemente.  
  
 \- oder –  
  
 Eines der <paramref name="values" /> Elemente ist länger als 32.766 Bytes.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt unter Verwendung der angegebenen registrierten Ereignisquelle einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten und Meldungsersetzungszeichenfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits registriert als Ereignisquelle für das entsprechende Protokoll schreiben. Sie geben die Ereigniseigenschaften Ressourcenbezeichner anstelle von Zeichenfolgenwerten. Die Ereignisanzeige verwendet die Ressourcenbezeichner zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die Quelle an. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen, die mithilfe der Ressourcen-IDs.  
  
 Die Eingabe `instance` Instanz angibt, die in der ereignismeldung wird und die Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe für die definierten Nachricht in der Meldungsressourcendatei der Quelle. Optional können Sie festlegen der <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags zu definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den lokalisierten Meldungstext angeben. Legen Sie `values` zu `null` , wenn die ereignismeldung keine Formatierung Platzhalter für Ersatzzeichenfolgen enthält.  
  
 Die angegebene Quelle für ein Ereignisprotokoll registriert werden muss, vor der Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge in das Protokoll. die Quelle muss mindestens eine Nachricht Ressourcendatei definiert werden.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
   
  
## Examples  
 Im folgende Beispiel werden ein Informationsereignis und eine Warnung Ereigniseintrag in ein vorhandenes Ereignisprotokoll schreibt. Der Text der Ereignis wird mit einem Ressourcenbezeichner in einer Ressourcendatei angegeben. Im Beispiel wird davon ausgegangen, dass die entsprechende Ressourcendatei für die Quelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="instance.InstanceId" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 <paramref name="values" />verfügt über mehr als 256 Elemente.  
  
 \- oder –  
  
 Eines der <paramref name="values" /> Elemente ist länger als 32.766 Bytes.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten und unter Verwendung der angegebenen registrierten Ereignisquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifische Daten in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits registriert als Ereignisquelle für das entsprechende Protokoll schreiben. Sie geben die Ereigniseigenschaften Ressourcenbezeichner anstelle von Zeichenfolgenwerten. Die Ereignisanzeige verwendet die Ressourcenbezeichner zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die Quelle an. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen, die mithilfe der Ressourcen-IDs.  
  
 Die Eingabe `instance` Instanz angibt, die in der ereignismeldung wird und die Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe für die definierten Nachricht in der Meldungsressourcendatei der Quelle. Optional können Sie festlegen der <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags zu definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den lokalisierten Meldungstext angeben. Legen Sie `values` zu `null` , wenn die ereignismeldung keine Formatierung Platzhalter für Ersatzzeichenfolgen enthält.  
  
 Geben Sie Binärdaten mit einem ausgelösten Ereignis bei Bedarf zusätzliche Details für das Ereignis bereit. Verwenden Sie z. B. die `data` Parameter, um Informationen zu einem bestimmten Fehler enthalten. Die Ereignisanzeige interpretiert die Daten für das zugeordnete Ereignis nicht; Es zeigt die Daten in einem kombinierten Hexadezimal- und Text-Format. Verwenden Sie nur selten ereignisspezifische Daten; Fügen Sie ihn nur, wenn Sie sind sicher, dass es sinnvoll sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für Ereignisse schreiben oder ein Programm schreiben, überprüft das Ereignisprotokoll und erstellt Berichte, die Informationen aus den ereignisspezifische Daten enthalten.  
  
 Die angegebene Quelle für ein Ereignisprotokoll registriert werden muss, vor der Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge in das Protokoll. die Quelle muss mindestens eine Nachricht Ressourcendatei definiert werden.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und ihre Konfiguration zu aktualisieren. Wenn das Betriebssystem hat seine Liste der Ereignisquellen nicht aktualisiert, und Sie versuchen, ein Ereignis mit der neuen Datenquelle zu schreiben, der Schreibvorgang fehl. Sie können konfigurieren, eine neue Datenquelle mit einer <xref:System.Diagnostics.EventLogInstaller>, oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratorrechte auf dem Computer eine neue Ereignisquelle erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe der Ressourcen-IDs und Zeichenfolgenwerte schreibt, müssen Sie zwei separate Quellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Klicken Sie dann eine andere Quelle ohne Ressourcendateien erstellen und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mit dieser Quelle.  
  
   
  
## Examples  
 Im folgende Beispiel werden ein Informationsereignis und eine Warnung Ereigniseintrag in ein vorhandenes Ereignisprotokoll schreibt. Der Text der Ereignis wird mit einem Ressourcenbezeichner in einer Ressourcendatei angegeben. Im Beispiel wird davon ausgegangen, dass die entsprechende Ressourcendatei für die Quelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldungstextdatei, in die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Textdatei handelt es sich um die Quelle aus der der Meldungsressourcendatei erstellt wird. Die Nachricht Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, die in der ereignismeldung wird und die Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="source" /> Wert ist eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="instance.InstanceId" />ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
 \- oder –  
  
 <paramref name="values" />verfügt über mehr als 256 Elemente.  
  
 \- oder –  
  
 Eines der <paramref name="values" /> Elemente ist länger als 32.766 Bytes.  
  
 \- oder –  
  
 Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat einen Fehler gemeldet, wenn den Ereigniseintrag in das Ereignisprotokoll zu schreiben. Ein Windows-Fehlercode ist nicht verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben von die Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
