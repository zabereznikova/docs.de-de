<Type Name="Process" FullName="System.Diagnostics.Process">
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf lokale Prozesse und Remoteprozesse und das Starten und Anhalten lokaler Systemprozesse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Ein <xref:System.Diagnostics.Process> Komponente bietet Zugriff auf einen Prozess, der auf einem Computer ausgeführt wird. Ein Prozess ist das einfachste ausgedrückt, eine ausgeführte app. Ein Thread ist die grundlegende Einheit, zu der das Betriebssystem Prozessorzeit reserviert. Ein Thread ausgeführt werden kann einen beliebigen Teil der Code des Prozesses, einschließlich der Teile, die derzeit von einem anderen Thread ausgeführt wird.  
  
 Die <xref:System.Diagnostics.Process> Komponente ist ein nützliches Werkzeug zum Starten, beenden, steuern und Überwachen von apps. Sie können die <xref:System.Diagnostics.Process> -Komponente, um eine Liste der Prozesse abzurufen, die ausgeführt werden, oder Sie können einen neuen Prozess starten. Ein <xref:System.Diagnostics.Process> Komponente wird verwendet, um Systemprozesse zugreifen. Nach einer <xref:System.Diagnostics.Process> Komponente initialisiert wurde, können sie zum Abrufen von Informationen über den laufenden Prozess verwendet werden. Dazu gehören die Gruppe von Threads, die geladenen Module (DLL- und .exe-Dateien), und Leistungsinformationen z. B. die Größe des Arbeitsspeichers des Prozesses verwendet.  
  
 Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
> [!NOTE]
>  32-Bit-Prozesse können nicht die Module eines 64-Bit-Prozesses zugreifen. Wenn Sie versuchen, erhalten Informationen zu einem 64-Bit-Prozess von einem 32-Bit-Prozess, erhalten Sie eine <xref:System.ComponentModel.Win32Exception> Ausnahme. Ein 64-Bit-Prozess kann hingegen, die Module von einer 32-Bit-Prozess zugreifen.  
  
 Die Process-Komponente ruft Informationen über eine Gruppe von Eigenschaften, die alle auf einmal ab. Nach der <xref:System.Diagnostics.Process> Komponente Informationen über ein Mitglied der Gruppe "Jeder" erhalten hat, wird die Werte für die anderen Eigenschaften in dieser Gruppe zwischengespeichert und neue Informationen zu den anderen Mitgliedern der Gruppe "nicht abgerufen werden, erst nach dem Aufruf der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Aus diesem Grund ein Eigenschaftswert ist nicht unbedingt aktueller als der letzte Aufruf von der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Die Einteilung der Gruppen sind abhängig vom Betriebssystem an.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
 Ein Systemprozess ist auf dem System durch die Prozess-ID eindeutig identifiziert. Wie viele Windows-Ressourcen ist ein Prozess auch von seinem Handle identifiziert, die nicht auf dem Computer eindeutig sein. Ein Handle ist der Oberbegriff für einen Bezeichner einer Ressource. Das Betriebssystem behält das Prozesshandle, die über zugegriffen wird die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft von der <xref:System.Diagnostics.Process> Komponente, selbst wenn der Prozess beendet wurde. Daher können Sie den Prozess administrativen Informationen abrufen, wie z. B. die <xref:System.Diagnostics.Process.ExitCode%2A> (in der Regel entweder 0 (null) für den Erfolg oder ein Fehlercode ungleich null) und die <xref:System.Diagnostics.Process.ExitTime%2A>. Handles sind Handles gelangen mehr als Speicherverlust bösartig ist eine äußerst wertvolle Ressourcen.  
  
> [!NOTE]
>  Diese Klasse enthält einen Linkaufruf und einer vererbungsanforderung auf Klassenebene, die für alle Member gilt. Ein <xref:System.Security.SecurityException> wird ausgelöst, wenn nicht für den unmittelbaren Aufrufer oder die abgeleitete Klasse volle Vertrauenswürdigkeit verfügt. Weitere Informationen zu sicherheitsforderungen, finden Sie unter [Verknüpfungsaufrufe](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]Hinweise  
 In .NET Framework die <xref:System.Diagnostics.Process> Klasse verwendet standardmäßig <xref:System.Console> Codierungen, die in der Regel sind code codepagecodierungen für die Eingabe, Ausgabe und Fehler Streams. Beispielcode hierzu auf Systemen mit der Kultur Englisch (Vereinigte Staaten), wird die Codepage 437 die standardcodierung für die <xref:System.Console> Klasse. Allerdings [!INCLUDE[net_core](~/includes/net-core-md.md)] kann nur eine beschränkte Teilmenge dieser Codierungen verfügbar machen. Wenn dies der Fall ist, verwendet er <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> als die standardcodierung.  
  
 Wenn eine <xref:System.Diagnostics.Process> Objekt auf bestimmte codepagecodierungen abhängig ist, können Sie weiterhin sie verfügbar machen, indem Sie die folgenden *vor* rufen Sie eine <xref:System.Diagnostics.Process> Methoden:  
  
1.  Fügen Sie einen Verweis auf die Assembly System.Text.Encoding.CodePages.dll zu Ihrem Projekt ein.  
  
2.  Abrufen der <xref:System.Text.EncodingProvider> -Objekt aus der <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> Eigenschaft.  
  
3.  Übergeben der <xref:System.Text.EncodingProvider> -Objekt an die <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> Methode zum Erstellen von zusätzlichen Codierungen, die von der Codierung verfügbaren Anbieter unterstützt.  
  
 Die <xref:System.Diagnostics.Process> Klasse automatisch verwendet dann das System standardcodierung anstatt UTF8, vorausgesetzt, dass Sie die codierungsanbieter registriert haben, bevor er einen <xref:System.Diagnostics.Process> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Process> selbst und eine statische Klasse <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines Prozesses.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Das folgende Beispiel f# definiert eine `runProc` -Funktion, die einen Prozess startet erfasst alle Ausgabe und Fehler, und zeichnet die Anzahl der Millisekunden, die der Prozess ausgeführt wurde.  Die `runProc` Funktion verfügt über drei Parameter: den Namen der Anwendung zu starten, die Argumente, um die Anwendung und das Startverzeichnis bereit.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Der Code für die `runProc` Funktion wurde von geschrieben [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) und steht unter der [Microsoft Public License](http://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Process" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie keinen angeben der <xref:System.Diagnostics.Process.MachineName%2A> -Eigenschaft, die Standardeinstellung ist der lokale Computer (".").  
  
 Sie haben zwei Möglichkeiten zum Zuordnen eines neuen <xref:System.Diagnostics.Process> Komponente mit einem Prozess auf dem Computer. Die erste Möglichkeit besteht, mit dem Konstruktor zum Erstellen der <xref:System.Diagnostics.Process> Komponente, legen Sie die entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und rufen <xref:System.Diagnostics.Process.Start%2A> Zuordnen der <xref:System.Diagnostics.Process> mit einem neuen Systemprozess. Die zweite Möglichkeit besteht in der Zuordnung der <xref:System.Diagnostics.Process> mit einem laufenden Systemprozess mit <xref:System.Diagnostics.Process.GetProcessById%2A> mindestens eine der <xref:System.Diagnostics.Process.GetProcesses%2A> Rückgabewerte.  
  
 Bei Verwendung einer `static` Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines neuen System-Prozesses, die Methode erstellt ein neues <xref:System.Diagnostics.Process> Komponente und ordnet diese den Prozess.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> Eigenschaft auf den Standardwert festgelegt ist `true`, Starten von Anwendungen und Dokumente in einer Weise, die ähnlich wie die `Run` Dialogfeld des Windows- `Start` Menü. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> ist `false`, können Sie nur die ausführbaren Dateien starten.  
  
 Jede ausführbare Datei, die Sie, über die Befehlszeile aufrufen können kann auf zwei Arten gestartet werden: durch Festlegen der entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft und der Aufruf der <xref:System.Diagnostics.Process.Start%2A> -Methode ohne Parameter oder durch Übergeben des entsprechenden Parameters an den `static` <xref:System.Diagnostics.Process.Start%2A> Member.  
  
 Können Sie erstellen eine <xref:System.Diagnostics.Process> -Komponente mithilfe des Konstruktors und die statische <xref:System.Diagnostics.Process.Start%2A> Überladungen und keines der <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methoden. Wenn Sie dies getan haben, müssen Sie einen Einblick in den zugeordneten Prozess. Dies ist eine dynamische Ansicht, die sich selbst automatisch aktualisiert, wenn die Prozesseigenschaften im Arbeitsspeicher geändert haben. Sie müssen stattdessen Aufrufen <xref:System.Diagnostics.Process.Refresh%2A> für die zu aktualisierende Komponente der <xref:System.Diagnostics.Process> Eigenschaftsinformationen in Ihrer Anwendung.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basispriorität des zugeordneten Prozesses ab.</summary>
        <value>Die Basispriorität, die anhand der <see cref="P:System.Diagnostics.Process.PriorityClass" /> des zugeordneten Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> des Prozesses ist die Startpriorität für Threads, die innerhalb des zugeordneten Prozesses erstellt. Sie können Informationen über die Basispriorität, die über den Systemmonitor Priorität Basiszähler anzeigen.  
  
 Basierend auf der Zeit, die verstrichene anderen Prozessen, das Betriebssystem die Basispriorität ändern können, wenn ein Prozess vor anderen platziert werden soll.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> -Eigenschaft können Sie die an einen Prozess zugewiesene Startpriorität anzeigen. Jedoch, da er schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> zum Festlegen der Priorität des Prozesses. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> Eigenschaft. Der <xref:System.Diagnostics.Process.BasePriority%2A> angezeigt werden der Systemmonitor dagegen die <xref:System.Diagnostics.Process.PriorityClass%2A> nicht. Sowohl die <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> können programmgesteuert angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen <xref:System.Diagnostics.Process.BasePriority%2A> Werte und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -   
  
 Der Prozess wurde nicht gestartet, daher gibt es keine Prozess-ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge auf den Fehlerausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es dem angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardError%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> auf `true` fest.  
  
3.  Fügen Sie den Ereignishandler an das <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Wenn asynchrone Lesevorgänge Start und der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile zu seiner <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang "Abbrechen", durch den Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortsetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument an. Die Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des net-Befehl, der wartet, bis der Prozess abgeschlossen ist, und führt die Ausgabe an die Konsole schreibt erfasst. Wenn der Benutzer die optionale Fehlerdatei bereitstellt, schreibt das Beispiel Fehler in die Datei an.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist <see langword="false" />.  
  
 \- oder –  
  
 Für den <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
 \- oder –  
  
 Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Ausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardOutput%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> auf `true` fest.  
  
3.  Fügen Sie den Ereignishandler an das <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Wenn asynchrone Lesevorgänge Start und der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile zu seiner <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang "Abbrechen", durch den Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortsetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `sort` Befehl. Die `sort` Befehl ist eine Konsolenanwendung, liest und Texteingabe sortiert.  
  
 Das Beispiel erstellt einen Delegaten für die `SortOutputHandler` Ereignishandler und ordnet sie der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen vom umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, den Text formatiert und schreibt den Text auf dem Bildschirm.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />-Eigenschaft ist <see langword="false" />.  
  
 \- oder –  
  
 Für den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
 \- oder –  
  
 Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardError%2A> Stream. <xref:System.Diagnostics.Process.CancelErrorRead%2A>beendet den asynchronen Lesevorgang.  
  
 Nach dem Abbruch können Sie durch Aufrufen den asynchronen Lesevorgang fortsetzen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>, werden alle in Bearbeitung Lesevorgänge für <xref:System.Diagnostics.Process.StandardError%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardError%2A> in einem Puffer gespeichert ist. Wenn Sie den Ereignishandler mit einem Aufruf von wieder aktivieren <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, wird die gespeicherte Ausgabe an den Ereignishandler gesendet, und asynchrone Lesevorgänge fortsetzen. Wenn Sie den Ereignishandler zu ändern, bevor Sie asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, vor dem Hinzufügen des neuen Ereignishandler:  
  
```  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten nicht Mischen <xref:System.Diagnostics.Process.StandardError%2A> Stream. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Wenn Sie den Vorgang Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardError%2A> und müssen aus dem Stream gelesenen erneut, verwenden Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelErrorRead%2A> durch einen Aufruf der synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardError%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Ausgaben des Fehler- und -Streams werden asynchron gelesen. die erfassten Textzeilen werden in der Konsole angezeigt als auch in eine Protokolldatei geschrieben. Wenn die Ausgabe des Befehls eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. <xref:System.Diagnostics.Process.CancelOutputRead%2A>beendet den asynchronen Lesevorgang.  
  
 Nach dem Abbruch können Sie asynchrone Lesevorgänge fortsetzen, indem Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>, werden alle in Bearbeitung Lesevorgänge für <xref:System.Diagnostics.Process.StandardOutput%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardOutput%2A> in einem Puffer gespeichert ist. Wenn Sie den Ereignishandler mit einem Aufruf von wieder aktivieren <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, wird die gespeicherte Ausgabe an den Ereignishandler gesendet, und asynchrone Lesevorgänge fortsetzen. Wenn Sie den Ereignishandler zu ändern, bevor Sie asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, vor dem Hinzufügen des neuen Ereignishandler:  
  
```  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten nicht Mischen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Wenn Sie den Vorgang Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardOutput%2A> und müssen aus dem Stream gelesenen erneut, verwenden Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelOutputRead%2A> durch einen Aufruf der synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardOutput%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Ausgaben des Fehler- und -Streams werden asynchron gelesen. die erfassten Textzeilen werden in der Konsole angezeigt als auch in eine Protokolldatei geschrieben. Wenn die Ausgabe des Befehls eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle dieser Komponente zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Close%2A> Methode bewirkt, dass den Prozess beendet wird, Warten beenden, wenn er gewartet wurde, schließt das Prozesshandle und löscht prozessspezifische Eigenschaften. <xref:System.Diagnostics.Process.Close%2A>standard-Ausgabe, Eingabe- und Reader und Writer schließt nicht für den Fall, dass sie extern verwiesen wird.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Dispose%2A>-Methode ruft <xref:System.Diagnostics.Process.Close%2A> auf. Platzieren der <xref:System.Diagnostics.Process> -Objekt in ein `using` Block verwirft Ressourcen aufrufen, ohne <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, bei 2-Sekunden-Intervallen für maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt einen Prozess mit einer Benutzeroberfläche, indem eine Meldung zum Schließen an das Hauptfenster gesendet wird.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung zum Schließen erfolgreich gesendet wurde. <see langword="false" />, wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt oder wenn das Hauptfenster deaktiviert ist (z. B., wenn ein modales Dialogfeld angezeigt wird).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess ausgeführt wird, ist die Nachrichtenschleife in einen Wartezustand versetzt. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum nahe, die in eine wohlgeformte Anwendung wird die untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung im Hauptfenster. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Die Anwendung kann fragt nach der Überprüfung des Benutzers vor dem Beenden oder kann es ablehnen, um den Vorgang abzubrechen. Um die Anwendung beenden zu erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten des <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer eine Anwendung im Hauptfenster über das Menü "System" zu schließen. Aus diesem Grund erzwingt die Anforderung an den Prozess zu beenden, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
 Daten, die vom Prozess bearbeitet oder an den Prozess reservierten Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A>bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A>ermöglicht es eine ordnungsgemäße Beendigung des Prozesses, und schließt alle Fenster, damit für Anwendungen mit einer Schnittstelle zu bevorzugen ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A>ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Schnittstellen haben.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur für Prozesse, die auf Remotecomputern ausgeführte Informationen anzeigen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von diesem Prozess verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob beim Beenden des Prozesses das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll, wenn der zugeordnete Prozess beendet wird (entweder durch Beenden oder einen Aufruf von <see cref="M:System.Diagnostics.Process.Kill" />); andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Beachten Sie, dass die <see cref="E:System.Diagnostics.Process.Exited" /> Ereignis wird ausgelöst, selbst wenn der Wert der <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> ist <see langword="false" /> Wenn während der Prozess beendet wird bzw. bevor der Benutzer führt eine <see cref="P:System.Diagnostics.Process.HasExited" /> überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft schlägt vor, ob die Komponente benachrichtigt werden soll, wenn das Betriebssystem einen Prozess beendet wurde. Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft wird bei der asynchronen Verarbeitung verwendet, um Ihre Anwendung zu benachrichtigen, die ein Prozess beendet wurde. Ihre Anwendung synchron einen Exit-Ereignis warten (wodurch die Verarbeitung der Anwendung bis Exit-Ereignis aufgetreten ist) erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode.

> [!NOTE]
> Wenn Sie Visual Studio verwenden, und doppelklicken Sie auf eine <xref:System.Diagnostics.Process> -Komponente in Ihrem Projekt eine <xref:System.Diagnostics.Process.Exited> Ereignisdelegaten und Ereignishandler werden automatisch generiert. Kein zusätzlicher Code legt die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft `false`. Sie müssen diese Eigenschaft ändern `true` für einen Ereignishandler, der ausgeführt wird, wenn der zugeordnete Prozess beendet wird.

Wenn der Komponente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Wert ist `true`, oder wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `false` und ein <xref:System.Diagnostics.Process.HasExited%2A> Kontrollkästchen wird aufgerufen, indem die Komponente, die Komponente über Zugriff auf die administrativen Informationen für den zugeordneten Prozess, die bleibt. durch das Betriebssystem gespeichert. Dazu gehören die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.ExitCode%2A>.

Nachdem der zugeordnete Prozess beendet wird, wird die <xref:System.Diagnostics.Process.Handle%2A> verweist nicht mehr von der Komponente auf eine vorhandene Prozessressource. Stattdessen können sie nur verwendet werden um das Betriebssystem Informationen über die Process-Ressource zuzugreifen. Das Betriebssystem ist, beachten Sie, dass die Handles für beendete Prozesse, die von veröffentlicht wurde noch nicht vorhanden sind <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher.

Es ist ein gewisser Aufwand verbunden, mit dem für einen Prozess zu beenden. Wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `true`die <xref:System.Diagnostics.Process.Exited> Ereignis wird ausgelöst, wenn der zugeordnete Prozess beendet wird. Verfahren für die <xref:System.Diagnostics.Process.Exited> Ereignis zu diesem Zeitpunkt ausführen.

In einigen Fällen die Anwendung startet einen Prozess jedoch benötigt keine Benachrichtigung über dessen Beendigung. Die Anwendung kann z. B. Editor, dass der Benutzer Text bearbeiten, aber keine weiteren Nutzen der Editor-Anwendung starten. Sie können auswählen, um die Benachrichtigung zu vermeiden, wenn der Prozess beendet wird, da sie nicht relevant für die weitere Ausführung der Anwendung ist. Festlegen von <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> auf `false` Systemressourcen speichern können.

## Examples  
Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Wird die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft dazu führen, dass den Prozess zum Auslösen der <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versetzt durch Aktivieren der systemeigenen <see cref="T:System.Diagnostics.Process" />-Eigenschaft für den aktuellen Thread eine <see langword="SeDebugPrivilege" />-Komponente in einen Zustand, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse in einem speziellen Modus ausgeführt. Zum Lesen von Eigenschaften oder Anfügen an diese Prozesse versuchen, ist nicht möglich, es sei denn, Sie haben aufgerufen <xref:System.Diagnostics.Process.EnterDebugMode%2A> auf die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis gibt an, dass der zugeordnete Prozess in ihren umgeleiteten geschrieben hat <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Das Ereignis tritt nur während der asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis, und rufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Danach ist die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis signalisiert jedes Mal der Prozess eine Zeile in den umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardError%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet sollte Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument an. Die Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des net-Befehl, der wartet, bis der Prozess abgeschlossen ist, und führt die Ausgabe an die Konsole schreibt erfasst. Wenn der Benutzer die optionale Fehlerdatei bereitstellt, schreibt das Beispiel Fehler in die Datei an.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der vom zugeordneten Prozess beim Beenden angegeben wurde.</summary>
        <value>Der Code, der vom zugeordneten Prozess beim Beenden angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.ExitCode%2A> zum Abrufen des Status, die die Systemprozess zurückgegeben, wenn er beendet. Sie können den Exitcode viel verwenden, wie eine ganze Zahl Rückgabewert aus einer `main()` Prozedur.  
  
 Die <xref:System.Diagnostics.Process.ExitCode%2A> -Wert für ein Prozess die spezifische Konvention, die vom Anwendungsentwickler für diesen Prozess implementiert widerspiegelt. Wenn Sie den Exitcodewert für Entscheidungen in Ihrem Code verwenden, achten Sie darauf, dass Sie wissen, dass die Exit Code Konvention, die von der Anwendungsprozess verwendet.  
  
 Entwickler weisen normalerweise darauf hin durch einen erfolgreichen Beendigung einer <xref:System.Diagnostics.Process.ExitCode%2A> Wert 0 (null), und Bestimmen von Fehlern durch ungleich NULL-Werte, die die aufrufende Methode verwenden können, um die Ursache für eine nicht ordnungsgemäße Beendigung zu identifizieren. Es ist nicht notwendig, diese Richtlinien befolgen, aber sie sind der Konvention.  
  
 Wenn Sie versuchen, erhalten die <xref:System.Diagnostics.Process.ExitCode%2A> , bevor der Prozess beendet wurde, löst der Versuch eine Ausnahme aus. Überprüfen Sie die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu überprüfen, ob der zugeordnete Prozess beendet wurde.  
  
> [!NOTE]
>  Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen, wenn <xref:System.Diagnostics.Process.HasExited%2A> gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, rufen Sie die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, vor dem Einchecken akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Können Sie die <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder die <xref:System.Diagnostics.Process.Kill%2A> -Methode veranlassen Sie einen zugeordneten Prozess beendet.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt werden, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung beruht auf Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um die Verarbeitung Ihrer Anwendung anhalten, bis der zugeordnete Komponente beendet wird. Asynchrone Benachrichtigung beruht auf dem <xref:System.Diagnostics.Process.Exited> Ereignis. Wenn die asynchrone Benachrichtigung verwendet <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die <xref:System.Diagnostics.Process> Komponente, für die Benachrichtigung erhalten, die der Prozess beendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht beendet.  
  
 - oder -   
  
 Der Prozess <see cref="P:System.Diagnostics.Process.Handle" /> ist ungültig.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitCode" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Beenden eines Prozesses ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Exited> Ereignis gibt an, dass der zugeordnete Prozess beendet. Dies bedeutet, das entweder, dass den Prozess abgebrochen "oder" wurde erfolgreich abgeschlossen. Dieses Ereignis kann nur auftreten, wenn der Wert der <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft ist `true`.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt werden, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung bedeutet Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um den aktuellen Thread zu blockieren, bis der Prozess beendet wird. Asynchrone Benachrichtigung verwendet die <xref:System.Diagnostics.Process.Exited> -Ereignis, das den aufrufenden Thread die Ausführung in der Zwischenzeit fortsetzen kann. Im letzteren Fall <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die aufrufende Anwendung das Exited-Ereignis empfangen.  
  
 Wenn das Betriebssystem einen Prozess heruntergefahren wird, wird benachrichtigt, alle anderen Prozesse, die Handler für das Ereignis Exited registriert wurden. Zu diesem Zeitpunkt an, die das Handle des Prozesses, der gerade beendet genutzt werden, einige Eigenschaften wie z. B. den Zugriff auf <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.HasExited%2A> , dass das Betriebssystem verwaltet, bis er vollständig dieses Handle freigibt.  
  
> [!NOTE]
>  Selbst wenn Sie ein Handle für einen beendeten Prozess haben, kann nicht aufgerufen <xref:System.Diagnostics.Process.Start%2A> erneut eine Verbindung mit den gleichen Prozess herzustellen. Aufrufen von <xref:System.Diagnostics.Process.Start%2A> automatisch der zugeordnete Prozess freigegeben und eine Verbindung mit einem Prozess mit derselben Datei, aber eine völlig neue <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Weitere Informationen zur Verwendung von der <xref:System.Diagnostics.Process.Exited> Ereignis in Windows Forms-Anwendungen finden Sie unter der <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Es wird ausgelöst, die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn der Prozess beendet wird, da die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> -Eigenschaft wurde festgelegt, wenn der Prozess erstellt wurde. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem der zugeordnete Prozess beendet wurde.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die angibt, wann der zugeordnete Prozess beendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess nicht beendet wurde, wird beim Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> -Eigenschaft löst eine Ausnahme aus. Verwendung <xref:System.Diagnostics.Process.HasExited%2A> vor dem Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaft, um zu bestimmen, ob der zugeordnete Prozess beendet wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Der Vorgang löst die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird, und der Ereignishandler zeigt die <xref:System.Diagnostics.Process.ExitTime%2A> -Eigenschaft und andere Informationen verarbeiten.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine neue <see cref="T:System.Diagnostics.Process" />-Komponente ab und ordnet diese dem gegenwärtig aktiven Prozess zu.</summary>
        <returns>Eine neue <see cref="T:System.Diagnostics.Process" />-Komponente, die der Prozessressource zugeordnet ist, die die aufrufende Anwendung ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz und der Prozessressource auf dem lokalen Computer zuordnen.  
  
 Ähnlich wie <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und <xref:System.Diagnostics.Process.GetProcesses%2A> Methoden <xref:System.Diagnostics.Process.GetCurrentProcess%2A> ordnet eine vorhandene Ressource einer neuen <xref:System.Diagnostics.Process> Komponente.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn der Bezeichner eines Prozesses auf dem lokalen Computer angegeben ist.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten lokalen Prozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf dem lokalen Computer zugeordnet. Die Prozessressource muss bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> erstellt keine Systemressource, sondern eine Ressource mit einer Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, die derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> löst eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>ein Prozess zurückgibt darf höchstens. Wenn Sie die Prozesse, die für die Ausführung einer bestimmten Anwendung verwenden abrufen möchten <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugeordneten Prozessen. Sie können jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, dem `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die an einen Prozess zugewiesen wird.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn die Prozess-ID und der Name des Computers im Netzwerk angegeben sind.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten Remoteprozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf einem Remotecomputer im Netzwerk zugeordnet. Die Prozessressource muss bereits auf dem angegebenen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> erstellt keine Systemressource, sondern eine Ressource mit einer Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, die derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> löst eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>ein Prozess zurückgibt darf höchstens. Wenn Sie die Prozesse, die für die Ausführung einer bestimmten Anwendung verwenden abrufen möchten <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugeordneten Prozessen. Sie können jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, dem `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die an einen Prozess zugewiesen wird.  
  
 Wenn Sie keinen angeben einer `machineName`, der lokale Computer verwendet. Alternativ können Sie den lokalen Computer angeben, durch Festlegen von `machineName` auf den Wert "." oder auf eine leere Zeichenfolge ("").  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.  
  
 - oder -   
  
 Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Der Name kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem lokalen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und diese allen Prozessressourcen auf dem lokalen Computer zuordnen. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen verfügbar sind, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle auf dem Computer ausgeführten Prozesse abrufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A>erstellt eine <xref:System.Diagnostics.Process> Komponente, die der Prozess, durch die Prozess-ID, die Sie an die Methode übergeben, auf dem System identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A>erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordnete Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz des Dienst-Hostprozesses (svchost.exe) geladen werden. GetProcesses erkennt diese einzelne Dienste nicht; dazu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem die Liste der Prozesse gelesen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem angegebenen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und diese allen Prozessressourcen auf dem angegebenen (in der Regel remoten) Computer zuordnen. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen verfügbar sind, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle auf dem Computer ausgeführten Prozesse abrufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A>erstellt eine <xref:System.Diagnostics.Process> Komponente, die der Prozess, durch die Prozess-ID, die Sie an die Methode übergeben, auf dem System identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A>erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordnete Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
 Diese Überladung von der <xref:System.Diagnostics.Process.GetProcesses%2A> Methode wird in der Regel zum Abrufen der Liste der Prozessressourcen auf einem Remotecomputer im Netzwerk ausgeführt, aber Sie können den lokalen Computer geben, indem ".".  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz des Dienst-Hostprozesses (svchost.exe) geladen werden. GetProcesses erkennt diese einzelne Dienste nicht; dazu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf dem lokalen Computer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und ordnen diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem lokalen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern vielmehr ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann angegeben werden.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A>ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben der `processName` -Parameter, um alle ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist für eine einzelnes Prozessressource auf dem System eindeutig, mehrere Prozesse auf dem lokalen Computer können ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugeordneten Prozessen. Wenn Sie den Prozess über standard-API-Aufrufe bearbeiten müssen, können Sie jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Namen des Prozesses allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden Prozessressourcen, starten, beenden und die Systemressourcen auf andere Weise bearbeiten.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf einem Remotecomputer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und ordnen diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem angegebenen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern vielmehr ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann angegeben werden.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A>ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben der `processName` -Parameter, um alle ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist für eine einzelnes Prozessressource auf dem System eindeutig, mehrere Prozesse auf dem lokalen Computer können ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugeordneten Prozessen. Wenn Sie den Prozess über standard-API-Aufrufe bearbeiten müssen, können Sie jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Namen des Prozesses allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden Prozessressourcen, starten, beenden und die Systemressourcen auf andere Weise bearbeiten.  
  
 Sie können diese Überladung verwenden, um Prozesse auf dem lokalen Computer sowie auf einem Remotecomputer abzurufen. Verwenden "." auf den lokalen Computer anzugeben. Eine andere Überladung vorhanden ist, die den lokalen Computer in der Standardeinstellung verwendet.  
  
 Sie können die Prozesse auf Remotecomputern nur zum Anzeigen von Informationen zu den Prozessen, z. B. Statistiken zugreifen. Sie können nicht schließen, und beenden (mit <xref:System.Diagnostics.Process.Kill%2A>), oder starten Sie Prozesse auf Remotecomputern.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Code. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle des zugeordneten Prozesses ab.</summary>
        <value>Das Handle, das das Betriebssystem dem zugeordneten Prozess beim Starten des Prozesses zugewiesen hat. Das System verwendet dieses Handle zum Verfolgen der Prozessattribute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Handle für einen Prozess abrufen, die als Parameter für viele Funktionen von Prozessinformationen und -Steuerelement verwendet werden kann. Verwenden Sie dieses Handle zum Initialisieren einer <xref:System.Threading.WaitHandle> oder aufrufen systemeigene Methoden mit einem Plattformaufruf aufgerufen werden soll.  
  
 Diese Prozesshandle ist privat zu einer Anwendung – also Handles können nicht gemeinsam genutzt werden. Ein Prozess verfügt auch über einen Prozess <xref:System.Diagnostics.Process.Id%2A> die im Gegensatz zu den <xref:System.Diagnostics.Process.Handle%2A>, ist eindeutig und somit im gesamten System gültig.  
  
 Nur Prozesse gestartet, durch einen Aufruf von <xref:System.Diagnostics.Process.Start%2A> legen Sie die <xref:System.Diagnostics.Process.Handle%2A> -Eigenschaft des entsprechenden <xref:System.Diagnostics.Process> Instanzen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht gestartet oder wurde beendet. Die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft kann nicht gelesen werden, weil dieser <see cref="T:System.Diagnostics.Process" />-Instanz kein Prozess zugeordnet ist.  
  
 - oder -   
  
 Die <see cref="T:System.Diagnostics.Process" />-Instanz wurde einem aktiven Prozess zugeordnet, Sie haben aber nicht die erforderlichen Berechtigungen, um ein Handle mit vollen Zugriffsrechten abzurufen.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der vom Prozess geöffneten Handles ab.</summary>
        <value>Die Anzahl der vom Prozess geöffneten Betriebssystemhandles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles bieten eine Möglichkeit für einen Prozess zum Verweisen auf Objekte. Ein Prozess kann Handles für Dateien, Ressourcen, Nachrichtenwarteschlangen und viele andere Objekte des Betriebssystems erhalten. Das Betriebssystem Gibt den Arbeitsspeicher frei nur, wenn die maximale Handleanzahl beträgt 0 (null) ist dem Prozess zugeordnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der zugehörige Prozess beendet wurde.</summary>
        <value>
          <see langword="true" />, wenn der Betriebssystemprozess, auf den die <see cref="T:System.Diagnostics.Process" />-Komponente verweist, beendet wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `true` für <xref:System.Diagnostics.Process.HasExited%2A> gibt an, dass der zugeordnete Prozess ordnungsgemäß oder nicht ordnungsgemäß beendet wurde. Sie können anfordern, oder Erzwingen der zugeordneten Prozess beendet durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Wenn ein Handle an den Prozess geöffnet ist, gibt das Betriebssystem den Prozessspeicher frei, wenn der Prozess wurde beendet, behält jedoch administrative Informationen über den Prozess, z. B. Handle, Exitcode und Beendigungszeit. Zum Abrufen dieser Informationen können Sie die <xref:System.Diagnostics.Process.ExitCode%2A> und <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaften. Diese Eigenschaften werden für Prozesse, die von dieser Komponente gestartet wurden, automatisch aufgefüllt. Verwaltungsinformationen wird freigegeben, wenn alle der <xref:System.Diagnostics.Process> Komponenten, die mit dem Systemprozess verknüpft sind beschädigt, und halten Sie keine weiteren Handles für den beendeten Prozess.  
  
 Ein Prozess kann unabhängig von Ihrem Code beendet. Wenn Sie den Prozess mit dieser Komponente gestartet, aktualisiert das System den Wert der <xref:System.Diagnostics.Process.HasExited%2A> automatisch, auch wenn der zugeordnete Prozess unabhängig voneinander beendet.  
  
> [!NOTE]
>  Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen haben, wenn diese Eigenschaft gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, rufen Sie die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, vor dem Einchecken akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Der Exitcode für den Prozess konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.HasExited" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner für den zugeordneten Prozess ab.</summary>
        <value>Der vom System generierte eindeutige Bezeichner des Prozesses, auf den von dieser <see cref="T:System.Diagnostics.Process" />-Instanz verwiesen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prozess <xref:System.Diagnostics.Process.Id%2A> ist ungültig, wenn der zugeordnete Prozess nicht ausgeführt wird. Aus diesem Grund sollten Sie sicherstellen, dass der Prozess ausgeführt wird, bevor Sie versuchen, die zum Abrufen der <xref:System.Diagnostics.Process.Id%2A> Eigenschaft. Bis der Prozess beendet wird, identifiziert den Prozess im gesamten System die Prozess-ID eindeutig.  
  
 Sie verbinden einen Prozess, der auf einem Computer lokal oder remote auf einen neuen ausgeführt wird <xref:System.Diagnostics.Process> Instanz durch Übergeben der Prozess-ID, die <xref:System.Diagnostics.Process.GetProcessById%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A>ist eine `static` -Methode, eine neue Komponente erstellt, und legt der <xref:System.Diagnostics.Process.Id%2A> Eigenschaft für die neue <xref:System.Diagnostics.Process> Instanz automatisch.  
  
 Prozess-IDs können durch das System wiederverwendet werden. Die <xref:System.Diagnostics.Process.Id%2A> Eigenschaftswert ist nur während der zugeordnete Prozess ausgeführt wird. Nachdem der Prozess beendet wurde, kann das System Wiederverwenden der <xref:System.Diagnostics.Process.Id%2A> Eigenschaftswert für einen nicht verwandten Prozess.  
  
 Da der Bezeichner für das System eindeutig ist, können Sie es für andere Threads übergeben, als Alternative zum Übergeben einer <xref:System.Diagnostics.Process> Instanz. Dadurch kann Systemressourcen sparen trotzdem sicherstellen, dass der Prozess ordnungsgemäß identifiziert wird.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der <xref:System.Diagnostics.Process.Id%2A> für alle Instanzen einer Anwendung ausführen. Der Code erstellt eine neue Instanz von Editor, listet Sie alle Instanzen von Editor und dann ermöglicht es dem Benutzer zur Eingabe der <xref:System.Diagnostics.Process.Id%2A> Zahl und eine bestimmte Instanz zu entfernen.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft des Prozesses wurde nicht festgelegt.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den zugeordneten Prozess sofort an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A>Erzwingt die Beendigung des Prozesses, während <xref:System.Diagnostics.Process.CloseMainWindow%2A> Beendigung lediglich anfordert. Wenn ein Prozess mit einer grafischen Benutzeroberfläche ausgeführt wird, ist die Nachrichtenschleife in einen Wartezustand versetzt. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum nahe, die in eine wohlgeformte Anwendung wird die untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung im Hauptfenster. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Die Anwendung kann fragt nach der Überprüfung des Benutzers vor dem Beenden oder kann es ablehnen, um den Vorgang abzubrechen. Um die Anwendung beenden zu erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten des <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer eine Anwendung im Hauptfenster über das Menü "System" zu schließen. Aus diesem Grund erzwingt die Anforderung an den Prozess zu beenden, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Kill%2A> Methode asynchron ausgeführt wird. Nach dem Aufruf der <xref:System.Diagnostics.Process.Kill%2A> -Methode, rufen die <xref:System.Diagnostics.Process.WaitForExit%2A> -Methode warten, für den Prozess zu beenden, oder überprüfen die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu bestimmen, ob der Prozess beendet wurde.  
  
 Daten, die vom Prozess bearbeitet oder an den Prozess reservierten Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A>bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A>ermöglicht es eine ordnungsgemäße Beendigung des Prozesses, und schließt alle Fenster, damit für Anwendungen mit einer Schnittstelle zu bevorzugen ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A>ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Schnittstellen haben.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur für Prozesse, die auf Remotecomputern ausgeführte Informationen anzeigen.  
  
> [!NOTE]
>  Wenn der Aufruf der <xref:System.Diagnostics.Process.Kill%2A> Methode erfolgt während der Prozess gerade beendet wird, eine <xref:System.ComponentModel.Win32Exception> wird ausgelöst, für den Zugriff verweigert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.  
  
 - oder -   
  
 Der Prozess wird beendet.  
  
 - oder -   
  
 Der zugeordnete Prozess ist eine ausführbare Win16-Datei.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den Zustand einer <see cref="T:System.Diagnostics.Process" />-Komponente, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse in einem speziellen Modus ausgeführt. Zum Lesen von Eigenschaften oder Anfügen an diese Prozesse versuchen, ist nicht möglich, es sei denn, Sie haben aufgerufen <xref:System.Diagnostics.Process.EnterDebugMode%2A> auf die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem der zugeordnete Prozess ausgeführt wird.</summary>
        <value>Der Name des Computers, auf dem der zugeordnete Prozess ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können statistische Daten anzeigen und Prozessinformationen für Prozesse auf Remotecomputern, aber Sie kann nicht aufgerufen werden <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, oder <xref:System.Diagnostics.Process.Kill%2A> auf Remotecomputern.  
  
> [!NOTE]
>  Wenn der zugeordnete Prozess auf dem lokalen Computer ausgeführt wird, gibt diese Eigenschaft einen Punkt (".") für den Computernamen. Verwenden Sie die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den richtigen Computernamen abzurufen.  
  
   
  
## Examples  
 Um verwenden das folgende Beispiel müssen Sie zuerst mindestens eine Instanz von Editor auf einem Remotecomputer starten. Im Beispiel fordert den Namen des Remotecomputers auf dem Editor ausgeführt wird, und zeigt dann die entsprechende <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, und <xref:System.Diagnostics.Process.MachineName%2A> Eigenschaften für jede Instanz.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Hauptmodul für den zugeordneten Prozess ab.</summary>
        <value>Das zum Starten des Prozesses verwendete <see cref="T:System.Diagnostics.ProcessModule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt DLL- oder .exe-Datei, die in einem bestimmten Prozess geladen wird. Die <xref:System.Diagnostics.Process.MainModule%2A> -Eigenschaft können Sie die Informationen über die ausführbare Datei, die zum Starten des Prozesses, einschließlich der Modulname, Dateiname und Arbeitsspeicher Moduldetails anzuzeigen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainModule" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ein 32-Bit-Prozess versucht, auf die Module eines 64-Bit-Prozesses zuzugreifen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
 - oder -   
  
 Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle des Hauptfensters des zugeordneten Prozesses ab.</summary>
        <value>Das vom System generierte Fensterhandle des Hauptfensters des zugeordneten Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Hauptfenster ist das Fenster geöffnet, die durch den Prozess, der gerade den Fokus besitzt (die <xref:System.Windows.Forms.Form.TopLevel%2A> Form). Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das die aktuelle im Hauptfenster Handle zu erhalten, wenn es geändert hat. Im Allgemeinen verwenden, da das Fensterhandle zwischengespeichert wird, <xref:System.Diagnostics.Process.Refresh%2A> im voraus, um sicherzustellen, dass das aktuelle Handle abgerufen werden müssen.  
  
 Sie erhalten die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft ist ein Wert, der das Fenster eindeutig bezeichnet, die dem Prozess zugeordnet ist.  
  
 Ein Prozess verfügt über ein Hauptfenster mit ihm verknüpft sind, nur, wenn der Prozess eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Wert ist 0 (null). Der Wert ist auch, dass NULL für Prozesse, die ausgeblendet wurden, d. h. verarbeitet werden, die nicht in der Taskleiste sichtbar sind. Dies kann der Fall für Prozesse, die als Symbole im Infobereich ganz rechts in der Taskleiste angezeigt werden.  
  
 Wenn Sie einen Prozess gestartet haben und ihr Handle im Hauptfenster verwenden möchten, können Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um der Prozess gestartet, abgeschlossen zuzulassen, um sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> ist nicht definiert werden, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowHandle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschriftung des Hauptfensters des Prozesses ab.</summary>
        <value>Der Titel des Hauptfensters des Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozess verfügt über ein Hauptfenster mit ihm verknüpft sind, nur, wenn der Prozess eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt (sodass <xref:System.Diagnostics.Process.MainWindowHandle%2A> 0 (null)), <xref:System.Diagnostics.Process.MainWindowTitle%2A> ist eine leere Zeichenfolge (""). Wenn Sie einen Prozess gestartet haben und den Titel des Hauptfensters verwenden möchten, können Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um der Prozess gestartet, abgeschlossen zuzulassen, um sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls löst das System eine Ausnahme aus.  
  
> [!NOTE]
>  Das Hauptfenster ist das Fenster, das gegenwärtig den Fokus besitzt. Beachten Sie, dass dies möglicherweise die primäre Fenster für den Prozess nicht. Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das die aktuelle im Hauptfenster Handle zu erhalten, wenn es geändert hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet und ruft die Beschriftung des Hauptfensters des Prozesses ab.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> Eigenschaft ist nicht definiert, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die maximal zulässige Workingsetgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher maximal zulässige Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die die Anwendung ausführt enthalten, u. a. die Seiten in der DLL-Dateien und die Dateien "System.dll". Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess verfügt Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt ist, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, mindestens die Mindestmenge an Arbeitsspeicher zu behalten residenten, wenn der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt die Größen für Workingsets. Sie können ändern, diese Größe mit der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Elemente. Allerdings garantiert Werten nicht, ob der Speicher reserviert oder resident sind.  
  
> [!NOTE]
>  Wenn Sie die Größe des Workingsets eines Prozesses erhöhen, gelangen Sie physischen Arbeitsspeicher Weg von der Rest des Systems an. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert werden, die zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Workingsetgröße ist ungültig. Sie muss größer gleich der Workingsetmindestgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -   
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MaxWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
 - oder -   
  
 Der Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die Workingsetmindestgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher mindestens erforderliche Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die die Anwendung ausführt enthalten, u. a. die Seiten in der DLL-Dateien und die Dateien "System.dll". Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess verfügt Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt ist, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, mindestens die Mindestmenge an Arbeitsspeicher zu behalten residenten, wenn der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt die Größen für Workingsets. Sie können ändern, diese Größe mit der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Elemente. Allerdings garantiert Werten nicht, ob der Speicher reserviert oder resident sind.  
  
> [!NOTE]
>  Wenn Sie die Größe des Workingsets eines Prozesses erhöhen, gelangen Sie physischen Arbeitsspeicher Weg von der Rest des Systems an. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert werden, die zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Workingsetmindestgröße ist ungültig. Sie muss kleiner gleich der maximalen Workingsetgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -   
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MinWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
 - oder -   
  
 Der Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Module ab, die vom zugeordneten Prozess geladen wurden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessModule" />, das die vom zugeordneten Prozess geladenen Module darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt DLL- oder .exe-Datei, die in einem bestimmten Prozess geladen wird. Ein <xref:System.Diagnostics.ProcessModule> Instanz können Sie Informationen zu einem Modul, einschließlich der Modulname, Dateiname und Arbeitsspeicher Moduldetails anzeigen.  
  
 Ein Prozess kann mehrere Module in den Arbeitsspeicher geladen werden. Beispielsweise haben .exe-Dateien, die zusätzliche DLL-Dateien laden, mehrere Module.  
  
 Nach dem Starten des Prozesses, ist dieser Auflistung leer, bis das System den Prozess geladen wurden. Wenn der Prozess über ein Hauptfenster verfügt, können Sie aufrufen <xref:System.Diagnostics.Process.WaitForInputIdle%2A> vor dem Abrufen dieser Eigenschaft, um sicherzustellen, dass die Auflistung nicht leeren beim Abrufen der Liste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für den Systemprozess oder den Leerlaufprozess zuzugreifen. Diese Prozesse verfügen über keine Module.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess reserviert ist und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des nicht ausgelagerten Systemspeichers verwendet, die für den Prozess in Bytes dar. Systemspeicher ist der vom Betriebssystem verwendeten physikalischen Speichers und Durchschnittswert unterteilt ist. Nicht ausgelagerte Arbeitsspeicher verbleiben im Arbeitsspeicher und nicht die Auslagerungsdatei des virtuellen Speichers ausgelagert werden.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Auslagerungsseiten (Bytes) Pool** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A>die API-Methode, die auslöst wird die <xref:System.Diagnostics.Process.Exited> Ereignis. Aufrufen <xref:System.Diagnostics.Process.OnExited%2A> bewirkt, dass die <xref:System.Diagnostics.Process.Exited> Ereignis auftreten und ist die einzige Möglichkeit zum Auslösen von dem Ereignis mit der <xref:System.Diagnostics.Process> Komponente. <xref:System.Diagnostics.Process.OnExited%2A>wird hauptsächlich verwendet, wenn Klassen von der Komponente abgeleitet.  
  
 Als Alternative zur <xref:System.Diagnostics.Process.OnExited%2A>, Sie können einen eigenen Ereignishandler schreiben. Erstellen Sie eine eigene Ereignishandlerdelegaten und eine eigene Methode für die Ereignisbehandlung.  
  
> [!NOTE]
>  Bei Verwendung von Visual Studio-Umgebung ein Ereignishandlerdelegat (AddOnExited) und eine Ereignisbehandlungsmethode (Process1_Exited) werden erstellt, wenn Sie ziehen ein <xref:System.Diagnostics.Process> -Komponente auf das Formular, und doppelklicken Sie auf das Symbol ". Der Code zum Ausführen beim Erstellen der <xref:System.Diagnostics.Process.Exited> Ereignis tritt auf, in der Prozedur Process1_Exited eingegeben wird. Sie ist nicht erforderlich, erstellen die <xref:System.Diagnostics.Process.OnExited%2A> Member auf, da es für Sie implementiert wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Diagnostics.Process.OnExited%2A> Methode in einer abgeleiteten Klasse.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt jedes Mal auf, wenn eine Anwendung eine Zeile in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis gibt an, dass die zugeordnete <xref:System.Diagnostics.Process> %medialocationinfo;) eine Zeile mit einem neue Zeilenumbruchzeichen in ihren umgeleiteten beendet <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Das Ereignis wird während der asynchrone Lesevorgänge aktiviert, auf <xref:System.Diagnostics.Process.StandardOutput%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis, und rufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Danach ist die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis signalisiert jedes Mal der Prozess eine Zeile in den umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardOutput%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet sollte Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `ipconfig` Befehl.  
  
 Das Beispiel erstellt einen Delegaten für die `OutputHandler` Ereignishandler und ordnet sie der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen vom umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, den Text formatiert und speichert sie in eine Ausgabezeichenfolge, die weiter unten im Konsolenfenster im Beispiel gezeigt wird.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Der Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Arbeitsspeichers in Bytes, der für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeitsspeichers in die Auslagerungsdatei des virtuellen Speichers durch den Prozess in Bytes verwendet. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten des virtuellen Adressraums für jeden Prozess. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Größe des Arbeitsspeichers, die vom Betriebssystem für den Prozess verwendet die <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Seite Dateibytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung wird gestartet und klicken Sie dann abgerufen und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess belegt wird und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des auslagerbaren Systemspeichers verwendet, die für den Prozess in Bytes dar. Systemspeicher ist der vom Betriebssystem verwendeten physikalischen Speichers und Durchschnittswert unterteilt ist. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Größe des vom Prozess verwendeten Anwendung der <xref:System.Diagnostics.Process.PagedMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Auslagerungsseiten (Bytes) Pool** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Der maximale Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Die maximale Größe des Arbeitsspeichers in Bytes, der seit dem Starten für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des Arbeitsspeichers in die Auslagerungsdatei des virtuellen Speichers durch den Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten des virtuellen Adressraums für jeden Prozess. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Seite Datei Bytes Peak** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des virtuellen Arbeitsspeichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des virtuellen Arbeitsspeichers, die vom Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem ordnet des virtuellen Adressraums für jeden Prozess auf Seiten im physischen Speicher oder zu Seiten, die in die Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeicherten geladen hat.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **virtuelle Bytes (max.)** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des Workingsets für den zugeordneten Prozess in Bytes ab.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, den der zugeordnete Prozess gleichzeitig angefordert hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Prozessmodule und der Systembibliotheken.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des physischen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe der Menge Arbeitsspeicher vom Prozess verwendet werden, da er, in Bytes gestartet dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Anweisungen über die Prozessmodule und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **maximale Größe der Arbeitsseiten** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugeordnete Prozesspriorität durch das Betriebssystem vorübergehend erhöht werden soll, wenn das Hauptfenster den Fokus besitzt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Prozesspriorität eines Prozesses dynamisch erhöht werden soll, wenn dieser den Wartezustand verlässt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread in einem Prozess für die die Prioritätsklasse einer der Enumerationswerte dynamische Priorität wurde ausgeführt wird (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), erhöht das System vorübergehend die Priorität des Threads, wenn es einen Wartezustand verlässt angenommen wird. Diese Aktion verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads zu unterbrechen. Die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads und alle Threads, die anschließend durch den Prozess erstellt. Um das normale Verhalten wiederherzustellen, legen die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft `false`.  
  
> [!NOTE]
>  Die Priorität zu stark angehoben, kann Ressourcen von wichtigen Betriebssystem- und Netzwerkfunktionen abgezogen werden, verursacht Probleme mit anderer betriebssystemtasks abzuleiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozesserhöhungsinformationen von der zugeordneten Prozessressource abgerufen werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.  
  
 - oder -   
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die allgemeine Prioritätskategorie für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die Prioritätskategorie für den zugeordneten Prozess, aus der die <see cref="P:System.Diagnostics.Process.BasePriority" /> des Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioritätsklasse eines Prozesses umfasst einen Bereich von Prioritätsstufen Thread. Threads mit unterschiedlichen Prioritäten, die im Prozess ausgeführt werden, die relativ zu die Prioritätsklasse des Prozesses ausgeführt werden. Win32 verwendet vier Prioritätsklassen mit sieben Basisprioritätsebenen pro Klasse. Dieser Prozess Prioritätsklassen werden erfasst, der <xref:System.Diagnostics.ProcessPriorityClass> -Enumeration, die Sie können die Prozesspriorität auf festgelegt <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Basierend auf dem Zeitpunkt verstrichene anderen Prozessen, die Basisprioritätsebene vom Betriebssystem nicht geändert werden können, wenn ein Prozess muss vor anderen für den Zugriff auf den Prozessor abgelegt werden. Sie können außerdem festlegen der <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> zeitweilig die Prioritätsstufe der Threads erhöht, die den Wartezustand verlässt ausgeführt wurden. Die Priorität wird zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> -Eigenschaft können Sie die Startpriorität anzeigen, die an einen Prozess zugewiesen wird. Jedoch, da er schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> Eigenschaft, um die Priorität eines Prozesses festzulegen. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> -Eigenschaft, die die allgemeine Prioritätskategorie für den Prozess festlegt oder abruft.  
  
 Die Prioritätsklasse kann nicht mithilfe des Systemmonitors angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen der <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozessprioritätsinformationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
 - oder -   
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityClass" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Sie haben bei Verwendung von Windows 98 oder Windows Millennium Edition (Windows Me) die <see cref="P:System.Diagnostics.Process.PriorityClass" /> auf <see langword="AboveNormal" /> oder <see langword="BelowNormal" /> festgelegt. Diese Plattformen unterstützen diese Werte für die Prioritätsklasse nicht.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die Prioritätsklasse kann nicht festgelegt werden, weil sie keinen gültigen Wert gemäß der Definition in der <see cref="T:System.Diagnostics.ProcessPriorityClass" />-Enumeration verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Anzahl der vom zugeordneten Prozess reservierten Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden können.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Speichers in Bytes, der für den zugeordneten Prozess belegt wird und nicht mit anderen Prozessen gemeinsam genutzt werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des belegten durch den Prozess in Bytes, der mit anderen Prozessen gemeinsam genutzt werden kann.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Private Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die privilegierte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Prozess im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Prozesses ab.</summary>
        <value>Der Name, mit dem das System den Prozess für den Benutzer kennzeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft enthält den Namen einer ausführbaren Datei an, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. Es ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind.  
  
> [!NOTE]
>  Auf [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] Betriebssysteme, die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft möglicherweise und 15 Zeichen abgeschnitten, wenn die Prozessinformationen für das Modul kann nicht abgerufen werden.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und übergeben sie den Namen einer ausführbaren Datei an, um ein Array abzurufen, die jede ausgeführte Instanz auf dem angegebenen Computer enthält. Dieses Array ab, z. B. können Sie um alle ausgeführten Instanzen der ausführbaren Datei zu schließen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Für den Prozess ist kein Bezeichner vorhanden, oder dem <see cref="T:System.Diagnostics.Process" /> ist kein Prozess zugeordnet.  
  
 - oder -   
  
 Der zugeordnete Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess ist auf diesem Computer nicht vorhanden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Prozessoren ab, auf denen die Ausführung der Threads in diesem Prozess geplant werden kann, oder legt diese fest.</summary>
        <value>Eine Bitmaske, die angibt, auf welchen Prozessoren die Threads im zugeordneten Prozess ausgeführt werden können. Der Standardwert hängt von der Anzahl der Prozessoren des Computers ab. Der Standardwert ist 2 <sup> n </sup> 1, wobei n die Anzahl der Prozessoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 und höher kann ein Thread in einem Prozess nach Prozessor, bei jeder Migration der Prozessorcache migrieren. Bei starker Auslastung kann angeben, welcher Prozessor einen bestimmten Thread ausgeführt werden soll Umfang zur Leistungssteigerung durch Verringern der Anzahl der Häufigkeit, mit der, die Cache des Prozessors geladen wird. Die Zuordnung zwischen einem Prozessor und ein Thread wird als Prozessoraffinität bezeichnet.  
  
 Jeder Prozessor wird als ein bit dargestellt. Bit 0 stellt einen Prozessor, Bit 1 ist Prozessor 2 usw.. Wenn Sie ein wenig mit dem Wert 1 festlegen, wird der entsprechenden Prozessor für die Threadzuweisung ausgewählt. Beim Festlegen der <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf 0 (null), das Betriebssystem der Algorithmen festlegen die Threadaffinität planen. Wenn die <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf einen Wert ungleich NULL festgelegt ist, wird der Wert als Bitmaske aus, die die infrage kommenden Prozessoren angibt interpretiert.  
  
 Die folgende Tabelle zeigt eine Auswahl von <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Werte für ein System mit acht Prozessoren.  
  
|Bitmaske|Binärer Wert|Verfügbare Prozessoren|  
|-------------|------------------|-------------------------|  
|0 x 0001|00000000 00000001|1|  
|0 x 0003|00000000 00000011|1 und 2|  
|0x0007|00000000 00000111|1, 2 und 3|  
|0x0009|00000000 00001001|1 bis 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 und 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          Es konnten keine <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Informationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
 - oder -   
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> war nicht verfügbar.  
  
 - oder -   
  
 Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft alle Informationen über den zugeordneten Prozess, die in der Prozesskomponente zwischengespeichert waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Diagnostics.Process.Refresh%2A> aufgerufen wird, um die erste Anforderung für Informationen über jede Eigenschaft führt dazu, dass der Process-Komponente, um einen neuen Wert aus den zugeordneten Prozess abzurufen.  
  
 Wenn eine <xref:System.Diagnostics.Process> Komponente bezieht sich auf eine Prozessressource, die Eigenschaftswerte der <xref:System.Diagnostics.Process> werden sofort nach dem Status des zugeordneten Prozesses aufgefüllt. Wenn die Informationen über den zugeordneten Prozess anschließend geändert wird, werden diese Änderungen nicht berücksichtigt die <xref:System.Diagnostics.Process> Komponente zwischengespeicherte Werte. Die <xref:System.Diagnostics.Process> Komponente ist eine Momentaufnahme der der Prozessressource, zu dem Zeitpunkt, der sie zugeordnet sind. Um die aktuellen Werte für den zugeordneten Prozess anzuzeigen, rufen die <xref:System.Diagnostics.Process.Refresh%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Benutzeroberfläche des Prozesses reagiert.</summary>
        <value>
          <see langword="true" />, wenn die Benutzeroberfläche des zugeordneten Prozesses auf das System reagiert; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess eine Benutzeroberfläche verfügt die <xref:System.Diagnostics.Process.Responding%2A> Eigenschaft kontaktiert die Benutzeroberfläche, um festzustellen, ob der Prozess auf Benutzereingaben reagiert. Wenn die Schnittstelle nicht sofort, reagiert die <xref:System.Diagnostics.Process.Responding%2A> -Eigenschaft gibt `false`. Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die Benutzeroberfläche des zugeordneten Prozesses reagiert.  
  
 Wenn der Prozess keine <xref:System.Diagnostics.Process.MainWindowHandle%2A>, gibt diese Eigenschaft `true`.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Responding" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle dieses Prozesses ab.</summary>
        <value>Das systemeigene Handle dieses Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Handle ist nur verfügbar, wenn die aufrufende Komponente der Prozess gestartet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess ab.</summary>
        <value>Die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.SessionId%2A> Eigenschaft identifiziert die Sitzung, in dem die Anwendung derzeit ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Diesem Prozess ist keine Sitzung zugeordnet.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Sitzungs-ID ist kein Prozess zugeordnet.  
  
 - oder -   
  
 Der zugeordnete Prozess befindet sich nicht auf diesem Computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="P:System.Diagnostics.Process.SessionId" /> Eigenschaft wird unter Windows 98 nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, mit dem die Fehlerausgabe der Anwendung gelesen wird.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardfehlerstreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in seinen Stream Standardfehler Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Stream, können Sie bearbeiten oder die Fehlerausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, unterschiedlich zu formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardError%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> auf `true`. Lesen, andernfalls aus den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom löst eine Ausnahme aus.  
  
 Die umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge auf den Fehlerausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen der <xref:System.Diagnostics.Process.StandardError%2A> Stream und das untergeordnete Element das Schreiben in diesem Datenstrom zu verarbeiten. Diese Abhängigkeiten können dazu führen, dass Deadlockbedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von dessen umgeleiteten Streams schreibt, ist es das übergeordnete Element abhängig. Der untergeordnete Prozess wartet auf die nächste Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, auf einander warten, um einen Vorgang abzuschließen, und weder fortgesetzt werden kann. Sie können Deadlocks vermeiden, durch das Auswerten von Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code veranschaulicht z. B. aus einem umgeleiteten Stream lesen und Warten auf den untergeordneten Prozess zu beenden.  
  
```  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardError.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu beenden. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Es wird ein ähnliches Problem beim Lesen von Text in die Standardausgabe und der Standardfehler des Streams. Der folgende C#-Code, führt z. B. einen Lesevorgang für beide Streams.  
  
```  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des Fehlerstreams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem zwei Threads erstellen und Lesen der Ausgabe der einzelnen Streams in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net use` Befehl zusammen mit einem Benutzer bereitgestellte Argument eine Netzwerkressource zugeordnet. Anschließend liest der Standardfehlerstream des Befehls net und in die Konsole schreibt.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
 \- oder –  
  
 Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, in den die Eingaben der Anwendung geschrieben werden.</summary>
        <value>Ein <see cref="T:System.IO.StreamWriter" /> zum Schreiben des Standardeingabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> seine Standardeingabestream in der Regel auf der Tastatur Eingabetext auslesen können. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream, können Sie die Eingabe programmgesteuert angeben. Beispielsweise können Sie anstelle von Tastatureingaben Text aus dem Inhalt einer angegebenen Datei oder die Ausgabe aus einer anderen Anwendung bereitstellen.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardInput%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> auf `true`. Andernfalls Schreiben in die <xref:System.Diagnostics.Process.StandardInput%2A> Datenstrom löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream eines Prozesses. Das Beispiel beginnt die `sort` -Befehl mit umgeleiteter Eingabe. Anschließend fordert den Benutzer für den Text, und übergibt dieses an die `sort` Prozess über den umgeleiteten <xref:System.Diagnostics.Process.StandardInput%2A> Stream. Die `sort` Ergebnisse werden an den Benutzer in der Konsole angezeigt.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardInput" />-Stream wurde nicht definiert, da <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> auf <see langword="false" /> festgelegt ist.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, der dazu verwendet wird, die Textausgabe der Anwendung zu lesen.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardausgabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in seinen Standardstream Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, können Sie bearbeiten oder die Ausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, unterschiedlich zu formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardOutput%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> auf `true`. Lesen, andernfalls aus den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom löst eine Ausnahme aus.  
  
 Die umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Ausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream und das untergeordnete Element das Schreiben in diesem Datenstrom zu verarbeiten. Diese Abhängigkeiten können dazu führen, dass Deadlockbedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von dessen umgeleiteten Streams schreibt, ist es das übergeordnete Element abhängig. Der untergeordnete Prozess wartet auf die nächste Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, auf einander warten, um einen Vorgang abzuschließen, und weder fortgesetzt werden kann. Sie können Deadlocks vermeiden, durch das Auswerten von Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code veranschaulicht z. B. aus einem umgeleiteten Stream lesen und Warten auf den untergeordneten Prozess zu beenden.  
  
```  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardOutput.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardOutput.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu beenden. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Es wird ein ähnliches Problem beim Lesen von Text in die Standardausgabe und der Standardfehler des Streams. Der folgende C#-Code, führt z. B. einen Lesevorgang für beide Streams.  
  
```  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des Fehlerstreams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem zwei Threads erstellen und Lesen der Ausgabe der einzelnen Streams in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das ipconfig.exe-Befehl ausgeführt und leitet die Standardausgabe Konsolenfenster das Beispiel.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
 \- oder –  
  
 Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die von der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft dieser <see cref="T:System.Diagnostics.Process" />-Komponente angegebene Prozessressource (oder verwendet sie erneut) und ordnet diese der Komponente zu.</summary>
        <returns>
          <see langword="true" />, wenn eine Prozessressource gestartet wird. <see langword="false" />, wenn keine neue Prozessressource gestartet wird, sondern z. B. eine vorhandene Prozessressource wiederverwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource gestartet, und ordnen es dem aktuellen <xref:System.Diagnostics.Process> Komponente. Der Rückgabewert `true` gibt an, dass eine neue Prozessressource gestartet wurde. Wenn die Prozessressource, wird angegeben die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bereits auf dem Computer ausgeführt wird, keine zusätzliche Prozessressource gestartet wird. Stattdessen die laufende Prozessressource wiederverwendet und `false` wird zurückgegeben.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
> [!NOTE]
>  Bei Verwendung von Visual Studio diese Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode ist dasjenige, das Sie in Ihren Code einzufügen, nachdem Sie ziehen ein <xref:System.Diagnostics.Process> -Komponente in den Designer. Verwenden der `Properties` Fenster zu erweitern die `StartInfo` Kategorie und Schreiben Sie den entsprechenden Wert in der `FileName` Eigenschaft. Ihre Änderungen werden angezeigt, in der Form `InitializeComponent` Prozedur.  
  
 Diese Überladung der <xref:System.Diagnostics.Process.Start%2A> ist eine `static` Methode. Sie müssen von einer Instanz von Aufrufen der <xref:System.Diagnostics.Process> Klasse. Vor dem Aufruf <xref:System.Diagnostics.Process.Start%2A>, müssen Sie zuerst angeben <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschafteninformationen für diese <xref:System.Diagnostics.Process> Instanz, da diese Informationen verwendet wird, um zu bestimmen, die Prozessressource gestartet.  
  
 Andere Überladungen der der <xref:System.Diagnostics.Process.Start%2A> Methode sind `static` Mitglieder. Sie müssen nicht zum Erstellen einer Instanz von der <xref:System.Diagnostics.Process> Komponente vor dem Aufrufen dieser Überladungen der Methode. Rufen Sie stattdessen <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> selbst und eine neue Klasse <xref:System.Diagnostics.Process> -Komponente erstellt wird, wenn der Prozess gestartet wurde. Oder, `null` wird zurückgegeben, wenn ein Prozess wiederverwendet wurde. Die Process-Ressource wird automatisch zugeordnet, mit dem neuen <xref:System.Diagnostics.Process> Komponente, die von zurückgegeben wird die <xref:System.Diagnostics.Process.Start%2A> Methode.  
  
 Die <xref:System.Diagnostics.Process.StartInfo%2A> Elemente können verwendet werden, die Funktionalität des Duplizieren der `Run` Dialogfeld des Windows- `Start` Menü. Elemente, die in einer Befehlszeile eingegeben werden, können die gestartet werden kann, durch Festlegen der entsprechenden Werte der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft hat keine ausführbare Datei sein. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung ".txt" aufweisen, wenn Sie Textdateien in einem Editor wie dem Editor zugeordnet oder die Erweiterung DOC haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word.  
  
 In der Befehlszeile können Sie Aktionen an, die für bestimmte Typen von Dateien angeben. Sie können beispielsweise Drucken von Dokumenten oder Textdateien bearbeiten. Geben Sie diese Aktionen mit den <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Für andere Typen von Dateien, können Sie Befehlszeilenargumente angeben, wenn Sie die Datei aus starten der `Run` (Dialogfeld). Angenommen, Sie können übergeben eine URL als Argument bei Angabe von Ihrem Browser als die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Diese Argumente können angegeben werden, der <xref:System.Diagnostics.Process.StartInfo%2A> der Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Member.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In <see cref="P:System.Diagnostics.Process.StartInfo" /> der Komponente <see cref="T:System.Diagnostics.Process" /> wurde kein Dateiname angegeben.
 – oder – die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Mitglied der <see cref="P:System.Diagnostics.Process.StartInfo" /> Eigenschaft <see langword="true" /> während <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die unter Betriebssystemen ohne Befehlsshell-Unterstützung, z. B. Nano Server (nur .NET Core) nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Informationen zum Starten des Prozesses enthält, einschließlich Dateiname und Befehlszeilenargumente.</param>
        <summary>Startet die Prozessressource, die durch den Parameter mit den Startinformationen für den Prozess angegeben wird (z. B. den Dateinamen des zu startenden Prozesses), und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, starten Sie eine Prozessressource durch Angeben einer <xref:System.Diagnostics.ProcessStartInfo> Instanz. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Verwendung dieser Überladung mit einer <xref:System.Diagnostics.ProcessStartInfo> Parameter ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen seiner <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaften, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Mithilfe einer <xref:System.Diagnostics.ProcessStartInfo> -Instanz als Parameter Sie die aufrufen können <xref:System.Diagnostics.Process.Start%2A> mit mehr Kontrolle über was an den Aufruf zum Starten des Prozesses übergeben wird. Wenn Sie nur einen Dateinamen oder einen Dateinamen und Argumente übergeben müssen, ist es nicht erforderlich, zum Erstellen eines neuen <xref:System.Diagnostics.ProcessStartInfo> Instanz, obwohl dies möglich ist. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss es sich nicht um eine ausführbare Datei darzustellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung ".txt" aufweisen, wenn Sie Textdateien in einem Editor wie dem Editor zugeordnet oder die Erweiterung DOC haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> Instanz festgelegt werden, die nicht verwaltete `CreateProcessWithLogonW` Funktion aufgerufen wird, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Wenn die <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> Eigenschaft ist `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> -Eigenschaft muss im UPN-Format sein *Benutzer*@*DNS-Domänenname*.   
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen die Angabe der Startinformationen für den Process-Ressource mit einer <xref:System.Diagnostics.ProcessStartInfo> Instanz.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` auf die `startInfo` Parameter, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 Weitere Beispiele für andere Verwendungen dieser Methode finden Sie in die einzelnen Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters wurde kein Dateiname angegeben.  
  
 - oder -   
  
 Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />-, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />- oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist ebenfalls <see langword="true" />.  
  
 - oder -   
  
 Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft ist nicht <see langword="null" /> oder leer, oder die <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />-Eigenschaft ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="startInfo" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die unter Betriebssystemen ohne Befehlsshell-Unterstützung, z. B. Nano Server (nur .NET Core) nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name eines Dokuments oder einer Anwendungsdatei, das bzw. die im Prozess ausgeführt werden soll.</param>
        <summary>Startet eine Prozessressource, indem der Name eines Dokuments oder einer Anwendungsdatei angegeben wird, und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben des Dateinamens zu starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Sie können eine ClickOnce-Anwendung starten, indem die `fileName` Parameter auf den Speicherort (z. B. eine Webadresse), die von der Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Starten eines Prozesses durch Angabe des Dateinamens ähnelt dem Eingeben der Informationen in den `Run` Dialogfeld des Windows- `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde.. Kann z. B. der Dateinamen die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor".  
  
 Diese Überladung lässt keine Befehlszeilenargumente für den Prozess. Wenn Sie Befehlszeilenargumente für den Prozess angeben müssen, verwenden Sie die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> oder <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> Überladungen.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen das Festlegen der Dateiname der der Prozessressource gestartet.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben der Dateiname und Befehlszeilenargumente starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Starten eines Prozesses durch Angabe des Dateinamens und der Argumente ähnelt dem Eingeben der Dateiname und Befehlszeilenargumente in die `Run` Dialogfeld des Windows- `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde.. Kann z. B. der Dateinamen die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`. Wenn die `fileName` -Parameter stellt eine Befehlsdatei (cmd), die `arguments` Parameter muss entweder enthalten eine "`/c`"oder"`/k`" Argument, um anzugeben, ob das Befehlsfenster beendet wird, oder bleibt nach Abschluss des Vorgangs.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen das Festlegen der Dateiname der der Prozessressource gestartet und die Befehlszeilenargumente übergeben.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft...  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="fileName" />-Parameter oder der <paramref name="arguments" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung, eines Benutzernamens und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seine primäre Thread durch Angabe des Dateinamens, Benutzername, Kennwort und Domäne zu erstellen. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe identifizieren, mit der ein uniform Resource Identifier (URI), keinen verknüpften Laufwerkbuchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft...  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieser Überladung zum Starten einer ausführbaren Datei und zeigt auch das Auslösen einer <xref:System.ComponentModel.Win32Exception> Wenn es versucht wird, zum Starten einer Anwendung eine nicht ausführbare Datei zugeordnet.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode unter Linux oder MacOS (nur .NET Core) nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten, eines Benutzernamens, eines Kennworts und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seine primäre Thread durch Angabe des Dateinamens, Befehlszeilenargumente, Benutzername, Kennwort und Domäne zu erstellen. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe identifizieren, mit der ein uniform Resource Identifier (URI), keinen verknüpften Laufwerkbuchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -   
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads zur zugehörigen Datei überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode unter Linux oder MacOS (nur .NET Core) nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaften ab, die an die <see cref="M:System.Diagnostics.Process.Start" />-Methode von <see cref="T:System.Diagnostics.Process" /> übergeben werden sollen, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Daten darstellt, mit denen der Prozess gestartet werden soll. Diese Argumente beinhalten den Namen der ausführbaren Datei oder des Dokuments, das zum Starten des Prozesses verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A>Stellt den Satz von Parametern zum Starten eines Prozesses verwendet. Wenn <xref:System.Diagnostics.Process.Start%2A> aufgerufen wird, die <xref:System.Diagnostics.Process.StartInfo%2A> wird verwendet, um den zu startenden Prozess angeben. Nur erforderliche <xref:System.Diagnostics.Process.StartInfo%2A> gehört zum Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Starten eines Prozesses durch Angabe der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft ähnelt dem Eingeben der Informationen in den **ausführen** Dialogfeld des Windows- **starten** Menü. Aus diesem Grund die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss es sich nicht um eine ausführbare Datei darzustellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde.. Zum Beispiel die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> kann die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft auf "Notepad.exe" oder "Editor".  
  
 Sie können eine ClickOnce-Anwendung starten, indem die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, um den Speicherort (z. B. eine Webadresse), die von der Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Wenn der Dateiname eine nicht ausführbare Datei, z. B. eine DOC-Datei umfasst, können Sie ein Verb an, welche Aktion für die Datei angeben einschließen. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> "Drucken" für eine Datei mit der Erweiterung DOC. Die Datei im angegebenen Namen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss nicht auf eine Erweiterung aufweisen, wenn Sie manuell einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft. Allerdings bei Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft, um zu bestimmen, welche Verben verfügbar sind, müssen Sie die Erweiterung einschließen.  
  
 Sie können die Parameter, die im angegebenen Ändern der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bis zu der Zeit, die Sie Aufrufen der <xref:System.Diagnostics.Process.Start%2A> -Methode für den Prozess. Nachdem Sie den Prozess starten, ändern die <xref:System.Diagnostics.Process.StartInfo%2A> Werte nicht beeinflussen, und starten Sie den zugeordneten Prozess. Beim Aufrufen der <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> Methode mit der <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> festgelegten Eigenschaften, die nicht verwaltete `CreateProcessWithLogonW` Funktion aufgerufen wird, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Wenn Sie nicht verwendet haben die <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines Prozesses, der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft reflektiert nicht die zum Starten des Prozesses verwendeten Parameter. Angenommen, Sie verwenden <xref:System.Diagnostics.Process.GetProcesses%2A> zum Abrufen eines Arrays auf dem Computer ausgeführten Prozesse auf die <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft jedes <xref:System.Diagnostics.Process> enthält nicht den ursprünglichen Dateinamen an oder die Argumente, die zum Starten des Prozesses verwendet.  
  
 Wenn der Prozess gestartet wird, wird der Dateiname ist die Datei, die die (schreibgeschützte) füllt <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie verwenden möchten, rufen Sie die ausführbare Datei, die mit dem Prozess zugeordnet ist, nachdem der Prozess gestartet wurde, verwenden die <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie die ausführbare Datei der festlegen möchten eine <xref:System.Diagnostics.Process> Instanz, für die ein zugeordnete Prozess nicht gestartet wurde, verwenden Sie die <xref:System.Diagnostics.Process.StartInfo%2A> der Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Da der Mitglieder der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft sind Argumente, die übergeben werden, der <xref:System.Diagnostics.Process.Start%2A> Methode eines Prozesses ändern der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft nach dem Start des zugeordneten Prozess nicht zurückgesetzt, der <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Diese Eigenschaften dienen nur zum Initialisieren des zugeordneten Prozesses.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Diagnostics.Process.StartInfo%2A> mit der auszuführenden Datei, die Aktion ausgeführt werden, und gibt an, ob es sollte eine Benutzeroberfläche angezeigt. Weitere Beispiele finden Sie unter den Referenzseiten für Eigenschaften von der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der die <see cref="P:System.Diagnostics.Process.StartInfo" /> angibt, ist <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, zu der der zugeordnete Prozess gestartet wurde.</summary>
        <value>Ein Objekt, das angibt, wann der zugeordnete Prozess gestartet wurde. Eine Ausnahme wird ausgelöst, wenn der Prozess nicht ausgeführt wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.StartTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -   
  
 Der Prozess wurde nicht gestartet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Aufruf der Windows-Funktion ist ein Fehler aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen der Ereignishandleraufrufe verwendet wird, die als Ergebnis eines Prozessbeendigungsereignisses ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die als Ergebnis eines <see cref="E:System.Diagnostics.Process.Exited" />-Ereignisses des Prozesses ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> ist `null`, Methoden zum Behandeln der <xref:System.Diagnostics.Process.Exited> Ereignis in einem Thread aus dem Threadpool System aufgerufen werden. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Diagnostics.Process.Exited> Ereignis erfolgt durch einen visuellen Windows Forms-Komponente, wie z. B. eine <xref:System.Windows.Forms.Button>, Zugriff auf die Komponente über den Threadpool System funktioniert möglicherweise nicht, oder wird unter Umständen eine Ausnahme ausgelöst. Vermeiden Sie dies, indem <xref:System.Diagnostics.Process.SynchronizingObject%2A> an eine Windows Forms-Komponente, durch die die Methoden zur Behandlung der <xref:System.Diagnostics.Process.Exited> Ereignis im selben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.Process> dient in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.Diagnostics.Process.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement, enthält die <xref:System.Diagnostics.Process>. Angenommen, Sie Platzieren einer <xref:System.Diagnostics.Process> in einem Designer für `Form1` (geerbt von <xref:System.Windows.Forms.Form>) der <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft <xref:System.Diagnostics.Process> festgelegt ist, mit der Instanz von `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In der Regel wird diese Eigenschaft festgelegt, wenn die Komponente in einem Steuerelement oder ein Formular platziert wird, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gruppe von Threads ab, die im zugeordneten Prozess ausgeführt werden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessThread" />, das die Threads des Betriebssystems darstellt, die gegenwärtig im zugeordneten Prozess ausgeführt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread führt Code in einem Prozess. Jeder Prozess wird mit einem einzelnen Thread, dessen primäre Thread gestartet. Jeder Thread kann zusätzliche Threads generieren. Threads innerhalb eines Prozesses freigeben den Adressraum des Prozesses.  
  
 Verwendung <xref:System.Diagnostics.ProcessThread> zum Abrufen aller Threads, die dem aktuellen Prozess zugeordnet. Der primäre Thread ist nicht unbedingt am Index 0 (null) im Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Für den Prozess ist kein <see cref="P:System.Diagnostics.Process.Id" /> vorhanden, oder der <see cref="T:System.Diagnostics.Process" />-Instanz ist kein Prozess zugeordnet.  
  
 - oder -   
  
 Der zugeordnete Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatiert den Prozessnamen als Zeichenfolge, ggf. kombiniert mit dem Typ der übergeordneten Komponente.</summary>
        <returns>Der <see cref="P:System.Diagnostics.Process.ProcessName" /> kombiniert mit dem <see cref="M:System.Object.ToString" />-Rückgabewert der Basiskomponente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" />wird unter Windows 98 nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess die CPU verwendet hat. Dieser Wert ist die Summe von <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> und <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.TotalProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Benutzerprozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess Code innerhalb der Anwendung des Prozesses (nicht im Betriebssystemkern) ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.UserProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers für diesen Prozess in Bytes ab.</summary>
        <value>Die virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers, der für den zugeordneten Prozess belegt wird, in Bytes ab.</summary>
        <value>Die Größe des virtuellen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des virtuellen Speichers durch den Prozess in Bytes verwendet. Das Betriebssystem ordnet des virtuellen Adressraums für jeden Prozess auf Seiten im physischen Speicher oder zu Seiten, die in die Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeicherten geladen hat.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **virtuelle Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, unbestimmte Zeit zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit>wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird.  Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine unendliche Zeitspanne für den Prozess und Ereignis-Handler zu beenden. Dies kann dazu führen, dass eine Anwendung nicht mehr reagiert. Angenommen, Sie rufen <xref:System.Diagnostics.Process.CloseMainWindow%2A> für einen Prozess, der über eine Benutzeroberfläche verfügt, die Anforderung an das Betriebssystem zum Beenden des zugeordneten Prozesses möglicherweise nicht behandelt werden, wenn der Prozess geschrieben wird, nie eine Meldungsschleife eingeben.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und früheren Versionen der <xref:System.Diagnostics.Process.WaitForExit> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt. Vorgängerversionen außerdem nicht warten, für die Ereignishandler auf, wenn der Agent beendet das vollständige <xref:System.Int32.MaxValue> Uhrzeit wurde erreicht.  
  
 Diese Überladung wird sichergestellt, dass die gesamte Verarbeitung abgeschlossen wurde, einschließlich der Behandlung von asynchrone Ereignisse für die umgeleiteten Standardausgabe. Verwenden Sie diese Überladung nach einem Aufruf von der <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung, wenn die Standardausgabe an asynchrone Ereignishandler umgeleitet wurde.  
  
 Wenn der zugehörige Prozess beendet wird (das heißt, wenn es durch das Betriebssystem über eine Beendigung ordnungsgemäß oder nicht ordnungsgemäß heruntergefahren wird), speichert das System administrative Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen wird, mussten <xref:System.Diagnostics.Process.WaitForExit>. Die <xref:System.Diagnostics.Process> Komponente kann dann die Informationen, darunter zugreifen der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft der Komponente verweist auf eine vorhandene Prozessressource nicht mehr darauf. Das Handle kann stattdessen verwendet werden, nur für das Betriebssystem-Informationen zu der Prozessressource zugreifen. Das System ist bewusst Handles für beendete Prozesse, die nicht freigegeben wurden, indem Sie <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente speziell Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> Wenn der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A>Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Diagnostics.Process.StandardError%2A> Eigenschaft-Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.  
  
 - oder -   
  
 Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Die Zeitspanne in Millisekunden, die auf die Beendigung des zugeordneten Prozesses gewartet werden soll. Der Höchstwert ist der größtmögliche Wert einer 32-Bit-Ganzzahl, der für das Betriebssystem unendlich bedeutet.</param>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, für die Dauer von angegebenen Millisekunden zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <returns>
          <see langword="true" />, wenn der zugeordnete Prozess beendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird. Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine begrenzte Zeitspanne für den Prozess zu beenden. Wenn der zugeordnete Prozess nicht am Ende des Intervalls beendet wird, da die Anforderung zum Beenden der Zugriff verweigert wird, `false` an die aufrufende Prozedur zurückgegeben wird. Sie können eine negative Zahl angeben (<xref:System.Threading.Timeout.Infinite>) für `milliseconds`, und <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> wird Verhalten sich wie die <xref:System.Diagnostics.Process.WaitForExit> überladen. Wenn Sie 0 (null) an die Methode übergeben, gibt es `true` nur, wenn der Prozess bereits beendet wurde; andernfalls wird sofort zurückgegeben `false`.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und frühere Versionen, wenn `milliseconds` -1 ist, wurde die <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt.  
  
 Wenn die Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, ist es möglich, dass die Verarbeitung der Ausgabe wird nicht abgeschlossen haben, wenn diese Methode zurückgegeben. Stellen Sie sicher, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, Aufrufen der <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, nachdem annimmt eine `true` von dieser Überladung. Um sicherzustellen, dass die <xref:System.Diagnostics.Process.Exited> Ereignis in Windows Forms-Anwendung ordnungsgemäß verarbeitet wird, legen Sie die <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
 Wenn ein zugeordnete Prozess beendet (heruntergefahren durch das Betriebssystem ordnungsgemäß oder nicht ordnungsgemäß beendet), das System speichert administrativen Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen hat <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Die <xref:System.Diagnostics.Process> Komponente kann dann die Informationen, darunter zugreifen der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft der Komponente verweist auf eine vorhandene Prozessressource nicht mehr darauf. Das Handle kann stattdessen verwendet werden, nur für das Betriebssystem-Informationen zu der Prozessressource zugreifen. Das System ist bewusst Handles für beendete Prozesse, die nicht freigegeben wurden, indem Sie <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente speziell Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> Wenn der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A>Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Codebeispiel für die <xref:System.Diagnostics.Process.ExitCode%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.  
  
 - oder -   
  
 Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente unbegrenzt wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns>
          <see langword="true" />, wenn der zugehörige Prozess in den Leerlauf wechselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlaufzustand zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt die Nachrichtenschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Der Prozess wird dann wieder an das die Meldungsschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist z. B. dann sinnvoll, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung dieses Fensters kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle> Überladung weist das <xref:System.Diagnostics.Process> Komponente auf unbestimmte Zeit zu warten, bis der Prozess in der Nachrichtenschleife in den Leerlauf versetzt wird. Diese Anweisung kann dazu führen, dass eine Anwendung nicht mehr reagiert. Z. B. wenn der Prozess immer in geschrieben werden die Nachrichtenschleife unmittelbar beendet, wie das Codefragment `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
 - oder -   
  
 Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
 - oder -   
  
 Der Prozess wurde bereits beendet.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Der Wert 1 für <see cref="F:System.Int32.MaxValue" />, der die Zeitspanne in Millisekunden angibt, die gewartet werden soll, bis sich der zugehörige Prozess im Leerlauf befindet. Der Wert 0 gibt eine sofortige Rückgabe an, der Wert -1 gibt eine unendliche Wartezeit an.</param>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente die Dauer von angegebenen Millisekunden wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns>
          <see langword="true" />, wenn der zugeordnete Prozess in den Leerlauf wechselt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlaufzustand zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt die Nachrichtenschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Der Prozess wird dann wieder an das die Meldungsschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist z. B. dann sinnvoll, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung dieses Fensters kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Überladung weist das <xref:System.Diagnostics.Process> -Komponente wartet, bis eine begrenzte Zeitspanne für den Prozess in den Leerlauf in der Nachrichtenschleife. Wenn der zugeordnete Prozess nicht am Ende des Intervalls Leerlauf Schleife noch Nachrichten verarbeitet `false` an die aufrufende Prozedur zurückgegeben wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
 - oder -   
  
 Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
 - oder -   
  
 Der Prozess wurde bereits beendet.  
  
 - oder -   
  
 Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Belegung des physischen Speichers durch den zugeordneten Prozess in Bytes ab.</summary>
        <value>Der Gesamtgröße des vom zugeordneten Prozess verwendeten physischen Speichers in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, die für den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, z. B. die Prozessmodule und der Systembibliotheken.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Prozessexitcode angezeigt.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, die für den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich der Anweisungen in die Prozessmodule und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Workingsets** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
