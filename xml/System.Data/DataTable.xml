<Type Name="DataTable" FullName="System.Data.DataTable">
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Tabelle mit Daten im Arbeitsspeicher dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable> ist ein zentrale Objekt in der Bibliothek für ADO.NET. Von anderen Objekten verwendet werden, die <xref:System.Data.DataTable> enthalten die <xref:System.Data.DataSet> und <xref:System.Data.DataView>.  
  
 Beim Zugriff auf <xref:System.Data.DataTable> Objekte, beachten Sie, dass sie bedingt Groß-/Kleinschreibung unterschieden werden. Angenommen, eine <xref:System.Data.DataTable> "Mydatatable" benannt ist und eine andere "Mydatatable" benannt ist, wird in eine Zeichenfolge, die zur Suche nach einer der Tabellen die Groß-/ Kleinschreibung. Allerdings wird Wenn "Mydatatable" vorhanden ist, und "Mydatatable", nicht aber, die zu suchende Zeichenfolge wie Groß-/Kleinschreibung beachten betrachtet. Ein <xref:System.Data.DataSet> können enthalten zwei <xref:System.Data.DataTable> Objekte, die dieselbe <xref:System.Data.DataTable.TableName%2A> Eigenschaftswert, aber unterschiedliche <xref:System.Data.DataTable.Namespace%2A> Eigenschaftswerte. Weitere Informationen zum Arbeiten mit <xref:System.Data.DataTable> anzuzeigen, [Erstellen einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Beim Erstellen einer <xref:System.Data.DataTable> programmgesteuert, müssen Sie zuerst das Schema definieren, durch Hinzufügen von <xref:System.Data.DataColumn> Datenbankobjekte in der <xref:System.Data.DataColumnCollection> (erfolgt über die <xref:System.Data.DataTable.Columns%2A> Eigenschaft). Weitere Informationen zum Hinzufügen von <xref:System.Data.DataColumn> anzuzeigen, [Hinzufügen von Spalten zu einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Zum Hinzufügen von Zeilen zu einer <xref:System.Data.DataTable>, müssen Sie zunächst mithilfe der <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues zurückzugeben <xref:System.Data.DataRow> Objekt. Die <xref:System.Data.DataTable.NewRow%2A> Methode gibt eine Zeile mit dem Schema der <xref:System.Data.DataTable>, wie sie von der Tabelle definiert ist <xref:System.Data.DataColumnCollection>. Die maximale Anzahl von Zeilen, die eine <xref:System.Data.DataTable> können Speicher ist 16.777.216. Weitere Informationen finden Sie unter [Hinzufügen von Daten zu einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 Die <xref:System.Data.DataTable> enthält auch eine Auflistung von <xref:System.Data.Constraint> Objekte, die verwendet werden können, um die Integrität der Daten sicherzustellen. Weitere Informationen finden Sie unter [DataTable-Einschränkungen](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Es gibt viele <xref:System.Data.DataTable> Ereignisse, die verwendet werden können, um zu bestimmen, wann Änderungen an einer Tabelle vorgenommen werden. Dazu gehören <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> und <xref:System.Data.DataTable.RowDeleted>. Weitere Informationen zu den Ereignissen, die mit verwendet werden, kann eine <xref:System.Data.DataTable>, finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Wenn eine Instanz von <xref:System.Data.DataTable> wird erstellt, einige Eigenschaften werden von der Lese-/Schreibzugriff auf Ausgangswerte festgelegt. Eine Liste der folgenden Werte sind, finden Sie unter der <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> Thema Konstruktor.  
  
> [!NOTE]
>  Die <xref:System.Data.DataSet> und <xref:System.Data.DataTable> Objekte erben von <xref:System.ComponentModel.MarshalByValueComponent>, und unterstützt die <xref:System.Runtime.Serialization.ISerializable> Schnittstelle für das .NET Framework-Remoting. Dies sind die einzigen ADO.NET-Objekte, die für .NET Framework Remoting verwendet werden können.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zwei <xref:System.Data.DataTable> Objekte und eine <xref:System.Data.DataRelation> -Objekt und fügt die neuen Objekte auf einer <xref:System.Data.DataSet>. Die Tabellen werden dann angezeigt, einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 Dieses Beispiel veranschaulicht, wie eine "DataTable" manuell mit bestimmten Schemadefinitionen erstellen:  
  
-   Erstellen Sie mehrere Datentabellen und definieren Sie die ursprünglichen Spalten.  
  
-   Erstellen Sie die tabelleneinschränkungen.  
  
-   Fügen Sie die Werte, und zeigen Sie die Tabellen.  
  
-   Erstellen Sie die Spalten für Ausdrücke, und zeigen Sie die Tabellen.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie in der [Developer Code Samples](http://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist für schreibgeschützte Vorgänge mit mehreren Threads sicher. Sie müssen alle Schreibvorgänge synchronisieren.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Data.DataTable" /> Klasse ohne Argumente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor legt die Anfangswerte für alle Eigenschaften des der <xref:System.Data.DataTable> Objekt. Die folgende Tabelle zeigt die Eigenschaften und ihre Standardwerte. Wenn eine Instanz von <xref:System.Data.DataTable> erstellt wird, werden die folgenden Eigenschaften werden festgelegt, um die Anfangswerte Lese-/Schreibzugriff.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|**CaseSensitive**|Identisch mit der übergeordneten <xref:System.Data.DataSet>, wenn es zu einem gehört. Andernfalls `false`.|  
|**DisplayExpression**|Leere Zeichenfolge ("")|  
|**Locale**|Wie das übergeordnete Element <xref:System.Data.DataSet> des Objekts <xref:System.Globalization.CultureInfo> (zurückgegebenes der <xref:System.Data.DataSet.Locale%2A> Eigenschaft), wenn kein übergeordnetes Element vorhanden ist, der Standardwert ist das aktuelle System <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 Zeilen.|  
  
 Sie können den Wert für alle diese Eigenschaften über einen separaten Aufruf der Eigenschaft ändern.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataTable> mit <xref:System.Data.DataColumn> und <xref:System.Data.DataRow>, und zeigt ihn in einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Der Name die Tabelle zu gewähren. Wenn <c>TableName</c> ist <see langword="null" /> oder eine leere Zeichenfolge bei hinzugefügt, wird ein Standardname zugewiesen der <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Data.DataTable" /> Klasse mit dem angegebenen Tabellennamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> und zeigt ihn in einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Zum Serialisieren oder Deserialisieren eines Objekts benötigten Daten.</param>
        <param name="context">Die Quelle und das Ziel eines angegebenen serialisierten Streams.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Data.DataTable" /> -Klasse mit der <see cref="T:System.Runtime.Serialization.SerializationInfo" /> und <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung der <xref:System.Data.DataTable> Konstruktor ist erforderlich, damit <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Der Name die Tabelle zu gewähren. Wenn <c>TableName</c> ist <see langword="null" /> oder eine leere Zeichenfolge bei hinzugefügt, wird ein Standardname zugewiesen der <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Der Namespace für die XML-Darstellung der Daten aus der <see langword="DataTable" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Data.DataTable" /> -Klasse mit dem angegebenen Tabellennamen und Namespace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen Commit für alle Änderungen, die versucht, diese Tabelle seit dem letzten <see cref="M:System.Data.DataTable.AcceptChanges" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Objekt immer noch im Bearbeitungsmodus Bearbeitungsvorgänge erfolgreich beendet. Die <xref:System.Data.DataRowState> ändert sich ebenfalls: alle `Added` und `Modified` Zeilen werden `Unchanged`, und `Deleted` Zeilen entfernt werden.  
  
 Die <xref:System.Data.DataTable.AcceptChanges%2A> Methode in der Regel aufgerufen wird eine <xref:System.Data.DataTable> Sie versucht haben, aktualisieren Sie die <xref:System.Data.DataSet> mithilfe der <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel testet jede Tabelle auf Fehler. Wenn die Tabelle Fehler abgeglichen werden können (durch Übergabe an eine nicht definierte Funktion), <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wurde, andernfalls <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung einer <see cref="T:System.Data.DataTable" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die Benachrichtigungen, indexverwaltung und Einschränkungen beim Laden von Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.BeginLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Zeichenfolgenvergleiche innerhalb der Tabelle die Groß-/Kleinschreibung.</summary>
        <value>
          <see langword="true" />Wenn der Vergleich Groß-/Kleinschreibung beachtet wird; andernfalls <see langword="false" />. Der Standardsatz an das übergeordnete Element <see cref="T:System.Data.DataSet" /> des Objekts <see cref="P:System.Data.DataSet.CaseSensitive" /> Eigenschaft oder <see langword="false" /> Wenn die <see cref="T:System.Data.DataTable" /> unabhängig von der Erstellung einer <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.CaseSensitive%2A> Eigenschaft wirkt sich auf Zeichenfolgenvergleichen in sortieren, suchen und filtern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Select%2A> Methode zweimal auf eine <xref:System.Data.DataTable>. Erstmals ausführen, die <xref:System.Data.DataTable.CaseSensitive%2A> -Eigenschaftensatz auf `false`, wird die zweite, auf `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der untergeordneten Beziehungen für diesen <see cref="T:System.Data.DataTable" />.</summary>
        <value>Ein <see cref="T:System.Data.DataRelationCollection" /> , die die untergeordnete Beziehungen für die Tabelle enthält. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataRelation" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.DataRelation> definiert die Beziehung zwischen zwei Tabellen. In der Regel werden zwei Tabellen über ein einzelnes Feld verknüpft, die dieselben Daten enthält. Z. B. möglicherweise eine Tabelle, die Adressdaten enthält ein einzelnes Feld mit Codes, die Länder/Regionen darstellen. Eine zweite Tabelle, die Land/Region-Daten enthält, müssen ein einzelnes Feld mit dem Code, der das Land/Region identifiziert, und es ist dieser Code die in das entsprechende Feld in der ersten Tabelle eingefügt wird. Ein <xref:System.Data.DataRelation>, dann enthält mindestens vier Arten von Informationen: (1) den Namen der ersten Tabelle, (2) den Spaltennamen in der ersten Tabelle, (3) den Namen der zweiten Tabelle und (4) der Spaltenname in der zweiten Tabelle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ChildRelations%2A> -Eigenschaft zum Zurückgeben von jedem untergeordneten Element <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetChildRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Der Wert der einzelnen Spalten in der Zeile wird dann ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die <see cref="T:System.Data.DataTable" /> aller Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Zeilen in allen Tabellen werden entfernt. Eine Ausnahme wird generiert, wenn die Tabelle erzwungene untergeordnete Beziehungen, die untergeordneten Zeilen verfügt verwaist werden würde.  
  
 Wenn die <xref:System.Data.DataSet> gebunden ist ein <xref:System.Xml.XmlDataDocument>Aufrufen <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> oder <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> löst die <xref:System.NotSupportedException>. Um diese Situation zu vermeiden, Durchsuchen Sie jede Tabelle, entfernen Sie jede Zeile zu einem Zeitpunkt. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen vor dem Aufruf verarbeitet werden müssen <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel löscht die Tabelle aller Daten.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klont die Struktur der <see cref="T:System.Data.DataTable" />, einschließlich sämtlicher <see cref="T:System.Data.DataTable" /> Schemas und Einschränkungen.</summary>
        <returns>Ein neues <see cref="T:System.Data.DataTable" /> mit dem gleichen Schema wie die aktuelle <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Klassen abgeleitet wurden, wird der Klon denselben abgeleiteten Klassen aufweisen.  
  
 Klon erstellt ein neues <xref:System.Data.DataTable> mit derselben Struktur wie der ursprüngliche <xref:System.Data.DataTable>, aber keine Daten kopiert (die neue <xref:System.Data.DataTable> enthält keine `DataRows`). So kopieren Sie die Struktur und die Daten in eine neue <xref:System.Data.DataTable>, verwenden Sie <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, wie die Struktur und die Einschränkungen der Zieltabelle aktualisiert, nachdem Sie DataTable.Clone ausgeführt wird. Die Klasse ClonedDataTable eine Zieltabelle zurück und umfasst die Aktualisierung Ereignisse. Nach der Klon wird nicht Strukturänderungen in der Quelltabelle in der Zieltabelle dargestellt werden. Insbesondere wird in diesem Beispiel:  
  
-   Aktualisieren Sie die Änderungen der Spalten in der Quelltabelle an.  
  
-   Aktualisieren Sie die Änderungen der UniqueConstraint in der Quelltabelle an.  
  
-   Aktualisieren Sie die Änderungen der ForeignKeyConstraint in der Quelltabelle an.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie in der [Developer Code Samples](http://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Dieses Beispiel zeigt, wie Daten in einer "DataTable" ändern und Aktualisieren der Datenquelle.  
  
 Erstellen Sie zunächst eine Datenbank aus:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Sie können jetzt kompilieren und Ausführen des Beispiels. [Gewusst wie: Ändern von Daten in DataTable und aktualisieren Sie auf die Datenquelle](http://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) Visual Basic- und C#-Projekte in diesem Beispiel hat.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem ein Wert geändert wurde für den angegebenen <see cref="T:System.Data.DataColumn" /> in einem <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Wert geändert wird, wird für den angegebenen <see cref="T:System.Data.DataColumn" /> in einem <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Spalten, die zu dieser Tabelle gehören.</summary>
        <value>Ein <see cref="T:System.Data.DataColumnCollection" /> , enthält die Auflistung der <see cref="T:System.Data.DataColumn" /> Objekte für die Tabelle. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataColumn" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataColumnCollection> bestimmt das Schema einer Tabelle durch den Datentyp jeder Spalte definieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird jeder Wert jeder Zeile in einer Tabelle mithilfe der <xref:System.Data.DataTable.Columns%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Der Ausdruck berechnet.</param>
        <param name="filter">Der Filter können Sie Zeilen zu beschränken, die im Ausdruck ausgewertet werden soll.</param>
        <summary>Berechnet den angegebenen Ausdruck für die aktuelle Zeilen, die die Filterkriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Object" />, legen Sie auf das Ergebnis der Berechnung. Wenn der Ausdruck null ergibt, wird der Rückgabewert sein <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `expression` Parameter erfordert eine Aggregatfunktion. Folgendes ist z. B. ein gültiger Ausdruck:  
  
 `Count(Quantity)`  
  
 Dieser Ausdruck ist jedoch nicht:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Wenn Sie eine Operation für zwei oder mehr Spalten durchführen müssen, sollten Sie erstellen eine <xref:System.Data.DataColumn>legen dessen <xref:System.Data.DataColumn.Expression%2A> Eigenschaft, um einen entsprechenden Ausdruck ein, und verwenden Sie ein Aggregatausdruck für die resultierende Spalte. In diesem Fall erhält eine <xref:System.Data.DataColumn> mit dem Namen "Total", und die <xref:System.Data.DataColumn.Expression%2A> Festlegen dieser Eigenschaft:  
  
 `"Quantity * UnitPrice"`  
  
 Die Expression-Argument für die <xref:System.Data.DataTable.Compute%2A> Methode wäre dann dies:  
  
 `Sum(total)`  
  
 Der zweite Parameter `filter`, bestimmt, welche Zeilen im Ausdruck verwendet werden. Wenn die Tabelle eine Datumsspalte mit dem Namen "colDate" enthält, können Sie beispielsweise die Zeilen mit dem folgenden Ausdruck begrenzen:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Regeln zum Erstellen von Ausdrücken für beide Parameter finden Sie unter der <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte einer Spalte mit dem Namen "Total" für den Verkäufer, dessen ID 5 summiert.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Einschränkungen, die von dieser Tabelle verwaltet wird.</summary>
        <value>Ein <see cref="T:System.Data.ConstraintCollection" /> , enthält die Auflistung der <see cref="T:System.Data.Constraint" /> Objekte für die Tabelle. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.Constraint" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.ForeignKeyConstraint> schränkt die Aktion ausgeführt, wenn ein Wert in einer Spalte (oder Spalten) entweder gelöscht oder aktualisiert wird. Eine solche Einschränkung soll mit den Schlüsselspalten verwendet werden. In einer über-/unterordnungsbeziehung zwischen zwei Tabellen kann einen Wert aus der übergeordneten Tabelle gelöscht untergeordneten Zeilen in einem der folgenden Arten wirken sich auf.  
  
-   Das untergeordnete Element, Zeilen, auch sein können, gelöscht (eine kaskadierende Aktion).  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf null-Werte festgelegt werden.  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf Standardwerte festgelegt werden.  
  
-   Eine Ausnahme kann ausgelöst werden.  
  
 Ein <xref:System.Data.UniqueConstraint> wird aktiviert, bei dem Versuch, einen Wert in einem Primärschlüssel auf einen nicht eindeutigen Wert festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Data.ForeignKeyConstraint> auf die Auflistung von Einschränkungen.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Struktur und die Daten für diesen <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Ein neues <see cref="T:System.Data.DataTable" /> mit dem gleichen Struktur (Tabellenschemas und Einschränkungen) und Daten, wie diese <see cref="T:System.Data.DataTable" />.  
  
 Wenn diese Klassen abgeleitet wurden, werden auch die Kopie der gleichen abgeleiteten Klassen.  
  
 <see cref="M:System.Data.DataTable.Copy" />erstellt ein neues <see cref="T:System.Data.DataTable" /> mit der gleichen Struktur und Daten wie der ursprüngliche <see cref="T:System.Data.DataTable" />. So kopieren Sie die Struktur in eine neue <see cref="T:System.Data.DataTable" />, jedoch nicht die Daten verwenden <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Copy%2A> Methode zum Erstellen einer Kopie des Originals <xref:System.Data.DataTable>. Der Name des Namespaces wird nicht beibehalten, wenn er von einem übergeordneten Element geerbt wird <xref:System.Data.DataTable> oder <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Data.DataTableReader" /> entspricht, auf die Daten in dieser <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Ein <see cref="T:System.Data.DataTableReader" /> mit einem Resultset, die an der Quelle entspricht <see cref="T:System.Data.DataTable" /> Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable>-Instanz. Im Beispiel übergibt dann das ausgefüllte <xref:System.Data.DataTable> an eine Prozedur, die Aufrufe der <xref:System.Data.DataTable.CreateDataReader%2A> -Methode, die Ergebnisse der enthaltenen durchläuft die <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Das new-Ausdruck.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Data.DataSet" /> zu dem diese Tabelle gehört.</summary>
        <value>Die <see cref="T:System.Data.DataSet" /> zu dem diese Tabelle gehört.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Steuerelement datengebunden ist auf eine <xref:System.Data.DataTable>, und die Tabelle gehört zu einer <xref:System.Data.DataSet>, erhalten Sie auf der <xref:System.Data.DataSet> über diese Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel gibt die übergeordnete <xref:System.Data.DataSet> einer angegebenen Tabelle über die <xref:System.Data.DataTable.DataSet%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine angepasste Ansicht der Tabelle, die eine gefilterte Sicht oder eine Cursorposition enthalten kann.</summary>
        <value>Der mit dem <see cref="T:System.Data.DataView" /> verknüpfte <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.DefaultView%2A> Eigenschaft gibt eine <xref:System.Data.DataView> können Sie sortieren, Filtern und Suchen einer <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Eigenschaft der <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataView> über die <xref:System.Data.DataTable.DefaultView%2A> Eigenschaft. Außerdem wird gezeigt, die Bindung von einer <xref:System.Windows.Forms.DataGridView> die Steuerung an eine <xref:System.Data.DataTable> mit dem Namen "Suppliers", die eine Spalte mit dem Namen "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abrufen oder festlegen den Ausdruck, der einen Wert zur Darstellung dieser Tabelle in der Benutzeroberfläche zurückgibt. Die <see langword="DisplayExpression" /> -Eigenschaft können Sie den Namen dieser Tabelle in einer Benutzeroberfläche anzuzeigen.</summary>
        <value>Eine Anzeigezeichenfolge.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung einer <see cref="T:System.Data.DataTable" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert Benachrichtigungen, indexverwaltung und Einschränkungen nach dem Laden von Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.EndLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von benutzerdefinierten Informationen ab.</summary>
        <value>Ein <see cref="T:System.Data.PropertyCollection" /> , die benutzerdefinierte Informationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ExtendedProperties%2A> benutzerdefinierte Informationen zum Hinzufügen einer <xref:System.Data.DataTable>. Hinzufügen von Daten mit der `Add` Methode. Abrufen von Informationen mit der `Item` Methode.  
  
 Erweiterte Eigenschaften muss vom Typ <xref:System.String>. Eigenschaften, die nicht vom Typ Zeichenfolge sind, werden nicht beibehalten. wenn die <xref:System.Data.DataTable> als XML geschrieben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Timestamp-Wert, der <xref:System.Data.DataTable> über die <xref:System.Data.DataTable.ExtendedProperties%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überprüft, ob die Initialisierung ausgeführt wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataTable" /> , enthält alle Änderungen, da es geladen wurde oder <see cref="M:System.Data.DataTable.AcceptChanges" /> zuletzt aufgerufen wurde.</summary>
        <returns>Eine Kopie der Änderungen aus dieser <see cref="T:System.Data.DataTable" />, oder <see langword="null" /> Wenn keine Änderungen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues <xref:System.Data.DataSet> , enthält eine Kopie aller Zeilen in der ursprünglichen <xref:System.Data.DataSet> , ausstehende Änderungen aufweisen. Beziehung Einschränkungen können dazu führen, dass zusätzliche unveränderte Zeilen in die neue hinzuzufügende <xref:System.Data.DataSet> enthält die unveränderten Zeilen Primärschlüsseln, Fremdschlüsseln in der geänderten Zeilen entspricht. Gibt die Methode `null` (`Nothing` in Visual Basic), wenn keine Zeilen vorhanden, in der ursprünglichen sind <xref:System.Data.DataSet> mit ausstehenden Änderungen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Einer der <see cref="T:System.Data.DataRowState" />-Werte.</param>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataTable" /> , enthält alle Änderungen, seit es zuletzt geladen wurde, oder seit <see cref="M:System.Data.DataTable.AcceptChanges" /> wurde aufgerufen, gefiltert nach <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Eine gefilterte Kopie der <see cref="T:System.Data.DataTable" /> deren Aktionen darauf und später wieder zusammengeführt werden die <see cref="T:System.Data.DataTable" /> mit <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Wenn keine Zeilen mit dem gewünschten <see cref="T:System.Data.DataRowState" /> gefunden werden, wird der Methodenrückgabe <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.GetChanges%2A> Methode wird verwendet, um eine zweite erzeugen <xref:System.Data.DataTable> Objekt, das nur die Änderungen enthält, die in der ursprünglichen eingeführt. Verwenden der `rowStates` Argument, um die Art von Änderungen anzugeben, sollte das neue Objekt enthalten.  
  
 Einschränkungen der Beziehung möglicherweise unverändert übergeordneten Zeilen eingeschlossen werden sollen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Eine <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Instanz.</param>
        <summary>Diese Methode gibt ein <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Instanz, die die WSDL Web Services Description Language (), die beschreibt, enthält die <see cref="T:System.Data.DataTable" /> für Webdienste.</summary>
        <returns>Die <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von <see cref="T:System.Data.DataRow" /> Objekte, die Fehler enthalten.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" /> Objekte, die Fehler enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die Liste der <xref:System.Data.DataRow> Objekte mit <xref:System.Data.DataRow.RowError%2A> festgelegt. Fehler können z. B. auftreten, beim Aufrufen von <xref:System.Data.Common.DataAdapter.Update%2A> mit <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> festgelegt **"true"**. Nicht aufgerufen werden <xref:System.Data.DataTable.AcceptChanges%2A> auf die <xref:System.Data.DataTable> , bis Sie alle Fehler zu beheben, und senden Sie erneut die <xref:System.Data.DataSet> für die Aktualisierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.GetErrors%2A> Methode, um ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte, die Fehler enthalten.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" /> -Objekt, das den serialisierten Daten zugeordnet sind die <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" /> -Objekt, das die Quelle und Ziel des serialisierten Streams zugeordnet enthält die <see cref="T:System.Data.DataTable" />.</param>
        <summary>Füllt ein Serialisierungsinformationsobjekt mit den Daten auf, die zum Serialisieren des <see cref="T:System.Data.DataTable" /> erforderlich sind.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="info" /> Parameter ist ein null-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Zeilentyp ab.</summary>
        <returns>Gibt den Typ des der <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Ein <see cref="T:System.Xml.Schema.XmlSchema" /> zur Beschreibung der XML-Darstellung des Objekts, das von der <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />-Methode erstellt und von der <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />-Methode verwendet wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, ob Fehler in einer der Zeilen in einer der Tabellen von der <see cref="T:System.Data.DataSet" /> zu dem die Tabelle gehört.</summary>
        <value>
          <see langword="true" />Wenn Fehler vorhanden sind; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer auf einen Satz von Daten in der Arbeit ein <xref:System.Data.DataTable>, Sie können jede Änderung mit einem Fehler markieren, wenn die Änderung das Fehlschlagen der Validierung verursacht. Sie können eine gesamte kennzeichnen <xref:System.Data.DataRow> mit einer Fehlermeldung mit der <xref:System.Data.DataRow.RowError%2A> Eigenschaft. Sie können auch Fehler festlegen, auf den einzelnen Spalten der Zeile mit der <xref:System.Data.DataRow.SetColumnError%2A> Methode.  
  
 Vor dem Aktualisieren einer Datenquelle mit einem <xref:System.Data.DataSet>, es wird empfohlen, Sie zuerst rufen die <xref:System.Data.DataSet.GetChanges%2A> Methode auf dem Ziel <xref:System.Data.DataSet>. Die Methode führt zu einem <xref:System.Data.DataSet> , enthält nur die mit dem ursprünglichen vorgenommenen Änderungen. Vor dem Senden der <xref:System.Data.DataSet> wie die Datenquelle für das Aktualisieren, finden Sie in der <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft jeder Tabelle, um festzustellen, ob die Zeilen oder Spalten in den Zeilen Fehler angefügt wurde.  
  
 Nach dem Abgleichen aller Fehler, deaktivieren Sie die Fehler mit der <xref:System.Data.DataRow.ClearErrors%2A> Methode der `DataRow`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft zu überprüfen, ob eine Tabelle Fehler enthält.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">Die <see cref="T:System.Data.DataRow" /> importiert werden sollen.</param>
        <summary>Kopiert ein <see cref="T:System.Data.DataRow" /> in einem <see cref="T:System.Data.DataTable" />, alle eigenschafteneinstellungen sowie die ursprünglichen und aktuellen Werte beibehalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Data.DataTable.NewRow%2A> Fügt eine Zeile der Tabelle mit dem vorhandenen Tabellenschema, jedoch mit den Standardwerten für die Zeile, und legt die <xref:System.Data.DataRowState> auf `Detached`. Aufrufen von <xref:System.Data.DataTable.ImportRow%2A> behält den vorhandenen <xref:System.Data.DataRowState> zusammen mit anderen Werten in der Zeile. Wenn die `DataRow` übergeben wird, wie ein Parameter im getrennten Zustand befindet ist, ignoriert wird und keine Ausnahme ausgelöst wird.  
  
 Die neue Zeile wird an das Ende der Datentabelle hinzugefügt werden.  
  
 Wenn die neue Zeile hinzugefügt in der Datentabelle wird nicht gegen eine Einschränkung verstößt.  
  
 Sie können den Index der neuen Zeile mit DataTable.Rows.Find und DataTable.Rows.IndexOf abrufen. Weitere Informationen finden Sie unter <xref:System.Data.DataRowCollection> und <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem die <see cref="T:System.Data.DataTable" /> initialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die <see cref="T:System.Data.DataTable" /> initialisiert wird.</summary>
        <value>
          <see langword="true" />um anzugeben, die Komponente die Initialisierung abgeschlossen; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt den Status der <xref:System.Data.DataTable> während der Erstellung, für die Instanz von Visual Studio. Die <xref:System.Data.DataTable.BeginInit%2A> Methode wird auf `false` und <xref:System.Data.DataTable.EndInit%2A> Methode wird auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle mit dem angegebenen <see cref="T:System.Data.IDataReader" />. Wenn die <see langword="DataTable" /> bereits Zeilen enthält, die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode kann verwendet werden, in mehrere allgemeine Szenarien, darum Abrufen von Daten aus einer bestimmten Datenquelle und den aktuellen Datencontainer hinzugefügt (in diesem Fall eine `DataTable`). Diese Szenarien beschreiben Standardverfahren für die eine `DataTable`, beschreiben Sie das Update und merge-Verhalten.  
  
 Ein `DataTable` anhand einer einzigen primären Datenquelle synchronisiert oder aktualisiert. Die `DataTable` verfolgt Änderungen, sodass die Synchronisierung mit der primären Datenquelle. Darüber hinaus eine `DataTable` inkrementelle Daten aus einem oder mehreren sekundären Datenquellen akzeptieren können. Die `DataTable` ist nicht verantwortlich für das Nachverfolgen von Änderungen um Synchronisierung mit der sekundären Datenquelle zu ermöglichen.  
  
 Wenn Sie diese beiden hypothetischen Datenquellen, ist ein Benutzer voraussichtlich benötigt eine der folgenden Verhaltensweisen:  
  
-   Initialisieren `DataTable` aus einer primären Datenquelle. In diesem Szenario wird der Benutzer ein leeres initialisieren möchte `DataTable` mit Werten aus der primären Datenquelle. Der Benutzer möchte später Weitergeben von Änderungen an der primären Datenquelle.  
  
-   Änderungen beibehalten und erneut über die primäre Datenquelle synchronisieren. In diesem Szenario möchte der Benutzer wird die `DataTable` im vorherigen Szenario gefüllt, und führen Sie eine inkrementelle Synchronisierung mit der primären Datenquelle beibehalten der Änderungen der `DataTable`.  
  
-   Inkrementelle Datenfeed aus sekundären Datenquellen. In diesem Szenario möchten die Benutzer zum Zusammenführen von Änderungen aus einem oder mehreren sekundären Datenquellen und zurück an die primäre Datenquelle weitergeben.  
  
 Die `Load` Methode ermöglicht all diesen Szenarien. Alle außer einer der Überladungen dieser Methode Sie einen Auslastungstest Optionsparameter angeben, kann die Verarbeitung, der angibt, wie Zeilen bereits in einer <xref:System.Data.DataTable> mit geladenen Zeilen kombiniert werden. (Die Überladung, die Sie zum Festlegen des Verhaltens ermöglichen keine verwendet die Standardoption für die Auslastung.) Die folgende Tabelle beschreibt die drei Ladeoptionen gebotenen der <xref:System.Data.LoadOption> Enumeration. In jedem Fall gibt die Beschreibung des Verhaltens, wenn der Primärschlüssel einer Zeile in den empfangenen Daten den Primärschlüssel einer vorhandenen Zeile übereinstimmt.  
  
|Laden Sie die Option|Beschreibung|  
|-----------------|-----------------|  
|`PreserveChanges` (Standardwert)|Aktualisiert die ursprüngliche Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
|`OverwriteChanges`|Die aktuellen und ursprüngliche Version der Zeile aktualisiert mit dem Wert der hinzukommenden Zeile.|  
|`Upsert`|Aktualisiert die aktuelle Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
  
 Im Allgemeinen die `PreserveChanges` und `OverwriteChanges` Optionen dienen für Szenarien, in denen der Benutzer synchronisieren muss, die `DataSet` und die Änderungen mit der primären Datenquelle. Die `Upsert` Option erleichtert das Aggregieren Änderungen aus einem oder mehreren sekundären Datenquellen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel wird schwerpunktmäßig dann Datenprobleme, einschließlich der Handhabung der verschiedenen Optionen für das Laden.  
  
> [!NOTE]
>  In diesem Beispiel wird gezeigt, wie mit einer der überladenen Versionen der `Load`. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" /> , der ein Resultset bereitstellt.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle mit dem angegebenen <see cref="T:System.Data.IDataReader" />. Wenn die <see cref="T:System.Data.DataTable" /> bereits Zeilen enthält, die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Data.DataTable.Load%2A> Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der <xref:System.Data.DataTable.Load%2A> Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die <xref:System.Data.DataTable.Load%2A> -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die <xref:System.Data.DataTable.Load%2A> Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden sind die <xref:System.Data.DataTable>.|Die <xref:System.Data.DataTable.Load%2A> Methode fügt die zusätzlichen Spalten `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die <xref:System.Data.DataTable.Load%2A> Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen die Standardeinstellung oder `null` Wert für die Spalte fehlt. Wenn kein Standardwert oder `null` verwendet werden können, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` -Methode verwendet die `null` Wert als der implizite Standardwert.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`.  Weitere Informationen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Diese Version von den `Load` Methode versucht, die aktuellen Werten in jeder Zeile wird den ursprünglichen Wert unverändert beibehalten. (Sie ggf. eine genauere Steuerung des Verhaltens der eingehenden Daten finden Sie unter <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt von den Zustand der Zeile vor der Ladevorgang ab. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die `Load` Methode. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde. In diesem Fall die Methode lässt nicht den Load-Option anzugeben, und die standardmäßige `PreserveChanges`.  
  
|Vorhandene DataRowState|Werte, nach dem `Load` -Methode und Ereignisaktion|  
|---------------------------|--------------------------------------------------|  
|Hinzugefügt|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Deleted|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Bestimmen, welche Version des primären Schlüsselfelds zum Vergleichen von der aktuellen Zeile mit einer eingehenden Zeile, die `Load` Methode verwendet die ursprüngliche Version des primären Schlüsselwert innerhalb einer Zeile aus, falls vorhanden. Andernfalls die `Load` Methode verwendet die aktuelle Version des Feld für den Primärschlüssel.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Das Beispiel ruft dann die `Load` -Methode, Anzeigen der Daten vor und nach dem Ladevorgang.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">Eine <see cref="T:System.Data.IDataReader" /> , die eine oder mehrere Resultsets bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" /> Enumeration, der angibt wie Zeilen bereits in der <see cref="T:System.Data.DataTable" /> zusammen mit den eingehenden Zeilen, die den gleichen Primärschlüssel aufweisen.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle mit dem angegebenen <see cref="T:System.Data.IDataReader" />. Wenn die <see langword="DataTable" /> bereits Zeilen enthält, die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen entsprechend dem Wert des zusammengeführt werden die <paramref name="loadOption" /> Parameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden waren die `DataTable`.|Die `Load` Methode fügt die zusätzlichen Spalten `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die `Load` Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen den Default und Null-Wert für die fehlende Spalte. Wenn kein Standardwert oder Null verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleiche Primärschlüssel wie vorhandene Zeilen haben? Sollte es aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und vieles mehr, hängen von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die Load-Methode, die bei einem Aufruf mit einzelnen der `LoadOption` Werte und zeigt außerdem, wie die Werte mit dem Zeilenstatus für die zu ladenden Zeile interagieren. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|Upsert|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
eleted|(Last ist nicht auf Zeilen auswirken, die gelöscht)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Merkmalen hinzugefügt)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschvorgang rückgängig zu machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neue Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie die Optionen OverwriteChanges oder PreserveChanges, beim Aufrufen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primäre Datenquelle und der DataTable Änderungen nachverfolgt und weitergeben können die Änderungen werden wieder an die Datenquelle. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass die Absicht zum Aggregieren von Daten aus einem oder mehreren Datenquellen in ist die `DataTable`, und klicken Sie dann möglicherweise die Daten zurück in die primäre Datenquelle übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. In der folgenden Tabelle enthält die Details an.  
  
|Laden Sie die option|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`PreserveChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, falls vorhanden, andernfalls die ursprüngliche version|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel wird schwerpunktmäßig dann Datenprobleme, einschließlich der Handhabung der verschiedenen Optionen für das Laden.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" /> , der ein Resultset bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" /> Enumeration, der angibt wie Zeilen bereits in der <see cref="T:System.Data.DataTable" /> zusammen mit den eingehenden Zeilen, die den gleichen Primärschlüssel aufweisen.</param>
        <param name="errorHandler">Ein <see cref="T:System.Data.FillErrorEventHandler" /> Delegat, der aufgerufen wird, tritt ein Fehler beim Laden von Daten.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle mit dem angegebenen <see cref="T:System.Data.IDataReader" /> mithilfe ein Delegaten für die Fehlerbehandlung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden waren die `DataTable`.|Die `Load` Methode fügt die zusätzlichen Spalten zu `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die `Load` Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen den Default und Null-Wert für die fehlende Spalte. Wenn kein Standardwert oder Null verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleiche Primärschlüssel wie vorhandene Zeilen haben? Sollte es aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und vieles mehr, hängen von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die Load-Methode, die bei einem Aufruf mit einzelnen der `LoadOption` Werte und zeigt außerdem, wie die Werte mit dem Zeilenstatus für die zu ladenden Zeile interagieren. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|Upsert|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
eleted|(Last ist nicht auf Zeilen auswirken, die gelöscht)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Merkmalen hinzugefügt)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschvorgang rückgängig zu machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neue Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie die Optionen OverwriteChanges oder PreserveChanges, beim Aufrufen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primäre Datenquelle und der DataTable Änderungen nachverfolgt und weitergeben können die Änderungen werden wieder an die Datenquelle. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass die Absicht zum Aggregieren von Daten aus einem oder mehreren Datenquellen in ist die `DataTable`, und klicken Sie dann möglicherweise die Daten zurück in die primäre Datenquelle übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. In der folgenden Tabelle enthält die Details an.  
  
|Laden Sie die option|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`PreserveChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, falls vorhanden, andernfalls die ursprüngliche version|  
  
 Die `errorHandler` Parameter ist ein <xref:System.Data.FillErrorEventHandler> Delegat, der auf eine Prozedur, die aufgerufen wird verweist, tritt ein Fehler beim Laden von Daten. Die <xref:System.Data.FillErrorEventArgs> an die Prozedur übergebenen Parameter enthält Eigenschaften, die Sie zum Abrufen von Informationen zu den aufgetretenen Fehler, die aktuelle Zeile der Daten zu ermöglichen und die <xref:System.Data.DataTable> gefüllt wird. Mithilfe dieses Delegatmechanismus, anstatt ein einfacher Try/Catch-Block, können Sie den Fehler ermitteln die Situation zu behandeln, und die Verarbeitung fortzusetzen bei Bedarf. Die <xref:System.Data.FillErrorEventArgs> Parameter liefert eine <xref:System.Data.FillErrorEventArgs.Continue%2A> Eigenschaft: Legen Sie diese Eigenschaft auf `true` , um anzugeben, dass Sie den Fehler behandelt haben und die Verarbeitung ansonsten fortgesetzt werden soll. Legen Sie die Eigenschaft auf `false` um anzugeben, dass die Verarbeitung angehalten werden soll. Beachten Sie das Festlegen der Eigenschaft auf `false` bewirkt, dass den Code, der das Problem, um eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Werten für die neue Zeile zu erstellen.</param>
        <param name="fAcceptChanges">
          <see langword="true" />Um Änderungen zu übernehmen; andernfalls <see langword="false" />.</param>
        <summary>Findet und eine bestimmte Zeile aktualisiert. Wenn keine übereinstimmende Zeile gefunden wird, wird eine neue Zeile mit den angegebenen Werten erstellt.</summary>
        <returns>Die neue <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte enthält die <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaft auf true festgelegt ist, übergeben einen null-Wert im Array, legen Sie den automatisch generierten Wert für die Zeile festgelegt.  
  
 Wenn die `fAcceptChanges` Parameter ist `true` oder nicht angegeben ist, werden die neuen Daten hinzugefügt und dann <xref:System.Data.DataTable.AcceptChanges%2A> wird aufgerufen, um alle Änderungen in akzeptieren die <xref:System.Data.DataTable>; Wenn das Argument ist `false`, neu hinzugefügten Zeilen werden als Einfüge- und Änderungen an vorhandene Zeilen werden als geändert markiert.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.LoadDataRow%2A> Methode versucht, eine Zeile zu finden. Wenn keine solche Zeile gefunden wird, werden die Werte verwendet, um eine neue Zeile zu erstellen.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Array ist größer als die Anzahl der Spalten in der Tabelle.</exception>
        <exception cref="T:System.InvalidCastException">Ein Wert stimmt nicht mit dem entsprechenden Spaltentyp überein.</exception>
        <exception cref="T:System.Data.ConstraintException">Hinzufügen der Zeile wird eine Einschränkung ungültig.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Es wird versucht, ein NULL-Wert in einer Spalte eingefügt werden soll, in denen <see cref="P:System.Data.DataColumn.AllowDBNull" /> lautet "false".</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Werten für die neue Zeile zu erstellen.</param>
        <param name="loadOption">Verwendet, um zu ermitteln, wie die Arraywerte auf die entsprechenden Werte in eine vorhandene Zeile angewendet werden.</param>
        <summary>Findet und eine bestimmte Zeile aktualisiert. Wenn keine übereinstimmende Zeile gefunden wird, wird eine neue Zeile mit den angegebenen Werten erstellt.</summary>
        <returns>Die neue <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte enthält die <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaft auf true festgelegt ist, übergeben einen null-Wert im Array, legen Sie den automatisch generierten Wert für die Zeile festgelegt.  
  
 Der Wert, der die `loadOption` Parameter wird verwendet, um zu bestimmen, wie die Werte im Array auf eine vorhandene Zeile angewendet werden. Z. B. wenn `loadOption` festgelegt ist, um `OverwriteChanges`, die `Original` und `Current` Werte der einzelnen Spalten werden mit den Werten in der hinzukommenden Zeile ersetzt und die `RowState` -Eigenschaftensatz auf `Unchanged`.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ermittelt oder definiert die Gebietsschemainformationen, die zum Vergleichen von Zeichenfolgen in der Tabelle verwendet.</summary>
        <value>Ein <see cref="T:System.Globalization.CultureInfo" /> , das Daten über die Computergebietsschema des Benutzers enthält. Die Standardeinstellung ist die <see cref="T:System.Data.DataSet" /> des Objekts <see cref="T:System.Globalization.CultureInfo" /> (zurückgegebenes der <see cref="P:System.Data.DataSet.Locale" /> Eigenschaft), der die <see cref="T:System.Data.DataTable" /> gehört; Wenn die Tabelle nicht angehört, eine <see cref="T:System.Data.DataSet" />, der Standardwert ist das aktuelle System <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Globalization.CultureInfo> stellt die Einstellungen für die Software von einer bestimmten Kultur oder der Community.  
  
 Wenn Sie für Zeichenfolgenvergleiche verwendet die <xref:System.Globalization.CultureInfo> wirkt sich auf vergleichen, Sortieren und filtern.  
  
> [!NOTE]
>  In Spalten, Ausdrücke, enthalten, die <xref:System.StringComparison.InvariantCulture> verwendet wird. Die <xref:System.StringComparison.CurrentCulture> wird ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Globalization.CultureInfo> über die <xref:System.Data.DataTable.Locale%2A> und gibt den Namen der ISO-Sprache.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit dem aktuellen <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung veranschaulicht das Verhalten von der `missingSchemaAction` Parameter von der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle aus, ändern das Schema für die zweite Version. Der Code versucht, die zweite Tabelle mit dem ersten zusammengeführt.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie mit einer der überladenen Versionen der Zusammenführung. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" /> mit dem aktuellen zusammenzuführenden <see cref="T:System.Data.DataTable" />.</param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit dem aktuellen <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Merge-Vorgang standardmäßig beibehalten. Entwickler können dieses Verhalten ändern, indem Sie eine der anderen zwei Überladungen für diese Methode aufrufen und Angeben von einen false-Wert für die `preserveChanges` Parameter.  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und somit effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted`, zum von Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen wird. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine einfache <xref:System.Data.DataTable> und die Tabelle Daten hinzugefügt. Das Beispiel erstellt dann eine Kopie der Tabelle, die Kopie Zeilen hinzugefügt. Zum Schluss das Beispiel ruft die <xref:System.Data.DataTable.Merge%2A> Methode, um die Daten in der zweiten Tabelle mit den Daten in der ersten Tabelle zusammenzuführen.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">Die <see langword="DataTable" /> mit dem aktuellen zusammenzuführenden <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, um Änderungen in der aktuellen beizubehalten, <see langword="DataTable" />andernfalls <see langword="false" />.<see langword="" /></param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit dem aktuellen <see langword="DataTable" />, gibt an, ob Änderungen in der aktuellen <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Zusammenführung beibehalten, es sei denn, der Entwickler "false" für gibt die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz auf `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz auf `false`, empfangenen Werten werden die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable> mit Zeilen, einige der Daten in diesen Zeilen ändert und versucht, Daten aus einer anderen zusammengeführt <xref:System.Data.DataTable>. Im Beispiel wird veranschaulicht, die unterschiedliche Verhaltensweisen für die `preserveChanges` Parameter.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" /> mit dem aktuellen zusammenzuführenden <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, um Änderungen in der aktuellen beizubehalten, <see cref="T:System.Data.DataTable" />andernfalls <see langword="false" />.</param>
        <param name="missingSchemaAction">Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit dem aktuellen <see langword="DataTable" />, der angibt, ob Änderungen erhalten bleiben und Behandeln von fehlenden Schema in der aktuellen <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Zusammenführung beibehalten, es sei denn, der Entwickler "false" für gibt die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz auf `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz auf `false`, empfangenen Werten werden die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataTable.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataTable> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataTable> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataTable> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung veranschaulicht das Verhalten von der `missingSchemaAction` Parameter von der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle aus, ändern das Schema für die zweite Version. Der Code versucht, die zweite Tabelle mit dem ersten zusammengeführt.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Ausgangsgröße für diese Tabelle.</summary>
        <value>Die Ausgangsgröße in Zeilen dieser Tabelle. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.MinimumCapacity%2A> kann das System vor dem Abrufen der Daten einen entsprechenden Satz von Ressourcen zu erstellen. In einer Situation Wenn Leistung kritisch ist, wird kann durch Festlegen dieser Eigenschaft Leistung optimiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.MinimumCapacity%2A> von einem <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namespace für die XML-Darstellung der Daten aus der <see cref="T:System.Data.DataTable" />.</summary>
        <value>Der Namespace von <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Data.DataRow" /> mit dem gleichen Schema wie die Tabelle.</summary>
        <returns>Ein <see cref="T:System.Data.DataRow" /> mit dem gleichen Schema wie die <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen neuer <xref:System.Data.DataRow> Objekte mit dem gleichen Schema wie die <xref:System.Data.DataTable>. Nach dem Erstellen einer <xref:System.Data.DataRow>, können Sie ihn zum Hinzufügen der <xref:System.Data.DataRowCollection>, bis die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.Rows%2A> Eigenschaft. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen müssen hinzugefügt oder aus der Tabelle gelöscht wird, vor dem Aufruf <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable>, addiert zwei <xref:System.Data.DataColumn> Objekte bestimmen das Schema der Tabelle, und erstellt mehrere neue <xref:System.Data.DataRow> -Objekten mit den <xref:System.Data.DataTable.NewRow%2A> Methode. Die <xref:System.Data.DataRow> Objekte werden dann hinzugefügt, um die <xref:System.Data.DataRowCollection> mithilfe der <xref:System.Data.DataRowCollection.Add%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Ein <see cref="T:System.Int32" /> Wert, der die Größe des Arrays beschrieben.</param>
        <summary>Gibt ein Array von <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Das neue Array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Ein <see cref="T:System.Data.DataRowBuilder" />-Objekt.</param>
        <summary>Erstellt eine neue Zeile aus einer vorhandenen Zeile an.</summary>
        <returns>Ein <see cref="T:System.Data.DataRow" /> abgeleitete Klasse.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataColumnChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.ColumnChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataColumnChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.ColumnChanging" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Ein <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">Die <see cref="T:System.Data.DataColumn" /> entfernt wird.</param>
        <summary>Benachrichtigt den <see cref="T:System.Data.DataTable" /> , die eine <see cref="T:System.Data.DataColumn" /> entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowChanging" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowDeleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowDeleting" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableClearEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableCleared" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableCleared> -Ereignis, das ausgelöst wird, sofort, nachdem alle Zeilen, jedoch bevor wurden erfolgreich gelöscht wurden die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung wieder an den Aufrufer zurückgibt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableClearEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableClearing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableClearing> Ereignis, das ausgelöst wird, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> -Vorgang beginnt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableNewRowEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableNewRow" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableNewRow> Ereignis, das ausgelöst, nachdem ein neues wird <xref:System.Data.DataRow> mit erstellt wurde <xref:System.Data.DataTable.NewRow%2A>.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Beziehungen in der übergeordneten dafür <see cref="T:System.Data.DataTable" />.</summary>
        <value>Ein <see cref="T:System.Data.DataRelationCollection" /> , die die übergeordneten Beziehungen für die Tabelle enthält. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataRelation" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ParentRelations%2A> -Eigenschaft zum Zurückgeben von jedem übergeordneten Element <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetParentRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Der Wert der einzelnen Spalten in der Zeile wird dann ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namespace für die XML-Darstellung der Daten aus der <see cref="T:System.Data.DataTable" />.</summary>
        <value>Das Präfix des der <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ein Array von Spalten die Funktion als Primärschlüssel für die Datentabelle.</summary>
        <value>Ein Array von <see cref="T:System.Data.DataColumn" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Primärschlüssel einer Tabelle muss zum Identifizieren des Datensatzes in der Tabelle eindeutig sein. Es ist auch möglich, eine Tabelle mit einem Primärschlüssel setzt sich aus zwei oder mehr Spalten enthalten. Dies tritt auf, wenn eine einzelne Spalte genügend eindeutige Werte enthalten kann. Beispielsweise kann ein Primärschlüssel zweispaltigen einer Spalte "FirstName" und "LastName" bestehen. Da der Primärschlüssel von mehr als eine Spalte vorgenommen werden können die <xref:System.Data.DataTable.PrimaryKey%2A> Eigenschaft besteht aus einem Array von <xref:System.Data.DataColumn> Objekte.  
  
   
  
## Examples  
 Im erste Beispiel wird gezeigt, wie die Primärschlüsselspalten für die zurückzugebenden eine <xref:System.Data.DataTable> angezeigt, die einem `DataGrid`. Im zweite Beispiel veranschaulicht das Festlegen der Primärschlüsselspalten für eine <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Der Schlüssel ist ein Fremdschlüssel.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest das XML-Schema und Daten in der <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die die `XmlReadMode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein Objekt, das von abgeleitet ist.<see cref="T:System.IO.Stream" /></param>
        <summary>Liest das XML-Schema und Daten in der <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <returns>Die <see cref="T:System.Data.XmlReadMode" /> verwendet, um die Daten zu lesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus dem angegebenen <xref:System.IO.Stream>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen Speicherstream, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die <see cref="T:System.IO.TextReader" /> , die zum Lesen der Daten verwendet werden.</param>
        <summary>Liest das XML-Schema und Daten in der <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.IO.TextReader" />.</summary>
        <returns>Die <see cref="T:System.Data.XmlReadMode" /> verwendet, um die Daten zu lesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus dem angegebenen <xref:System.IO.TextReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen Speicherstream, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus dem die Daten gelesen werden soll.</param>
        <summary>Liest das XML-Schema und Daten in der <see cref="T:System.Data.DataTable" /> aus der angegebenen Datei.</summary>
        <returns>Die <see cref="T:System.Data.XmlReadMode" /> verwendet, um die Daten zu lesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus der Datei mit dem Namen in der bereitgestellten <xref:System.String>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten auf dem Datenträger. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die <see cref="T:System.Xml.XmlReader" /> , die zum Lesen der Daten verwendet werden.</param>
        <summary>Liest das XML-Schema und Daten in der <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>Die <see cref="T:System.Data.XmlReadMode" /> verwendet, um die Daten zu lesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus der Datei mit dem Namen in der bereitgestellten <xref:System.Xml.XmlReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataTable.ReadXml%2A> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schemas und Daten zu einem <xref:System.Xml.XmlReader>. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten füllen die <xref:System.Xml.XmlReader> Instanz.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein XML-Schema in der <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `ReadXmlSchema` Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstrom wird verwendet, um das Schema zu lesen.</param>
        <summary>Liest ein XML-Schema in der <see cref="T:System.Data.DataTable" /> mit dem angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die <see cref="T:System.IO.TextReader" /> verwendet, um die Schemainformationen zu lesen.</param>
        <summary>Liest ein XML-Schema in der <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe einer <xref:System.IO.StreamReader> (geerbt von <xref:System.IO.TextReader>) als Updatequelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus dem die Schemainformationen gelesen werden soll.</param>
        <summary>Liest ein XML-Schema in der <see cref="T:System.Data.DataTable" /> aus der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der `DataTable`.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und das Schema für diese Tabelle in eine Datei schreibt. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe der Datei als Quelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die <see cref="T:System.Xml.XmlReader" /> verwendet, um die Schemainformationen zu lesen.</param>
        <summary>Liest ein XML-Schema in der <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Die Möglichkeit zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema werden implizite geschachtelter Elemente aufweisen. Darüber hinaus könnte die geschachtelte Beziehung neu konfiguriert werden, um explizite Spaltennamen sein. Es ist zwingend erforderlich, für Elemente, die implizit für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe einer <xref:System.Xml.XmlTextReader> (geerbt von <xref:System.Xml.XmlReader>) als Updatequelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Xml.XmlReader" />-Objekt.</param>
        <summary>Liest aus einem XML-Datenstrom.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rollback aller Änderungen, die vorgenommen wurden, um die Tabelle, da es geladen wurde, bzw. des letzten <see cref="M:System.Data.DataTable.AcceptChanges" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Objekte, die immer noch im Bearbeitungsmodus befinden Bearbeitungsvorgänge abgebrochen. Neue Zeilen werden entfernt. Zeilen mit den <xref:System.Data.DataRowState> festgelegt `Modified` oder `Deleted` wieder auf den ursprünglichen Zustand zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere Änderungen an einer <xref:System.Data.DataTable>, jedoch weist die Änderungen durch Aufrufen der <xref:System.Data.DataTable.RejectChanges%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das Serialisierungsformat.</summary>
        <value>Ein <see cref="T:System.Data.SerializationFormat" /> -Enumeration, der entweder angibt <see langword="Binary" /> oder <see langword="Xml" /> Serialisierung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="T:System.Data.DataTable" /> in seinen ursprünglichen Zustand. Zurücksetzen entfernt alle Daten, Indizes, Beziehungen und Spalten der Tabelle. Wenn ein DataSet eine "DataTable" enthält, werden die Tabelle immer noch Teil des Datasets, nach dem Zurücksetzen der Tabelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem eine <see cref="T:System.Data.DataRow" /> erfolgreich geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine <see cref="T:System.Data.DataRow" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem eine Zeile in der Tabelle gelöscht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, bevor eine Zeile in der Tabelle gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Zeilen, die zu dieser Tabelle gehören.</summary>
        <value>Ein <see cref="T:System.Data.DataRowCollection" /> enthält <see cref="T:System.Data.DataRow" /> Objekte; andernfalls eine Null-Wert, wenn kein <see cref="T:System.Data.DataRow" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen eines neuen <xref:System.Data.DataRow>, verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues Objekt zurückzugeben. Ein solches Objekt wird automatisch konfiguriert, gemäß dem Schema definierten für die <xref:System.Data.DataTable> durch die Auflistung der <xref:System.Data.DataColumn> Objekte. Fügen Sie nach dem Erstellen einer neuen Zeile, und Festlegen der Werte für jede Spalte in der Zeile, die Zeile an die <xref:System.Data.DataRowCollection> mithilfe der `Add` Methode.  
  
 Jede <xref:System.Data.DataRow> in der Auflistung stellt eine Datenzeile in der Tabelle. Um eine Änderung auf den Wert einer Spalte in der Zeile einen Commit auszuführen, rufen Sie die <xref:System.Data.DataTable.AcceptChanges%2A> Methode.  
  
   
  
## Examples  
 Im folgenden sehen zwei Beispiele für zurückgeben und Festlegen von Zeilen. Im ersten Beispiel wird die <xref:System.Data.DataTable.Rows%2A> Eigenschaft und die Werte der einzelnen Spalten für jede Zeile ausgegeben. Im zweiten Beispiel wird die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen eines neuen <xref:System.Data.DataRow> Objekt mit dem Schema der <xref:System.Data.DataTable>. Nach dem Festlegen der Werte der Zeilen, die Zeile hinzugefügt wird die <xref:System.Data.DataRowCollection> über die `Add` Methode.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" /> Objekte.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die richtigen Sortierreihenfolge sicherzustellen möchten, geben Sie Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel gibt ein Array von <xref:System.Data.DataRow> Objekte über die <xref:System.Data.DataTable.Select%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die Kriterien zum Filtern von Zeilen. Beispiele für das zum Filtern von Zeilen, finden Sie unter ["DataView" RowFilter Syntax [c#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" /> Objekte, die den Filterkriterien entsprechen.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen der `filterExpression` Argument verwenden, gelten, die gleichen Regeln die <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert für das Erstellen von Filtern.  
  
 Um die richtigen Sortierreihenfolge sicherzustellen möchten, geben Sie Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugebenden <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die Kriterien zum Filtern von Zeilen. Beispiele für das zum Filtern von Zeilen, finden Sie unter ["DataView" RowFilter Syntax [c#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Eine Zeichenfolge, der die Richtung und die Sortierreihenfolge angibt.</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" /> Objekte, die die Filterkriterien erfüllen, in der angegebenen Sortierreihenfolge ab.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" /> Objekte, die mit dem Filterausdruck übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln zum Erstellen der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugebenden <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die Kriterien zum Filtern von Zeilen. Beispiele für das zum Filtern von Zeilen, finden Sie unter ["DataView" RowFilter Syntax [c#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Eine Zeichenfolge, der die Richtung und die Sortierreihenfolge angibt.</param>
        <param name="recordStates">Einer der <see cref="T:System.Data.DataViewRowState" />-Werte.</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" /> Objekte, die den Filter in der Reihenfolge der Sortierung entsprechen, die in Übereinstimmung mit dem angegebenen Status.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln zum Erstellen der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Ausdruck und Datensatz-Filterstatus zurückzugebenden ein Array von <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.Data.DataTable" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites Binden einer <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen diesen sowie bieten eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" />Wenn die Auflistung eine Auflistung von <see cref="T:System.Collections.IList" /> Objekte; anderenfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Ein <see cref="T:System.Collections.IList" /> an eine Datenquelle aus dem Objekt gebunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Ein <see cref="T:System.Xml.Schema.XmlSchema" /> zur Beschreibung der XML-Darstellung des Objekts, das von der <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />-Methode erstellt und von der <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />-Methode verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Einen "XmlReader".</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein XmlWriter.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein <see cref="T:System.Data.DataTable" /> deaktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableCleared> Ereignis wird ausgelöst, unmittelbar nachdem alle Zeilen, jedoch bevor wurden erfolgreich gelöscht wurden die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung wieder an den Aufrufer zurückgibt. Die <xref:System.Data.DataTable.TableCleared> Ereignis wird nicht ausgelöst, wenn alle Ausnahmen während der Löschvorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine <see cref="T:System.Data.DataTable" /> deaktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableClearing> Ereignis wird ausgelöst, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> -Vorgang beginnt. Dieses Ereignis wird immer ausgelöst, wenn die <xref:System.Data.DataTable.Clear%2A> Methode aufgerufen wird, selbst wenn die Tabelle keine Zeilen enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der <see cref="T:System.Data.DataTable" /> ab oder legt diesen fest.</summary>
        <value>Der Name des <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableName%2A> wird verwendet, um diese Tabelle aus dem übergeordneten zurückgeben <xref:System.Data.DataSet> des Objekts <xref:System.Data.DataTableCollection> (zurückgegebenes der <xref:System.Data.DataSet.Tables%2A> Eigenschaft).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.TableName%2A> für jede Tabelle in einer Auflistung von <xref:System.Data.DataTable> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" />oder eine leere Zeichenfolge ("") übergeben und die Tabelle gehört zu einer Auflistung.</exception>
        <exception cref="T:System.Data.DuplicateNameException">Die Tabelle gehört zu einer Auflistung, die bereits eine Tabelle mit dem gleichen Namen verfügt. (Vergleich wird die Groß-/Kleinschreibung).</exception>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein neues <see cref="T:System.Data.DataRow" /> eingefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird ausgelöst, nachdem ein neues <xref:System.Data.DataRow> mit erstellt wurde <xref:System.Data.DataTable.NewRow%2A>. Dieses Ereignis wird ausgelöst, bevor die aufgerufene `NewRow` -Methode zurückkehrt. Die neue <xref:System.Data.DataRow> Instanz getrennt ist, wurde nicht auf die Auflistung hinzugefügt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Data.DataTable.TableName" /> und <see cref="P:System.Data.DataTable.DisplayExpression" />, wenn eine als eine verkettete Zeichenfolge vorhanden ist.</summary>
        <returns>Eine Zeichenfolge mit der <see cref="P:System.Data.DataTable.TableName" /> und die <see cref="P:System.Data.DataTable.DisplayExpression" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> für die <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> mithilfe der <xref:System.Data.DataTable.ToString%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie eine der überladenen Versionen von WriteXml verwenden. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstrom, der die Daten geschrieben werden.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.Stream" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.TextWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Die Datei an, in die XML-Daten geschrieben werden soll.</param>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> als XML mit der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Xml.XmlWriter" /> mit dem der Inhalt geschrieben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.Xml.XmlWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstrom, der die Daten geschrieben werden.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.Stream" /> im XML-Format. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstrom, der die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> in der angegebenen Datei unter Verwendung des angegebenen <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.TextWriter" /> im XML-Format. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle seine untergeordneten, verwandten Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> verwendet, um das Dokument zu schreiben.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" /> und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Die Datei an, in die XML-Daten geschrieben werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> als XML mit der angegebenen Datei. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> Verwendung der angegebenen Datei und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Xml.XmlWriter" /> mit dem der Inhalt geschrieben.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.Xml.XmlWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit der `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Xml.XmlWriter" /> verwendet, um das Dokument zu schreiben.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" /> und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstrom, der die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> in der angegebenen Datei unter Verwendung des angegebenen <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in ein XML-Dokument während der `WriteXmlSchema` Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> verwendet, um das Dokument zu schreiben.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" /> und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> Verwendung der angegebenen Datei und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Wenn die Daten für die aktuelle Tabelle und alle Schemas gespeichert werden soll die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle abhängigen verknüpften Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Xml.XmlWriter" /> verwendet, um das Dokument zu schreiben.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie den Inhalt der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), die Daten für die aktuelle Tabelle nur schreiben.</param>
        <summary>Schreibt die aktuellen Daten und optional das Schema für die <see cref="T:System.Data.DataTable" /> unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" /> und <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für die <paramref name="mode" /> Parameter <see langword="WriteSchema" />. Legen Sie zum Speichern der Daten für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw.. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit der `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  In diesem Beispiel wird gezeigt, wie mit einer der überladenen Versionen der `WriteXmlSchema` andere Beispiele, die möglicherweise verfügbar ist, finden Sie in den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, den das XML-Schema geschrieben wird.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema in den angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> der zum Schreiben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei verwendet werden soll.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema in der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der zu verwendende <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, den das XML-Schema geschrieben wird.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie das Schema der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), das Schema für die aktuelle Tabelle nur geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema in den angegebenen Stream. Legen Sie zum Speichern des Schemas für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> der zum Schreiben.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie das Schema der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), das Schema für die aktuelle Tabelle nur geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" />. Legen Sie zum Speichern des Schemas für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei verwendet werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie das Schema der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), das Schema für die aktuelle Tabelle nur geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema in der angegebenen Datei. Legen Sie zum Speichern des Schemas für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Xml.XmlWriter" /> verwendet, um das Dokument zu schreiben.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, Schreiben Sie das Schema der aktuellen Tabelle und allen seinen untergeordneten Elementen. Wenn <see langword="false" /> (Standardwert), das Schema für die aktuelle Tabelle nur geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als ein XML-Schema unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" />. Legen Sie zum Speichern des Schemas für die Tabelle und allen seinen untergeordneten Elementen der <paramref name="writeHierarchy" /> Parameter <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
