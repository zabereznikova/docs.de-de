<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt das Bindungselement dar, das die Sende- und Empfangskanäle für eine zuverlässige Sitzung zwischen Endpunkten erzeugen kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stellt Sitzungen sowie optional sortierte Nachrichtenübermittlung bereit. Diese implementierte Sitzung kann SOAP und Transportvermittler überqueren.  
  
 Jedes Bindungselement stellt einen Verarbeitungsschritt beim Senden und Empfangen von Nachrichten dar. Zur Laufzeit erstellen Bindungselemente die Kanalfactorys und die Listener, die notwendig sind, um ausgehende und eingehende Kanalstapel zum Senden und Empfangen von Nachrichten zu erstellen. Das <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> bietet eine optionale Ebene im Stapel, die eine zuverlässige Sitzung zwischen Endpunkten herstellen und das Sitzungsverhalten konfigurieren kann.  
  
 Das <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> wird für die Standardbindungen in der folgenden Tabelle zur Verfügung gestellt.  
  
|Bindung|Standard|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|Aus|  
|<xref:System.ServiceModel.WSHttpBinding>|Aus|  
|<xref:System.ServiceModel.WSDualHttpBinding>|Aktiviert (erforderlich)|  
  
   
  
## Examples  
 Das <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> kann jeder benutzerdefinierten Bindung hinzugefügt werden. Dies wird mit den folgenden Konfigurationselementen erreicht.  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 Im folgenden Beispielcode wird die Verwendung des <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> im Code veranschaulicht.  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <see langword="true" />, wenn Nachrichten in der gesendeten Reihenfolge zugestellt werden sollen; andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />-Klasse, die angibt, ob bei der Nachrichtenübermittlung die Reihenfolge beibehalten werden soll, in der die Nachrichten gesendet werden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zeitintervall ab oder legt fest, wie lange ein Ziel wartet, bevor eine Bestätigung an die Nachrichtenquelle in zuverlässigen Kanälen gesendet wird, die von der Factory erstellt werden.</summary>
        <value>Die <see cref="T:System.TimeSpan" />, die das Zeitintervall angibt, das der Dienst abwartet, bevor eine Bestätigung an die Nachrichtenquelle gesendet wird. Der Standardwert beträgt 2 Sekunden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ziel, das die Nachrichten auf einem zuverlässigen Kanal empfängt, gruppiert die Bestätigungen für diese Nachrichten in einer einzigen Nachricht, um den Netzwerkverkehr zu reduzieren und die Informationsdichte in Nachrichten zu erhöhen. Die Gruppierungsskalierung verbessert sich, wenn der Verkehr zunimmt. Es wird nicht versucht, für jede empfangene Nachricht so bald wie möglich eine Bestätigung zu senden, sondern es wird ein Zeitintervall abgewartet, die Bestätigungen für dieses Intervall werden zusammengefasst und dann alle zusammen gesendet. Die erste empfangene Nachricht bildet eine Ausnahme. Sie wird sofort bei Empfang bestätigt. Wenn zuverlässige Sitzungen mit einzelnen HTTP-Verbindungen verwendet werden, z.&#160;B. bei <xref:System.ServiceModel.WSHttpBinding>, aber nicht <xref:System.ServiceModel.WSDualHttpBinding>, wird diese Einstellung nicht verwendet.  
  
 Der Wert, der über die <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A>-Eigenschaft eingestellt wird, ist eine Empfehlung für die Infrastruktur, kein festes Limit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist kleiner oder gleich 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der Typ des Kanals, der von der Factory erstellt wird.</typeparam>
        <param name="context">Die <see cref="T:System.ServiceModel.Channels.BindingContext" /> , enthält die erforderlichen Informationen an die Factorys zu erstellen, die Kanäle des Typs erzeugen kann <c>TChannel</c>.</param>
        <summary>Gibt eine Factory zurück, die einen Kanal eines angegebenen Typs erstellt, der eine zuverlässige Sitzung unterstützt.</summary>
        <returns>Eine <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> des Typs <see cref="T:System.ServiceModel.Channels.IChannel" />, initialisiert aus dem <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von der Factory erzeugte <xref:System.ServiceModel.Channels.IChannel> ist vom Typ `TChannel`. Die auf dem Client unterstützten `TChannel`-Typen sind unabhängig von den zugrunde liegenden Kanälen, die die Verbindung zum Dienst herstellen. In der folgenden Tabelle sind die Typen von zuverlässigen Sitzungskanälen aufgeführt, die als Funktion der zugrunde liegenden Kanäle unterstützt werden.  
  
|Unterstützung für zuverlässige Sitzung `TChannel` Typen nach zugrunde liegenden Kanaltypen|IRequestChannel|IRequestSessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|IOutputSessionChannel|Ja|Ja|Ja|Ja|  
|IRequestSessionChannel|Ja|Ja|Nein|Nein|  
|IDuplexSessionChannel|Nein|Nein|Ja|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der <see cref="T:System.ServiceModel.Channels.IChannel" />, den der Listener akzeptiert.</typeparam>
        <param name="context">Die <see cref="T:System.ServiceModel.Channels.BindingContext" /> , enthält die erforderlichen Informationen an den Listener zu erstellen, die Kanäle des Typs zu akzeptieren, können <c>TChannel</c>.</param>
        <summary>Gibt einen Listener zurück, der einen Kanal eines angegebenen Typs akzeptiert, der eine zuverlässige Sitzung unterstützt.</summary>
        <returns>Der <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> des Typs <see cref="T:System.ServiceModel.Channels.IChannel" />, initialisiert aus dem <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der vom Listener akzeptierte <xref:System.ServiceModel.Channels.IChannel> ist vom Typ `TChannel`. Die auf dem Server, der den Dienst hostet, unterstützten `TChannel`-Typen hängen von den Typen der zugrunde liegenden Kanäle ab, die für die Verbindung mit dem Client verwendet werden. In der folgenden Tabelle sind die Typen von zuverlässigen Sitzungskanälen aufgeführt, die als Funktion der zugrunde liegenden Kanäle unterstützt werden.  
  
|Unterstützung für zuverlässige Sitzung `TChannel` Typen nach zugrunde liegenden Kanaltypen|IReplyChannel|IReplySessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|IInputSessionChannel|Ja|Ja|Ja|Ja|  
|IReplySessionChannel|Ja|Ja|Nein|Nein|  
|IDuplexSessionChannel|Nein|Nein|Ja|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der Typ des Kanals, der von der Factory erstellt wird.</typeparam>
        <param name="context">Die <see cref="T:System.ServiceModel.Channels.BindingContext" /> , enthält die erforderlichen Informationen an die Factorys zu erstellen, die Kanäle des Typs erzeugen kann <c>TChannel</c>.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine Kanalfactory für den bereitgestellten Kanal und Kontext erstellt werden kann, die eine zuverlässige Sitzung unterstützt.</summary>
        <returns>
          <see langword="true" />, wenn eine <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> des Typs <paramref name="TChannel" /> erzeugt werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `true` oder `false` für einen `TChannel` zurück, entsprechend der Wertetabelle in <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Die <see cref="T:System.ServiceModel.Channels.IChannel" /> , den Kanallistener an, wenn "erstellen", akzeptiert.</typeparam>
        <param name="context">Die <see cref="T:System.ServiceModel.Channels.BindingContext" /> , enthält die erforderlichen Informationen an den Listener zu erstellen, die Kanäle des Typs zu akzeptieren, können <c>TChannel</c>.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein Kanallistener für den bereitgestellten Kanal und Kontext erstellt werden kann, der eine zuverlässige Sitzung unterstützt.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" />, der einen <see cref="T:System.ServiceModel.Channels.IChannel" /> des Typs <paramref name="TChannel" /> erzeugen kann, vom Bindungselement erstellt werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kanalstapel werden i. d. R. mit einem Factorymuster erstellt, in dem eine Bindung den Kanalstapel erstellt. Beim Senden von Nachrichten wird eine Bindung zum Erstellen einer Kanalfactory verwendet, die wiederum einen Kanalstapel erstellt und einen Verweis auf den obersten Kanal im Stapel zurückgibt. Die Anwendung kann dann diesen Kanal verwenden, um Nachrichten zu senden. Beim Empfang von Nachrichten wird eine Bindung verwendet, um einen Kanallistener zu erstellen, der eingehende Nachrichten überwacht. Der Kanallistener stellt der überwachenden Anwendung Nachrichten zur Verfügung, indem ein Kanalstapel erstellt und der Anwendungsverweis an den oberen Kanal übergeben wird.  
  
 Diese Methode gibt `true` oder `false` für einen `TChannel` zurück, entsprechend der Wertetabelle in <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie des aktuellen Bindungselements der zuverlässigen Sitzung.</summary>
        <returns>Das <see cref="T:System.ServiceModel.Channels.BindingElement" />, das ein Klon des aktuellen Bindungselements ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in einer zuverlässigen Sitzung Flusssteuerung aktiviert ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn in der zuverlässigen Sitzung Flusssteuerung aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flusssteuerung ist eine Methode, mit der zuverlässige Sitzungen sicherstellen, dass Absender nicht mehr Nachrichten senden, als ein Empfänger verarbeiten kann. Empfänger haben einen Puffer von Nachrichten, die verwendet werden, um gehäufte Nachrichten und Nachrichten außerhalb der Reihenfolge unterzubringen. Empfänger geben dem Absender in jeder Bestätigung den verbliebenen Speicherplatz in diesem Puffer an. Absender können diese Informationen verwenden, um das Senden weiterer Nachrichten zu stoppen, sobald kein Pufferspeicher mehr beim Empfänger verfügbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der abgerufenen Eigenschaft.</typeparam>
        <param name="context">Die <see cref="T:System.ServiceModel.Channels.BindingContext" /> , enthält die erforderlichen Informationen an den Kanal des Typs abrufen <c>T</c>.</param>
        <summary>Ruft eine Eigenschaft des angegebenen Typs aus dem Bindungskontext ab.</summary>
        <returns>Die Eigenschaft vom Typ <paramref name="T" /> mit dem angegebenen <paramref name="context" /> oder <see langword="null" />, wenn keine Eigenschaft des Typs <paramref name="T" /> gefunden wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Zeitintervall ab oder legt fest, wie lange ein Dienst vor Schließung inaktiv bleibt.</summary>
        <value>Die <see cref="T:System.TimeSpan" />, die das Zeitintervall angibt, während der ein Dienst vor Schließung inaktiv bleibt. Der Standardwert ist 10 Minuten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktivität auf einem Kanal wird als Empfang einer Anwendungs- oder Infrastrukturnachricht definiert. Der Timeout-Parameter bei Inaktivität steuert die maximale Menge an Zeit, um eine inaktive Sitzung am Leben zu erhalten. Bei einem Zeitintervall länger als <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> wird die Sitzung durch die Infrastruktur beendet, und im Kanal wird ein Fehler ausgelöst. Die zuverlässige Sitzung wird einseitig abgebrochen.  
  
 Wenn die sendende Anwendung keine Nachrichten zum Senden hat, zeigt die zuverlässige Sitzung normalerweise keinen Fehler wegen Inaktivität an. Stattdessen wird die Sitzung durch einen Keep-Alive-Mechanismus unbegrenzt aktiv gehalten. Der Verteiler kann unabhängig davon die zuverlässige Sitzung abbrechen, wenn keine Anwendungsnachrichten gesendet oder empfangen werden. Deshalb läuft das Timeout bei Inaktivität normalerweise ab, wenn die Netzwerkbedingungen dazu führen, dass keine Nachrichten empfangen werden oder beim Absender ein Fehler auftritt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist kleiner als oder gleich 0 oder größer als <see cref="F:System.Int32.MaxValue" /> oder <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höchstanzahl von Kanälen ab oder legt die Anzahl fest, die während der zuverlässigen Sitzung anstehen können.</summary>
        <value>Die größte Anzahl von Kanälen, die anstehen können. Der Standardwert ist 4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kanäle sind ausstehend, wenn sie darauf warten, akzeptiert zu werden. Sobald das Limit erreicht ist, werden keine Kanäle mehr erstellt und in den ausstehenden Modus versetzt, bis diese Zahl sinkt (durch das Akzeptieren ausstehender Kanäle). Dies ist eine Grenze für jeden Listener.  
  
 Wenn der Schwellenwert erreicht wird und eine Remoteanwendung versucht, eine neue zuverlässige Sitzung herzustellen, wird die Anforderung abgelehnt und der Öffnungsvorgang, der dies angefordert hat, schlägt fehl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist kleiner als oder gleich 0 oder größer als 16384.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl der Übertragungsversuche ab oder legt die Anzahl der Versuche fest, die eine Nachricht während der zuverlässigen Sitzung hat.</summary>
        <value>Die maximale Anzahl von erneuten Sendeversuchen für Nachrichten. Der Mindestwert ist 1, der Höchstwert <see cref="F:System.Int32.MaxValue" />; der Standardwert ist 8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Nachricht wird als übertragen betrachtet, wenn die Zustellung vom Empfänger bestätigt wurde.  
  
 Wenn die Bestätigung nicht innerhalb einer bestimmten Zeit eingegangen ist, überträgt die Infrastruktur die Nachricht automatisch neu. Die Infrastruktur versucht, die Nachricht maximal entsprechend dem Wert <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> erneut zu senden. Wird keine Bestätigung gesendet, bevor dieses Limit erreicht ist, wird ein schwerwiegender Kommunikationsfehler ausgegeben und das Fehlerereignis des Kanals ausgelöst.  
  
 Die Infrastruktur verwendet einen exponentiellen Backoff-Algorithmus um den Zeitpunkt für die Neuübertragung zu ermitteln. Dabei wird eine berechnete durchschnittliche Round Trip Time zugrunde gelegt. Die anfängliche Wiederholungszeit wird auf Grundlage der gemessenen Roundtrip-Zeit zum Erstellen der Sitzung berechnet. Der Neuübertragungs-Algorithmus wird bei jedem erneuten Versuch verdoppelt. Zwischen dem ersten Übertragungsversuch und dem letzten Übertragungsversuch liegen somit ca. 8,5 Minuten. Der Zeitpunkt für den ersten Neuübertragungsversuch wird gemäß der berechneten Round Trip Time angepasst, und die daraus resultierende Zeitspanne für die Übertragungsversuche variiert entsprechend. Dadurch können die Zeitpunkte für die Neuübertragung dynamisch an die unterschiedlichen Netzwerkbedingungen angepasst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist kleiner oder gleich 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höchstanzahl von Nachrichten ab oder legt die Anzahl fest, die im Sende- oder Empfangspuffer vorhanden sein kann.</summary>
        <value>Die größte Anzahl von Nachrichten, die gepuffert werden kann. Der Mindestwert ist 1, der maximale Wert 4096, und der Standardwert beträgt 32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der Eigenschaft <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> kann für Absender und Empfänger festgelegt werden. Dieser Wert wird in der die WSDL-Bindungsrichtlinie enthalten, die bei Verwendung der [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) zum Erstellen des Clients hat er denselben Wert. Andernfalls entspricht dieser Wert Ihrer Einstellung auf dem Client.  
  
 Wenn dieses Limit beim Absender erreicht wird, werden zusätzliche Sendeaufrufe blockiert. Wenn dieses Limit beim Empfänger erreicht ist, werden neue Nachrichten, die im zugrunde liegenden Kanal eintreffen, nicht akzeptiert.  
  
 Eine zuverlässige Sitzung verwendet ein Fensterprotokoll, um die Netzwerkverwendung zu verbessern. Die erforderliche Menge an Pufferung wird direkt von der Größe des Übertragungsfensters abgeleitet. Wenn Sie diesen Wert ändern, beachten Sie, dass das optimale Übertragungsfenster direkt mit der Bandbreite und der Wartezeit zusammenhängt. Die ideale maximale Fenstergröße ist die Bandbreite mal die Wartezeit. Kleinere Werte ergeben weniger als 100&#160;% Netzwerkverwendung, größere Werte sind eine Platzverschwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist kleiner als oder gleich 1 oder größer als 4096.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob bei der Nachrichtenübermittlung die Reihenfolge beibehalten werden soll, in der die Nachrichten gesendet wurden.</summary>
        <value>
          <see langword="true" />, wenn Nachrichten in der gesendeten Reihenfolge zugestellt werden sollen; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um in Reihenfolge weitergeleitete Nachrichten abzurufen, müssen Sie auch den <xref:System.ServiceModel.ConcurrencyMode> auf <xref:System.ServiceModel.ConcurrencyMode.Single> festlegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version des vom Bindungselement angegebenen WS-ReliableMessaging ab oder legt sie fest.</summary>
        <value>Eine Instanz, die von der <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> abgeleitet wurde, die die Standardversion des WS-ReliableMessaging-Protokolls darstellt, das vom Konfigurationselement verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt derzeit zwei Versionen des WS-ReliableMessaging-Protokolls, die von [!INCLUDE[indigo1](~/includes/indigo1-md.md)] unterstützt werden: WS-ReliableMessaging1.1 und WS-ReliableMessagingFebruary2005. Die Standardversion ist WS-ReliableMessagingFebruary2005.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">Das <see cref="T:System.ServiceModel.Description.MetadataExporter" />, das die Bindungsinformationen im Bindungselement der zuverlässigen Sitzung an die WSDL-Elemente exportiert.</param>
        <param name="context">Der <see cref="T:System.ServiceModel.Description.PolicyConversionContext" />, der die Zuordnungen aus exportierten WSDL-Elementen zur Endpunktbeschreibung bereitstellt.</param>
        <summary>Ordnet die im Bindungselement der zuverlässigen Sitzung enthaltenen Informationen den WSDL-Elementen zu, die einem Remoteendpunkt ermöglichen, über eine zuverlässige Sitzung auf den Dienst zuzugreifen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
