<Type Name="CompositeDuplexBindingElement" FullName="System.ServiceModel.Channels.CompositeDuplexBindingElement">
  <TypeSignature Language="C#" Value="public sealed class CompositeDuplexBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CompositeDuplexBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt das Bindungselement dar, das verwendet werden muss, wenn der Client einen Endpunkt für den Dienst zum Senden von Nachrichten zurück an den Client verfügbar machen muss.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies wird häufig mit Transporten verwendet, z.&#160;B. HTTP, die keine systemseitige Duplexkommunikation ermöglichen. Im Gegensatz dazu ermöglicht das TCP-Protokoll nicht die systemseitige Duplexkommunikation, sodass das Bindungselement vom Dienst zum Senden von Nachrichten zurück an den Client nicht benötigt wird.   
  
 Der Client muss eine Adresse zur Verfügung stellen, an der der Dienst ihn zum Herstellen einer Verbindung vom Dienst zum Client erreichen kann. Die Clientadresse wird von der <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A>-Eigenschaft bereitgestellt. Beachten Sie, dass [!INCLUDE[indigo1](~/includes/indigo1-md.md)] automatisch eine <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A> generiert, wenn der Benutzer keine explizit festlegt.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CompositeDuplexBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der <see cref="T:System.ServiceModel.Channels.IChannel" />, den die Factory erstellt.</typeparam>
        <param name="context">Der <see cref="T:System.ServiceModel.Channels.BindingContext" />, der den Kontext bereitstellt, der zum Erstellen der Kanalfactory erforderlich ist.</param>
        <summary>Gibt eine Kanalfactory zurück, die einen zusammengesetzten Duplexkanal erstellen kann.</summary>
        <returns>Eine <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" />, die einen zusammengesetzten Duplexkanal des Typs <paramref name="TChannel" /> erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Buildkontext erfordert einen <xref:System.ServiceModel.Channels.IOutputChannel> für den `TChannel`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TChannel" /> ist nicht vom Typ <see cref="T:System.ServiceModel.Channels.IOutputChannel" /> und wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der <see cref="T:System.ServiceModel.Channels.IChannel" />, der vom Listener akzeptiert wird.</typeparam>
        <param name="context">Der <see cref="T:System.ServiceModel.Channels.BindingContext" />, der den Kontext bereitstellt, der zum Erstellen des Kanallisteners erforderlich ist.</param>
        <summary>Gibt einen Kanallistener zurück, der einen zusammengesetzten Duplexkanal akzeptieren kann.</summary>
        <returns>Ein <see cref="T:System.ServiceModel.Channels.IChannelListener`1" />, der einen zusammengesetzten Duplexkanal des Typs <paramref name="TChannel" /> akzeptiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Buildkontext erfordert einen <xref:System.ServiceModel.Channels.IInputChannel> für den `TChannel`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TChannel" /> ist nicht vom Typ <see cref="T:System.ServiceModel.Channels.IInputChannel" /> und wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der <see cref="T:System.ServiceModel.Channels.IChannel" />, der von der Kanalfactory generiert wird.</typeparam>
        <param name="context">Der <see cref="T:System.ServiceModel.Channels.BindingContext" />, der den Kontext bereitstellt, der zum Erstellen des Kanallisteners erforderlich ist.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Bindung die Kanalfactory erstellen kann, die einen bestimmten Kanaltyp generiert, der die Kontextanforderungen erfüllt.</summary>
        <returns>
          <see langword="true" />Wenn die Bindung die Kanalfactory erstellen kann; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`Wenn `TChannel`  ==  <xref:System.ServiceModel.Channels.IOutputChannel> und die innere Bindung ebenfalls erstellen <xref:System.ServiceModel.Channels.IOutputChannel>ist, andernfalls `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der <see cref="T:System.ServiceModel.Channels.IChannel" />, der vom Listener akzeptiert wird.</typeparam>
        <param name="context">Der <see cref="T:System.ServiceModel.Channels.BindingContext" />, der den Kontext bereitstellt, der zum Erstellen des Kanallisteners erforderlich ist.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Bindung den Kanallistener erstellen kann, der einen bestimmten Kanaltyp akzeptiert, der die Kontextanforderungen erfüllt.</summary>
        <returns>
          <see langword="true" />, wenn der Kanallistener für den Build erstellt werden kann, der zur Annahme des angegebenen Kanaltyps erforderlich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`Wenn `TChannel`  ==  <xref:System.ServiceModel.Channels.IInputChannel> und die innere Bindung ebenfalls erstellen <xref:System.ServiceModel.Channels.IInputChannel>ist, andernfalls `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientBaseAddress">
      <MemberSignature Language="C#" Value="public Uri ClientBaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ClientBaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basisadresse für den Client ab, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Uri" />, der die Basisadresse für den Client enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt eine Adresse bereit, unter der der Dienst den Client kontaktieren kann. Ein `null`-Wert bewirkt, dass das System automatisch eine Clientbasisadresse generiert.  
  
 Dies ist eine Basisadresse, keine absolute Adresse. Eine GUID wird an die Basisadresse angefügt, wenn Clientendpunkte von dieser Bindung generiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen tiefen Klon des aktuellen Bindungselements zurück.</summary>
        <returns>Das <see cref="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" />, das ein tiefes Klon des aktuellen Bindungselements darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Zurückgeben eines Klons kann zur Laufzeit der Fall unterstützt werden, in dem mehrere benutzerdefinierte Bindungen ein benutzerdefiniertes Bindungselement gemeinsam nutzen. Wenn ein Klon nicht zurückgegeben wird, ist das Laufzeitverhalten nicht definiert.  
  
 Mit einem tiefen Klon eines Objekts wird neben der Kopie des Objekts eine Kopie aller Elemente erstellt, auf die das betreffende Objekt direkt oder indirekt verweist. (Dieser Vorgang wird auch als Kopieren des gesamten Objektdiagramms bezeichnet.) Ein flacher Klon eines Objekts stellt im Gegensatz dazu nur eine Kopie des Objekts dar. Wenn das Objekt Verweise auf andere Objekte enthält, werden von der flachen Kopie keine Kopien der Objekte erstellt, auf die verwiesen wird. Stattdessen werden nur die Verweise auf die ursprünglichen Objekte kopiert. Vor allem eine tiefe Kopie von <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement> kopiert über den <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A>-Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Das typisierte Objekt, dessen Unterstützung getestet wird.</typeparam>
        <param name="context">Der <see cref="T:System.ServiceModel.Channels.BindingContext" />, der den Kontext bereitstellt, der zum Erstellen des Kanals erforderlich ist.</param>
        <summary>Gibt ein angefordertes typisiertes Objekt aus der entsprechenden Ebene in einem der Kanalstapel zurück.</summary>
        <returns>Das von <paramref name="T" /> angeforderte typisierte Objekt, oder <see langword="null" />, falls das Objekt nicht unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Anforderung können Sie typisierte Objekte, wie beispielsweise eine Schnittstelle, für das Festlegen von Eigenschaften oder für das Abrufen des Status aus der entsprechenden Ebene in der gestapelten Bindung abfragen. Wenn eine Ebene das Zurückgeben des angeforderten Objekts unterstützt, wird der Vorgang ausgeführt. Andernfalls wird der Aufruf an die nächst tiefere Ebene im Stapel delegiert. Wenn die letzte Ebene erreicht ist und der Abruf des angeforderten Objekts von keiner Ebene unterstützt wird, gibt der Anrufer einen `null`-Wert zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">Der <see cref="T:System.ServiceModel.Description.MetadataExporter" />, den Sie zum Ändern des Exportvorgangs verwenden können.</param>
        <param name="context">Der <see cref="T:System.ServiceModel.Description.PolicyConversionContext" />, den Sie zum Einfügen einer benutzerdefinierten Richtlinienassertion verwenden können.</param>
        <summary>Exportiert benutzerdefinierte Richtlinienassertionen über Bindungen, die das Vorhandensein von Composite Duplex in der Bindung darstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[crdefault](~/includes/crdefault-md.md)]<xref:System.ServiceModel.Description.IPolicyExportExtension>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
