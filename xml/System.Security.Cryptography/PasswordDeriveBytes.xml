<Type Name="PasswordDeriveBytes" FullName="System.Security.Cryptography.PasswordDeriveBytes">
  <TypeSignature Language="C#" Value="public class PasswordDeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PasswordDeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.PasswordDeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Leitet mithilfe einer Erweiterung des PBKDF1-Algorithmus einen Schlüssel von einem Kennwort ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse verwendet eine Erweiterung des PBKDF1-Algorithmus in die PKCS #5 2.0-standard definierten geeignet für die Verwendung als Schlüsselmaterial Bytes aus einem Kennwort abgeleitet werden. Der Standard ist in der IETF RRC 2898 dokumentiert.  
  
> [!IMPORTANT]
>  Nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter abgerufen werden können, aus einer Assembly der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tools, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort und den Salt-Wert des Schlüssels an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort und dem Salt-Wert, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter abgerufen werden können, aus einer Assembly der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tools, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für den Vorgang.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels und den CSP (Cryptographic Service Provider) an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) l, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels und den CSP-Parametern (Cryptographic Service Provider), die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter abgerufen werden können, aus einer Assembly der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tools, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="hashName">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels, den Hashnamen und die Anzahl der Iterationen an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Eine Liste von Hash-Algorithmus verwendet werden soll, finden Sie unter der <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="strHashName">Der Name des Hashalgorithmus für die Operation.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels, dem Hashnamen und der Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter abgerufen werden können, aus einer Assembly der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tools, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie notepad.exe.  
  
 Eine Liste von Hash-Algorithmus verwendet werden soll, finden Sie unter der <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="hashName">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für den Vorgang.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels, den Hashnamen, die Iterationen und die CSP-Parameter an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Eine Liste von Hash-Algorithmus verwendet werden soll, finden Sie unter der <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="strHashName">Der Name des Hashalgorithmus für die Operation.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <param name="cspParams">Die CSP-Parameter für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels, dem Hashnamen, der Anzahl der Iterationen und den CSP-Parametern (Cryptographic Service Provider), die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter abgerufen werden können, aus einer Assembly der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tools, einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie notepad.exe.  
  
 Eine Liste von Hash-Algorithmus verwendet werden soll, finden Sie unter der <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">Der Name des Algorithmus, für den der Schlüssel abgeleitet werden soll.</param>
        <param name="alghashname">Der Name des Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="keySize">Die Größe des abzuleitenden Schlüssels in Bits.</param>
        <param name="rgbIV">Der zum Ableiten des Schlüssels zu verwendende Initialisierungsvektor.</param>
        <summary>Leitet einen kryptografischen Schlüssel vom <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Objekt ab.</summary>
        <returns>Der abgeleitete Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion ist ein Wrapper für die CryptoAPI-Funktion CryptDeriveKey() und dient der Interoperabilität mit Anwendungen, die mithilfe der Crypto-API zu bieten.  
  
 Wenn die `keySize` Parameter auf 0 Bit festgelegt ist, wird die Standard-Schlüsselgröße für den angegebenen Algorithmus verwendet.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#2)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#2)]
 [!code-vb[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Die <paramref name="keySize" /> Parameter ist falsch.  
  
 - oder -   
  
 Der Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) kann nicht abgerufen werden.  
  
 - oder -   
  
 Die <paramref name="algname" /> -Parameter ist kein gültiger Algorithmusname.  
  
 - oder -   
  
 Die <paramref name="alghashname" /> Parameter ist nicht der Name ein gültiger Hashalgorithmus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die `Finalize` Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. `Finalize`Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Cryptography.PasswordDeriveBytes> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" />müssen Sie darauf achten, nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.GetBytes(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</param>
        <summary>Gibt pseudozufällige Schlüsselbytes zurück.</summary>
        <returns>Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann eine beliebige Anzahl von Bytes pseudozufälligen Schlüsselbytes erstellen. Allerdings ist die Stärke der Bytesequenz durch die Anzahl der Bytes in der Hashausgabe beschränkt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashName">
      <MemberSignature Language="C#" Value="public string HashName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HashName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.HashName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Hashalgorithmus für die Operation ab oder legt diesen fest.</summary>
        <value>Der Name des Hashalgorithmus für die Operation.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Name des Hashwerts ist unveränderlich, und es wird versucht, diesen Wert zu ändern.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Iterationen für die Operation ab oder legt diese fest.</summary>
        <value>Die Anzahl der Iterationen für die Operation.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Die Anzahl der Iterationen wird festgelegt, und es wird versucht, diesen Wert zu ändern.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Eigenschaft kann nicht festgelegt werden, weil ihr Wert außerhalb des gültigen Bereichs ist. Diese Eigenschaft erfordert eine nicht Negative Zahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Zustand der Operation zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Salt-Wert des Schlüssels für die Operation ab oder legt diesen fest.</summary>
        <value>Der Wert der Schlüsselsalt für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Wörterbuchangriff ist ein Angriff, in dem der Angreifer versucht, eine verschlüsselte Nachricht durch Vergleichen des verschlüsselten Werts mit der zuvor berechnete verschlüsselte Werte für den wahrscheinlichsten Schlüssel entschlüsselt. Dieser Angriff erfolgt durch die Einführung von zufälligen Bytes am Ende des Kennworts vor dem schlüsselableitung viel schwieriger. Diese zufälligen Bytes werden als Salt bezeichnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Wert der Schlüsselsalt ist unveränderlich, und es wird versucht, diesen Wert zu ändern.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
