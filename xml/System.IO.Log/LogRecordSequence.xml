<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine in einem <see cref="T:System.IO.Log.LogStore" /> gespeicherte Datensatzsequenz dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Log.LogRecordSequence>-Klasse stellt eine Implementierung der Datensatzsequenzschnittstelle auf einem CLFS-Protokoll (gemeinsames Protokolldateisystem) bereit. Zusätzlich zu den datensatzorientierten Standardfunktionen wird ein Richtlinienmodell zur Vermeidung von vollen Protokollen und von Multiplexing von Clients auf derselben physischen Datei bereitgestellt. Die Funktionsweise erfolgt in Kombination mit der <xref:System.IO.Log.LogStore>-Klasse, die eine Schnittstelle für die direkte Bearbeitung und Verwaltung einer CLFS-Protokolldatei bereitstellt. Die Beziehung zwischen der <xref:System.IO.Log.LogStore>-Klasse und der <xref:System.IO.Log.LogRecordSequence>-Klasse ähnelt der Beziehung zwischen einer Datenträgerdatei und einem <xref:System.IO.FileStream>-Objekt. Die Datenträgerdatei stellt den tatsächlichen Speicherplatz bereit und weist Attribute wie die Länge und den letzten Zugriff auf, während das <xref:System.IO.FileStream>-Objekt eine Ansicht der Datei bereitstellt, über die Lese- und Schreibvorgänge für die Datei ausgeführt werden können. Die <xref:System.IO.Log.LogStore>-Klasse weist Attribute wie eine Richtlinie und eine Auflistung von Datenträgerwertebereichen auf, und die <xref:System.IO.Log.LogRecordSequence>-Klasse bietet einen datensatzorientierten Mechanismus zum Lesen und Schreiben von Daten.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence>-Klasse veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">Der <see cref="T:System.IO.Log.LogStore" />, den diese Datensatzsequenz verwenden sollte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit dem angegebenen Protokollspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann. In diesem Konstruktor ist ein Standardwert von 64 festgelegt. Die gewünschte Anzahl der Puffer wird auf 10 gesetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logStore" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad und Modus öffnet. Dem Objekt wird Lese-/Schreibzugriff auf den Speicher erteilt, und der Speicher wird geöffnet und der Lesezugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
 - oder -   
  
 <paramref name="path" /> enthält nur Leerraum.  
  
 - oder -   
  
 <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist. Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">Der <see cref="T:System.IO.Log.LogStore" />, den diese Datensatzsequenz verwenden sollte.</param>
        <param name="bufferSize">Die gewünschte Puffergröße in Bytes. Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</param>
        <param name="bufferCount">Die gewünschte Anzahl an Puffern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit dem angegebenen Protokollspeicher, der angegebenen Puffergröße für jeden Datensatz und der Pufferanzahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn Sie Werte für `bufferSize` und `bufferCount` angeben möchten und nicht den Standardwert 64 für `bufferSize` und 10 für `bufferCount` verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="logStore" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="bufferCount" /> ist negativ oder 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</param>
        <param name="access">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffs- und Freigabemodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der Lesezugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
 - oder -   
  
 <paramref name="path" /> enthält nur Leerraum.  
  
 - oder -   
  
 <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist. Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</param>
        <param name="access">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</param>
        <param name="share">Einer der <see cref="T:System.IO.FileShare" />-Werte, der bestimmt, wie der Protokollspeicher für Prozesse freigegeben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Verwendung dieses <xref:System.IO.Log.LogRecordSequence>-Konstruktors:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
 - oder -   
  
 <paramref name="path" /> enthält nur Leerraum.  
  
 - oder -   
  
 <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist. Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</param>
        <param name="access">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</param>
        <param name="share">Einer der <see cref="T:System.IO.FileShare" />-Werte, der bestimmt, wie der Protokollspeicher für Prozesse freigegeben wird.</param>
        <param name="bufferSize">Die gewünschte Puffergröße in Bytes. Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</param>
        <param name="bufferCount">Die gewünschte Anzahl an Puffern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit den Angaben für den Pfad zum Protokollspeicher, die Dateiberechtigung, den Zugriffs- und Freigabemodus sowie die Puffergröße und -anzahl für Datensätze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
 - oder -   
  
 <paramref name="path" /> enthält nur Leerraum.  
  
 - oder -   
  
 <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist. Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</param>
        <param name="mode">Ein gültiger <see cref="T:System.IO.FileMode" />-Wert, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</param>
        <param name="access">Ein gültiger <see cref="T:System.IO.FileAccess" />-Wert, der festlegt, wie auf den Protokollspeicher zugegriffen werden kann.</param>
        <param name="share">Ein gültiger <see cref="T:System.IO.FileShare" />-Wert, der bestimmt, wie der Protokollspeicher unter Prozessen freigegeben wird.</param>
        <param name="bufferSize">Die gewünschte Puffergröße in Bytes. Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</param>
        <param name="bufferCount">Die gewünschte Anzahl an Puffern.</param>
        <param name="fileSecurity">Ein gültiger <see cref="T:System.Security.AccessControl.FileSecurity" />-Wert, der die Sicherheit für den neu erstellten Speicher festlegt, sofern der Speicher erstellt werden muss.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die durch <paramref name="path" /> angegebene Datei ist nicht gültig.  
  
 - oder -   
  
 Der angegebene Dateiname des Protokollspeichers ist ungültig.  
  
 - oder -   
  
 <paramref name="mode" /> hat den Wert <see cref="F:System.IO.FileMode.CreateNew" /> und kann nicht ohne Schreibzugriff verwendet werden.  
  
 - oder -   
  
 <paramref name="mode" /> hat den Wert <see cref="F:System.IO.FileMode.OpenOrCreate" /> und kann nicht ohne Schreibzugriff verwendet werden.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens ein Argument liegt außerhalb des Bereichs.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="path" /> angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Auf die von <paramref name="path" /> angegebene Datei kann nicht zugegriffen werden, da sie von einem anderen Prozess verwendet wird.  
  
 - oder -   
  
 Die von <paramref name="path" /> angegebene Datei kann nicht erstellt werden, da die Datei oder das Verzeichnis bereits vorhanden ist.  
  
 - oder -   
  
 Das Protokollhandle konnte nicht an den Threadpool gebunden werden.  
  
 - oder -   
  
 Das angegebene Protokolldateiformat oder die Version ist ungültig.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist. Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Gibt die neue Basis-<see cref="T:System.IO.Log.SequenceNumber" /> für das Protokoll an. Diese muss im Bereich zwischen der aktuellen Basissequenznummer und der letzten Sequenznummer des Protokolls liegen.</param>
        <summary>Rückt die Basissequenznummer des Protokolls vor. Diese Methode kann nicht vererbt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird oft mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis verwendet, um Speicherplatz in einem Datensatz freizugeben. Das <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis gibt an, dass das Ende der Sequenz (die Basissequenznummer) nach vorne verschoben werden muss, um Speicherplatz freizugeben. Speicherplatz kann freigegeben werden, indem Neustartbereiche mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode geschrieben werden oder indem das Protokoll abgeschnitten wird und die Basissequenznummer eines Protokolls mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode in die durch den `newBaseSequenceNumber`-Parameter angegebene Nummer geändert wird. Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.  
  
 Beachten Sie, dass das Aufrufen dieser Methode dem Festlegen einer neuen Basissequenznummer mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode entspricht. Die einzige Ausnahme besteht darin, dass kein Neustartdatensatz in das Protokoll geschrieben wird.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis, um Speicherplatz in einer Protokollsequenz freizugeben.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> ist für diese Sequenz nicht gültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.  
  
 - oder -   
  
 <paramref name="newBaseSequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene Protokoll verfügt nicht über Wertebereiche. Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Protokolldatensatz in die <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung des <xref:System.IO.Log.LogRecordSequence.Append%2A>-Members.  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <summary>Schreibt einen Protokolldatensatz in die <see cref="T:System.IO.Log.LogRecordSequence" />. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie diese Methode verwendet werden kann, um einer Sequenz einen Protokolldatensatz anzufügen.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <summary>Fügt einen Protokolldatensatz an die <see cref="T:System.IO.Log.IRecordSequence" /> an. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservations">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</param>
        <summary>Fügt der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservations">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</param>
        <summary>Fügt der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sequenznummer des ersten gültigen Datensatzes in der <see cref="T:System.IO.Log.LogRecordSequence" /> ab.</summary>
        <value>Die niedrigste Sequenznummer, die einem gültigen Datensatz in der <see cref="T:System.IO.Log.LogRecordSequence" /> entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Der Wert dieser Eigenschaft kann durch Aufrufen der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode oder der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode geändert werden.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>-Members in einer Schleife veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservations">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservations">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss. Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Löschvorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Löschanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Löschvorgang und verwendet Speicherplatz, der zuvor in der Sequenz reserviert wurde. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Löschvorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der aktuellen Methode ausgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode weiterleiten, um sicherzustellen, dass der Löschvorgang abgeschlossen wird und die Ressourcen korrekt freigegeben werden. Wenn während eines asynchronen Löschvorgangs ein Fehler auftritt, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Bei einer asynchronen Löschanforderung auftretende Fehler, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene Protokoll verfügt nicht über Wertebereiche. Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservationCollection">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</param>
        <param name="reservations">Die vorzunehmenden Reservierungen in Byte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Reservierungs- und Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservationCollection">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</param>
        <param name="reservations">Die vorzunehmenden Reservierungen in Byte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Reservierungs- und Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Bytearraysegmente, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <param name="reservation">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Neustartbereich-Schreibvorgang, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservation" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.  
  
 - oder -   
  
 <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <param name="reservationCollection">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</param>
        <param name="callback">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Neustartbereich-Schreibvorgang, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservationCollection" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.  
  
 - oder -   
  
 <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.IO.Log.ReservationCollection" />. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Der neu erstellte <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Reservierungen können auf zwei Arten vorgenommen werden, wie in den nachstehenden Beispielen beschrieben. Sie können die Vorgehensweise aus den Beispielen für stabile Verarbeitung übernehmen. Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der Komponente verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel zeigt, wie <xref:System.IO.Log.LogRecordSequence.Dispose%2A> um Ressourcen freizugeben:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Löschvorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des letzten geschriebenen Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Löschanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Reservierungs- und Anfügevorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Neustartbereichsschreibvorgang. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass alle angefügten Datensätze geschrieben wurden. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des letzten geschriebenen Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Beim Löschen der Daten ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird nicht unterstützt.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene Protokoll verfügt nicht über Wertebereiche. Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss. Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</param>
        <summary>Gewährleistet, dass alle angehängten Datensätze bis zum Datensatz mit der angegebenen Sequenznummer dauerhaft geschrieben wurden. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des letzten geschriebenen Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen diese Methode wird sichergestellt, dass alle Datensätze mit Sequenznummern bis zu der angegebenen Sequenznummer dauerhaft geschrieben wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene Protokoll verfügt nicht über Wertebereiche. Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</summary>
        <value>Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält eine Sequenznummer, die in jedem Fall größer ist als die Sequenznummer des letzten angefügten Datensatzes. Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Alle anderen Sequenznummern sind ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.IO.Log.LogStore" /> ab, der die Daten für diese Datensatzsequenz enthält. Diese Methode kann nicht vererbt werden.</summary>
        <value>Der <see cref="T:System.IO.Log.LogStore" />, der die Daten für diese Datensatzsequenz enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.LogStore%2A>-Members zum Hinzufügen von Wertebereichen veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe eines Datensatzes ab, der dieser Datensatzsequenz hinzugefügt werden kann.</summary>
        <value>Die maximale Größe eines Datensatzes, der dieser Datensatzsequenz hinzugefügt werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Die Sequenznummer des ersten Datensatzes, bei dem mit dem Lesen begonnen wird.</param>
        <param name="logRecordEnum">Ein gültiger <see cref="T:System.IO.Log.LogRecordEnumeratorType" />-Wert, der die Art (vorwärts oder rückwärts) angibt, in der Datensätze aus einer <see cref="T:System.IO.Log.LogRecordSequence" /> gelesen werden sollten.</param>
        <summary>Gibt eine zählbare Auflistung von Datensätzen in der Sequenz zurück. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Eine zählbare Auflistung von Datensätzen in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine aufzählbare Auflistung von Datensätzen in der Sequenz zurück. Die Reihenfolge der aufgelisteten Datensätze hängt vom Wert des `logRecordEnum`-Parameters ab.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung von <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in einer Schleife veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="logRecordEnum" /> ist ungültig.  
  
 - oder -   
  
 Das angegebene Element wurde nicht in der Auflistung gefunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.  
  
 – oder –  
  
 Die zum Schreiben des Protokolldatensatzes verwendete Puffergröße ist größer als die zum Lesen verwendete Puffergröße.  
  
 - oder -   
  
 Die Datensatzsequenz ist beschädigt.  
  
 - oder -   
  
 Das angegebene Protokolldateiformat oder die Version ist ungültig.  
  
 - oder -   
  
 Der Datensatz wurde mit einer inkompatiblen Version der Datensatzsequenz geschrieben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist ungültig, da die Enumeration nicht gestartet wurde. Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zählbare Auflistung der Neustartbereiche in der Sequenz zurück. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Eine zählbare Auflistung der Neustartbereiche in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Neustartbereiche sind in umgekehrter Reihenfolge der Sequenznummern aufgelistet, von der höchsten bis zur niedrigsten Sequenznummer. Nur Neustartbereiche mit Sequenznummern zwischen der letzten Sequenznummer und der Basissequenznummer sind aufgelistet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.  
  
 – oder –  
  
 Die zum Schreiben des Protokolldatensatzes verwendete Puffergröße ist größer als die zum Lesen verwendete Puffergröße.  
  
 - oder -   
  
 Die Datensatzsequenz ist beschädigt.  
  
 - oder -   
  
 Das angegebene Protokolldateiformat oder die Version ist ungültig.  
  
 - oder -   
  
 Der Datensatz wurde mit einer inkompatiblen Version der Datensatzsequenz geschrieben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist ungültig, da die Enumeration nicht gestartet wurde. Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.  
  
 – oder –  
  
 Die Enumeration wurde beendet.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="nextUndoRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservationCollection">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Auflistung enthält, in der Reservierungen vorgenommen werden.</param>
        <param name="reservations">Die vorzunehmenden Reservierungen in Byte.</param>
        <summary>Führt automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mit dieser Methode Reservierungen vornehmen. Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="userRecord">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</param>
        <param name="previousRecord">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</param>
        <param name="recordAppendOptions">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</param>
        <param name="reservationCollection">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</param>
        <param name="reservations">Die vorzunehmenden Reservierungen in Byte.</param>
        <summary>Führt automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des angefügten Datensatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.NotSupportedException">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl von Byte ab, die reserviert wurden.</summary>
        <value>Die Gesamtgröße aller in dieser Datensatzsequenz vorgenommenen Reservierungen.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sequenznummer des Neustartbereichs ab, die am nächsten am Protokollende liegt.</summary>
        <value>Die Sequenznummer des Neustartbereichs, die am nächsten am Protokollende liegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Mit der <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>-Methode können Sie den zuletzt geschriebenen Neustartbereich entfernen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist.</summary>
        <value>
          <see langword="true" />, wenn Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der Eigenschaft `true` lautet und ein <xref:System.IO.Log.LogRecordSequence.Append%2A>-Abruf fehlschlägt, da die Sequenz nicht genügend Speicherplatz aufweist, versucht die Datensatzsequenz, Speicherplatz freizugeben und den Anfügevorgang zu wiederholen.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Die neue letzte Sequenznummer für die <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
 Dies sollte auf einen aktuellen gültigen Datensatz verweisen, der sich zurzeit im Protokoll befindet.</param>
        <summary>Legt den letzten Datensatz in der <see cref="T:System.IO.Log.LogRecordSequence" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die angegebene Sequenznummer muss größer sein als die Basissequenznummer.  
  
 Wenn diese Methode abgeschlossen ist, ist der Zugriff auf Datensätze, die zuvor mit Sequenznummern angehängt wurden, die größer sind als die angegebene Sequenznummer, nicht mehr möglich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.  
  
 - oder -   
  
 <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Das Ende des Protokolls wurde erreicht.  
  
 - oder -   
  
 Das angegebene Protokolldateiformat oder die Version ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signalisiert das Erfordernis, das Ende der Sequenz zu verschieben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis auslösen, wenn der Datensatzsequenz Speicherplatz ausgegangen ist. Wenn dieses Ereignis ausgelöst wird, wird das Ende der Sequenz (die Basissequenznummer) nach vorn verschoben, um Speicherplatz freizugeben.  
  
 Das Ereignis kann jederzeit ausgelöst werden, wenn die Datensatzsequenz aus einem beliebigen Grund Speicherplatz freigeben muss. So kann das CLFS-Richtlinienmodul beispielsweise entscheiden, das Ereignis auszulösen, wenn es feststellt, dass die Enden von zwei Anmeldeclients, die sich eine Protokolldatei teilen, zu weit auseinander liegen. Die Freigabe von Speicherplatz kann durch Schreiben von Neustartbereichen oder durch Abschneiden des Protokolls und Freigeben von Speicherplatz mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode erfolgen. Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.  
  
 Sie können auch die <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>-Methode außerhalb des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses aufrufen, um Speicherplatz freizugeben. Ein Neustartbereich ist mit einem Prüfpunkt anderer Protokollverarbeitungssysteme vergleichbar. Beim Aufruf dieser Methode betrachtet die Anwendung alle vorherigen Datensätze vor dem Neustartbereich als abgeschlossen und für spätere Datensatzanhängevorgänge verfügbar. Ähnlich wie andere Datensätze erfordert der mit dieser Methode geschriebene Datensatz tatsächlich freien Speicherplatz im Protokoll, um funktionieren zu können.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses veranschaulicht.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Ein Arraysegment, das verkettet und als Datensatz angefügt wird.</param>
        <summary>Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <summary>Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <summary>Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <summary>Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <param name="reservations">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</param>
        <summary>Schreibt unter Verwendung einer Reservierung einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens eines der Argumente ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</param>
        <param name="newBaseSeqNum">Die neue Basissequenznummer. Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</param>
        <param name="reservationCollection">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</param>
        <summary>Schreibt unter Verwendung einer Reservierung einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer. Diese Methode kann nicht vererbt werden.</summary>
        <returns>Die Sequenznummer des geschriebenen Neustartbereichs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.  
  
 - oder -   
  
 Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.  
  
 - oder -   
  
 <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.  
  
 - oder -   
  
 <paramref name="reservationCollection" /> wurde nicht von dieser Datensatzsequenz erstellt.</exception>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.  
  
 - oder -   
  
 <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.  
  
 - oder -   
  
 Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</exception>
        <exception cref="T:System.OutOfMemoryException">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Die Datensatzsequenz ist voll.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
