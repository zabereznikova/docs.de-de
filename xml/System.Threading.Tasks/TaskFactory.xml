<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet Unterstützung für das Erstellen und Planen von <see cref="T:System.Threading.Tasks.Task" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework stellt zwei Factorys zum Erstellen und Planen von Aufgaben bereit:  
  
-   Die <xref:System.Threading.Tasks.TaskFactory> -Klasse, die erstellt <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> Objekte. Sie können die Überladungen dieser Methode zum Erstellen und Ausführen eines Tasks, das nicht standardmäßigen Argumente erfordert aufrufen.  
  
    > [!WARNING]
    >  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)]die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen einer Aufgabe mit Konfigurationswerte, und starten Sie ihn sofort.  
  
-   Die <xref:System.Threading.Tasks.TaskFactory%601> -Klasse, die erstellt <xref:System.Threading.Tasks.Task%601> Objekte.  
  
 Die <xref:System.Threading.Tasks.TaskFactory> -Klasse können Sie die folgenden Schritte ausführen:  
  
-   Eine Aufgabe erstellt, und starten Sie ihn sofort durch Aufrufen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode.  
  
    > [!WARNING]
    >  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)]die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen einer Aufgabe mit Konfigurationswerte, und starten Sie ihn sofort.  
  
-   Erstellen Sie eine Aufgabe, die beginnt, wenn eine der Aufgaben in einem Array, durch Aufrufen abgeschlossen wurde der <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> Methode.  
  
-   Erstellen Sie eine Aufgabe, die beginnt, wenn alle Aufgaben in einem Array, durch Aufrufen abgeschlossen wurden der <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode.  
  
 Die statische <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> Eigenschaft gibt den Standardwert <xref:System.Threading.Tasks.TaskFactory%601> Objekt. Sie können auch rufen Sie eine der der <xref:System.Threading.Tasks.TaskFactory> Klassenkonstruktoren so konfigurieren Sie die <xref:System.Threading.Tasks.Task> Objekte, die <xref:System.Threading.Tasks.TaskFactory> Klasse erstellt. Das folgende Beispiel konfiguriert eine neue <xref:System.Threading.Tasks.TaskFactory> Objekt, das Aufgaben zu erstellen, die einem angegebenen Abbruchtoken, Aufgabenerstellungsoptionen Fortsetzungsoptionen und eines benutzerdefinierten Taskplaners verfügen.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 In den meisten Fällen, Sie müssen keine zum Instanziieren einer neuen <xref:System.Threading.Tasks.TaskFactory> Instanz. Stattdessen können Sie die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Eigenschaft, die ein Factoryobjekt zurückgibt, die Standardwerte verwendet. Sie können dann Aufrufen ihrer Methoden zu den neue Aufgaben gestartet oder aufgabenfortsetzungen definieren. Eine Veranschaulichung finden Sie im Beispiel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task.Factory%2A> Eigenschaft zwei Aufrufe an die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Das erste füllt ein Objektarray mit den Namen der Dateien im Verzeichnis Eigene Dateien des Benutzers an, während die zweite ein Array mit den Namen von Unterverzeichnissen des Verzeichnisses für die Benutzer eigene füllt. Er ruft dann die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> -Methode, die Informationen über die Anzahl von Dateien und Verzeichnissen in den beiden Arrays angezeigt, nach der Ausführung der ersten beiden Aufgaben abgeschlossen ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member der <see cref="T:System.Threading.Tasks.TaskFactory" /> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der Standardkonfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die <xref:System.Threading.Tasks.TaskCreationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> -Eigenschaft wird auf den aktuellen Planer initialisiert (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die <xref:System.Threading.Tasks.TaskCreationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> -Eigenschaft wird auf den aktuellen Planer initialisiert (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass der aktuelle TaskScheduler verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None>, die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> -Eigenschaft wird mit initialisiert `scheduler`, es sei denn, sie in diesem Fall null ist, ist die -Eigenschaft wird auf den aktuellen Planer initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> -Eigenschaft wird mit initialisiert `creationOptions`, <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert `continuationOptions`, und die <xref:System.Threading.Tasks.TaskScheduler> -Eigenschaft wird auf den aktuellen Planer initialisiert (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Wert. Weitere Informationen finden Sie unter den Hinweisen für <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
 - oder -   
  
 Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das standardmäßige <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende standardmäßige <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass TaskScheduler.Current verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> -Eigenschaft wird mit initialisiert `creationOptions`, die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert `continuationOptions`, und die <xref:System.Threading.Tasks.TaskScheduler> -Eigenschaft wird mit initialisiert `scheduler`, es sei denn, sie in diesem Fall null ist, ist die -Eigenschaft wird auf den aktuellen Planer initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Wert. Weitere Informationen finden Sie unter den Hinweisen für <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
 - oder -   
  
 Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Standardabbruchtoken für diese Aufgabenfactory ab.</summary>
        <value>Das standardmäßige Aufgabenabbruchtoken für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt die standardmäßige <xref:System.Threading.CancellationToken> , die für alle Aufgaben, die von dieser Factory erstellten zugewiesen wird, es sei denn, eine andere <xref:System.Threading.CancellationToken> Wert wird beim Aufrufen der Factorymethoden explizit angegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird verwendet, alle Fortsetzungsaufgaben zu erstellen, es sei denn, andere Optionen während Aufrufen der Methoden dieser Factory explizit angegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode führt die `continuationAction` Delegat, wenn alle Aufgaben im die `tasks` Array abgeschlossen wurden, unabhängig von deren Abschlussstatus.  
  
 Von Aufgaben ausgelöste Ausnahmen der `tasks` Array sind nicht verfügbar, das der Fortsetzungsaufgabe über die strukturierte Ausnahmebehandlung. Sie können bestimmen, welche Ausnahmen ausgelöst wurden, mithilfe der <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> Eigenschaft der einzelnen Aufgaben im die `tasks` Array. Zum Verwenden der strukturierten Ausnahmebehandlung von Aufgaben ausgelöste Ausnahmen behandelt die `tasks` array, rufen Sie die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine separate Aufgaben, die die Anzahl von Wörtern in einem Satz von Textdateien mithilfe eines regulären Ausdrucks gestartet. Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode wird verwendet, um eine Aufgabe, die die gesamte Wortanzahl zeigt an, nach Abschluss aller Vorgängeraufgaben zu starten.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 Der Aufruf, das der Fortsetzungsaufgabe <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode nicht zulässt, behandeln Ausnahmen, die von den vorhergehenden Tasks ausgelöst werden, damit das Beispiel überprüft die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft für jede Vorgängeraufgabe zu bestimmen, ob der Task erfolgreich ausgeführt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [\], Aktion (Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D% 2CSystem.Threading.CancellationToken%29 > Methode führt die `continuationAction` Delegat, wenn alle Aufgaben in der `tasks` Array abgeschlossen wurden, unabhängig von deren Abschlussstatus.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Abbruchtoken, übergibt sie um Aufgaben zu trennen, die die Anzahl von Wörtern in einem Satz von Textdateien mithilfe eines regulären Ausdrucks. Das Abbruchtoken, das festgelegt ist, wenn eine Datei nicht gefunden werden kann. Die [\], Aktion (Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A >-Methode wird verwendet, um eine Aufgabe, die die gesamte Wortanzahl zeigt an, nach Abschluss aller Vorgängeraufgaben zu starten. Wenn das Abbruchtoken, das festgelegt wird, gibt an, dass eine oder mehrere Aufgaben wurden abgebrochen wurde, verarbeitet die <xref:System.AggregateException> Ausnahme und eine Fehlermeldung angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn alle Aufgaben in der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet sind.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn alle Aufgaben der <c>Aufgaben</c> Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array ist leer oder enthält einen null-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Ein Element in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie `ContinueWhenAny` und `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
 - oder -   
  
 <paramref name="cancellationToken" />wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
 - oder -   
  
 Die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen TaskContinuationOptions-Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen TaskContinuationOptions-Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt wird, wenn eine Aufgabe in der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationAction" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen TaskContinuationOptions-Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.  
  
 - oder -   
  
 Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme ausgelöst, wenn ist eines der Elemente in der <paramref name="tasks" /> Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen TaskContinuationOptions-Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und die zugehörigen des erstellten <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt wird, wenn eine Aufgabe der <c>Aufgaben</c> Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Member NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für die einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Parameterarray ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="continuationFunction" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentException">Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array enthält einen null-Wert.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="tasks" /> Array ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird verwendet, um alle Aufgaben erstellen, es sei denn, andere Optionen während Aufrufen der Methoden dieser Factory explizit angegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird.  Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`. Die <xref:System.Threading.Tasks.TaskCreationOptions> Werte <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> und <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> sind alle gegenseitig. In den FromAsync-Methoden entweder `LongRunning` oder `AttachedToParent` selbst führt dazu, dass ein <xref:System.ArgumentOutOfRangeException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das "IAsyncResult", dessen Abschluss die Verarbeitung auslösen sollte, die <c>EndMethod</c>.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene verarbeitet <c>AsyncResult</c>.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` Parameter sind nicht so effizient wie die Überladungen, eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die Bereitstellen der `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="asyncResult" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg3">Das dritte Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg3">Das dritte Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg3">Das dritte Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments übergeben wird, um die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg2">Das zweite Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="arg3">Das dritte Argument zu übergeben, um die <c>BeginMethod</c> delegieren.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>BeginMethod</c> delegieren.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegaten auf dem Thread gestartet wird, <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst keine Ausnahmen auslöst der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="beginMethod" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="endMethod" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den standardmäßigen Aufgabenplaner für diese Aufgabenfactory ab.</summary>
        <value>Der standardmäßige Aufgabenplaner für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird so planen Sie alle Aufgaben verwendet, es sei denn, ein anderes Zeitplanungsmodul während Aufrufen der Methoden dieser Factory explizit angegeben wird.  
  
 Wenn der Wert dieser Eigenschaft `null`, den Wert von der <xref:System.Threading.Tasks.TaskScheduler.Current%2A> Eigenschaft wird verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)]die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode ist die empfohlene Vorgehensweise für eine rechnergebundene Aufgabe zu starten. Verwenden der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode, nur, wenn Sie eine präzisere Kontrolle für eine lang andauernde, rechnergebundene Aufgabe benötigen. Dies umfasst Szenarien, in denen Sie die folgenden steuern möchten:  
  
-   Aufgabenerstellungsoptionen. Aufgaben erstellt, indem die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode standardmäßig erstellt werden, mit der <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> Option. Um dieses Verhalten zu überschreiben, oder um andere bereitzustellen <xref:System.Threading.Tasks.TaskCreationOptions> Optionen rufen eine <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> überladen.  
  
-   Übergeben von Parametern. Die Überladungen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode können Sie einen Parameter an dem Aufgabendelegaten übergeben. Der Überladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode ausführen.  
  
-   Der Aufgabenplaner. Die Überladungen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode verwenden, den standardmäßigen Aufgabenplaner. Rufen Sie zum Steuern des Taskplaners eine <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> -Überladung mit einem `scheduler` Parameter. Weitere Informationen finden Sie unter .  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <summary>Erstellt und startet eine Aufgabe.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und anschließend durch Aufrufen der <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode zur Planung der Aufgabe für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> mit Standardparametern. Beachten Sie jedoch, dass es einen Unterschied im Verhalten zwischen den beiden Methoden gibt im Hinblick auf: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben gestartet, mit der <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> Option zum Anfügen an die aktuelle <xref:System.Threading.Tasks.Task> Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> verfügt. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> wiederholt aufgerufen werden soll eine <xref:System.Action> Delegat, der generiert eine zufällige Zahl interpretiert ihn als einen Unicode-Codepunkt in eine UTF16-codierte Codeeinheit konvertiert und zeigt Informationen über das resultierende Zeichen oder Zeichen.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von `StartNew` ist funktionell gleichwertig mit der Erstellung eines Tasks mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> mit Standardparametern. Beachten Sie jedoch, dass es einen Unterschied im Verhalten zwischen den beiden Methoden gibt im Hinblick auf: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben gestartet, mit der <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> Option zum Anfügen an die aktuelle <xref:System.Threading.Tasks.Task> Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> verfügt. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> Methode, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode zum Hinzufügen von Informationen über jede Datei eine <xref:System.Collections.Generic.List%601> Objekt. Jedes getrennte geschachtelte Aufgabe, die aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> Ausnahme von behandelt wird eine `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Aktion</c> delegieren.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit erstellen eine <xref:System.Threading.Tasks.Task> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen der <xref:System.Threading.Tasks.Task.Start%2A> Methode, um ihn für die Ausführung planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6-Wörter. Jedes Wort übergeben, eine <xref:System.Action%601> -Delegat, der das Wort verschlüsselt und des ursprünglichen Worts und die verschlüsselte Version angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Beachten Sie, dass im Beispiel wird einen einzelnen Zufallszahlengenerator initialisiert, die durch eine Sperre geschützt ist. Die Notwendigkeit einer Sperre, finden Sie unter "Die System.Random Klasse und Threadsicherheit" in der <xref:System.Random> klassenthema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Aktion</c> delegieren.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6-Wörter. Jedes Wort übergeben, eine <xref:System.Action%601> -Delegat, der das Wort verschlüsselt und des ursprünglichen Worts und die verschlüsselte Version angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Beachten Sie, dass im Beispiel wird einen einzelnen Zufallszahlengenerator initialisiert, die durch eine Sperre geschützt ist. Die Notwendigkeit einer Sperre, finden Sie unter "Die System.Random Klasse und Threadsicherheit" in der <xref:System.Random> klassenthema. Behandeln Sie die Gefahr einer Beschädigung der vom Zufallszahlen-Generator wird ein Abbruchtoken übergeben Aufgabe. Zwei zufällige Zahlen gleich null sein, geht davon aus die Methode, dass der vom Zufallszahlen-Generator ist beschädigt und legt das Abbruchtoken. Vor dem Sortieren der `chars` Array mit sechs Zeichen in einem Wort Methodenaufrufe der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode auslöst ein <xref:System.OperationCanceledException> , wenn das Token abgebrochen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Aktion</c> delegieren.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Aktion</c> delegieren.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe mit einem seiner Konstruktoren und Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter [Task.Run Vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="action" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit erstellen eine <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], Sie erreichen die <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Beachten Sie jedoch, dass es einen Unterschied im Verhalten zwischen den beiden Methoden gibt im Hinblick auf: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben gestartet, mit der <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> Option zum Anfügen an die aktuelle <xref:System.Threading.Tasks.Task%601> Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> verfügt. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine einfache Addition-app, die beiden Zufallszahlen generiert und fordert den Benutzer zur Eingabe der Summe. Er gibt dann an, ob die Antwort richtig ist, oder wenn die Antwort des Benutzers nicht um eine gültige Zahl ist der Benutzer aufgefordert, eine gültige Zahl erneut eingeben. Die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> dient zum Erstellen der <xref:System.Threading.Tasks.Task%601> Objekte, die die Zufallszahlen hinzuzufügende zurückgeben.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Funktion</c> delegieren.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit erstellen eine <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> mit Standardparametern. Beachten Sie jedoch, dass es einen Unterschied im Verhalten zwischen den beiden Methoden gibt im Hinblick auf: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben gestartet, mit der <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> Option zum Anfügen an die aktuelle <xref:System.Threading.Tasks.Task%601> Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> verfügt. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
   
  
## Examples  
 Im folgende Beispiel verwendet zwei Aufgaben, um die Fibonacci-Sequenz F100 Endziffern = F100 1 + F100 2 mit Ausgangswerte F1 = 1, F2 = 1 und F1 = 0, F2 = 1. Ungefähr die Hälfte der Zeit, ein Abbruchtoken, das nach der Vorgänge ausführen festgelegt. Die Ausgabe des Beispiels zeigt das Ergebnis, wenn die beiden Aufgaben erfolgreich abgeschlossen, und wenn das Token abgebrochen wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Funktion</c> delegieren.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Funktion</c> delegieren.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt mit Daten von verwendet die <c>Funktion</c> delegieren.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe von einem seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> um für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einer <xref:System.Action> Objekt als eine schnelle Möglichkeit zum Aufruf <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag [Task.Run Vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme ausgelöst, wenn ist die <paramref name="function" /> Argument ist null.  
  
 - oder -   
  
 Die Ausnahme ausgelöst, wenn ist die <paramref name="scheduler" /> Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Die Ausnahme ausgelöst, wenn ist die <paramref name="creationOptions" /> -Argument gibt einen ungültigen TaskCreationOptions-Wert. Weitere Informationen finden Sie unter den Hinweisen<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>
