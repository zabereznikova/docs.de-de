<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen asynchronen Vorgang dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Die <xref:System.Threading.Tasks.Task> -Klasse stellt ein einzelnen Vorgang, die keinen Wert und, in der Regel zurückgibt asynchron ausgeführt wird. <xref:System.Threading.Tasks.Task>Objekte sind eine zentrale Komponente der [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) in .NET Framework 4 eingeführt. Da die Arbeit von ausgeführt eine <xref:System.Threading.Tasks.Task> Objekt in der Regel führt asynchron für einen Thread des Threadpools statt synchron für den Thread Hauptassembly der Anwendung verwenden Sie können die <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft, als auch die <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, und <xref:System.Threading.Tasks.Task.IsFaulted%2A> Eigenschaften, um den Status eines Vorgangs zu bestimmen. In den meisten Fällen wird ein Lambda-Ausdruck verwendet, die angeben, die die Aufgabe auszuführen.  
  
 Für Vorgänge, die Werte zurückgeben, verwenden Sie die <xref:System.Threading.Tasks.Task%601> Klasse.  
  
 In diesem Abschnitt  
  
 [Erstellen und Ausführen einer Aufgabe](#Creating)   
 [Trennung ihrer Erstellung und Ausführung](#Separating)   
 [Warten auf eine oder mehrere Aufgaben abgeschlossen](#WaitingForOne)   
 [Aufgaben und Kultur](#Culture)   
 [Debugger-Entwickler](#Debugger)  
  
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Erstellen und Ausführen einer Aufgabe  
 <xref:System.Threading.Tasks.Task>Instanzen können auf verschiedene Arten erstellt werden. Die am häufigsten verwendete Ansatz, nämlich verfügbar, beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], besteht im Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%2A> Methode. Die <xref:System.Threading.Tasks.Task.Run%2A> Methode bietet eine einfache Möglichkeit, eine Aufgabe, die mit Standardwerten zu starten und ohne zusätzliche Parameter. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode, um eine Aufgabe zu starten, Schleifen und zeigt dann die Anzahl der Schleifeniterationen:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Eine Alternative und die am häufigsten verwendete Methode, die eine Aufgabe zu starten, [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wird die statische <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> -Eigenschaft gibt ein <xref:System.Threading.Tasks.TaskFactory> Objekt. Der Überladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode können Sie angeben, um die Aufgabenerstellungsoptionen und einen Aufgabenplaner zu übergebenden Parameter. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode, um eine Aufgabe zu starten. Es ist funktionell gleichwertig mit der Code im vorherigen Beispiel.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Ausführlichere Beispiele finden Sie unter [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Trennung ihrer Erstellung und Ausführung  
 Die <xref:System.Threading.Tasks.Task> -Klasse stellt außerdem Konstruktoren, die den Task initialisiert, aber nicht planen sie für die Ausführung. Aus Gründen der Leistung der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode ist der bevorzugte Mechanismus zum Erstellen und Planen von Berechnungsaufgaben, aber für Szenarien, in denen Erstellung und Planung getrennt werden müssen, können Sie mithilfe der Konstruktoren und rufen dann die <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um die Aufgabe für die Ausführung zu einem späteren Zeitpunkt zu planen.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Warten auf eine oder mehrere Aufgaben abgeschlossen  
 Da Aufgaben in der Regel asynchron über einen Threadpoolthread ausgeführt werden, wird die Ausführung des Threads, die erstellt und startet den Vorgang, sobald die Aufgabe instanziiert wurde fortgesetzt. In einigen Fällen, wenn der aufrufende Thread den Thread der hauptanwendung ist die app möglicherweise beendet vor die Aufgabe tatsächlich mit der Ausführung beginnt. In anderen Fällen kann die Logik Ihrer Anwendung erfordern, dass der aufrufende Thread die Ausführung fortsetzen, nur, wenn eine oder mehrere Aufgaben die Ausführung abgeschlossen hat. Sie können die Ausführung des aufrufenden Threads synchronisieren und die asynchrone Aufgaben es gestartet wird durch Aufrufen einer `Wait` -Methode warten, für eine oder mehrere Aufgaben abgeschlossen.  
  
 Zum Abschluss einer einzelnen Aufgabe warten, rufen Sie die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode. Ein Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode blockiert den aufrufenden Thread, bis die einzelnen Klasseninstanz Ausführung abgeschlossen ist.  
  
 Im folgenden Beispiel wird die parameterlose <xref:System.Threading.Tasks.Task.Wait> Methode bedingungslos warten bis zum Abschluss einer Aufgabe. Der Task simuliert Arbeit durch Aufrufen der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, damit zwei Sekunden in den Energiesparmodus.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Sie können auch bedingt Abschluss einer Aufgabe warten. Die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> und <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> Methoden blockiert den aufrufenden Thread, bis die Aufgabe abgeschlossen ist oder ein Timeoutintervall abläuft, welcher Fall zuerst eintritt. Da im folgende Beispiel wird eine Aufgabe, die für zwei Sekunden ruht, aber definiert einen 1-Sekunden Timeoutwert, der aufrufende Thread blockiert gestartet, bis das Timeout abläuft, und vor hat der Task Ausführung abgeschlossen.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Sie können auch ein Abbruchtoken angeben, durch Aufrufen der <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> und <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> Methoden. Wenn des Tokens <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> Eigenschaft `true`, bis der Wartevorgang abgebrochen wird, wenn es sich bei "true" wird die <xref:System.Threading.Tasks.Task.Wait%2A> Methode beendet.  
  
 In einigen Fällen möchten Sie möglicherweise warten, für die erste einer Reihe von Ausführen von Aufgaben abgeschlossen, aber sorgfältig, dem diese Aufgabe ist.  Zu diesem Zweck können Sie eine der Überladungen der Aufrufen der <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode.  Das folgende Beispiel erstellt drei Aufgaben, von denen jede für ein Intervall ermitteln, indem Sie einen Zufallszahlengenerator ruht. Die <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Methode wartet, bis die erste Aufgabe abgeschlossen. Das Beispiel zeigt anschließend Informationen zum Status aller drei Aufgaben.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Sie können auch warten, für alle einer Reihe von Aufgaben abgeschlossen durch Aufrufen der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methode. Im folgenden Beispiel werden zehn Aufgaben erstellt, wartet, bis alle zehn abgeschlossen ist, und klicken Sie dann deren Status angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Beachten Sie, dass, wenn Sie eine oder mehrere Aufgaben abgeschlossen warten, in den ausgeführten Aufgaben ausgelöste Ausnahmen für den Thread weitergegeben werden, die Aufrufe der `Wait` Methode, wie im folgenden Beispiel gezeigt. Er startet 12 Tasks, von denen drei nicht regulär abgeschlossen werden und drei welche löst eine Ausnahme. Der verbleibenden sechs Aufgaben drei werden vor dem Start abgebrochen, und drei werden abgebrochen, während sie ausgeführt. Ausnahmen werden ausgelöst, der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methodenaufruf und sind durch behandelt eine `try` / `catch` Block.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Weitere Informationen zur Ausnahmebehandlung in aufgabenbasierte asynchrone Vorgänge finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Aufgaben und Kultur  
 Beginnend mit desktop-apps, die gezielt die [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die Kultur des Threads, die erstellt und ruft eine Aufgabe wird der Kontext des Threads. Unabhängig von der aktuellen Kultur des Threads, die auf dem der Task ausgeführt wird, ist die aktuelle Kultur des Tasks "", also die Kultur des aufrufenden Threads. Für apps, die gezielt Versionen von .NET Framework vor der [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die Kultur des Vorgangs wird die Kultur des Threads, die auf dem der Task ausgeführt wird. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" in der <xref:System.Globalization.CultureInfo> Thema.  
  
> [!NOTE]
>  Führen Sie Store-apps die Windows-Runtime in festlegen und Abrufen der Standardkultur.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Debugger-Entwickler  
 Für Entwickler, die benutzerdefinierte Debugger implementieren möglicherweise mehrere interne und private Member der Aufgabe nützlich (diese können von Version zu Version ändern). Die `m_taskId` Feld dient als Sicherungsspeicher für die <xref:System.Threading.Tasks.Task.Id%2A> -Eigenschaft, jedoch den Zugriff auf dieses Feld direkt von einem Debugger effizienter als das Zugreifen auf den gleichen Wert über die Eigenschaft Getter-Methode werden kann (die `s_taskIdCounter` Indikator ist verwendet die nächste verfügbare ID für eine Aufgabe abgerufen). Auf ähnliche Weise die `m_stateFlags` Feld speichert Informationen über die aktuelle Lebenszyklusphase von der Aufgabe, die Informationen, die auch über die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Die `m_action` Feld speichert einen Verweis an den Aufgabendelegaten und `m_stateObject` Feld speichert, die asynchrone Status vom Entwickler an die Aufgabe übergeben. Schließlich für den Debugger, die Stapelrahmen, Analysieren der `InternalWait` Methode dient, einen potenziellen Marker für Wenn eine Aufgabe eine "Wait"-Vorgang eintritt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt und vier Aufgaben ausführt. Führen Sie die drei Aufgaben ein <xref:System.Action%601> Delegaten mit dem Namen `action`, der akzeptiert ein Argument des Typs <xref:System.Object>. Eine vierte Aufgabe ausgeführt wird, einen Lambda-Ausdruck (ein <xref:System.Action> delegieren), Inline definiert im Aufruf der Methode zum Erstellen von Tasks. Jede Aufgabe instanziiert und auf andere Weise ausführen:  
  
-   Aufgabe `t1` durch den Aufruf eines Aufgabe Klassenkonstruktors instanziiert wird, jedoch wird durch den Aufruf gestartet seine <xref:System.Threading.Tasks.Task.Start> Methode erst nach dem Vorgang `t2` wurde gestartet.  
  
-   Aufgabe `t2` instanziiert und Schritte in einem einzelnen Methodenaufruf durch Aufrufen der <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> Methode.  
  
-   Aufgabe `t3` instanziiert und Schritte in einem einzelnen Methodenaufruf durch Aufrufen der <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode.  
  
-   Aufgabe `t4` wird synchron im Hauptthread ausgeführt, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously> Methode.  
  
 Da Aufgabe `t4` synchron, führt es für den Thread der hauptanwendung führt. Die übrigen Aufgaben führen Sie in der Regel asynchron auf eine oder mehrere Threads im Threadpool.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Mitglieder der <see cref="T:System.Threading.Tasks.Task" />, mit Ausnahme von <see cref="M:System.Threading.Tasks.Task.Dispose" />, sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit der angegebenen Aktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> angegebenen Verzeichnissen zu Konstruktor, um Aufgaben zu erstellen, die alle Dateinamen in abrufen. Alle Aufgaben schreiben die Dateinamen in einer einzelnen <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt. Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, und klicken Sie dann zeigt die Anzahl der Gesamtzahl der Dateinamen, die geschrieben werden, um die <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Das folgende Beispiel ist nahezu identisch, außer dass sie verwendet die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> -Methode instanziiert, und führen Sie den Task in einem einzigen Vorgang. Die Methode gibt die <xref:System.Threading.Tasks.Task> Objekt, das die Aufgabe darstellt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> und <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methoden. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 Weitere Informationen finden Sie unter [Aufgabenparallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> Konstruktor, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode zum Hinzufügen von Informationen über jede Datei eine <xref:System.Collections.Generic.List%601> Objekt. Jedes getrennte geschachtelte Aufgabe, die aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> Ausnahme von behandelt wird eine `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  Die <xref:System.Threading.Tasks.Task.Start%2A> Methode wird aufgerufen, um den Vorgang zu starten.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6-Wörter. Jedes Wort wird dann als Argument übergeben der <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> -Konstruktor, dessen <xref:System.Action%601> Delegaten verschlüsselt die Zeichen im Wort und zeigt anschließend die ursprüngliche Word und die verschlüsselte Version.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 Weitere Informationen finden Sie unter [Aufgabenparallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Aufgabenabbruch](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt das Aufrufen dieses Konstruktors der gängigsten Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass Objektinstanziierung von Task-Aufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> erstellten <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="creationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das beim Erstellen der <see cref="T:System.Threading.Tasks.Task" /> angegebene Zustandsobjekt ab, oder NULL, wenn kein Zustandsobjekt angegeben wurde.</summary>
        <value>Ein <see cref="T:System.Object" />, das die Zustandsdaten darstellt, die bei der Erstellung an die Aufgabe übergeben wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wandeln Sie das Objekt wieder in den ursprünglichen Typ seine Daten abruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Aufgabe ab, die bereits erfolgreich abgeschlossen wurde.</summary>
        <value>Die erfolgreich abgeschlossene Aufgabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt einen Task zurück, dessen <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Um Aufgabe zu erstellen, die einen Wert zurückgibt und bis zum Abschluss ausgeführt, rufen die <xref:System.Threading.Tasks.Task.FromResult%2A> Methode.  
  
 Wiederholte Versuche zum Abrufen der Wert dieser Eigenschaft möglicherweise nicht immer die gleiche Instanz zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> um zu versuchen, die Fortsetzung zurück in den ursprünglich erfassten Text zu marshallen, andernfalls <see langword="false" />.</param>
        <summary>Konfiguriert einen Awaiter, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</summary>
        <returns>Ein Objekt, das verwendet wird, um diese Aufgabe zu erwarten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Aufgabe, die ein Array mit 100 zufällige Datums- und Uhrzeitwerten aufgefüllt wird. Er verwendet die <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> Methode, um den ältesten und neuesten Datumswerte auswählen, nachdem das Array vollständig aufgefüllt ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Da eine Konsolenanwendung beendet werden kann, bevor die Fortsetzungsaufgabe ausgeführt wird, die <xref:System.Threading.Tasks.Task.Wait> Methode wird aufgerufen, um sicherzustellen, dass die Fortsetzung, die vor dem Ende der Beispiel Ausführung abgeschlossen ist.  
  
 Ein weiteres Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die ausgeführt werden soll, wenn die Aufgabe abgeschlossen wurde. Wenn der Delegat ausgeführt wird, werden ihm der abgeschlossene Task und das vom Aufrufer bereitgestellte Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis zum Abschluss der aktuellen Aufgabe, ob er abgeschlossen wurde aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder auf einen Abbruch zurückzuführen vorzeitig beendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> , erstellt das Token wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die entsprechend den Angaben ausführen <c>ContinuationOptions</c>. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die, sobald der Zieltask abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben der `continuationOptions` Parameter sind nicht erfüllt, das der Fortsetzungsaufgabe abgebrochen anstelle von geplant.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung <xref:System.Threading.Tasks.TaskContinuationOptions> um anzugeben, dass eine Fortsetzungsaufgabe synchron ausgeführt werden soll, wenn die Vorgängeraufgabe abgeschlossen wird. (Wenn die angegebene Aufgabe bereits vom Typ der abgeschlossenen <xref:System.Threading.Tasks.Task.ContinueWith%2A> aufgerufen wird, die synchrone Fortsetzung ausgeführt wird, auf dem aufrufenden Thread <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben der `continuationOptions` Parameter sind nicht erfüllt, das der Fortsetzungsaufgabe abgebrochen anstelle von geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.  Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die entsprechend den Angaben ausführen <c>ContinuationOptions</c>. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die, sobald der Zieltask abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird. Die Fortsetzung empfängt ein Abbruchtoken und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen anstelle von geplant.  
  
   
  
## Examples  
 Im folgenden ist ein Beispiel für die Verwendung von ContinueWith für die Arbeit im Hintergrund sowohl für den Benutzer Schnittstelle Threads ausgeführt werden.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> , erstellt das Token wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen anstelle von geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde, und gibt einen Wert zurück.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Verwenden von ContinueWith-Methode veranschaulicht:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung empfängt ein Abbruchtoken.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> , erstellt das Token wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend der im angegebenen Bedingung ausgeführt <c>ContinuationOptions</c>. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben der `continuationOptions` Parameter sind nicht erfüllt, das der Fortsetzungsaufgabe abgebrochen anstelle von geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Taskfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben der `continuationOptions` Parameter sind nicht erfüllt, das der Fortsetzungsaufgabe abgebrochen anstelle von geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.  Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht geplant werden für die Ausführung bis der aktuelle Task abgeschlossen ist, ob er aufgrund von erfolgreich ausgeführt, aufgrund eines Ausnahmefehlers zugesteht oder frühzeitig beendet aufgrund eines Abbruchs abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend den Angaben ausgeführt <c>ContinuationOptions.</c> Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück. An die Fortsetzung wird ein Abbruchtoken übergeben, und sie verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen anstelle von geplant.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Verwendung von ContinueWith-Methode mit Fortsetzungsoptionen veranschaulicht:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.CancellationTokenSource" /> , erstellt das Token wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
 - oder -   
  
 Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Taskfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken und verwendet den angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird für die Ausführung nicht geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen anstelle von geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="continuationOptions" /> -Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> ab.</summary>
        <value>Die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die ID der momentan ausgeführten <see cref="T:System.Threading.Tasks.Task" /> zurück.</summary>
        <value>Eine ganze Zahl, die der gerade ausgeführten Aufgabe vom System zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A>ist eine `static` (`Shared` in Visual Basic) Eigenschaft, die verwendet wird, um den Bezeichner der aktuell ausgeführten Aufgabe aus dem Code abzurufen, die die Aufgabe ausgeführt wird. Sie unterscheidet sich von der <xref:System.Threading.Tasks.Task.Id%2A> Eigenschaft, die den Bezeichner eines bestimmten zurückgibt <xref:System.Threading.Tasks.Task> Instanz. Wenn Sie versuchen, das Abrufen der <xref:System.Threading.Tasks.Task.CurrentId%2A> Wert von außerhalb der Code, der eine Aufgabe ausgeführt wird, die Eigenschaft zurückgibt `null`.  
  
 Beachten Sie, dass obwohl Konflikte äußerst selten sind, Task-IDs nicht garantiert eindeutig sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Die Anzahl der Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</param>
        <summary>Erstellt eine Aufgabe, die nach einer Verzögerung abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Delay%2A> Methode wird normalerweise verwendet, um die Vorgänge aller oder einen Teil einer Aufgabe für ein angegebenes Zeitintervall zu verzögern. In den meisten Fällen wird die Verzögerung eingeführt:  
  
-   AT wird der Beginn des Vorgangs, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Einige Zeit, während die Aufgabe ausgeführt wird. In diesem Fall wird der Aufruf der <xref:System.Threading.Tasks.Task.Delay%2A> Methode als eine untergeordnete Aufgabe innerhalb einer Aufgabe ausgeführt wird, wie im folgenden Beispiel gezeigt. Beachten Sie, dass seit der Aufgabe, die aufgerufen die <xref:System.Threading.Tasks.Task.Delay%2A> Methode asynchron ausgeführt wird, muss die übergeordnete Aufgabe mit abzuschließende warten die `await` Schlüsselwort.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Nach der angegebenen Verzögerung, die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die zeitverzögerung ungefähr die Auflösung der Systemuhr gleich wird die `millisecondsDelay` Arguments ist kleiner als die Auflösung der Systemuhr, also etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine einfache Verwendung von der <xref:System.Threading.Tasks.Task.Delay%2A> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="millisecondsDelay" /> Arguments ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</param>
        <summary>Erstellt eine Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach der angegebenen Verzögerung, die Aufgabe abgeschlossen ist, <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die zeitverzögerung ungefähr die Auflösung der Systemuhr gleich wird die `delay` Arguments ist kleiner als die Auflösung der Systemuhr, also etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine einfache Verwendung von der <xref:System.Threading.Tasks.Task.Delay%2A> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />ein negatives Zeitintervall außer stellt <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 - oder -   
  
 Die <paramref name="delay" /> des Arguments <see cref="P:System.TimeSpan.TotalMilliseconds" /> -Eigenschaft ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Die Anzahl der Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Das Abbruchtoken, das vor dem Abschließen der zurückgegebenen Aufgabe geprüft wird.</param>
        <summary>Erstellt eine abzubrechende Aufgabe, die nach einer Verzögerung abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Abbruchtoken, das signalisiert wird, bevor die angegebene Verzögerung ein <xref:System.Threading.Tasks.TaskCanceledException> Ausnahmeergebnisse handelt und die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  Andernfalls die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status nach Ablauf der angegebenen Verzögerung.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die zeitverzögerung ungefähr die Auflösung der Systemuhr gleich wird die `millisecondsDelay` Arguments ist kleiner als die Auflösung der Systemuhr, also etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Im folgende Beispiel startet eine Aufgabe, die ein Aufruf der <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> Methode mit einer Verzögerung von einer Sekunde. Bevor Sie die Verzögerungsintervall abläuft, wird das Token abgebrochen. Die Ausgabe des Beispiels zeigt, dass daher, ein <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird, und die Tasks' <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="millisecondsDelay" /> Arguments ist kleiner als -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Das Abbruchtoken, das vor dem Abschließen der zurückgegebenen Aufgabe geprüft wird.</param>
        <summary>Erstellt eine abzubrechende Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Abbruchtoken, das signalisiert wird, bevor die angegebene Verzögerung ein <xref:System.Threading.Tasks.TaskCanceledException> Ausnahmeergebnisse handelt und die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  Andernfalls die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status nach Ablauf der angegebenen Verzögerung.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die zeitverzögerung ungefähr die Auflösung der Systemuhr gleich wird die `delay` Arguments ist kleiner als die Auflösung der Systemuhr, also etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Im folgende Beispiel startet eine Aufgabe, die ein Aufruf der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methode mit einer Verzögerung von-und-a-halbe Sekunde. Bevor Sie die Verzögerungsintervall abläuft, wird das Token abgebrochen. Die Ausgabe des Beispiels zeigt, dass daher, ein <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird, und die Tasks' <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Beachten Sie, dass in diesem Beispiel wird eine mögliche Racebedingung enthält: sie hängt von der Aufgabe, die die Verzögerung asynchron ausgeführt, wenn das Token abgebrochen wird. Obwohl im Aufruf von 1,5 Sekunden verzögert die <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methode diese Annahme ist wahrscheinlich, es ist dennoch möglich, den Aufruf von der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methode konnte zurück, bevor das Token abgebrochen wird. In diesem Fall erzeugt das Beispiel die folgende Ausgabe:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />ein negatives Zeitintervall außer stellt <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 - oder -   
  
 Die <paramref name="delay" /> des Arguments <see cref="P:System.TimeSpan.TotalMilliseconds" /> -Eigenschaft ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der bereitgestellte <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Tasks.Task" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task> -Klasse implementiert die <xref:System.IDisposable> Schnittstelle, da intern Ressourcen verwendet, die ebenfalls implementieren <xref:System.IDisposable>. Jedoch vor allem, wenn die app aufgerichtet ist die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder höher, besteht keine Notwendigkeit zum Aufrufen <xref:System.Threading.Tasks.Task.Dispose%2A> , wenn Leistung oder Skalierbarkeitstests gibt an, dass basierend auf Ihrer Verwendungsmuster, die Leistung Ihrer app würde verbessert werden, indem Aufgaben verworfen. Weitere Informationen finden Sie unter [benötige ich zum Verwerfen von Aufgaben?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Task ist nicht in einem der endgültigen Zustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ein boolescher Wert, der angibt, ob diese Methode aufgrund eines Aufrufs von <see cref="M:System.Threading.Tasks.Task.Dispose" /> aufgerufen wird.</param>
        <summary>Verwirft den <see cref="T:System.Threading.Tasks.Task" /> und gibt somit alle von ihm verwendeten nicht verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task> -Klasse implementiert die <xref:System.IDisposable> Schnittstelle, da intern Ressourcen verwendet, die ebenfalls implementieren <xref:System.IDisposable>. Jedoch vor allem, wenn die app aufgerichtet ist die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder höher, besteht keine Notwendigkeit zum Aufrufen <xref:System.Threading.Tasks.Task.Dispose%2A> , wenn Leistung oder Skalierbarkeitstests gibt an, dass basierend auf Ihrer Verwendungsmuster, die Leistung Ihrer app würde verbessert werden, indem Aufgaben verworfen. Weitere Informationen finden Sie unter [benötige ich zum Verwerfen von Aufgaben?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Task ist nicht in einem der endgültigen Zustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>Im Gegensatz zu den Großteil der Mitglieder der <see cref="T:System.Threading.Tasks.Task" /> -Klasse, die diese Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.AggregateException" /> ab, die die vorzeitige Beendigung der <see cref="T:System.Threading.Tasks.Task" /> verursacht hat. Wenn die <see cref="T:System.Threading.Tasks.Task" /> erfolgreich abgeschlossen wurde oder noch keine Ausnahmen ausgelöst wurden, wird <see langword="null" /> zurückgegeben.</summary>
        <value>Die <see cref="T:System.AggregateException" />, die die vorzeitige Beendigung der <see cref="T:System.Threading.Tasks.Task" /> verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben, die nicht behandelte Ausnahmen auslösen, speichern Sie die resultierende Ausnahme und weitergeben es die eingebunden in eine <xref:System.AggregateException> Aufrufe <xref:System.Threading.Tasks.Task.Wait%2A> oder Zugriffe auf die <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft. Alle Ausnahmen, die nach der Zeit die Aufgabeninstanz Garbage Collection wird nicht beachtet werden der Finalizer-Thread weitergegeben. Weitere Informationen und ein Beispiel finden Sie unter [Ausnahmebehandlung (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bietet Zugriff auf Factorymethoden zum Erstellen und Konfigurieren von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Instanzen.</summary>
        <value>Ein Factoryobjekt, das eine Vielzahl von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Objekten erstellen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine Standardinstanz von die <xref:System.Threading.Tasks.TaskFactory> Klasse, die identisch mit dem Kennwort erstellt durch Aufrufen der parameterlosen <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> Konstruktor. Es hat die folgenden Eigenschaftenwerte fest:  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, oder<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Die häufigste Verwendung dieser Eigenschaft wird zum Erstellen und starten eine neue Aufgabe in einem einzigen Aufruf der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen einer <xref:System.Threading.Tasks.Task> Objekt mit den Standardwerten für die Konfiguration.  
  
 Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task.Factory%2A> Eigenschaft zwei Aufrufe an die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Das erste füllt ein Objektarray mit den Namen der Dateien im Verzeichnis Eigene Dateien des Benutzers an, während die zweite ein Array mit den Namen von Unterverzeichnissen des Verzeichnisses für die Benutzer eigene füllt. Er ruft dann die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> -Methode, die Informationen über die Anzahl von Dateien und Verzeichnissen in den beiden Arrays angezeigt, nach der Ausführung der ersten beiden Aufgaben abgeschlossen ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch Abbruch abgeschlossene <see cref="T:System.Threading.Tasks.Task" /> mit einem angegebenen Abbruchtoken.</summary>
        <returns>Die abgebrochene Aufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für nicht Abbruch angefordert wurde <paramref name="cancellationToken" />; die <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="cancellationToken">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch Abbruch abgeschlossene <see cref="T:System.Threading.Tasks.Task`1" /> mit einem angegebenen Abbruchtoken.</summary>
        <returns>Die abgebrochene Aufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für nicht Abbruch angefordert wurde <paramref name="cancellationToken" />; die <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch eine angegebene Ausnahme abgeschlossene <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Die fehlgeschlagene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task> Objekt, dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft <xref:System.Threading.Tasks.TaskStatus.Faulted> und dessen <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft enthält `exception`. Die Methode wird häufig verwendet, wenn Sie wissen sofort, dass die Arbeit, die eine Aufgabe ausführt Ausnahme vor der Ausführung eines längeren Codepfads ausgelöst wird. Ein Beispiel finden Sie unter der <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> überladen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="exception">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch eine angegebene Ausnahme abgeschlossene <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Die fehlgeschlagene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task%601> Objekt, dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft <xref:System.Threading.Tasks.TaskStatus.Faulted> und dessen <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft enthält `exception`. Die Methode wird häufig verwendet, wenn Sie wissen sofort, dass die Arbeit, die eine Aufgabe ausführt Ausnahme vor der Ausführung eines längeren Codepfads ausgelöst wird. Dies wird im Beispiel veranschaulicht.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, deren Name als Befehlszeilenargument übergeben wird. Anstatt Ausführen eines längeren Codepfads, der instanziiert einen <xref:System.IO.FileInfo> -Objekt und ruft den Wert des seine <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> Eigenschaft für jede Datei in das Verzeichnis, das Beispiel ruft einfach die <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> Methode, um einer fehlerhaften Aufgabe erstellen, wenn eine bestimmte Unterverzeichnis ist nicht vorhanden.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="result">Das in der abgeschlossenen Aufgabe zu speichernde Ergebnis.</param>
        <summary>Erstellt eine <see cref="T:System.Threading.Tasks.Task`1" />, die erfolgreich mit dem angegebenen Ergebnis abgeschlossen wurde.</summary>
        <returns>Die erfolgreich abgeschlossene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task%601> Objekt, dessen <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft `result` und dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft ist <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Die Methode wird häufig verwendet, wenn der Rückgabewert eines Vorgangs sofort bekannt ist, ohne einen längeren Codepfad auszuführen. Dies wird im Beispiel veranschaulicht.  
  
 Um ein Task-Objekt zu erstellen, die keinen Wert zurückgibt, rufen Sie die Aufgabenobjekt die <xref:System.Threading.Tasks.Task.CompletedTask%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, deren Name als Befehlszeilenargument übergeben wird. Anstatt das Ausführen eines längeren Codepfads, der instanziiert eine <xref:System.IO.FileStream> -Objekt und ruft den Wert des seine <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> Eigenschaft für jede Datei in das Verzeichnis, das Beispiel ruft einfach die <xref:System.Threading.Tasks.Task.FromResult%2A> Methode, um eine Aufgabe zu erstellen, deren <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft ist 0 (null), wenn ein Verzeichnis keine Dateien aufweist.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Awaiter ab, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</summary>
        <returns>Eine Awaiter-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für die Verwendung durch den Compiler und nicht für die Verwendung im Code vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine ID für diese <see cref="T:System.Threading.Tasks.Task" />-Instanz ab.</summary>
        <value>Der Bezeichner, der dieser <see cref="T:System.Threading.Tasks.Task" />-Instanz vom System zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben-IDs werden bei Bedarf zugewiesen und entsprechen nicht notwendigerweise die Reihenfolge, in welche, die Aufgabe Instanzen erstellt werden. Beachten Sie, dass obwohl Konflikte äußerst selten sind, Task-IDs nicht garantiert eindeutig sein.  
  
 Um die Aufgaben-ID des aktuell ausgeführten Tasks innerhalb des Codes erhalten, die diese Aufgabe ausgeführt wird, verwenden die <xref:System.Threading.Tasks.Task.CurrentId%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Threading.Tasks.Task" />-Instanz die Ausführung aufgrund eines Abbruchs abgeschlossen hat.</summary>
        <value>
          <see langword="true" />, wenn die Aufgabe aufgrund eines Abbruchs beendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Threading.Tasks.Task> schließt der <xref:System.Threading.Tasks.TaskStatus.Canceled> Status unter einer der folgenden Bedingungen:  
  
-   Die <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> für einen Abbruch gekennzeichnet wurde, vor dem Start der Aufgabe ausführen,  
  
-   Die Aufgabe hat die abbruchanforderung auf bereits signalisierten <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> durch Auslösen einer <xref:System.OperationCanceledException> zweitaktuellste identisch <xref:System.Threading.CancellationToken>.  
  
-   Die Aufgabe hat die abbruchanforderung auf bereits signalisierten <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> durch Aufrufen der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> Methode für die <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Das Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsCanceled%2A> Eigenschaft nicht den aufrufenden Thread blockieren, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <value>
          <see langword="true" />, wenn die Aufgabe abgeschlossen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A>Gibt zurück, `true` wann der Vorgang ist in einem der letzten drei Zustände: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, oder <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Das Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> Eigenschaft nicht den aufrufenden Thread blockieren, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Threading.Tasks.Task" /> aufgrund einer nicht behandelten Ausnahme abgeschlossen wurde.</summary>
        <value>
          <see langword="true" />, wenn die Aufgabe einen Ausnahmefehler ausgelöst hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.Tasks.Task.IsFaulted%2A> ist `true`, der Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> gleich <xref:System.Threading.Tasks.TaskStatus.Faulted>, und die zugehörige <xref:System.Threading.Tasks.Task.Exception%2A> -Eigenschaft wird nicht Null sein.  
  
> [!IMPORTANT]
>  Das Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> Eigenschaft nicht den aufrufenden Thread blockieren, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein Task- oder <see cref="T:System.Threading.Tasks.Task`1" />-Handle für diese Aufgabe zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode bietet eine Reihe von Überladungen, die eine Aufgabe zu starten, mit Standardwerten zu erleichtern. Es ist eine einfache Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Überladungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt.</summary>
        <returns>Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode können Sie zum Erstellen und Ausführen einer Aufgabe in einem einzelnen Methodenaufruf und eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode. Er erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Ist die Abbruchtoken <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Den standardmäßige Aufgabenplaner verwendet.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `ShowThreadInfo` -Methode, die zeigt die <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> des aktuellen Threads. Er ist direkt vom Thread Anwendung, aufgerufen und aus der <xref:System.Action> Delegaten übergeben werden, um die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Im folgende Beispiel ähnelt der vorherigen Abfrage, außer dass es einen Lambda-Ausdruck verwendet, um den Code zu definieren, den der Task ausgeführt wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Die Beispiele zeigen, dass die asynchrone Aufgabe in einem anderen Thread als dem Hauptthread der Anwendung-Thread ausgeführt wird.  
  
 Der Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode wird sichergestellt, dass die Aufgabe abgeschlossen ist, und die Ausgabe vor dem Beenden der Anwendung zeigt. Andernfalls ist es möglich, die die `Main` Methode wird abgeschlossen, bevor die Aufgabe abgeschlossen ist.  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode. Definiert ein Array von Verzeichnisnamen und startet eine separate Aufgabe, um die Dateinamen in jedem Verzeichnis abzurufen. Alle Aufgaben schreiben die Dateinamen in einer einzelnen <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt. Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, und klicken Sie dann zeigt die Anzahl der Gesamtzahl der Dateinamen, die geschrieben werden, um die <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="action" />-Parameter war <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt einen Proxy für die zurückgegebene Aufgabe <paramref name="function" />.</summary>
        <returns>Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden kann, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt. Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</summary>
        <returns>Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Abbruch angefordert wird, bevor die Aufgabe mit der Ausführung beginnt, wird der Task nicht ausgeführt. Stattdessen wird festgelegt ist, dass die <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand und löst eine <xref:System.Threading.Tasks.TaskCanceledException> Ausnahme.  
  
 Die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Er erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Den standardmäßige Aufgabenplaner verwendet.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Methode, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode zum Hinzufügen von Informationen über jede Datei eine <xref:System.Collections.Generic.List%601> Objekt. Jedes getrennte geschachtelte Aufgabe, die aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> Ausnahme von behandelt wird eine `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="action" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt einen Proxy für die zurückgegebene Aufgabe <paramref name="function" />.</summary>
        <returns>Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabetyp der Aufgabe.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task`1" />-Objekt zurück, das diese Aufgabe darstellt.</summary>
        <returns>Ein Aufgabenobjekt, das die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> Methode. Er erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Ist die Abbruchtoken <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Den standardmäßige Aufgabenplaner verwendet.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Anzahl von Wörtern in Textdateien, die veröffentlichte Bücher darstellen. Jede Aufgabe ist verantwortlich für das Öffnen einer Datei, lesen den gesamten Inhalt asynchron und berechnen die Anzahl der Wörter mithilfe eines regulären Ausdrucks. Die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode wird aufgerufen, um sicherzustellen, dass alle Aufgaben abgeschlossen sind, bevor die Wortanzahl jedes Buch in der Konsole anzeigen.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Der reguläre Ausdruck `\p{P}*\s+` entspricht 0 (null), einer oder mehrere Interpunktionszeichen, gefolgt von mindestens einem Leerzeichen. Es wird davon ausgegangen, dass die Gesamtzahl der Übereinstimmungen die ungefähre Wortanzahl entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Ergebnistyp der Aufgabe.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see langword="Task(TResult)" />-Objekt zurück, das diese Aufgabe darstellt. Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</summary>
        <returns>Ein <see langword="Task(TResult)" /> , darstellt, die die Arbeit in die Warteschlange eingereiht, um im Threadpool ausgeführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Abbruch angefordert wird, bevor die Aufgabe mit der Ausführung beginnt, wird der Task nicht ausgeführt. Stattdessen wird festgelegt ist, dass die <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand und löst eine <xref:System.Threading.Tasks.TaskCanceledException> Ausnahme.  
  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode. Er erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Den standardmäßige Aufgabenplaner verwendet.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 20 Aufgaben, die Schleife werden, bis ein Wert von 2 Millionen erhöht wird. Wenn die ersten 10 Aufgaben 2 Millionen erreichen, das Abbruchtoken abgebrochen wird, und alle Aufgaben, deren Leistungsindikatoren 2 Millionen nicht erreicht haben, werden abgebrochen. Im Beispiel wird eine mögliche Ausgabe gezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Anstatt die <xref:System.AggregateException.InnerExceptions%2A> Eigenschaft, um die Ausnahmen, überprüfen Sie im Beispiel durchläuft alle Aufgaben aus, um zu bestimmen, die erfolgreich abgeschlossen wurden und die abgebrochen wurden. Für Entitäten, die abgeschlossen wurden, wird den Wert, der von der Aufgabe zurückgegebenen angezeigt.  
  
 Da der Aufgabenabbruch kooperativ ist, können jede Aufgabe auf den Abbruch reagieren. Im folgende Beispiel wird z. B. die erste Seite mit der Ausnahme zurück, nachdem das Token abgebrochen wird, Aufgaben die Anzahl der Iterationen sie abgeschlossen haben und nicht als eine Ausnahme auslösen.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Das Beispiel muss immernoch die <xref:System.AggregateException> Ausnahme, da alle Aufgaben, die nicht gestartet wurden, wenn der Abbruch angefordert wird weiterhin eine Ausnahme auslöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt den <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise werden die Aufgaben asynchron über einen Threadpoolthread ausgeführt werden und den aufrufenden Thread nicht blockieren. Aufgaben, die ausgeführt wird, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously> Methode die aktuelle zugeordnet sind <xref:System.Threading.Tasks.TaskScheduler> und im aufrufenden Thread ausgeführt werden. Wenn der Zielplaner Ausführen dieser Aufgabe im aufrufenden Thread nicht unterstützt wird, wird die Aufgabe für die Ausführung auf den Planer geplant werden und der aufrufende Thread blockiert, bis der Task die Ausführung abgeschlossen ist. Auch wenn der Vorgang synchron ausgeführt wird, sollten immer noch der aufrufende Thread Aufrufen <xref:System.Threading.Tasks.Task.Wait%2A> Ausnahmen behandeln, die die Aufgabe auslösen kann.  Weitere Informationen zur Ausnahmebehandlung finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Aufgaben, die ausgeführt wird, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode durch Aufrufen von instanziiert werden eine <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Klassenkonstruktor. Der Vorgang synchron ausgeführt werden muss, der <xref:System.Threading.Tasks.TaskStatus.Created> Zustand. Eine Aufgabe kann gestartet und nur einmal ausgeführt werden. Alle Versuche zum Planen eines Tasks eine zweite Dies ergibt eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Aufgabe ausgeführt wird, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode mit einem asynchron ausgeführt. In beiden Fällen die Aufgaben ausführen, identische Lambda-Ausdrücke, die anzeigen, die Aufgaben-ID und die ID des Threads auf dem der Task ausgeführt wird. Der Task berechnet die Summe der ganzen Zahlen zwischen 1 und 1.000.000. Wie die Ausgabe des Beispiels zeigt, wird die Aufgabe ausgeführt, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode, die von der Thread der Anwendung ausgeführt werden, während die asynchrone Aufgabe nicht der Fall ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der Taskplaner, mit dem diese Aufgabe inline ausgeführt werden soll.</param>
        <summary>Führt die <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem bereitgestellten <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben, die ausgeführt wird, durch Aufrufen der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode durch Aufrufen von instanziiert werden eine <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Klassenkonstruktor. Der Vorgang synchron ausgeführt werden muss, der <xref:System.Threading.Tasks.TaskStatus.Created> Zustand. Eine Aufgabe kann gestartet und nur einmal ausgeführt werden. Alle Versuche zum Planen eines Tasks eine zweite Dies ergibt eine Ausnahme ausgelöst.  
  
 Wenn der Zielplaner Ausführen dieses Tasks für den aktuellen Thread nicht unterstützt wird, wird die Aufgabe für die Ausführung auf den Planer geplant werden und der aktuelle Thread blockiert, bis der Task die Ausführung abgeschlossen ist. Aus diesem Grund der aufrufende Thread muss nicht aufrufen eine Methode wie <xref:System.Threading.Tasks.Task.Wait%2A> um sicherzustellen, dass die Ausführung der Aufgabe abgeschlossen wurde. Weitere Informationen zur Ausnahmebehandlung für Vorgänge mit dem Task finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die <see cref="T:System.Threading.Tasks.Task" /> und plant ihre Ausführung mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Aufgabe kann gestartet und nur einmal ausgeführt werden. Eine Ausnahme führt jeder Versuch, eine Aufgabe ein zweites Mal zu planen.  
  
 Die <xref:System.Threading.Tasks.Task.Start%2A> wird verwendet, um eine Aufgabe auszuführen, der durch einen Aufruf der erstellt wurde die <xref:System.Threading.Tasks.Task> Konstruktoren. In der Regel führen Sie dies beim Trennen der taskerstellung aus seiner Ausführung, z. B. Wenn Sie bedingt Aufgaben ausführen, die Sie erstellt haben müssen. Für die allgemeinerer Fall, in dem Sie nicht Aufgabe Instanziierung von Ausführung trennen müssen, wird empfohlen, eine Überladung von Aufrufen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> Konstruktor zum Instanziieren einer neuen <xref:System.Threading.Tasks.Task> -Objekt, das die Task-ID und verwalteten Thread-ID angezeigt und führt dann eine Schleife. Er ruft dann die <xref:System.Threading.Tasks.Task.Start%2A> Methode, um die Aufgabe auszuführen.  Da dies eine Konsolen-app, den Aufruf von ist die <xref:System.Threading.Tasks.Task.Wait%2A> Methode ist erforderlich, um zu verhindern, dass die app beendet wird, bevor der Task die Ausführung beendet.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, dem diese Aufgabe zugeordnet und mit dem sie ausgeführt werden soll.</param>
        <summary>Startet die <see cref="T:System.Threading.Tasks.Task" /> und plant ihre Ausführung mit dem angegebenen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Aufgabe kann nur gestartet, und nur einmal ausgeführt. Eine Ausnahme führt jeder Versuch, eine Aufgabe ein zweites Mal zu planen.  
  
 Weitere Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Der Planer konnte diesen Task nicht in die Warteschlange einreihen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabe ab.</summary>
        <value>Der aktuelle <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabeninstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts der <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft nicht den aufrufenden Thread blockieren, bis die Aufgabe abgeschlossen wurde.  
  
 Weitere Informationen und ein Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) und [wie: Abbrechen eine Aufgabe und die zugehörigen untergeordneten](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 20 Aufgaben, die Schleife werden, bis ein Wert von 2 Millionen erhöht wird. Wenn die ersten 10 Aufgaben 2 Millionen erreichen, das Abbruchtoken abgebrochen wird, und alle Aufgaben, deren Leistungsindikatoren 2 Millionen nicht erreicht haben, werden abgebrochen. Im Beispiel wird dann untersucht die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft der einzelnen Aufgaben aus, um anzugeben, ob er erfolgreich abgeschlossen oder abgebrochen wurde. Für Entitäten, die abgeschlossen wurde, wird den Wert, der von der Aufgabe zurückgegebenen angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</summary>
        <value>Ein <see cref="T:System.Threading.WaitHandle" />, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wait-Funktion verwenden, <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ist es besser mit <xref:System.IAsyncResult.AsyncWaitHandle%2A> für ähnliche Funktionen. Weitere Informationen finden Sie im Abschnitt "Warten auf Aufgaben" [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [unter Verwendung von TPL mit anderen asynchronen Mustern](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Vorgang synchron abgeschlossen wurde.</summary>
        <value>
          <see langword="true" />, wenn der Vorgang synchron abgeschlossen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A>ist eine Synchronisierungsmethode, die bewirkt, dass den aufrufenden Thread wartet, bis der aktuelle Task abgeschlossen wurde. Wenn der aktuelle Task die Ausführung nicht gestartet wurde, versucht die Wait-Methode vom Planer die Aufgabe entfernen, und führen Sie es Inline für den aktuellen Thread. Wenn sie dazu kann oder die aktuelle Aufgabe bereits Ausführung gestartet wurde, blockiert den aufrufenden Thread, bis die Aufgabe abgeschlossen ist. Weitere Informationen finden Sie unter [Task.Wait und "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 Weitere Informationen und ein Beispiel finden Sie unter [wie: Warten auf einer oder mehrerer Aufgaben zum Abschluss](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).  
  
   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die eine Million zufällige ganze Zahlen zwischen 0 und 100 generiert und deren Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%2A> Methode, um sicherzustellen, dass die Aufgabe abgeschlossen ist, bevor die Anwendung beendet wird. Da dies eine Konsolenanwendung ist, würde, andernfalls im Beispiel wird beendet, bevor die Aufgabe zu berechnen und den Mittelwert anzeigen kann.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
 - oder -   
  
 Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt wird.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>ist eine Synchronisierungsmethode, die bewirkt, der aufrufenden Thread warten Sie, bis die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Der Vorgang selbst abgebrochen oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält Details über die Ausnahme oder die Ausnahmen.  
  
-   Das Intervall von definierten `millisecondsTimeout` abläuft. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt, und die Methode gibt `false`.  
  
   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die Millionen von fünf zufällige ganze Zahlen zwischen 0 und 100 generiert und deren Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> -Methode warten, für die Anwendung in 150 Millisekunden abgeschlossen. Wenn die Anwendung normal abgeschlossen wurde, zeigt die Aufgabe, die Summe und Mittelwert der zufälligen Zahlen, die es generiert wurde. Wenn das Timeoutintervall abgelaufen ist, zeigt das Beispiel eine Meldung an, bevor er beendet wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
 - oder -   
  
 Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt. Der Wartevorgang wird beendet, wenn ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Methode erstellt einen Wartevorgang abgebrochen werden; d. h. es bewirkt, dass des aktuellen Threads wartet, bis eines der folgenden Ereignisse eintritt:  
  
-   Die Aufgabe abgeschlossen ist.  
  
-   Das Abbruchtoken abgebrochen wird. In diesem Fall wird der Aufruf der <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> -Methode löst eine <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Durch das Abbrechen der `cancellationToken` Abbruchtoken hat keine Auswirkung auf die aktuell ausgeführter Task, wenn er auch das Abbruchtoken übergeben wurde und Abbruch behandeln vorbereitet ist. Übergeben der `cancellationToken` Objekt an diese Methode kann einfach den Wartevorgang abgebrochen wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die einfache Verwendung eines Abbruchtokens zum Abbrechen auf den Abschluss einer Aufgabe zu warten. Eine Aufgabe gestartet wird, ruft die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> Methode, um die Tokenquelle Abbruchtoken, und klicken Sie dann Verzögerungen fünf Sekunden "Abbrechen". Beachten Sie, dass der Task selbst nicht das Abbruchtoken übergeben wurde und nicht abgebrochen werden kann. Der Anwendungsthread ruft der Aufgabe <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode zu warten, bis die Aufgabe abgeschlossen, aber der Wartevorgang abgebrochen wird, sobald das Abbruchtoken abgebrochen wird, und eine <xref:System.OperationCanceledException> ausgelöst wird. Der Ausnahmehandler meldet die Ausnahme und wartet dann für sechs Sekunden. Diese Verzögerung ermöglicht es dem Task in Anspruch nehmen, wie die Ausgabe des Beispiels zeigt, die <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Aufgabe wurde verworfen.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
 - oder -   
  
 Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt wird.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>ist eine Synchronisierungsmethode, die bewirkt, der aufrufenden Thread warten Sie, bis die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Der Vorgang selbst abgebrochen oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält Details über die Ausnahme oder die Ausnahmen.  
  
-   Das Intervall von definierten `timeout` abläuft. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt, und die Methode gibt `false`.  
  
   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die Millionen von fünf zufällige ganze Zahlen zwischen 0 und 100 generiert und deren Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> -Methode warten, für die Anwendung in 150 Millisekunden abgeschlossen. Wenn die Anwendung normal abgeschlossen wurde, zeigt die Aufgabe, die Summe und Mittelwert der zufälligen Zahlen, die es generiert wurde. Wenn das Timeoutintervall abgelaufen ist, zeigt das Beispiel eine Meldung an, bevor er beendet wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.  
  
 - oder -   
  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
 - oder -   
  
 Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt. Der Wartevorgang wird beendet, wenn ein Timeoutintervall abläuft oder ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>ist eine Synchronisierungsmethode, die bewirkt, der aufrufenden Thread warten Sie, bis die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Der Vorgang selbst abgebrochen oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält Details über die Ausnahme oder die Ausnahmen.  
  
-   Die `cancellationToken` Abbruchtoken abgebrochen wird. In diesem Fall wird der Aufruf der <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode löst eine <xref:System.OperationCanceledException>.  
  
-   Das Intervall von definierten `millisecondsTimeout` abläuft. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt, und die Methode gibt `false`.  
  
> [!NOTE]
>  Durch das Abbrechen der `cancellationToken` Abbruchtoken hat keine Auswirkung auf die aktuell ausgeführter Task, wenn er auch das Abbruchtoken übergeben wurde und Abbruch behandeln vorbereitet ist. Übergeben der `cancellationToken` Objekt an diese Methode einfach die Möglichkeit des Wartevorgang abgebrochen wird basierend auf einer Bedingung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> Methode zum Bereitstellen einer Zeitüberschreitungswert und ein Abbruch token, die das Warten auf den Abschluss einer Aufgabe beenden kann. Ein neuer Thread gestartet und führt die `CancelToken` -Methode, die anhält und ruft dann die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> Methode, um das Abbruchtoken abgebrochen. Eine Aufgabe wird gestartet, und 5 Sekunden lang verzögert. Die <xref:System.Threading.Tasks.Task.Wait%2A> Methode wird aufgerufen, um den Abschluss des Vorgangs gewartet werden soll, und eine kurze Timeoutwert sowie ein Abbruchtoken bereitgestellt wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Beachten Sie, dass die genaue Ausgabe des Beispiels abhängt, ob aufgrund das Abbruchtoken, das der Wartevorgang abgebrochen wurde oder weil das Timeoutintervall abgelaufen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
 - oder -   
  
 Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <summary>Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel startet 10 Aufgaben, von die jede einen Index als ein Zustandsobjekt übergeben wird. Aufgaben mit einem Index aus zwei bis fünf auslösen Ausnahmen. Der Aufruf der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methode dient als Wrapper für alle Ausnahmen in eine <xref:System.AggregateException> Objekt und gibt es an den aufrufenden Thread weiter.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn eine Aufgabe abgebrochen wurde, die <see cref="T:System.AggregateException" /> Ausnahme enthält eine <see cref="T:System.OperationCanceledException" /> Ausnahme in seiner <see cref="P:System.AggregateException.InnerExceptions" /> Auflistung.  
  
 - oder -   
  
 Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</summary>
        <returns>
          <see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
 - oder -   
  
 Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</param>
        <summary>Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cancellationToken` Argument wird verwendet, um die "Wait"-Vorgang "Abbrechen". Abbruch der Aufgaben ist eine distinct-Vorgang, und signalisiert wird, indem Sie die <xref:System.AggregateException> wie oben beschrieben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
 - oder -   
  
 Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</summary>
        <returns>
          <see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
 - oder -   
  
 Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich „-1 Millisekunden“, die ein unendliches Timeout darstellt.  
  
 - oder -   
  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis zum Abbruch des Wartevorgangs.</summary>
        <returns>
          <see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cancellationToken` Argument wird verwendet, um die "Wait"-Vorgang "Abbrechen". Abbruch der Aufgaben ist eine distinct-Vorgang, und signalisiert wird, indem Sie die <xref:System.AggregateException> wie oben beschrieben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
 - oder -   
  
 Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
 - oder -   
  
 Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <summary>Wartet, bis eines der bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließt.</summary>
        <returns>Der Index des abgeschlossenen <see cref="T:System.Threading.Tasks.Task" />-Objekts im <paramref name="tasks" />-Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel startet fünf Tasks, die jeweils mindestens 50 Millisekunden oder maximal 1.050 Millisekunden inaktiv. Die <xref:System.Threading.Tasks.Task.WaitAny%2A> Methode wartet dann eine der Aufgaben abgeschlossen. Das Beispiel zeigt die Aufgaben-ID des Tasks, der den Wartevorgang beendet als auch den aktuellen Status aller Tasks.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</summary>
        <returns>Der Index der ausgeführten Aufgabe im <paramref name="tasks" />-Arrayargument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich „-1 Millisekunden“, die ein unendliches Timeout darstellt.  
  
 - oder -   
  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis ein Abbruchtoken abgebrochen wird.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einer aufzählbaren Auflistung abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methode, die Zurückgeben einer <xref:System.Threading.Tasks.Task> Objekt werden in der Regel aufgerufen, wenn Sie interessiert, in den Status einer Reihe von Aufgaben oder die Ausnahmen, die durch eine Reihe von Aufgaben ausgelöst werden.  
  
> [!NOTE]
>  Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode blockiert den aufrufenden Thread nicht.  
  
 Wenn eine der angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand befinden, wird die zurückgegebene Aufgabe auch abgeschlossen eine <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die zugehörigen Ausnahmen, in dem die Aggregation des Satzes von entpackte Ausnahmen aus jedem der angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben fehlerhaft, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keine der Aufgaben abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Wenn das angegebene Array/aufzählbare Objekt keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in ein <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor sie an den Aufrufer zurückgegeben werden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen Satz von Aufgaben, die die URLs in einem Array zu pingen. Die Aufgaben in gespeichert werden eine `List<Task>` -Auflistung, die an die <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode. Nach dem Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode wird sichergestellt, dass alle Threads abgeschlossen haben, im Beispiel überprüft die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob alle Tasks einen Fehler verursacht haben.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> -Auflistung enthielt eine <see langword="null" /> Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einem Array abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methode, die Zurückgeben einer <xref:System.Threading.Tasks.Task> Objekt werden in der Regel aufgerufen, wenn Sie interessiert, in den Status einer Reihe von Aufgaben oder die Ausnahmen, die durch eine Reihe von Aufgaben ausgelöst werden.  
  
> [!NOTE]
>  Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> Methode blockiert den aufrufenden Thread nicht.  
  
 Wenn eine der angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand befinden, wird die zurückgegebene Aufgabe auch abgeschlossen eine <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die zugehörigen Ausnahmen, in dem die Aggregation des Satzes von entpackte Ausnahmen aus jedem der angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben fehlerhaft, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keine der Aufgaben abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Wenn das angegebene Array/aufzählbare Objekt keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in ein <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor sie an den Aufrufer zurückgegeben werden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen Satz von Aufgaben, die die URLs in einem Array zu pingen. Die Aufgaben werden gespeichert, einer `List<Task>` -Auflistung, die in ein Array konvertiert und übergeben der <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode. Nach dem Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode wird sichergestellt, dass alle Threads abgeschlossen haben, im Beispiel überprüft die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob alle Tasks einen Fehler verursacht haben.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthielt eine <see langword="null" /> Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einer aufzählbaren Auflistung abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> Methode blockiert den aufrufenden Thread nicht. Allerdings einen Aufruf der zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft blockiert den aufrufenden Thread.  
  
 Wenn eine der angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand befinden, wird die zurückgegebene Aufgabe auch abgeschlossen eine <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die zugehörigen Ausnahmen, in dem die Aggregation des Satzes von entpackte Ausnahmen aus jedem der angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben fehlerhaft, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keine der Aufgaben abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  Die <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft der zurückgegebenen Aufgabe wird in ein Array, das alle für die Ergebnisse der angegebenen Aufgaben in der gleichen Reihenfolge wie sie bereitgestellt wurden enthält festgelegt werden (z. B. wenn die Eingabe enthaltene Array t1, t2, t3, der ausgabeaufgabe Vorgänge <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft zurückgegeben wird ein `TResult[]` , in denen `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Wenn die `tasks` Argument enthält keine Vorgänge, die zurückgegebene Aufgabe geht sofort in ein <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor sie an den Aufrufer zurückgegeben werden. Das zurückgegebene `TResult[]` wird ein Array mit 0 Elementen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die zehn Aufgaben, von die jede einen Zufallszahlengenerator instanziiert, der 1.000 zufällige Zahlen zwischen 1 und 1.000 erstellt und deren Mittelwert berechnet. Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Methode wird verwendet, um die Instanziierung von random Number-Generatoren zu verzögern, damit sie mit identischen Startwerten nicht erstellt werden. Der Aufruf der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenrückgabe klicken Sie dann eine <xref:System.Int64> Array, den Mittelwert enthält, berechnet, indem jede Aufgabe. Diese werden dann verwendet, insgesamt Mittelwert zu berechnen.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 In diesem Fall werden die zehn einzelne Aufgaben gespeichert, einem <xref:System.Collections.Generic.List%601> Objekt. <xref:System.Collections.Generic.List%601> implementiert die <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> -Auflistung enthielt eine <see langword="null" /> Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einem Array abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> Methode blockiert den aufrufenden Thread nicht. Allerdings einen Aufruf der zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft blockiert den aufrufenden Thread.  
  
 Wenn eine der angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand befinden, wird die zurückgegebene Aufgabe auch abgeschlossen eine <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die zugehörigen Ausnahmen, in dem die Aggregation des Satzes von entpackte Ausnahmen aus jedem der angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben fehlerhaft, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keine der Aufgaben abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  Die <xref:System.Threading.Tasks.Task%601.Result%2A> der zurückgegebenen Aufgabe festgelegt, um ein Array mit alle Ergebnisse der angegebenen Aufgaben in der gleichen Reihenfolge wie sie bereitgestellt wurden (z. B. wenn die Eingabe enthaltene Array t1, t2, t3, der ausgabeaufgabe Vorgänge <xref:System.Threading.Tasks.Task%601.Result%2A> zurück ein `TResult[]` wobei `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Wenn das angegebene Array/aufzählbare Objekt keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in ein <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor sie an den Aufrufer zurückgegeben werden.  Das zurückgegebene `TResult[]` wird ein Array mit 0 Elementen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die zehn Aufgaben, von die jede einen Zufallszahlengenerator instanziiert, der 1.000 zufällige Zahlen zwischen 1 und 1.000 erstellt und deren Mittelwert berechnet. In diesem Fall werden die zehn einzelne Aufgaben gespeichert, einem `Task<Int64>` Array.  Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Methode wird verwendet, um die Instanziierung von random Number-Generatoren zu verzögern, damit sie mit identischen Startwerten nicht erstellt werden. Der Aufruf der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenrückgabe klicken Sie dann eine <xref:System.Int64> Array, den Mittelwert enthält, berechnet, indem jede Aufgabe. Diese werden dann verwendet, insgesamt Mittelwert zu berechnen.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthielt eine <see langword="null" /> Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe beendet immer der `RanToCompletion` Zustand mit das Resultset auf die erste Aufgabe abgeschlossen.  Dies gilt auch, wenn die erste Aufgabe abgeschlossen beendet die `Canceled` oder `Faulted` Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthaltenen einen null-Task oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe beendet immer der `RanToCompletion` mit Status seiner `Result` an die erste Aufgabe auf abgeschlossen festgelegt.  Dies gilt auch, wenn die erste Aufgabe abgeschlossen beendet die `Canceled` oder `Faulted` Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war null.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthaltenen einen null-Task oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe wird immer mit das Resultset auf die erste Aufgabe abgeschlossen im Status "RanToCompletion" enden. Dies gilt auch, wenn die erste Aufgabe abgeschlossen abgebrochen oder Faulted-Zustand beendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthaltenen einen null-Task oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe wird immer mit das Resultset auf die erste Aufgabe abgeschlossen im Status "RanToCompletion" enden. Dies gilt auch, wenn die erste Aufgabe abgeschlossen abgebrochen oder Faulted-Zustand beendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="tasks" /> Argument war null.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" /> Array enthaltenen einen null-Task oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Awaitable-Aufgabe, die asynchron an den aktuellen Kontext liefert, wenn erwartet.</summary>
        <returns>Ein Kontext, der während des Abwartens asynchron wieder in den aktuellen Kontext zum Zeitpunkt des Abwartens übergeht. Wenn der aktuelle <see cref="T:System.Threading.SynchronizationContext" /> nicht Null ist, wird er als der aktuelle Kontext behandelt. Andernfalls wird der Taskplaner, der der aktuell ausgeführten Aufgabe zugeordnet ist, als der aktuelle Kontext behandelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können `await Task.Yield();` in eine asynchrone Methode, um die Methode, die asynchron abgeschlossen zu erzwingen. Es ist ein aktuelle Synchronisierungskontext (<xref:System.Threading.SynchronizationContext> Objekt), stellt dies den Rest der methodenausführung wieder den Kontext bereit. Allerdings wird der Kontext entscheiden, wie dieses Werk relativ zu anderen Arbeitsaufgaben zu priorisieren, die anstehen können. Der Synchronisierungskontext, der auf einem UI-Thread in den meisten Umgebungen der Benutzeroberfläche vorhanden ist wird häufig Arbeit an den Kontext höher als Eingabe und Rendering Arbeit gebucht priorisieren. Aus diesem Grund verlassen Sie sich nicht auf `await Task.Yield();` eine Benutzeroberfläche reaktionsfähig.  Weitere Informationen finden Sie im Eintrag [nützliche Abstraktionen mit ContinueWith aktiviert](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) in parallelen Programmierung mit .NET-Blog.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
