<Type Name="Double" FullName="System.Double">
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit doppelter Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double> Werttyp stellt eine 64-Bit-Zahl mit doppelter Genauigkeit mit Werten, die im Bereich von negativen 1. 79769313486232e308 bis positive 1. 79769313486232e308 sowie positive oder negative 0 (null), <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>, und keine Zahl (<xref:System.Double.NaN>). Sie dient zur Darstellung von Werten sind extrem (z. B. die Abstände zwischen Planeten oder Galaxien) großen oder sehr klein (Molekülmasse ein Stoff in Kilogramm) und, häufig unpräzise sind (wie der Abstand zwischen Erde und eine andere Sonnensystem), sind die <xref:System.Double> Typ den IEC 60559: 1989 (IEEE 754) für binäre Gleitkommaarithmetik standard entspricht.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Gleitkommadarstellung und Genauigkeit](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleitkommawerte und Ausnahmen](#Exceptions)  
  
-   [Typumwandlungen und die Double-Struktur](#Conversions)  
  
-   [Gleitkomma-Funktion](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Gleitkommadarstellung und Genauigkeit  
 Die <xref:System.Double> -Datentyp speichert Gleitkommawerte mit doppelter Genauigkeit in eine 64-Bit-Binärformat, wie in der folgenden Tabelle dargestellt:  
  
|Segment|Bits|  
|----------|----------|  
|Signifikanden oder Mantisse|0-51|  
|Exponent|52-62|  
|Zeichen (0 = positiv, 1 = Negative)|63|  
  
 Genauso wie Decimal Brüche nicht genau einige Bruchzahlen darstellen können (z. B. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), binary Brüche können nicht auf einige Bruchzahlen darstellen. 1/10, der genau durch.1 als Dezimalbruch dargestellt wird, wird z. B. durch.001100110011 als Binärbruch, mit dem Muster "0011" wiederholten unendlicher dargestellt. In diesem Fall stellt der Gleitkommawert eine ungenaue Darstellung der Zahl, die es darstellt. Zusätzliche mathematische Operationen auf der ursprünglichen Gleitkommawert häufig ausgeführt ist der Mangel an Genauigkeit zu erhöhen. Z. B. wenn wir das Ergebnis Vergleichen der Multiplikation.1 von 10 und hinzufügen.1 zu.1 neun Mal, wir finden Sie diese hinzufügen, da sie acht weitere Vorgänge beteiligt ist, hat das weniger präzise Ergebnis erzeugt. Beachten Sie, dass diese Abweichung vorliegt, offensichtlich ist, nur dann, wenn wir die beiden anzeigen <xref:System.Double> Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), welche wenn nötig angezeigt werden alle 17 Ziffern von unterstützt die <xref:System.Double> Typ.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht genau als binäre Bruchzahlen dargestellt werden können, können Gleitkommazahlen ungefähre reelle Zahlen.  
  
 Alle Gleitkommazahlen haben auch eine begrenzte Anzahl von signifikanten Stellen, die auch bestimmt, wie genau ein Gleitkommawert mit eine reellen Zahl entspricht.   Ein <xref:System.Double> Wert ist bis zu 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Dies bedeutet, dass einige Gleitkommaoperationen, die Genauigkeit fehlen, um einen Gleitkommawert ändern Datenpunktwert. Dies wird im folgenden Beispiel veranschaulicht. Er definiert einen sehr großen Gleitkommawert, und fügt dann das Produkt der <xref:System.Double.Epsilon?displayProperty=nameWithType> und eine Billiarde darauf. Das Produkt ist jedoch zu klein, um die ursprünglichen Gleitkommawert ändern. Die am wenigsten signifikante Ziffer ist, Zehntausendstel-, während die signifikanteste Ziffer des Produkts 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Der eingeschränkte Genauigkeit einer Gleitkommazahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit gleich angezeigt werden möglicherweise nicht gleich, da es sich bei ihrer letzten gültigen Ziffern unterscheiden. Im folgenden Beispiel werden eine Reihe von Zahlen addiert und deren Summe ist mit ihrer erwarteten insgesamt verglichen. Obwohl die beiden Werte angezeigt werden, auf die gleichen, einen Aufruf der `Equals` Methode gibt an, dass sie nicht sind.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Formatelemente in Ändern der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> -Anweisung aus `{0}` und `{1}` auf `{0:R}` und `{1:R}` anzuzeigenden alle signifikanten Ziffern der beiden <xref:System.Double> Werte, es ist klar, dass die beiden Werte ungleich sind, da von einem Genauigkeitsverlust während der Vorgänge hinzufügen. In diesem Fall kann das Problem gelöst werden, durch Aufrufen der <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode gerundet wird, die <xref:System.Double> Werte auf die gewünschte Genauigkeit vor dem Vergleich.  
  
-   Eine mathematische oder Vergleichsoperation Operation, die eine Gleitkommazahl verwendet möglicherweise nicht dasselbe Ergebnis ausgeben, wenn eine Dezimalzahl verwendet wird, da die binäre Gleitkommazahl möglicherweise nicht die Dezimalzahl Wert. In einem vorherigen Beispiel veranschaulicht dies durch das Ergebnis der Multiplikation.1 von 10 und Hinzufügen von.1 Zeiten anzeigen.  
  
     Wenn die Genauigkeit der numerischen Operationen mit Bruchwerten wichtig ist, können Sie die <xref:System.Decimal> statt über das <xref:System.Double> Typ. Wenn die Genauigkeit der numerischen Operationen mit ganzzahligen Werten außerhalb des Gültigkeitsbereichs für die <xref:System.Int64> oder <xref:System.UInt64> Typen ist sehr wichtig, verwenden Sie die <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert kann nicht zurückkonvertiert, wenn eine Gleitkommazahl einbezogen ist. Ein Wert ist für den roundtripvorgang genannten, wenn ein Vorgang eine ursprüngliche Gleitkommazahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Format zurück in eine Gleitkommazahl transformiert und die endgültige Gleitkommazahl nicht gleich dem ursprünglichen ist Gleitkommazahl. Der Roundtrip kann fehlschlagen, da eine oder mehrere Ziffern verloren gehen oder bei der Konvertierung geändert werden. Im folgenden Beispiel drei <xref:System.Double> Werte in Zeichenfolgen konvertiert und in einer Datei gespeichert werden. Wie die Ausgabe allerdings zeigt auch, wenn die Werte identisch sind, werden angezeigt sind die wiederhergestellten Werte nicht gleich den ursprünglichen Werten.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In diesem Fall die Werte können werden erfolgreich Roundtrip mithilfe der "G17" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) die vollständige Genauigkeit beibehalten <xref:System.Double> Werte, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Bei Verwendung mit einem <xref:System.Double> Wert, der Formatbezeichner "R" in einigen Fällen nicht erfolgreich in den ursprünglichen Wert. Um sicherzustellen, dass <xref:System.Double> Werte, die erfolgreich in der Formatbezeichner "G17" zu verwenden.

-   <xref:System.Single>Werte müssen weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> -Wert, der in eine entsprechende scheinbar konvertiert wird <xref:System.Double> häufig stimmt nicht mit der <xref:System.Double> Wert aufgrund der Unterschiede in der Genauigkeit. Im folgenden Beispiel wird das Ergebnis identisch Divisionsoperationen zugewiesen, um eine <xref:System.Double> und ein <xref:System.Single> Wert. Nach der <xref:System.Single> Wert umgewandelt ist eine <xref:System.Double>, ein Vergleich der beiden Werte zeigt an, dass sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder die <xref:System.Double> anstelle von der <xref:System.Single> Datentyp aufweisen, oder verwenden die <xref:System.Math.Round%2A> Methode so, dass beide Werte die gleiche Genauigkeit verfügen.  
  
 Darüber hinaus wird das Ergebnis der arithmetischen und Zuordnungsvorgänge mit <xref:System.Double> Werte möglicherweise unterscheiden sich geringfügig von der Plattform aufgrund der Verlust an Genauigkeit von der <xref:System.Double> Typ. Z. B. das Ergebnis der Zuweisung eines literalen <xref:System.Double> Wert kann in der 32-Bit und 64-Bit-Versionen von .NET Framework unterscheiden. Das folgende Beispiel veranschaulicht dies Unterschied, wenn das Literal-Wert - 4.42330604244772E-305 und eine Variable, deren Wert - 4.42330604244772E-305 zugewiesen sind eine <xref:System.Double> Variable. Beachten Sie, dass das Ergebnis der <xref:System.Double.Parse%28System.String%29> Methode wird in diesem Fall nicht aus einem Genauigkeitsverlust beeinträchtigt.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet werden zwei <xref:System.Double> Werte müssen identische Werte darstellen. Jedoch aktivieren, aufgrund der Unterschiede in der Genauigkeit zwischen Werten oder aufgrund einer Unterbrechung der Genauigkeit von einer oder beide Werte, Gleitkommawerte, die häufig identisch sein soll aufgrund der Unterschiede in ihren letzten gültigen Ziffern berücksichtigt werden. Folglich aufruft, um die <xref:System.Double.Equals%2A> -Methode, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe von der <xref:System.Double.CompareTo%2A> Methode, um die Beziehung zwischen zwei bestimmen <xref:System.Double> Werte, häufig zu unerwarteten Ergebnissen führen. Dies wird im folgenden Beispiel ersichtlich, gleich, in denen zwei offensichtlich <xref:System.Double> hellste Werte berücksichtigt werden, da es sich bei der ersten 15 Dezimalstellen, sind, während die zweite 17 hat.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die unterschiedlichen Codepfaden folgen und, die bearbeitet werden auf unterschiedliche Weise häufig, kosteneffizienter, berücksichtigt werden. Im folgenden Beispiel ein <xref:System.Double> Wert wird das Quadrat, und klicken Sie dann die Quadratwurzel berechnet wird, um den ursprünglichen Wert wiederherzustellen. Ein zweites <xref:System.Double> 3.51 multipliziert und Quadrat, bevor die Quadratwurzel des Ergebnisses durch 3.51 zum Wiederherstellen des ursprünglichen Werts dividiert wird. Scheinbar, dass die zwei Werte identisch sind, werden ein Aufruf der <xref:System.Double.Equals%28System.Double%29> Methode gibt an, dass sie nicht gleich sind. Verwenden die Standardformatzeichenfolge "R", um eine Ergebniszeichenfolge zurückzugeben, die alle signifikanten Ziffern der einzelnen Double-Wert zeigt an, dass der zweite Wert.0000000000001 zeigt kleiner als das erste.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen ein Genauigkeitsverlust ist wahrscheinlich das Ergebnis eines Vergleichs auswirken, übernehmen Sie eine der folgenden Alternativen zum Aufrufen der <xref:System.Double.Equals%2A> oder <xref:System.Double.CompareTo%2A> Methode:  
  
-   Rufen Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass beide Werte die gleiche Genauigkeit enthalten. Im folgende Beispiel ändert ein vorherigen Beispiel für diesen Ansatz verwenden, sodass zwei Bruchzahlen äquivalent sind.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie jedoch, dass das Problem der Genauigkeit weiterhin, gilt um Werte für Mittelpunkt Rundung. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test auf Gleichheit ungefähre anstatt auf Gleichheit. Dies erfordert, dass Sie entweder ein absoluter definieren Menge nach dem die beiden Werte unterscheiden sich jedoch immer noch können identisch sein, oder, die Sie definieren eine relative Menge nach dem der kleinere Wert von der jeweils größere Wert voneinander abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType>In einigen Fällen als absolute ein Maß für den Abstand zwischen zwei verwendet <xref:System.Double> Werte beim Testen der Gleichheit.  Allerdings <xref:System.Double.Epsilon?displayProperty=nameWithType> misst den kleinstmöglichen Wert, der hinzugefügt oder davon subtrahiert werden kann ein <xref:System.Double> , dessen Wert ist 0 (null). Für die meisten Positive und negative <xref:System.Double> Werte, die den Wert des <xref:System.Double.Epsilon?displayProperty=nameWithType> ist zu klein, um erkannt zu werden. Aus diesem Grund mit Ausnahme der Werte, die NULL sind, wird nicht die Verwendung in Gleichheit empfohlen.  
  
     Im folgenden Beispiel wird den zweiten Ansatz zum Definieren einer `IsApproximatelyEqual` -Methode, die die relative Unterschied zwischen zwei Werten testet. Auch Unterschiede aufgezeigt, das Ergebnis der Aufrufe an die `IsApproximatelyEqual` Methode und die <xref:System.Double.Equals%28System.Double%29> Methode.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleitkommawerte und Ausnahmen  
 Im Gegensatz zu Vorgängen mit ganzzahligen Typen, die Auslösen von Ausnahmen bei Überlauf oder nicht zulässige Vorgänge wie z. B. Division durch 0 (null), führen Sie die Operationen mit Gleitkommazahlen-Punktwerte keine Ausnahmen auslösen. Stattdessen ist das Ergebnis einer Gleitkommaoperation in Ausnahmefällen, 0 (null), unendlich, negativ unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleitkommaoperation für das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann auftreten, wenn zwei sehr kleine Zahlen, wie im folgenden Beispiel gezeigt multipliziert werden.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Wenn das Ergebnis einer Gleitkommaoperation als Maßeinheit des Bereichs von im Zielformat überschreitet, wird das Ergebnis des Vorgangs <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>je nach Bedarf für das Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, die führt zu einem Überlauf <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double.PositiveInfinity>, und das Ergebnis eines Vorgangs, die führt zu einem Überlauf <xref:System.Double.MinValue?displayProperty=nameWithType> ist <xref:System.Double.NegativeInfinity>, wie im folgende Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity>auch aus einer Division durch 0 (null) mit einer positiven Dividend ausgegeben und <xref:System.Double.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null), mit einem negativen Dividend.  
  
-   Wenn eine Gleitkommaoperation ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Double.NaN>. Beispielsweise <xref:System.Double.NaN> führt Sie aus den folgenden Vorgängen:  
  
    -   Division durch 0 (null), mit einer Dividende 0 (null). Beachten Sie, dass andere Fälle der Division durch 0 (null) Ergebnis entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>.  
  
-   Alle Gleitkommaoperation mit der ungültigen Eingabe. Z. B. durch Aufruf der <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> Methodenrückgabe mit einem negativen Wert <xref:System.Double.NaN>, wie der Aufruf wird die <xref:System.Math.Acos%2A?displayProperty=nameWithType> Methode mit einem Wert, der größer als 1 oder kleiner als eine negative Zahl ist.  
  
-   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Typumwandlungen und die Double-Struktur  
 Die <xref:System.Double> Struktur werden kein explizite oder implizite Konvertierungsoperatoren definiert; stattdessen werden die Konvertierungen vom Compiler implementiert.  
  
 Die Konvertierung des Werts eines beliebigen primitiven numerischen Typs zu einem <xref:System.Double> eine erweiternde Konvertierung ist und daher nicht erfordern einen explizite Umwandlungsoperator oder an eine Konvertierungsmethode aufrufen, es sei denn, sie explizit ein Compiler erfordert. Beispielsweise erfordert der C#-Compiler einen Typumwandlungsoperator für Konvertierungen von <xref:System.Decimal> zu <xref:System.Double>, während das Visual Basic-Compiler nicht der Fall ist. Das folgende Beispiel konvertiert die minimalen oder maximalen Wert von anderen primitiven numerischen Typen zur eine <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Darüber hinaus die <xref:System.Single> Werte <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> konvertieren, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zugeordnet.  
  
 Beachten Sie, dass die Konvertierung des Werts von einigen numerische Typen, die eine <xref:System.Double> Wert kann ein Genauigkeitsverlust umfassen. Wie im Beispiel veranschaulicht, ein Genauigkeitsverlust kann beim Konvertieren von <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, und <xref:System.UInt64> Werte <xref:System.Double> Werte.  
  
 Die Konvertierung von einer <xref:System.Double> Wert mit einem Wert von einem beliebigen anderen primitiven numerischen Datentyp ist eine einschränkende Konvertierung und erfordert eine Umwandlungsoperator (in c#), eine Konvertierungsmethode (in Visual Basic) oder einen Aufruf einer <xref:System.Convert> Methode. Werte, die außerhalb des Bereichs des Zieltyps Daten sind die durch des Zieltyps definiert sind `MinValue` und `MaxValue` Eigenschaften, verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Jedes beliebigen ganzzahligen Typs|Eine <xref:System.OverflowException> -Ausnahme aus, wenn die Konvertierung in einem überprüften Kontext auftritt.<br /><br /> Wenn die Konvertierung in einem nicht geprüften Kontext (die Standardeinstellung in c#) auftritt, wird der Konvertierungsvorgang ist erfolgreich, aber der Wert überläuft.|  
|<xref:System.Decimal>|Ein <xref:System.OverflowException> Ausnahme.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>für negative Werte.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>für positive Werte zulässig sind.|  
  
 Darüber hinaus <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Auslösen einer <xref:System.OverflowException> für Konvertierungen in einem überprüften Kontext, aber diese Werte Überlauf beim Konvertieren zu einer ganzen Zahl in einem nicht geprüften Kontext zu ganzen Zahlen. Für die Konvertierung in <xref:System.Decimal>, sie immer lösen eine <xref:System.OverflowException>. Für die Konvertierung in <xref:System.Single>, konvertieren sie Sie in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>zugeordnet.  
  
 Beachten Sie, dass es sich bei einem Genauigkeitsverlust führen kann, aus der Konvertierung einer <xref:System.Double> Wert in einen anderen numerischen Typ. Bei der Konvertierung von nicht ganzzahligen <xref:System.Double> Werte, wie die Ausgabe des Beispiels zeigt, der Nachkommawert wird abgebrochen, wenn die <xref:System.Double> Wert (wie in Visual Basic) gerundet oder gekürzt (wie in c#). Für die Konvertierung in <xref:System.Decimal> und <xref:System.Single> Werte, die <xref:System.Double> Wert möglicherweise keine genaue Darstellung in den Zieldatentyp.  
  
 Das folgende Beispiel konvertiert eine Zahl von <xref:System.Double> Werte in verschiedene andere numerischen Typen. Die Konvertierungen erfolgen, in einem überprüften Kontext in Visual Basic (Standard) und in c# (aufgrund der der [überprüft](~/docs/csharp/language-reference/keywords/checked.md) Schlüsselwort). Die Ausgabe des Beispiels zeigt das Ergebnis für Konvertierungen in einem überprüften einem nicht geprüften Kontext. Führen Sie Konvertierungen in einem nicht geprüften Kontext in Visual Basic, durch die Kompilierung mit der `/removeintchecks+` Compilerschalter und in c# Auskommentieren der `checked` Anweisung.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung von numerischen Typen finden Sie unter [Typkonvertierung in .NET Framework](~/docs/standard/base-types/type-conversion.md) und [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleitkomma-Funktion  
 Die <xref:System.Double> Struktur und verwandte Typen bieten Ihnen Methoden zum Ausführen von Vorgängen in den folgenden Bereichen:  
  
-   **Vergleich der Werte**. Sie erreichen die <xref:System.Double.Equals%2A> Methode, um zu bestimmen, ob zwei <xref:System.Double> Werte gleich sind, oder die <xref:System.Double.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten festzulegen.  
  
     Die <xref:System.Double> Struktur unterstützt auch einen kompletter Satz von Vergleichsoperatoren. Sie können z. B. auf Gleichheit oder Ungleichheit testen oder bestimmen, ob ein Wert größer als oder gleich einem anderen ist. Wenn einer der Operanden ein numerischer Typ, außer ist eine <xref:System.Double>, Konvertierung in einen <xref:System.Double> vor dem Vergleich.  
  
    > [!WARNING]
    >  Aufgrund der Unterschiede in Genauigkeit zwei <xref:System.Double> Werte, die voraussichtlich identisch sein können berücksichtigt, werden die wirkt sich auf das Ergebnis des Vergleichs verwandeln. Finden Sie unter der [Testen auf Gleichheit](#Equality) Abschnitt, um weitere Informationen zum Vergleichen von zwei <xref:System.Double> Werte.  
  
     Sie können auch aufrufen, die <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, und <xref:System.Double.IsNegativeInfinity%2A> Methoden für diese speziellen Werte testen.  
  
-   **Mathematische Operationen**. Allgemeine arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division, werden durch Sprachcompiler und Common Intermediate Language (CIL) Anweisungen anstelle von implementiert <xref:System.Double> Methoden. Wenn einer der Operanden in einer mathematischen Operation einen numerischen Typ, außer handelt einem <xref:System.Double>, Konvertierung in eine <xref:System.Double> vor dem Ausführen des Vorgangs. Das Ergebnis des Vorgangs ist ebenfalls eine <xref:System.Double> Wert.  
  
     Andere mathematischen Operationen ausgeführt werden können, durch den Aufruf `static` (`Shared` in Visual Basic) Methoden in der <xref:System.Math?displayProperty=nameWithType> Klasse. Es enthält zusätzliche Methoden, die häufig für arithmetische Operationen verwendet (z. B. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. B. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>), und Analysis (z. B. <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     Sie können auch den einzelnen Bit in Bearbeiten einer <xref:System.Double> Wert. Die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> -Methode behält eine <xref:System.Double> Wert des Bitmuster in einer 64-Bit-Ganzzahl. Die <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> Methode gibt die Bitmuster in ein Bytearray zurück.  
  
-   **Rundung**. Rundung wird häufig als eine Technik verwendet zur Verringerung der Auswirkungen der Unterschiede zwischen den Werten, die aufgrund von Problemen mit der gleitkommadarstellung und Genauigkeit. Runden Sie können eine <xref:System.Double> -Wert durch Aufrufen der <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode.  
  
-   **Formatieren von**. Sie können konvertieren eine <xref:System.Double> Wert in seine Zeichenfolgendarstellung durch Aufrufen der <xref:System.Double.ToString%2A> Methode oder mithilfe der Funktion für kombinierte Formatierung. Weitere Informationen dazu, wie die Zeichenfolgendarstellung von Gleitkommawerten Formatzeichenfolgen gesteuert werden, finden Sie unter der [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md) Themen.  
  
-   **Analysieren von Zeichenfolgen**. Sie können die angegebene Zeichenfolgendarstellung eines Gleitkommawerts auf Konvertieren einer <xref:System.Double> Wert durch den Aufruf eines der <xref:System.Double.Parse%2A> oder <xref:System.Double.TryParse%2A> Methode. Wenn der Analysevorgang misslingt, die <xref:System.Double.Parse%2A> Methode eine Ausnahme auslöst, während die <xref:System.Double.TryParse%2A> -Methode zurückkehrt `false`.  
  
-   **Typkonvertierung**. Die <xref:System.Double> Struktur stellt eine explizite Implementierung für die <xref:System.IConvertible> -Schnittstelle, die Konvertierung zwischen jeder zwei standardmäßigen .NET Framework-Datentypen unterstützt. Sprachcompiler unterstützen auch die implizite Konvertierung von Werten von allen anderen standardmäßigen numerischen Typen zur <xref:System.Double> Werte. Konvertierung eines Werts eines beliebigen standardmäßigen numerischen Typs zu einem <xref:System.Double> ist eine erweiternde Konvertierung und den Benutzer eine Umwandlungsmethode Operator oder Konvertierung ist nicht erforderlich  
  
     Allerdings Konvertierung <xref:System.Int64> und <xref:System.Single> Werte können ein Genauigkeitsverlust verwendet. In der folgenden Tabelle sind die Unterschiede in der Genauigkeit für jeden dieser Typen aufgeführt:  
  
    |Typ|Die maximale Genauigkeit|Interne Genauigkeit|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 Dezimalstellen|19 Dezimalstellen|  
    |<xref:System.Single>|7 Dezimalstellen.|9 Dezimalstellen|  
  
     Das Problem der Genauigkeit am häufigsten wirkt sich auf <xref:System.Single> Werte, die konvertiert werden <xref:System.Double> Werte. Im folgenden Beispiel zwei Werte, die durch identische Divisionsoperationen erstellte sind ungleich, da einer der Werte wird eine Gleitkommazahl mit einfacher Genauigkeit Datenpunktwert konvertiert eine <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Elemente, die angezeigt werden, so ändern Sie den Zustand der Instanz zurückgeben tatsächlich eine neue Instanz mit dem neuen Wert initialisiert. Als müssen mit einem beliebigen anderen Typ Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch ein Schloss auf Threadsicherheit geschützt werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit doppelter Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit doppelter Genauigkeit und gibt eine Ganzzahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Diese Instanz ist kleiner als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz ist gleich <paramref name="value" />.  
  
 - oder -   
  
 Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" />, oder <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Diese Instanz ist größer als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommawerte abhängt, ist es üblich sind, um die Genauigkeit verloren gehen und deren Werte mit Ausnahme von ihren letzten gültigen Ziffern fast identisch sein. Deswegen den Rückgabewert der <xref:System.Double.CompareTo%2A> Methode manchmal mag überraschenden. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert erzeugt z. B. sollte den ursprünglichen Wert. Im folgenden Beispiel stellt jedoch der berechnete Wert heraus größer als der ursprüngliche Wert sein. Anzeigen von alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der berechnete Wert der ursprüngliche Wert in der letzten gültigen Ziffern unterscheiden. Informationen zur Behandlung von solche Vergleiche, finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> Schnittstelle und führt etwas bessere Leistung als die <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> Methode, da sie keinen konvertieren die `value` Parameter für ein Objekt.  
  
 Beachten Sie, dass, obwohl ein Objekt, dessen Wert <xref:System.Double.NaN> ist nicht gleich einem anderen Objekt, dessen Wert, berücksichtigt <xref:System.Double.NaN> (sogar selbst), die <xref:System.IComparable%601> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Double.CompareTo%2A> Methode, in dem der Parametertyp weniger Bits aufweist (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführt, die den Parameter als einen Typ mit wie vielen Bits wie die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Double> und der Parametertyp ist <xref:System.Int32>. Der Microsoft C#-Compiler generiert Anweisungen, um die Darstellung des Werts des Parameters als eine <xref:System.Double> -Objekt, und generiert dann eine <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> Methode, die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen von numerischen Typen durchführt. Weitere Informationen finden Sie unter der [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generische Versionen der <xref:System.Double.CompareTo%2A> Methode für verschiedene Wert- und Referenztypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Eine negative ganze Zahl  
  
 </term><description>Diese Instanz ist kleiner als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz ist gleich <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz und <paramref name="value" /> sind beide <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, oder <see cref="F:System.Double.NegativeInfinity" /> </description> </item> <item> <term> eine positive ganze Zahl  
  
 </term><description>Diese Instanz ist größer als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
 - oder -   
  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss `null` oder einer Instanz von `Double`ist, andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Double>, unabhängig vom Wert wird als größer betrachtet `null`.  
  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommawerte abhängt, ist es üblich sind, um die Genauigkeit verloren gehen und deren Werte mit Ausnahme von ihren letzten gültigen Ziffern fast identisch sein. Deswegen den Rückgabewert der <xref:System.Double.CompareTo%2A> Methode manchmal mag überraschenden. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert erzeugt z. B. sollte den ursprünglichen Wert. Im folgenden Beispiel stellt jedoch der berechnete Wert heraus größer als der ursprüngliche Wert sein. Anzeigen von alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der berechnete Wert der ursprüngliche Wert in der letzten gültigen Ziffern unterscheiden. Informationen zur Behandlung von solche Vergleiche, finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode implementiert wird, zur Unterstützung der <xref:System.IComparable> Schnittstelle. Beachten Sie, dass, obwohl ein <xref:System.Double.NaN> ist nicht als gleich einem anderen <xref:System.Double.NaN> (sogar selbst), die <xref:System.IComparable> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `CompareTo` im Kontext des `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Double" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Double.Epsilon> Eigenschaft gibt den kleinsten positiven <xref:System.Double> Wert, der in numerischen Operationen oder Vergleichen signifikant ist bei den Wert des der <xref:System.Double> Instanz ist 0 (null). Z. B. der folgende Code zeigt, die 0 (null) und <xref:System.Double.Epsilon> gelten als ungleiche Werte während 0 (null) und die Hälfte der Wert der <xref:System.Double.Epsilon> als gleich betrachtet werden.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesagt, die floating Point Format besteht aus einer Anmeldung, eine 52-Bit-Mantisse oder Signifikanden und einen 11-Bit-Exponenten. Wie im folgenden Beispiel wird gezeigt, verfügt über 0 (null), Exponenten-1022 und einer Mantisse 0. <xref:System.Double.Epsilon>verfügt über einen Exponenten der-1022 und einer Mantisse 1. Dies bedeutet, dass <xref:System.Double.Epsilon> ist die kleinste Positive <xref:System.Double> -Wert größer als 0 (null) und stellt den kleinstmöglichen Wert und das kleinste mögliche Inkrement für eine <xref:System.Double> , deren Exponent ist-1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Allerdings die <xref:System.Double.Epsilon> Eigenschaft ist für ein allgemeines Maß für die Genauigkeit des nicht die <xref:System.Double> geben; gilt nur für <xref:System.Double> Instanzen, die einen Wert von 0 (null) oder ein Exponent der-1022 verfügen.  
  
> [!NOTE]
>  Der Wert, der die <xref:System.Double.Epsilon> Eigenschaft ist nicht gleichbedeutend mit Epsilon für Computer, die Obergrenze des relativen Fehlers durch runden in Gleitkommazahlen dar.  
  
 Der Wert dieser Konstanten ist 4.94065645841247e-324.  
  
 Zwei offensichtlich gleichwertige Gleitkommazahlen möglicherweise aufgrund der Unterschiede in ihren letzten gültigen Ziffern nicht gleich. Z. B. den C#-Ausdruck, `(double)1/3 == (double)0.33333`, lässt nicht gleich vergleichen, da die Division auf der linken Seite maximalen Genauigkeit ausgeführt, während die Konstante auf der rechten Seite nur auf die angegebenen Ziffern präzise ist. Wenn Sie einen benutzerdefinierten Algorithmus, der bestimmt erstellen, ob zwei Gleitkommazahlen als gleich betrachtet werden können, wir empfehlen nicht, dass Sie einen Algorithmus den Wert des als Grundlage für die <xref:System.Double.Epsilon> -Konstante, um die zulässigen absolute Differenz für festzulegen die beiden Werte als gleich betrachtet werden.  (In der Regel ist dieser Unterschied deutlich größer als <xref:System.Double.Epsilon>.) Informationen zum Vergleichen von zwei Gleitkommazahlen mit doppelter Genauigkeit-Werten finden Sie unter <xref:System.Double> und <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Anmerkungen zur Plattform  
 Auf ARM-Systemen, den Wert, der die <xref:System.Double.Epsilon> Konstante ist zu klein, um erkannt zu werden, damit er 0 (null) entspricht. Sie können einen alternative Epsilon-Wert, der gleich 2.2250738585072014E definieren-308 stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes <see cref="T:System.Double" />-Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Double" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> Schnittstelle, und führt etwas bessere Leistung als <xref:System.Double.Equals%2A> , da sie keinen konvertieren die `obj` Parameter für ein Objekt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Double.Equals%2A> Methode, in dem der Parametertyp weniger Bits aufweist (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführt, die den Parameter als einen Typ mit wie vielen Bits wie die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Double> und der Parametertyp ist <xref:System.Int32>. Der Microsoft C#-Compiler generiert Anweisungen, um die Darstellung des Werts des Parameters als eine <xref:System.Double> -Objekt, und generiert dann eine <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> Methode, die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen von numerischen Typen durchführt. Weitere Informationen finden Sie unter der [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die <xref:System.Double.Equals%2A> Methode sollte mit Vorsicht verwendet werden, da zwei offensichtlich gleichwertig aufgrund der unterschiedlichen Genauigkeit der beiden Werte berücksichtigt werden können. Im folgenden Beispiel gemeldet, die die <xref:System.Double> .333333 Wert und die <xref:System.Double> Rückgabewert von 1 durch 3 dividiert ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Anstatt Vergleich, Gleichheit, eine Technik wird eine akzeptable relative Rand Unterschied zwischen zwei Werten definieren (z. B.. 001 % einer der Werte). Wenn der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich besagter Rand ist, der Unterschied ist wahrscheinlich aufgrund von Unterschieden bei der Genauigkeit, und daher die Werte als gleich wahrscheinlich sind. Im folgenden Beispiel wird diese Technik um zu.33333 und 1/3, die beiden zu vergleichenden <xref:System.Double> Werte, die im vorherigen Codebeispiel gefunden werden. In diesem Fall sind die Werte gleich.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> minimale Ausdruck definiert, der einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied zwischen zwei ähnliche Werte muss größer sein als <xref:System.Double.Epsilon>. In der Regel ist es oft größer als <xref:System.Double.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie nicht verwenden <xref:System.Double.Epsilon> beim Vergleich von <xref:System.Double> Werte hinsichtlich ihrer Gleichheit.  
  
 Eine zweite Technik wird durch Vergleichen des Unterschieds zwischen zwei Gleitkommazahlen mit einem bestimmten absoluter Wert. Wenn Sie den absoluten Wert kleiner oder gleich der Unterschied besteht darin, sind die Zahlen gleich. Wenn sie größer ist, sind die Zahlen ungleich. Eine Alternative besteht darin nach dem Zufallsprinzip einen absoluten Wert auszuwählen. Dies ist problematisch, jedoch, da eine akzeptable Rand Unterschied für die Größenordnung der der <xref:System.Double> Werte. Eine zweite Alternative nutzt ein Entwurf Bestandteil der Gleitkommaformat: der Unterschied zwischen der Integer-Darstellung von zwei Gleitkommazahlen-Punktwerte gibt die Anzahl der möglichen Gleitkommawerte, die sie trennt. Beispielsweise den Unterschied zwischen 0,0 und <xref:System.Double.Epsilon> beträgt 1, da <xref:System.Double.Epsilon> ist der kleinste darstellbare Wert bei der Arbeit mit einem <xref:System.Double> , dessen Wert ist 0 (null). Im folgenden Beispiel wird diese Technik zum Vergleichen von.33333 und 1/3, die die beiden sind <xref:System.Double> Werte, die im vorangehenden Codebeispiel wird mit der <xref:System.Double.Equals%28System.Double%29> Methode gefunden werden. Beachten Sie, die im Beispiel wird die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> Methode, um einen Gleitkommawert mit doppelter Genauigkeit in die Integer-Darstellung zu konvertieren.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte Gleichheit getestet werden, durch Aufrufen der <xref:System.Double.Equals%2A> -Methode, die Methode gibt `true`. Jedoch wenn zwei <xref:System.Double.NaN> Werte werden mithilfe des Gleichheitsoperators Gleichheit getestet, gibt der Operator `false`. Wenn Sie bestimmen möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (Number, NaN) eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Double.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Double" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Double.Equals(System.Double)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Double.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Double" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Decimal" /> und in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Double.Equals(System.Double)" /> -Methode, während der zweite Vergleich Gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Double.Equals(System.Object)" /> Methode.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Double" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.Equals%2A> Methode sollte mit Vorsicht verwendet werden, da zwei offensichtlich gleichwertig aufgrund der unterschiedlichen Genauigkeit der beiden Werte berücksichtigt werden können. Im folgenden Beispiel gemeldet, die die <xref:System.Double> .3333 Wert und die <xref:System.Double> Division zurückgegebenes 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Alternativen zum Aufrufen der <xref:System.Double.Equals%2A> -Methode finden Sie in der Dokumentation für die <xref:System.Double.Equals%28System.Double%29> überladen.  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> minimale Ausdruck definiert, der einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied zwischen zwei ähnliche Werte muss größer sein als <xref:System.Double.Epsilon>. In der Regel ist es oft größer als <xref:System.Double.Epsilon>.  
  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte Gleichheit getestet werden, durch Aufrufen der <xref:System.Double.Equals%2A> -Methode, die Methode gibt `true`. Jedoch wenn zwei <xref:System.Double.NaN> Werte werden mithilfe des Gleichheitsoperators Gleichheit getestet, gibt der Operator `false`. Wenn Sie bestimmen möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (Number, NaN) eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Double.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Double" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Double.Equals(System.Double)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Double.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Double" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Decimal" /> und in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Double.Equals(System.Double)" /> -Methode, während der zweite Vergleich Gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Double.Equals(System.Object)" /> Methode.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Double" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl minus unendlich oder plus unendlich ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /> entweder <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Double.NaN" />).</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NaN" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.NaN> signalisiert, dass das Ergebnis des Vorgangs nicht definiert ist. Division von 0.0 durch 0.0 ergibt z. B. <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A>Gibt `false` Wenn eine <xref:System.Double> Wert lautet entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>. Um diese Werte zu testen, verwenden die <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, und <xref:System.Double.IsNegativeInfinity%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.NegativeInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.PositiveInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist positive 1. 7976931348623157E + 308.  
  
 Das Ergebnis eines Vorgangs, die überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double?displayProperty=nameWithType> von Addition und Multiplikation Potenzierung Vorgängen führt, wenn das Ergebnis überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist negativ 1. 7976931348623157E + 308.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType> ist <xref:System.Double?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double?displayProperty=nameWithType> Subtraktion und Multiplikation Vorgänge ergibt das Ergebnis ist kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt einen Wert dar, der keine Zahl ist (<see langword="NaN" />). Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt eine Methode oder einen Operator <xref:System.Double.NaN> Wenn das Ergebnis eines Vorgangs ist nicht definiert. Das Ergebnis der Division von 0 durch 0 (null) ist z. B. <xref:System.Double.NaN>, wie im folgende Beispiel gezeigt. (Aber beachten Sie, dass eine Zahl ungleich NULL durch 0 (null) geteilt entweder gibt <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>, je nachdem, auf das Vorzeichen des Divisors identisch.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Darüber hinaus Aufrufen einer Methode mit einer <xref:System.Double.NaN> Wert oder einen Vorgang auf eine <xref:System.Double.NaN> Wert gibt <xref:System.Double.NaN>, wie das folgende Beispiel zeigt.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Verwenden der <xref:System.Double.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Die <xref:System.Double.op_Equality%2A> Operator betrachtet zwei <xref:System.Double.NaN> Werte miteinander berücksichtigt werden. Im allgemeinen <xref:System.Double> Operatoren können nicht verwendet werden, um <xref:System.Double.NaN?displayProperty=nameWithType> mit anderen <xref:System.Double> Werte, obwohl Methoden zum Zeichenfolgenvergleich (z. B. <xref:System.Double.Equals%2A> und <xref:System.Double.CompareTo%2A>) können. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Double> Vergleichsoperatoren und Methoden.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Double.NaN> veranschaulicht:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs ist kleiner als <xref:System.Double.MinValue>.  
  
 Verwendung <xref:System.Double.IsNegativeInfinity%2A> zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_Equality%2A> Methode definiert, den Gleichheitsoperator für <xref:System.Double> Werte.  
  
 Wenn zwei <xref:System.Double?displayProperty=nameWithType> Werte werden mithilfe des Gleichheitsoperators Gleichheit getestet, das Ergebnis ist `false`; zwei <xref:System.Double?displayProperty=nameWithType> Werte nicht als gleich betrachtet werden. Wenn sie auf Gleichheit, durch Aufrufen getestet werden der <xref:System.Double.Equals%2A> -Methode, um das Ergebnis ist `true`.  Wenn Sie bestimmen möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (Number, NaN) eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der den größer-als-oder-gleich-Operator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_Inequality%2A> Methode definiert den Ungleichheitsoperator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der den kleiner-als-oder-gleich-Operator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, oder eine Zeichenfolge der Form:  
  
 [*ws*] [*Anmeldung*] [*ganzzahligen Ziffern*[*,*]]*ganzzahligen Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Es können nur mit einem vorangestellten Plus-oder Minuszeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Aufsetzend *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Tausendergruppen. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|,|Eine kulturspezifische Tausende Trennzeichen.|  
|.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird der Einsatz einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen sind z. B. zulässig, während Währungssymbole nicht sind. Eine feinere für steuern, welche Elemente im zulässig sind `s` aufrufen, damit der Analysevorgang erfolgreich ausgeführt werden kann, die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> oder <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `s` Parameter interpretiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Threadkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge, die unter Verwendung der Formatierungsinformationen einer anderen Kultur zu analysieren, rufen Sie die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> oder <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Double.Parse%28System.String%29>-Methode veranschaulicht.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />ist keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die im vorhanden sein können <c>s</c>. Ein häufig anzugebender Wert ist eine Kombination von <see cref="F:System.Globalization.NumberStyles.Float" /> und <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert, die die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbole), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. Abhängig vom Wert `style`, dauert auch die Form:  
  
 [*ws*] [*$*] [*Anmeldung*] [*ganzzahligen Ziffern*[*,*]]* ganzzahlige Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag|  
|.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen wie positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das 1000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausender-Trennzeichen und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `s` Parameter analysiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode analysiert die zeichenfolgendarstellungen <xref:System.Double> Werte mithilfe der Kultur En-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />ist keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>s</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode wird in der Regel verwendet, um Text zu konvertieren, die in einer Vielzahl von Möglichkeiten, formatiert werden können eine <xref:System.Double> Wert. Beispielsweise kann verwendet werden, um den Text zu konvertieren, der von einem Benutzer in einem Textfeld HTML in einen numerischen Wert eingegeben wird.  
  
 Die `s` Parameter wird der Einsatz einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die durch den angegebenen Kultur `provider`, oder sie können eine Zeichenfolge im Format enthalten:  
  
 [*ws*] [*Anmeldung*]*ganzzahligen Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die die Begriff "Ziffern" enthalten bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+).|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Aufsetzend *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Tausendergruppen. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formate finden Sie unter der [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md) Thema.  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Interpretieren des Formats der bereitstellt `s`. Es ist normalerweise eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder ein <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Schaltfläche mit der click-Ereignishandler, der ein Web Form. Er verwendet das zurückgegebene Array die <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> Eigenschaft um Gebietsschema des Benutzers zu bestimmen. Klicken Sie dann instanziiert einen <xref:System.Globalization.CultureInfo> -Objekt, das diesem Gebietsschema entspricht. Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das zu gehört <xref:System.Globalization.CultureInfo> Objekt wird dann zum Übergeben der <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode, um den Benutzer Konvertieren der Eingabe für eine <xref:System.Double> Wert.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />ist keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die im vorhanden sein können <c>s</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>s</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert, die die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbole), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die durch den angegebenen Kultur `provider`. Abhängig vom Wert `style`, dauert auch die Form:  
  
 [*ws*] [*$*] [*Anmeldung*] [*ganzzahligen Ziffern*,]*ganzzahligen Ziffern*[. [ *Dezimalstellen*]] [E [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente müssen in eckigen Klammern ([und]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag|  
|.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen wie positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das 1000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausender-Trennzeichen und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Interpretieren des Formats der bereitstellt `s`. Es ist normalerweise eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder ein <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, um mehrere zeichenfolgendarstellungen Temperaturwerte zum Zuweisen einer `Temperature` Objekt.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />ist die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs übersteigt <xref:System.Double.MaxValue>.  
  
 Verwendung <xref:System.Double.IsPositiveInfinity%2A> zu bestimmen, ob ein Wert plus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Double" />-Wert konvertiert werden soll.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Implementierung, die kulturspezifische Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString> -Methode formatiert einen <xref:System.Double> Wert in der Standardeinstellung ("G" oder Allgemeines) Format der aktuellen Kultur. Wenn Sie ein anderes Format, die Genauigkeit oder die Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder die Genauigkeit|Standardkultur (aktueller)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Anmeldung] Ganzzahl-Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die die Begriff "Ziffern" enthalten bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. In der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*Anmelden*|Ein negatives Vorzeichen oder Pluszeichen.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|'*.*'|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl angeben.|  
|"*e*"|Ein Kleinbuchstabe "e", der angibt, Exponentialschreibweise (wissenschaftlich).|  
|*exponentielle Ziffern*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardeinstellung <xref:System.Double.ToString?displayProperty=nameWithType> zeichenfolgendarstellungen, die eine Anzahl von anzuzeigenden Methode <xref:System.Double> Werte.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Double> Wert in der Standardeinstellung ("G" oder Allgemeines) Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard (aktueller)|<xref:System.Double.ToString>|  
|Ein bestimmtes Format oder die Genauigkeit|Standardkultur (aktueller)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Anmeldung] Ganzzahl-Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die die Begriff "Ziffern" enthalten bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. In der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*Anmelden*|Ein negatives Vorzeichen oder Pluszeichen.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|'*.*'|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl angeben.|  
|"*e*"|Ein Kleinbuchstabe "e", der angibt, Exponentialschreibweise (wissenschaftlich).|  
|*exponentielle Ziffern*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 Diese Instanz wird mit dem allgemeinen numerische Formatbezeichner ("G") formatiert.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert wird mit formatiert die <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Zeichenfolgendarstellung von zwei <xref:System.Double> Werte mit <xref:System.Globalization.CultureInfo> Objekte, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>unter Berücksichtigung einer <xref:System.String> und ein <xref:System.IFormatProvider> als Parameter.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%29> -Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format mit den Konventionen der aktuellen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder die angegebene Zeichenfolgendarstellung einer Zahl entsprechend den Angaben von `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerische Standardformatbezeichner außer D und X sowie eine beliebige Kombination von benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge, die den Rückgabewert mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 15 Stellen <xref:System.Double.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` mit der "G17" Format-Spezifikation, die immer 17 Ziffern Genauigkeit oder "R" zurückgibt, wobei 15 Ziffern zurückgegeben, wenn die Anzahl mit weiterhin Genauigkeit bzw. 17 Ziffern dargestellt werden kann, wenn die Zahl nur werden kann wird mit einer maximalen Genauigkeit dargestellt.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen numerischen Wert und formatiert diese als Währungswert mit der "C" standardmäßige Zahlenformatzeichenfolge und als numerischen Wert auf drei Dezimalstellen mithilfe der standardmäßigen numerischen Formatierungszeichenfolge von "N". Die Ergebniszeichenfolgen werden mit den Konventionen der Kultur En-US formatiert. Weitere Informationen auf numerische Formatzeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 Das folgende Beispiel zeigt mehrere <xref:System.Double> Werte mit den unterstützten standardmäßigen Zahlenformatbezeichner zusammen mit drei benutzerdefinierte numerische Formatzeichenfolgen. Eines dieser benutzerdefinierten Formatzeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit führenden Nullen. Darüber hinaus verwendet das Beispiel mit einfacher Genauigkeit Spezifizierer, mit jeder Standardformatbezeichner "R" mit Ausnahme von. Die Werte von der Genauigkeit Spezifizierer zwischen 0 und 3. Um die numerischen Werte in Zeichenfolgen zu konvertieren, wird im Beispiel die Formatierungskonventionen der Kultur En-US verwendet.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
        <block subset="none" type="usage">
          <para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
 [!code-csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)]
 [!code-vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder die Genauigkeit|Standardkultur (aktueller)|<xref:System.Double.ToString%28System.String%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder die angegebene Zeichenfolgendarstellung einer Zahl entsprechend den Angaben von `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerische Standardformatbezeichner außer D und X sowie eine beliebige Kombination von benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge ist, der Rückgabewert für diese Instanz mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert wird mit formatiert die <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 15 Stellen <xref:System.Double.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` mit der "G17" Format-Spezifikation, die immer 17 Ziffern Genauigkeit oder "R" zurückgibt, wobei 15 Ziffern zurückgegeben, wenn die Anzahl mit weiterhin Genauigkeit bzw. 17 Ziffern dargestellt werden kann, wenn die Zahl nur werden kann wird mit einer maximalen Genauigkeit dargestellt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Double> -Wert mit den einzelnen unterstützten numerischen Standardformatbezeichnern für verschiedene Kulturen.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>unter Berücksichtigung einer <xref:System.String> und ein <xref:System.IFormatProvider> als Parameter.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
 [!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)]
 [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="result">Wenn diese Methode zurückgibt, enthält die Gleitkommazahl mit doppelter Genauigkeit-Anzahl-Entsprechung des der <c>s</c> -Parameters, wenn die Konvertierung erfolgreich abgeschlossen wurde, oder NULL, wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn die <c>s</c> Parameter ist <see langword="null" /> oder <see cref="F:System.String.Empty" />, ist keine Zahl in einem gültigen Format oder eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" />. Dieser Parameter wird nicht initialisiert übergeben; Jeder Wert, der ursprünglich im bereitgestellten <c>Ergebnis</c> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, mit der Behandlung von Ausnahmen für Testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (Zeichenfolgenvergleich wird die Groß-/Kleinschreibung beachtet) oder eine Zeichenfolge der Form:  
  
 [ws] [anmelden] [ganzzahligen Ziffern,] ganzzahligen Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern] [ws]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein negatives Vorzeichen oder Pluszeichen.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die die Nachkommastellen der Zahl angeben.|  
|*E*|Ein klein-oder Großbuchstaben und Zeichen "e", der Exponentialschreibweise (wissenschaftlich) angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formate finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `s` Parameter wird durch eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausendertrennzeichen Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> methodenüberladung.  
  
 Die `s` Parameter analysiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analysieren eine Zeichenfolge unter Verwendung der Formatierungsinformationen einer anderen Kultur angegeben, verwenden Sie die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Wenn es eine Trennzeichen in kommt die `s` Parameter bei einem Analysevorgang und der Dezimal- und Gruppentrennzeichen identisch sind, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen und Gruppentrennzeichen ist. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> Methode, um die zeichenfolgenentsprechungen von numerischen Werten zu konvertieren <xref:System.Double> Werte. Es wird davon ausgegangen, dass die aktuelle Kultur "En-US".  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" /> Werte, die das zulässige Format von <c>s</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" /> , liefert kulturspezifische Formatierungsinformationen zu <c>s</c>.</param>
        <param name="result">Wenn diese Methode zurückgibt, enthält eine Gleitkommazahl mit doppelter Genauigkeit-Anzahl-Entsprechung der dem numerischen Wert oder Symbol in enthaltenen <c>s</c>, wenn die Konvertierung erfolgreich abgeschlossen wurde, oder NULL, wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn die <c>s</c> Parameter ist <see langword="null" /> oder <see cref="F:System.String.Empty" />, befindet sich nicht in einem mit kompatiblen Format <c>Stil</c>, eine Zahl kleiner als <see cref="F:System.SByte.MinValue" /> größeroder<see cref="F:System.SByte.MaxValue" />, oder wenn <c>Stil</c> ist keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" /> -Enumerationskonstanten. Dieser Parameter wird nicht initialisiert übergeben; Jeder Wert, der ursprünglich im bereitgestellten <c>Ergebnis</c> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.TryParse%2A> Methode entspricht der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, außer diese Methode keine Ausnahme auslöst, wenn die Konvertierung fehlschlägt. Wenn die Konvertierung erfolgreich ist, ist der Rückgabewert `true` und `result` Parameter auf das Ergebnis der Konvertierung festgelegt ist. Wenn die Konvertierung fehlschlägt, ist der Rückgabewert `false` und `result` Parameter auf 0 (null) festgelegt ist. Hierdurch entfällt die Notwendigkeit, Ausnahmebehandlung zum Testen verwenden eine <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur erkennbar `provider`. Darüber hinaus, abhängig vom Wert der `style`die `s` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [ws] [$] [anmelden] [ganzzahligen Ziffern,] [.fractional-Ziffern] [-e [Anmeldung] exponentiellen-Ziffern] Ganzzahl-Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Es stehen am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, indem die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode der `provider` Parameter. Das Währungssymbol stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen. Tausendertrennzeichen der aktuellen Kultur Trennzeichen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, der angibt, dass `s` kann eine Zahl, die mit der Exponentialschreibweise darstellen. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn Style enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die nicht unbedingt in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können auch Exponentialschreibweise. Dieses Flag allein unterstützt Werte im Formular *ganzzahligen Ziffern*E*exponentiellen Ziffern*; zusätzliche Flags sind erforderlich, um erfolgreich analysieren von Zeichenfolgen in Exponentialschreibweise mit Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die * $ * Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` Parameter keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (*,),* und Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Formatvorlagen außer `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` ist `null` oder ein <xref:System.Globalization.NumberFormatInfo> Objekt kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Kultur verwendet.  
  
 Die Konvertierung schlägt fehl, wenn die `s` Parameter ist `null` oder des numerischen Werts, der `provider` Parameter keine Arbeitsvorgänge zugunsten von einer <xref:System.Globalization.NumberFormatInfo> -Objekt, oder die `style` Parameter ist keine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> -Enumeration.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich. Darüber hinaus versucht, die Zeichenfolgendarstellung eines analysieren <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst ein <xref:System.OverflowException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> Methode, um die Darstellung von Zahlen zu analysieren, das einen bestimmten nachrichtenstil haben und mit den Konventionen einer bestimmten Kultur formatiert sind.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
