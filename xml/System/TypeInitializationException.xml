<Type Name="TypeInitializationException" FullName="System.TypeInitializationException">
  <TypeSignature Language="C#" Value="public sealed class TypeInitializationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit TypeInitializationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.TypeInitializationException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Die Ausnahme, die als Wrapper um die von dieser Klasseninitialisierung ausgelöste Ausnahme ausgelöst wird. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Initialisierung eines Typs durch eine Klasseninitialisierung fehlschlägt, wird eine <xref:System.TypeInitializationException> erstellt. Dieser Ausnahme wird dann ein Verweis auf die Ausnahme übergeben, die durch die Klasseninitialisierung des Typs ausgelöst wurde. Die <xref:System.Exception.InnerException%2A> Eigenschaft <xref:System.TypeInitializationException> enthält die zugrunde liegende Ausnahme.  
  
 In der Regel die <xref:System.TypeInitializationException> Ausnahme widerspiegelt eine schwerwiegende Bedingung (die Laufzeit ist nicht möglich, einen Typ zu instanziieren), die verhindert, dass eine Anwendung nicht fortgesetzt werden kann.  In den meisten Fällen die <xref:System.TypeInitializationException> als Antwort auf eine Änderung in der ausgeführten Umgebung der Anwendung ausgelöst wird. Folglich außer möglicherweise für die Problembehandlung für Debugcode die Ausnahme nicht behandelt werden sollen einer `try` / `catch` Block. Stattdessen, die Ursache der Ausnahme sollte untersucht und beseitigt werden.  
  
 <xref:System.TypeInitializationException>wird mit dem Wert 0 x 80131534 HRESULT COR_E_TYPEINITIALIZATION verwendet.  
  
 Eine Liste der anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.TypeInitializationException>, finden Sie unter der <xref:System.TypeInitializationException.%23ctor%2A> Konstruktoren.  
  
 Den folgenden Abschnitten werden einige Situationen, in denen eine <xref:System.TypeInitializationException> Ausnahme wird ausgelöst.  
  
 [Statische Konstruktoren und der TypeInitializationException-Ausnahme](#Static)   
 [Timeoutwerte für reguläre Ausdrücke übereinstimmen](#Timeout)   
 [Kalender und kulturellen Daten](#Calendars)  
  
<a name="Static"></a>   
## <a name="static-constructors-and-the-typeinitializationexception-exception"></a>Statische Konstruktoren und der TypeInitializationException-Ausnahme  
 Ein statischer Konstruktor, wird wenn vorhanden, automatisch von der Laufzeit aufgerufen vor dem Erstellen einer neuen Instanz eines Typs. Statische Konstruktoren können von einem Entwickler explizit definiert werden. Wenn ein statischer Konstruktor nicht explizit definiert ist, erstellen Compiler automatisch einen Eintrag, um alle initialisieren `static` (in c#) oder `Shared` (in Visual Basic) Member dieses Typs.  Weitere Informationen bei statischen Konstruktoren finden Sie unter [statische Konstruktoren](~/docs/csharp/programming-guide/classes-and-structs/static-constructors.md).  
  
 In den meisten Fällen eine <xref:System.TypeInitializationException> Ausnahme wird ausgelöst, wenn ein statischer Konstruktor kann nicht auf einen Typ zu instanziieren.  Die <xref:System.Exception.InnerException%2A> Eigenschaft gibt an, warum der statische Konstruktor der Typ instanziiert werden konnte. Einige der häufigsten Ursachen für eine <xref:System.TypeInitializationException> gilt:  
  
 Eine nicht behandelte Ausnahme in einem statischen Konstruktor  
 Wenn in einem statischen Konstruktor eine Ausnahme ausgelöst wird, wird diese Ausnahme umschlossen, einem <xref:System.TypeInitializationException> Ausnahme und der Typ kann nicht instanziiert werden.  
  
 Wie oft diese Ausnahme behandeln schwierig zu ist, dass statische Konstruktoren nicht immer explizit im Quellcode definiert sind. Ein statischer Konstruktor ist in einem Typ vorhanden, wenn:  
  
-   Es wurde explizit als ein Member eines Typs definiert.  
  
-   Der Typ verfügt über `static` (in c#) oder `Shared` (in Visual Basic) Variablen deklariert und in einer einzelnen Anweisung initialisiert. In diesem Fall generiert der Sprachcompiler einen statischen Konstruktor für den Typ an. Sie können überprüfen, wie z. B. mithilfe eines Hilfsprogramms [IL-Disassemblers](~/docs/framework/tools/ildasm-exe-il-disassembler.md). Beim Kompilieren von c# und VB-Compiler des folgenden Beispiels, generieren sie z. B. den IL-Code für einen statischen Konstruktor, der etwa wie folgt:  
  
    ```  
  
    .method private specialname rtspecialname static   
            void  .cctor() cil managed  
    {  
      // Code size       12 (0xc)  
      .maxstack  8  
      IL_0000:  ldc.i4.3  
      IL_0001:  newobj     instance void TestClass::.ctor(int32)  
      IL_0006:  stsfld     class TestClass Example::test  
      IL_000b:  ret  
    } // end of method Example::.cctor  
  
    ```  
  
 Das folgende Beispiel zeigt eine <xref:System.TypeInitializationException> von einer vom Compiler generierte statischen Konstruktor ausgelöste Ausnahme. Die `Example` Klasse enthält eine `static` (in c#) oder `Shared` (in Visual Basic) Feld des Typs `TestClass` , durch die Übergabe des Werts 3 an den Klassenkonstruktor instanziiert wird.  Dieser Wert ist jedoch ungültig. nur die Werte von 0 oder 1 sind zulässig. Daher die `TestClass` -Klasse Konstruktors löst eine <xref:System.ArgumentOutOfRangeException>. Da diese Ausnahme nicht behandelt wird, wird die umschlossen einem <xref:System.TypeInitializationException> Ausnahme.  
  
 [!code-csharp[System.TypeInitializationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/ctorException1.cs#3)]
 [!code-vb[System.TypeInitializationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/CtorException1.vb#3)]  
  
 Beachten Sie, dass die Meldung für die Ausnahme zu zeigt Informationen an die <xref:System.Exception.InnerException%2A> Eigenschaft.  
  
 Eine fehlende Assembly oder ein Daten-Datei  
 Eine häufige Ursache für eine <xref:System.TypeInitializationException> Ausnahme ist, dass eine Assembly oder ein Daten-Datei, die in einer Anwendung Entwicklungs- und Test vorhanden war der Common Language Runtime-Umgebung nicht vorhanden ist. Sie können z. B. im folgende Beispiel für eine Assembly namens Missing1a.dll mithilfe dieser kompilieren Befehlszeilensyntax:  
  
```csharp  
csc /t:library Missing1a.cs  
```  
  
```vb  
vbc Missing1a.vb /t:library  
```  
  
 [!code-csharp[System.TypeInitializationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1a.cs#1)]
 [!code-vb[System.TypeInitializationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1a.vb#1)]  
  
 Sie können dann das folgende Beispiel für eine ausführbare Datei namens Missing1.exe durch einen Verweis auf Missing1a.dll einschließlich kompilieren:  
  
```csharp  
csc Missing1.cs /r:Missing1a.dll  
```  
  
```vb  
vbc Missing1.vb /r:Missing1a.dll  
```  
  
 Wenn Sie umbenennen, verschieben oder Missing1a.dll löschen und des Beispiels ausführen, sie löst jedoch eine <xref:System.TypeInitializationException> Ausnahme und zeigt die Ausgabe im Beispiel gezeigt.  Beachten Sie, dass die Ausnahmemeldung Informationen über die <xref:System.Exception.InnerException%2A> Eigenschaft. In diesem Fall die innere Ausnahme ist eine <xref:System.IO.FileNotFoundException> , die ausgelöst wird, da die Common Language Runtime die abhängige Assembly nicht gefunden.  
  
 [!code-csharp[System.TypeInitializationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1.cs#2)]
 [!code-vb[System.TypeInitializationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1.vb#2)]  
  
> [!NOTE]
>  In diesem Beispiel wird eine <xref:System.TypeInitializationException> Ausnahme wurde ausgelöst, weil eine Assembly nicht geladen werden konnte. Die Ausnahme kann auch ausgelöst werden, wenn ein statischer Konstruktor versucht, eine Datendatei zu öffnen, z. B. eine Konfigurationsdatei, eine XML-Datei oder eine Datei mit Daten, serialisiert, die nicht gefunden werden kann.  
  
<a name="Timeout"></a>   
## <a name="regular-expression-match-timeout-values"></a>Timeoutwerte für reguläre Ausdrücke übereinstimmen  
 Sie können die Standard-Timeoutwert für die Muster eines regulären Ausdrucks Abgleichvorgang regelmäßig pro Anwendungsdomäne festlegen. Das Timeout wird durch eine Angabe definiert eine <xref:System.TimeSpan> Wert für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT", um die <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> Methode. Das Zeitintervall muss eine gültige <xref:System.TimeSpan> Objekt, das größer als 0 (null) und kleiner als ca. 24 Tage. Wenn diese Anforderungen nicht erfüllt sind, löst der Versuch, legen Sie die Standard-Timeoutwert ein <xref:System.ArgumentOutOfRangeException>, die wiederum umgeben in eine <xref:System.TypeInitializationException> Ausnahme.  
  
 Das folgende Beispiel zeigt die <xref:System.TypeInitializationException> , die ausgelöst wird, wenn die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" zugewiesene Wert ungültig ist. Legen Sie die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" zur Beseitigung dieser Ausnahme auf einen <xref:System.TimeSpan> Wert größer als 0 (null) und kleiner als ca. 24 Tage.  
  
 [!code-csharp[System.TypeInitializationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Regex1.cs#4)]
 [!code-vb[System.TypeInitializationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Regex1.vb#4)]  
  
<a name="Calendars"></a>   
## <a name="calendars-and-cultural-data"></a>Kalender und kulturellen Daten  
 Wenn Sie versuchen, einen Kalender zu instanziieren, aber die Laufzeit konnte nicht instanziiert ist die <xref:System.Globalization.CultureInfo> Objekt, das diesen Kalender entspricht, löst eine <xref:System.TypeInitializationException> Ausnahme. Diese Ausnahme kann von der folgenden Kalender Klassenkonstruktoren ausgelöst werden:  
  
-   Der Standardkonstruktor, der die <xref:System.Globalization.JapaneseCalendar> Klasse.  
  
-   Der Standardkonstruktor, der die <xref:System.Globalization.KoreanCalendar> Klasse.  
  
-   Der Standardkonstruktor, der die <xref:System.Globalization.TaiwanCalendar> Klasse.  
  
 Da kulturelle Daten für diese Kulturen auf allen Systemen verfügbar sein sollen, sollten Sie selten, falls überhaupt, diese Ausnahme auftreten.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeInitializationException (string fullTypeName, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fullTypeName, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fullTypeName" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="fullTypeName">Der vollqualifizierte Name des Typs, der nicht initialisiert werden kann.</param>
        <param name="innerException">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn die <c>"InnerException"</c> Parameter ist kein null-Verweis (<see langword="Nothing" /> in Visual Basic), die aktuelle Ausnahme wird ausgelöst, einem <see langword="catch" /> Block, der die innere Ausnahme behandelt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.TypeInitializationException" /> Klasse mit die Standardfehlermeldung, dem angegebenen Typnamen und einen Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme, die als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst wird, kann in der <xref:System.Exception.InnerException%2A>-Eigenschaft über einen Verweis auf die vorhergehende Ausnahme verfügen. Die <xref:System.Exception.InnerException%2A>-Eigenschaft gibt denselben Wert zurück, der an den Konstruktor übergeben wurde, bzw. einen NULL-Verweis (`Nothing` in Visual Basic), wenn die <xref:System.Exception.InnerException%2A>-Eigenschaft nicht den Wert für die innere Ausnahme für den Konstruktor bereitstellt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.TypeInitializationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Der Verweis auf die interne Ausnahme.|  
|<xref:System.Exception.Message%2A>|Die lokalisierte Zeichenfolge mit der Fehlermeldung.|  
|<xref:System.TypeInitializationException.TypeName%2A>|Der Name des Typs.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, die die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
        <param name="context">Der <see cref="T:System.Runtime.Serialization.StreamingContext" />, der die Kontextinformationen über die Quelle oder das Ziel enthält.</param>
        <summary>Legt die <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Objekt mit dem Typnamen und zusätzlichen Informationen zur Ausnahme.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberSignature Language="DocId" Value="P:System.TypeInitializationException.TypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Namen des Typs, der nicht initialisiert werden kann.</summary>
        <value>Der vollqualifizierte Name des Typs, der nicht initialisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
