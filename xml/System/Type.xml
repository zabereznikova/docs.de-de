<Type Name="Type" FullName="System.Type">
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 `Type`Stellt den Stamm der <xref:System.Reflection> Funktionalität und ist die primäre Methode Zugriff auf Metadaten. Verwenden Sie die Elemente der <xref:System.Type> beim Abrufen von Informationen über die Typdeklaration, über die Elemente eines Typs (z. B. die Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse einer Klasse), sowie das Modul und die Assembly, in der die Klasse bereitgestellt wird.  
  
 Es sind keine Berechtigungen erforderlich, damit der Code die Reflexion zum Abrufen von Informationen zu Typen und Member, unabhängig von deren Zugriffsebenen verwenden. Es sind keine Berechtigungen erforderlich, damit Code Reflektion verwenden, um Zugriff auf öffentliche Member oder andere Elemente, deren Zugriffsebenen sie während der normalen Kompilierung sichtbar wäre. Damit Ihr Code auch mithilfe der Reflektion, um auf Member zuzugreifen, die normalerweise nicht zugegriffen werden kann, z. B. private oder interne Methoden werden, oder geschützte Felder eines Typs kann die Klasse erbt nicht, der Code benötigen jedoch <xref:System.Security.Permissions.ReflectionPermission>. Finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type`ist eine abstrakte Basisklasse, die mehrere Implementierungen ermöglicht. Das System wird immer die abgeleitete Klasse bereitstellen `RuntimeType`. In der Reflektion werden alle Klassen, die mit dem Wort Runtime ab nur einmal pro Objekt in der System- und Unterstützung Vergleichsvorgängen erstellt.  
  
> [!NOTE]
>  Multithreading Szenarien nicht sperren <xref:System.Type> Objekte zum Synchronisieren des Zugriffs auf `static` Daten. Anderer Code, über den Sie keine Kontrolle haben kann möglicherweise auch Ihr Klassentyp gesperrt. Dies kann zu einem Deadlock führen. Synchronisieren Sie den Zugriff auf statische Daten stattdessen durch Sperren eines privaten `static` Objekt.  
  
> [!NOTE]
>  Eine abgeleitete Klasse kann geschützte Member der Basisklassen des aufrufenden Codes zugreifen. Darüber hinaus wird der Zugriff auf Assemblymember der Assembly des aufrufenden Codes zugelassen. Wenn es im Code früh gebundene Zugriff zulässig ist er in der Regel auch in spät gebundenem Code zulässig.  
  
> [!NOTE]
>  Schnittstellen, die das Erweitern von anderen Schnittstellen erben nicht die Methoden, die in die erweiterten Schnittstellen definiert.  
  
 In diesem Abschnitt  
  
 [Welche Typen stellt ein Objekt vom Typ dar?](#WhatTypes)   
 [Ein Objekt vom Typ abrufen](#Retrieve)   
 [Vergleichen von Objekten auf Gleichheit](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Welche Typen stellt ein Objekt vom Typ dar?  
 Diese Klasse ist threadsicher. eine Instanz dieses Typs können mehrere Threads gleichzeitig gelesen werden. Eine Instanz von der <xref:System.Type> -Klasse kann eines der folgenden Typen darstellen:  
  
-   Klassen  
  
-   Werttypen  
  
-   Arrays  
  
-   Schnittstellen  
  
-   Enumerationen  
  
-   Delegaten  
  
-   Konstruierte generische Typen und generische Typdefinitionen  
  
-   Typargumenten Sie und Typparametern Sie konstruierte generische Typen, generische Typdefinitionen und generischen Methodendefinitionen  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Ein Objekt vom Typ abrufen  
 Die <xref:System.Type> Objekt zugewiesen ist, mit einem bestimmten Typ kann auf folgende Weise abgerufen werden:  
  
-   Die Instanz <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Type> -Objekt, das den Typ einer Instanz darstellt. Da alle verwaltete Typen abgeleitet sein <xref:System.Object>die <xref:System.Object.GetType%2A> für eine Instanz eines beliebigen Typs können Methoden aufgerufen werden.  
  
     Im folgenden Beispiel wird die <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode, um den Laufzeittyp der einzelnen Objekte in einem Objektarray festzulegen.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Die statische <xref:System.Type.GetType%2A?displayProperty=nameWithType> -Methoden zurückgeben einer <xref:System.Type> -Objekt, das einen durch den vollqualifizierten Namen angegebenen Typ darstellt.  
  
-   Die <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> -Methoden zurückgeben `Type` Objekte, die in einem Modul definierten Typen darstellen. Die erste Methode verwendet werden kann, zum Abrufen eines Arrays von <xref:System.Type> Objekte für alle öffentlichen und privaten Typen, die in einem Modul definiert. (Sie erhalten eine Instanz von `Module` über die <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> -Methode, oder über die <xref:System.Type.Module%2A?displayProperty=nameWithType> Eigenschaft.)  
  
-   Die <xref:System.Reflection.Assembly?displayProperty=nameWithType> Objekt enthält eine Reihe von Methoden zum Abrufen der Klassen in einer Assembly, einschließlich definiert <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Type.FindInterfaces%2A> Methode gibt eine gefilterte Liste von Schnittstellentypen, die von einem Typ unterstützt.  
  
-   Die <xref:System.Type.GetElementType%2A> Methode gibt ein `Type` Objekt, das das Element darstellt.  
  
-   Die <xref:System.Type.GetInterfaces%2A> und <xref:System.Type.GetInterface%2A> -Methoden zurückgeben <xref:System.Type> Objekte, die von einem Typ unterstützten Schnittstellentypen darstellt.  
  
-   Die <xref:System.Type.GetTypeArray%2A> Methode gibt ein Array von <xref:System.Type> Objekten, die von einer beliebigen Gruppe von Objekten angegebenen Typen darstellen. Die Objekte sind mit einem Array des Typs angegeben <xref:System.Object>.  
  
-   Die <xref:System.Type.GetTypeFromProgID%2A> und <xref:System.Type.GetTypeFromCLSID%2A> Methoden für COM-Interoperabilität bereitgestellt werden. Diese Zurückgeben einer <xref:System.Type> Objekt, das den vom angegebenen Typ darstellt eine `ProgID` oder `CLSID`.  
  
-   Die <xref:System.Type.GetTypeFromHandle%2A> Methode wird bereitgestellt, für die Interoperabilität. Es gibt eine `Type` Objekt, das durch ein Klassenhandle angegebenen Typ darstellt.  
  
-   Die C#- `typeof` -Operator, der C++ `typeid` Operator und die Visual Basic `GetType` Operator erhalten die `Type` Objekt für einen Typ.  
  
-   Die <xref:System.Type.MakeGenericType%2A> Methode gibt ein <xref:System.Type> Objekt einen konstruierten generischen Typ, der einen offenen konstruierten Typ ist, darstellt, seine <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, und einem geschlossenen konstruierten Typ andernfalls. Ein generischer Typ kann instanziiert werden, nur dann, wenn er geschlossen wurde.  
  
-   Die <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, und <xref:System.Type.MakeByRefType%2A> -Methoden zurückgeben <xref:System.Type> Objekte, die, die ein Array des angegebenen Typs, der einen Zeiger auf einen angegebenen Typ und den Typ des Verweisparameters darstellen (`ref` in c# `ByRef`in Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Vergleichen von Objekten auf Gleichheit  
 Ein <xref:System.Type> -Objekt, stellt ein Typ eindeutig ist, d. h. zwei <xref:System.Type> Objektverweise auf dasselbe Objekt verweisen, wenn sie denselben Typ darstellen. Dies ermöglicht den Vergleich von <xref:System.Type> Objekte mithilfe von Verweisgleichheit. Das folgende Beispiel vergleicht die <xref:System.Type> Objekte, die als von ganzzahligen Werten Zahl, um zu bestimmen, ob sie vom selben Typ sind.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige repräsentative Features von <xref:System.Type>. Die C#- `typeof` Operator (`GetType` Operator in Visual Basic `typeid` -Operator in Visual C++) Dient zum Abrufen einer <xref:System.Type> Objekt darstellt <xref:System.String>. Aus diesem <xref:System.Type> -Objekt, das <xref:System.Type.GetMethod%2A> Methode zum Abrufen einer <xref:System.Reflection.MethodInfo> darstellt der <xref:System.String.Substring%2A> Überladung mit einer Anfangsposition und einer Länge.  
  
 Um die Überladungssignatur zu identifizieren, das Codebeispiel erstellt ein temporäres Array mit zwei <xref:System.Type> Objekte darstellt `int` (`Integer` in Visual Basic).  
  
> [!NOTE]
>  Um genau zu sein, das Array enthält zwei Verweise auf die Instanz von <xref:System.Type> darstellt, die `int` in der aktuellen Anwendungsdomäne. Für jeden Typ, es ist nur eine Instanz des <xref:System.Type> pro Anwendungsdomäne.  
  
 Das Codebeispiel verwendet die <xref:System.Reflection.MethodInfo> zum Aufrufen der <xref:System.String.Substring%2A> -Methode mit der Zeichenfolge "Hello, World!", und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides">
      <para>Beim Erben von <see langword="Type" />, müssen Sie die folgenden Member überschreiben:  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Type" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung von Type-Objekten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.Assembly" /> ab, in der der Typ deklariert ist. Ruft bei generischen Typen die <see cref="T:System.Reflection.Assembly" /> ab, in der der generische Typ definiert ist.</summary>
        <value>Eine <see cref="T:System.Reflection.Assembly" />-Instanz, die die Assembly mit dem aktuellen Typ beschreibt. Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> Objekt einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Assembly, die generische Typdefinition enthält. Nehmen wir beispielsweise an, die Sie erstellen eine Assembly mit dem Namen MyGenerics.dll, die die generische Typdefinition enthält `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic `generic<T> ref class MyGenericStack` in C++). Bei der Erstellung einer Instanz von `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in einer anderen Assembly die <xref:System.Type.Assembly%2A> -Eigenschaft für den konstruierten Typ gibt eine <xref:System.Reflection.Assembly> -Objekt, das MyGenerics.dll darstellt.  
  
 Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> Objekt stellt einen nicht zugewiesenen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert `T`.  
  
 Wenn die <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Eigenschaft nicht auf eine bestimmte Implementierung der .NET, z. B. .NET Core oder universellen Windows-Plattform verfügbar ist, verwenden Sie die <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> Eigenschaft stattdessen.      
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde.</summary>
        <value>Der durch die Assembly qualifizierte Name des <see cref="T:System.Type" />, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde, oder <see langword="null" />, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly qualifizierte Name eines Typs besteht aus den Typnamen, einschließlich des Namespaces, gefolgt von einem Komma, gefolgt von den Anzeigenamen der Assembly. Der Anzeigename einer Assembly abgerufen wird, mit der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Alle Compiler, die die common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Komma (,)|Ist der Name der Assembly vorangestellt.|  
|Pluszeichen (+)|Ist eine geschachtelte Klasse vorangestellt.|  
|Punkt (.)|Gibt die Namespacebezeichner.|  
|Klammern ([])|Nach einem Typnamen gibt Sie ein Array dieses Typs an.<br /><br /> - oder - <br /><br /> Für einen generischen Typ umschließt die Liste der generischen Typargumente.<br /><br /> - oder - <br /><br /> In einer Liste der Typargumente schließt eine Assembly qualifizierten Typnamen.|  
  
 Beispielsweise kann die Assembly qualifizierte Name für eine Klasse wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Wenn der Namespace enthalten ein Pluszeichen (+), z. B. TopNamespace.Sub, würde das Pluszeichen (+) ein Escapezeichen vorangestellt werden (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird. Diese Zeichenfolge würde wie folgt Reflektionsausgabe:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>. Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen. <xref:System.Type.GetType%2A>mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A>mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.  
  
 Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.  
  
 Generische Argumente von generischen Typen werden selbst durch Name der Assembly gekennzeichnet wird. Beispielsweise ist in der Assembly qualifizierte Typname für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` wird erweitert, um die Assembly qualifizierten Typnamen für <xref:System.Int32>.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück `null`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordneten Attribute ab.</summary>
        <value>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt. Falls <see cref="T:System.Type" /> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Member der <xref:System.Reflection.TypeAttributes> Enumeration sind Masken, die eine Gruppe von Werten darstellen. Jede Gruppe enthält ein Element, dessen zugrunde liegenden Wert 0 (null) ist. Z. B. den zugrunde liegenden Wert von der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Gruppe ist 0 (null), ist die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Gruppe. Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie für diese Werte testen. Dies wird im Beispiel veranschaulicht.  
  
> [!TIP]
>  Für die meisten Zwecke Eigenschaften wie <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, und <xref:System.Type.IsSpecialName%2A> sind einfacher zu verwenden als Attribute des Typs.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt die Attribute der generischen Typdefinition. Z. B. die Attribute, die für die zurückgegebenen `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) sind die Attribute des `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typparameter darstellt – d. h. wenn die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` – die <xref:System.Reflection.TypeAttributes> von dieser Eigenschaft zurückgegebene Wert ist nicht angegeben.  
  
   
  
## Examples  
 Das folgende Beispiel verwenden bewirkt, dassdie <xref:System.Type.Attributes%2A> Eigenschaft.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, von dem der aktuelle <see cref="T:System.Type" /> direkt vererbt wird.</summary>
        <value>Der <see cref="T:System.Type" />, von dem der aktuelle <see cref="T:System.Type" /> direkt erbt, oder <see langword="null" />, wenn der aktuelle <see langword="Type" /> die <see cref="T:System.Object" />-Klasse oder eine Schnittstelle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt. <xref:System.Object>ist die einzige Art, die aus diesem Grund keinen Basistyp `null` wird zurückgegeben, als der Basistyp des <xref:System.Object>.  
  
 Schnittstellen werden von keinem oder mehreren Basisschnittstellen erben. Diese Eigenschaft daher gibt `null` Wenn die `Type` Objekt stellt eine Schnittstelle dar. Die Basisschnittstellen können bestimmt werden, mit <xref:System.Type.GetInterfaces%2A> oder <xref:System.Type.FindInterfaces%2A>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, die der Basistyp Version stellt die generische Argumente. Betrachten Sie beispielsweise die folgenden Deklarationen:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Für den konstruierten Typ `C<int>` (`C(Of Integer)` in Visual Basic), wird die <xref:System.Type.BaseType%2A> -Eigenschaft gibt `B<int>`.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typdefinition <xref:System.Type.BaseType%2A> gibt die Class-Einschränkung, d. h. die Klasse, die die Typparameter erben muss. Es ist keine klasseneinschränkung <xref:System.Type.BaseType%2A> gibt <xref:System.Object?displayProperty=nameWithType>.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.BaseType%2A> Eigenschaft.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 Im folgenden Beispiel wird die Rekursion zum Auflisten der vollständige Vererbungshierarchie jede Klasse in einer Assembly gefunden. Im Beispiel definiert eine Klasse namens `C` abgeleitet, die eine Klasse namens `B`, das wiederum leitet sich von einer Klasse mit dem Namen `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz eines Typs zu erstellen, muss keine generischen Typdefinitionen oder offen konstruierte Typen in den Typargumenten des Typs selbst und alle einschließenden generischen Typen und Elemente des Typs vorhanden sein. Anders ausgedrückt: Dies ist bei überprüft rekursiv, der Typ darf keine generische Typparameter.  
  
 Da Typen beliebig komplex sein können, ist dieser Feststellung schwierig. Der Einfachheit halber und reduziert die Wahrscheinlichkeit des Fehlers, der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft bietet eine standardmöglichkeit zum unterscheiden von geschlossener konstruierter Typen, die instanziiert werden kann, und offen konstruierte Typen, die nicht. Wenn die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, der Typ kann nicht instanziiert werden.  
  
 Die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft sucht rekursiv für Typparameter angegeben. Es gibt z. B. `true` für ein Array, dessen Elemente sind `A<T>` (`A(Of T)` in Visual Basic), auch wenn das Array selbst nicht generisch ist. Vergleichen Sie dies mit dem Verhalten von der <xref:System.Type.IsGenericType%2A> Eigenschaft, die zurückgibt `false` für Arrays.  
  
 Für eine Gruppe von Beispielklassen und eine Tabelle, die Werte der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft finden Sie unter <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert dann eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist. Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <xref:System.Int32> und das zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Reflection.MethodBase" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt.</summary>
        <value>Wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt, eine <see cref="T:System.Reflection.MethodBase" />, die die deklarierende Methode darstellt, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die deklarierende Methode ist eine generische Methodendefinition. D. h. wenn <xref:System.Type.DeclaringMethod%2A> keinen zurückgibt `null`, klicken Sie dann `DeclaringMethod.IsGenericMethodDefinition` gibt `true`.  
  
 Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, die in der der generische Typparameter ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.  
  
-   Abrufen der <xref:System.Type.DeclaringMethod%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Reflection.MethodBase> der zurückgegeben wird, indem die <xref:System.Type.DeclaringMethod%2A> Eigenschaft ist entweder eine <xref:System.Reflection.MethodInfo> im Fall einer generischen Methode oder eine <xref:System.Reflection.ConstructorInfo> bei einem generischen Konstruktor.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 sind generische Konstruktoren nicht unterstützt.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine Klasse, die eine generische Methode und weist ein Type-Argument an die Methode aufruft, die sich ergebende konstruierte generische Methode. Es zeigt auch Informationen zur Definition der generischen Methode und die konstruierte Methode. Beim Anzeigen von Informationen über die Typparameter der generischen Methodendefinition, in der `DisplayGenericMethodInfo` -Methode der Beispielcode zeigt den Wert von der <xref:System.Type.DeclaringMethod%2A> -Eigenschaft für generische Typparameter der Methode.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft die generische Typdefinition.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter einer generischen Methode darstellt, gibt diese Eigenschaft den Typ, die generischen Methodendefinition enthält. Wenn der Typ generisch ist, wird die generische Typdefinition zurückgegeben. Der folgende Code gibt also die generische Typdefinition von der <xref:System.Collections.Generic.List%601> generische Klasse, die enthält die <xref:System.Collections.Generic.List%601.ConvertAll%2A> generische Methode:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, in dem der generische Typparameter, ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.  
  
-   Abrufen der <xref:System.Type.DeclaringType%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 In diesem Beispiel wird den deklarierenden Typ von einer Methode in einer abgeleiteten Klasse angezeigt.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> aufgerufen werden sollen.</summary>
        <value>Ein Verweis auf den vom System verwendeten Standardbinder.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardbinder bereitgestellt, mit der common Language Runtime ist außer den speziellen Umständen anwendbar. Wenn Sie benötigen einen Binder, mit denen folgt Regeln, die von den von der angegebenen Standardbinder unterscheiden definiert einen abgeleiteten Typ aus der <xref:System.Reflection.Binder> Klasse, und übergeben Sie eine Instanz dieses Typs unter Verwendung der `binder` Parameter eines der <xref:System.Type.InvokeMember%2A> Überladungen.  
  
 Reflektion modelliert die Zugriffsregeln des allgemeinen Typsystems. Z. B. wenn der Aufrufer in der gleichen Assembly befindet, benötigt der Aufrufer keine besondere Berechtigungen für interne Member. Andernfalls muss der Aufrufer <xref:System.Security.Permissions.ReflectionPermission>. Dies ist konsistent mit der Suche nach Membern, die geschützt werden, private und usw. ein.  
  
 Im Allgemeinen gilt <xref:System.Reflection.Binder.ChangeType%2A> sollten ausführen, nur erweiternde Konvertierungen, die keine Daten verloren gehen. Ein Beispiel für eine erweiternde Konvertierung ist eine Umwandlung einer 32-Bit-Ganzzahl mit Vorzeichen in einen Wert einer 64-Bit-Ganzzahl mit Vorzeichen. Dies ist von der eine einschränkende Konvertierung unterschieden, die Daten verloren gehen können. Ein Beispiel für eine einschränkende Konvertierung ist eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.  
  
 Die folgende Tabelle enthält die Konvertierungen, die von der Standardbinder unterstützt.  
  
|Quelltyp|Zieltyp|  
|-----------------|-----------------|  
|Beliebiger Typ|Der Basistyp.|  
|Beliebiger Typ|Die Schnittstelle implementiert.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Ohne Verweis|Per-Verweis.|  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Standardbinder aus der `DefaultBinder` -Eigenschaft, und ruft Sie ein Mitglied MyClass durch Übergeben der `DefaultBinder` Wert als Parameter an <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trennt Namen im Namespace des <see cref="T:System.Type" />. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein leeres Array vom <see cref="T:System.Type" />-Typ dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt die `EmptyTypes` Feld verwendet wird, in einem von der `GetConstructor` Methoden zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll. Damit der Vergleich erfolgreich <c>o</c> muss umgewandelt oder in ein Objekt vom Typ konvertiert werden können <see cref="T:System.Type" />.</param>
        <summary>Bestimmt, ob der zugrunde liegende des aktuellen Systemtyp <see cref="T:System.Type" /> Objekt ist identisch mit den zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Object" />.</summary>
        <returns>
          <see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />. Diese Methode gibt auch zurück <see langword="false" /> wenn:.  
  
-   <paramref name="o" /> ist <see langword="null" />.  
  
-   <paramref name="o" />kann nicht umgewandelt oder konvertiert einen <see cref="T:System.Type" /> Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Seinem Schattenwurf `o` auf ein Objekt des Typs <xref:System.Type> und ruft die <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Type.Equals%28System.Object%29> verschiedenen vergleichen <xref:System.Type> Objektinstanzen mit verschiedenen <xref:System.Object> Instanzen.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Zwei Dinge sind besonders erwähnenswert zum Beispiel:  
  
-   Beim Vergleich von einer <xref:System.Type> -Objekt, das eine ganze Zahl mit darstellt eine <xref:System.Reflection.TypeInfo> -Objekt, das eine ganze Zahl zurückgegeben darstellt `true` da <xref:System.Reflection.TypeInfo> stammt aus <xref:System.Type>.  
  
-   Beim Vergleich von einer <xref:System.Type> Objekt, das darstellt eine <xref:System.Collections.Generic.IList%601> Objekt (ein offener generischer Typ) mit einer `List(Of String)` -Objekt (einen geschlossenen generischen Typs) zurückgibt `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Type" /> übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird `Equals` , zwei Typen verglichen werden soll.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Attribute verwendeten Memberfilter dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode. Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`. Die `Object` möglicherweise den Wert eines der Felder in den Klassen zugeordnet <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, oder <xref:System.Reflection.MethodImplAttributes>.  
  
 Z. B. die `Object` kann der Wert eines Felds aus zugewiesen werden `FieldAttributes` wie "Public". In diesem Fall, wenn die `FilterAttribute` Delegat aufgerufen wird, wird zurückgegeben, die `true` nur, wenn die Methode über dargestellt die `MemberInfo` Objekt mit dem öffentlichen Feldattribut in den Metadaten ergänzt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `FilterAttribute` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die angegebenen Elemente und ihre Attribute.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode. Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`. Die `Object` ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "*" Platzhalterzeichen. Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.  
  
 Z. B. die `Object` kann den Wert "Byte *" zugewiesen werden. In diesem Fall, wenn die `FilterName` Delegat aufgerufen wird, wird zurückgegeben, die `true` nur, wenn die Methode über dargestellt die `MemberInfo` Objekt verfügt über einen Namen, die mit "Byte" beginnt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die zugeordneten die benutzerdefinierten Methoden `Application` Typ.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode. Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`. Die `Object` ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "*" Platzhalterzeichen. Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.  
  
 Z. B. die `Object` kann den Wert "ByTe *" zugewiesen werden. In diesem Fall, wenn die `FilterName` Delegat wird aufgerufen, es wird nur dann true zurück, wenn die Methode von dargestellt die `MemberInfo` Objekt besitzt einen Namen, die mit "Byte", ignorieren Groß-/Kleinschreibung beginnt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `MemberFilter` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die Methoden und deren Attribute von der `String` -Klasse, die mit dem Buchstaben "c", die Groß-/Kleinschreibung Basiseigenschaft beginnen.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Der Delegat, der die Schnittstellen anhand vergleicht <c>FilterCriteria</c>.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</param>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden, oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn der aktuelle <see cref="T:System.Type" /> keine dem Filter entsprechenden Schnittstellen implementiert oder erbt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Die <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> und <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> Delegaten angegeben wird, indem Sie die <xref:System.Reflection.Module?displayProperty=nameWithType> Klasse kann auch verwendet werden, und in anstelle der der <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegieren.  
  
 Alle von dieser Klasse implementierten Schnittstellen werden während der Suche berücksichtigt, ob von einer Basisklasse oder von der Klasse selbst deklariert.  
  
 Diese Methode sucht in der Basisklasse-Hierarchie, die Rückgabe aller der entsprechenden Schnittstellen, die jede Klasse, sowie alle entsprechenden implementiert Schnittstellen für jede von diesen Schnittstellen implementiert (d. h. der transitive Abschluss von übereinstimmenden Schnittstellen wird zurückgegeben). Es sind keine doppelten Schnittstellen zurückgegeben.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, <xref:System.Type.FindInterfaces%2A> sucht alle Schnittstellen, die in die Einschränkungen für den Typparameter deklariert, und alle Schnittstellen geerbt wird, über die Schnittstellen in der die Einschränkungen deklariert. Wenn die aktuelle <xref:System.Type> stellt ein Typargument eines generischen Typs <xref:System.Type.FindInterfaces%2A> sucht alle Schnittstellen, die durch den Typ implementiert, und zwar unabhängig davon, ob sie Einschränkungen entsprechen.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>können generische Schnittstellen, auch auf Typen zurückgeben, die nicht generische sind. Beispielsweise kann ein nicht generischer Typ implementieren `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).  
  
   
  
## Examples  
 Das folgende Beispiel sucht die angegebene Schnittstelle implementiert oder geerbt werden, durch den angegebenen Typ und zeigt dann die Schnittstellennamen.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Ein Objekt, das den Typ der gesuchten Member angibt.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="filter">Der Delegat, der die Vergleiche ist zurückgeben <see langword="true" /> , wenn der gerade Übereinstimmungen Member betrachtete den <c>FilterCriteria</c> und <see langword="false" /> andernfalls. Sie können die Delegaten <see langword="FilterAttribute" />, <see langword="FilterName" /> und <see langword="FilterNameIgnoreCase" /> dieser Klasse verwenden. Der erste Delegat verwendet als Suchkriterien die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" />, die anderen beiden Delegaten verwenden <see langword="String" />-Objekte als Suchkriterien.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob ein Member im Array von <see langword="MemberInfo" />-Objekten zurückgegeben wird.  
  
 Die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" /> können zusammen mit dem <see langword="FilterAttribute" />-Delegaten dieser Klasse verwendet werden.</param>
        <summary>Gibt ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten mit dem angegebenen Membertyp zurück.</summary>
        <returns>Ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten vom angegebenen Membertyp.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine den Filterkriterien entsprechenden Member vom <paramref name="memberType" />-Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Instance` Instanzmember in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.Static` auf statische Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Gültige Werte für <xref:System.Type.MemberType%2A> im definiert <xref:System.Reflection.MemberInfo>. Wenn keine solchen Member gefunden werden, wird ein leeres Array zurückgegeben.  
  
 Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typ- oder Methodendefinition, <xref:System.Type.FindMembers%2A> verarbeitet alle Member deklariert, indem der Class-Einschränkung und die schnittstelleneinschränkungen des Typparameters.  
  
   
  
## Examples  
 Das folgende Beispiel findet alle Elemente in einer Klasse, die die angegebenen Suchkriterien entsprechen, und zeigt dann die übereinstimmenden Elemente.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</summary>
        <value>Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <see langword="null" />, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <see langword="byref" />-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. den vollqualifizierten Namen des der <xref:System.String> ist `System.String`. Vergleichen Sie dies mit der Assembly qualifizierte Name zurückgegeben werden, indem Sie die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft, die den vollständigen Namen sowie den vollen Assemblynamens besteht.  
  
 Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, die Typargumente in der Zeichenfolge zurückgegeben, durch die <xref:System.Type.FullName%2A> Eigenschaft sind, obwohl die Darstellung des generischen Typparameters selbst nicht von seiner voll qualifiziert wird anhand des Assemblynamens vollständige qualifiziert der Name der Assembly. Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der generische Typdefinition darstellt, und eine, die einen geschlossenen generischen Typs darstellt.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Diese Eigenschaft gibt `null` wenn:  
  
-   Die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt.  
  
     Das folgende Beispiel ruft die Typparameter der <xref:System.Nullable%601> Typ und die Versuche zum Anzeigen seiner <xref:System.Type.FullName%2A> Eigenschaft.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Die aktuelle <xref:System.Type> Objekt stellt einen Arraytyp, ein Zeigertyp oder ein `byref` Typ, der einen generischen Typparameter basiert.  
  
     Das folgende Beispiel definiert einen generischen Typ `Generictype1<T>`, mit drei Methoden: `Display(T[])`, der übergeben wird, ein Array vom Typ T enthalten ist `HandleT(T)`, die ein Objekt auf T übergeben wird und `ChangeValue(ref T)`, die ein T-Objekt als Verweis übergeben wird. Da (c# und Visual Basic nicht als Zeiger in T definieren zulässt, führen Sie die `HandleT` -Methode aufrufen, müssen die <xref:System.Type.MakePointerType%2A> Methode auf die <xref:System.Type> Objekt, das Parametertyp der Methode, um einen Zeiger auf einen generischen Typ erstellen darstellt. Die Ausgabe des Beispiels zeigt, dass in allen drei Fällen die <xref:System.Type.FullName%2A> Eigenschaft ist `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Der aktuelle Typ enthält generische Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`), ist jedoch keine generische Typdefinition (, also die <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft gibt`false`  
  
     Im folgenden Beispiel `Derived<T>` erbt von `Base<T>`. Die <xref:System.Type.BaseType%2A> Eigenschaft ruft die <xref:System.Type> Objekt, das den Basistyp des darstellt `Derived<T>`, und die zugehörige <xref:System.Type.FullName%2A> -Eigenschaft gibt `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Zum Abrufen einer <xref:System.Type.FullName%2A> , die sich nicht `null`, können Sie die <xref:System.Type.GetGenericTypeDefinition%2A> Methode, um die generische Typdefinition abzurufen, wie im Beispiel veranschaulicht.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den vollständigen Namen des angegebenen Typs.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuelle generische Typparameter kovariant ist und die Flags, die besonderen Einschränkungen beschreiben. Verwenden Sie die <xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType> Wert, der die Kovarianzflags auswählen, und Verwenden der <xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType> Wert, der die Einschränkungsflags auswählen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Type" /> Objekt ist keinen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</summary>
        <value>Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert. Die Positionsnummern beginnen mit 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gibt die Position eines Typparameters in der Parameterliste von der generischen Typ- oder Methodendefinition, in dem der Typparameter ursprünglich definiert wurde. Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften identifizieren den generischen Typ- oder Methodendefinition:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.  
  
 Angeben des richtigen Kontexts für den Wert von der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft, es ist notwendig, identifizieren Sie die generischen Typ oder Methode, die ein Typparameter gehört. Betrachten Sie beispielsweise den Rückgabewert der aufgerufenen generischen Methode `GetSomething` in den folgenden Code:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Der zurückgegebene Typ `GetSomething` richtet sich nach der angegebenen Klasse Typargumente `A` und `GetSomething` selbst. Sie erhalten eine <xref:System.Reflection.MethodInfo> für `GetSomething`, und von dem Sie den Rückgabetyp erhalten. Wenn Sie die Typparameter des Rückgabetyps, untersuchen <xref:System.Type.GenericParameterPosition%2A> für beide 0 zurück. Die Position des `V` ist 0, da `V` ist der erste Typparameter in der Typparameterliste für die Klasse `A`. Die Position des `X` ist 0, da `X` ist der erste Typparameter in der Typparameterliste für `GetSomething`.  
  
> [!NOTE]
>  Aufrufen der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft löst eine Ausnahme aus, wenn die aktuelle <xref:System.Type> stellt keinen Parameters für einen Typ dar. Verwenden Sie bei der Überprüfung die Typargumente einer offenen konstruierten Typ müssen die <xref:System.Type.IsGenericParameter%2A> Eigenschaft anzuweisen, die Typparameter und welche Typen sind. Die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für einen Typparameter, können Sie anschließend die <xref:System.Type.GenericParameterPosition%2A> Methode, um seine Position abrufen und Verwenden der <xref:System.Type.DeclaringMethod%2A> und <xref:System.Type.DeclaringType%2A> Eigenschaften bestimmen die generische Methode oder die Typdefinition, der ihn definiert .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist. Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <xref:System.Int32>, und die zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keinen Typparameter dar. Das heißt, <see cref="P:System.Type.IsGenericParameter" /> gibt <see langword="false" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von generischen Typargumenten für diesen Typ ab.</summary>
        <value>Ein Array von generischen Typargumenten für diesen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft nur die generischen Typargumente an. d. h. Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden. Wenn der aktuelle Typ eine generische Typdefinition ist, gibt diese Eigenschaft ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn ein generischer Typ in einer generischen Methode oder einem anderen generischen Typ verwendet wird, möglicherweise einige seiner generische Typargumente generischen Typparameter von einschließenden Methode oder Typ.  
  
 Um die generischen Typparameter eines Typs ab, das eine generische Typdefinition darstellt, verwenden Sie die <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> Eigenschaft. Zum Abrufen einer <xref:System.Reflection.TypeInfo> -Objekt für die aktuelle <xref:System.Type> -Objekts die <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> Erweiterungsmethode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Anzahl der Dimensionen eines Arrays ab.</summary>
        <returns>Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Anzahl der Dimensionen in einem Array.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</exception>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist kein Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.Attributes" />-Eigenschaft und ruft eine Bitmaske ab, die die <see cref="T:System.Type" /> zugeordneten Attribute anzeigt.</summary>
        <returns>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
 - oder -   
  
 Ein leeres Array von <see cref="T:System.Type" />-Objekten zum Abrufen eines Konstruktors ohne Parameter. Das <see langword="static" />-Feld <see cref="F:System.Type.EmptyTypes" /> stellt ein entsprechendes leeres Array bereit.</param>
        <summary>Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</summary>
        <returns>Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um ein Klasseninitialisierer (".cctor") zu erhalten. Um ein Klasseninitialisierer zu erhalten, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode `null`.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ der `MyClass`, ruft der <xref:System.Reflection.ConstructorInfo> -Objekt und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.  
  
 - oder -   
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Das folgende Programm ruft den Typ der `MyClass1` -Klasse ruft die <xref:System.Reflection.ConstructorInfo> -Objekt den angegebenen Bindungsflags und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ der `MyClass1`, ruft der <xref:System.Reflection.ConstructorInfo> Objekt, das den angegebenen Bindungsflags entspricht, und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Diese Methode implementiert <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <see cref="T:System.Type" /> definiert sind.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> -Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen. Wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetConstructors%2A> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück. Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Diese methodenüberladung Ruft die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> -methodenüberladung mit <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Es findet keine Klasseninitialisierer (".cctor"). Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) wird beim Aufrufen <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellt, die `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors%2A> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors> Überladung verwendet nur <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.  
  
 Um statische Konstruktoren zu ermitteln, verwenden Sie die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> überladen, und übergeben Sie die Kombination (logische `OR`) des <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, wie im folgenden Codebeispiel wird gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Jetzt ist die Ausgabe:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <see cref="T:System.Type" /> die für den aktuellen <see langword="BindingFlags" /> definierten Konstruktoren.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen. Gibt ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurück, wenn für den aktuellen <see cref="T:System.Type" /> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetConstructors%2A> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück. Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.  
  
 `bindingAttr`kann verwendet werden, um anzugeben, ob nur öffentliche oder öffentlichen und nicht öffentlichen Konstruktoren zurück.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen. Konstruktoren von Basisklassen werden nicht zurückgegeben.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) wird beim Aufrufen <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellt, die `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors%2A> Überladung verwendet nur <xref:System.Reflection.BindingFlags.Public> und <xref:System.Reflection.BindingFlags.Instance>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.  
  
 Um statische Konstruktoren zu ermitteln, verwenden Sie die <xref:System.Type.GetConstructors%2A> überladen, und übergeben sie die Kombination (logisches OR) von <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Jetzt ist die Ausgabe:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach den für den aktuellen <see cref="T:System.Type" /> definierten Membern, deren <see cref="T:System.Reflection.DefaultMemberAttribute" /> festgelegt ist.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die alle Standardmember des aktuellen <see cref="T:System.Type" /> darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetDefaultMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über eine Eigenschaft `P` zurückgibt `T`Aufrufen <xref:System.Type.GetDefaultMembers%2A> auf `C<int>` gibt `int P` in c# (`Property P As Integer` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen über das Element der `MyClass` und die Standardelemente angezeigt.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Type" /> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</summary>
        <returns>Der <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Type" /> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `null` für die <xref:System.Array> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `GetElementType` Methode.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Name abgerufen werden soll.</param>
        <summary>Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</summary>
        <returns>Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<see langword="null" />, wenn keine solche Konstante gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
 - oder -   
  
 <paramref name="value" />ist nicht vom aktuellen Typ und weist auch nicht den gleichen zugrunde liegenden Typ wie der aktuelle Typ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</summary>
        <returns>Ein Array, das die Namen der Member der Enumeration enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des Arrays Rückgabewert sind nach den Binärwerten (d. h. aus den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert. Wenn das Array Enumerationskonstanten mit demselben Wert enthält, ist die Reihenfolge der entsprechenden Namen nicht angegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</summary>
        <returns>Der zugrunde liegende Typ der aktuellen Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ist der zugrunde liegende Typ einer Enumeration in c# und Visual Basic <xref:System.Int32>. Andere ganzzahlige Typen können angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
 - oder -   
  
 Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</summary>
        <returns>Ein Array, das die Werte enthält. Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <summary>Gibt das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</summary>
        <returns>Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist. Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanz Ereignisse.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein <xref:System.Reflection.EventInfo> -Objekt und ruft das Ereignis für eine Schaltfläche für das angegebene Ereignis ab.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</summary>
        <returns>Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist. Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, um einen Typ für einen öffentlichen oder nicht öffentlichen-Ereignis mit dem Namen "Klicken Sie auf" suchen, die nicht `static` (`Shared` in Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse zurück.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Ereignisse besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist. Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die <xref:System.Type.GetEvents%2A> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.  
  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, ruft die Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt. Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <see cref="T:System.Type" /> definierten oder geerbten Ereignissen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetEvents%2A> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen. Nur geschützte und interne Ereignisse für Basisklassen werden zurückgegeben. Private Ereignisse für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist. Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, die den angegebenen Bindungsflags übereinstimmen Ruft alle Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt. Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <summary>Sucht das öffentliche Feld mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanzfelder.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Type` -Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> Objekt für das Feld und der Wert des Felds angezeigt.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Dies <see cref="T:System.Type" /> Objekt ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> , deren <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> Methode noch nicht aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Type` -Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> Objekt für das Feld, das den angegebenen Bindungsflags entspricht, und zeigt den Wert des Felds.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Felder des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Felder definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields()` Methode.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Felder.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen. Nur geschützte und interne Felder für Basisklassen werden zurückgegeben. private Felder für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields(BindingFlags)` Methode.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente eines generischen Typs darstellen. Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des Arrays werden in der Reihenfolge zurückgegeben, in denen sie in der Liste der Typargumente für den generischen Typ angezeigt werden.  
  
-   Wenn der aktuelle Typ ein geschlossen konstruierter Typ ist (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `false`), das zurückgegebene Array die <xref:System.Type.GetGenericArguments%2A> Methode enthält die Typen, die die generischen Typparameter der generischen Typdefinition zugewiesen wurden .  
  
-   Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter an.  
  
-   Wenn der aktuelle Typ ein offener konstruierten Typ ist (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`) in denen bestimmten Typen nicht für alle Typparameter und die Typparameter von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array Typen und Typparametern. Verwenden der <xref:System.Type.IsGenericParameter%2A> Eigenschaft, um Sie voneinander zu unterscheiden. Eine Demonstration dieses Szenarios, finden Sie im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Type.GetGenericArguments%2A> Methode, um die Typargumente eines konstruierten Typs und die Typparameter der generischen Typdefinition anzuzeigen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft. Siehe das größere Beispiel für die Ausgabe des Beispiels.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Einschränkung für einen generischen Typparameter wird als eine <xref:System.Type> Objekt. Verwenden der <xref:System.Type.IsClass%2A> -Eigenschaft können Sie bestimmen, ob eine Einschränkung der base Class-Einschränkung ist; wenn die Eigenschaft zurückgibt `false`, die Einschränkung ist eine schnittstelleneinschränkung. Wenn ein Typparameter ohne klasseneinschränkung und keine schnittstelleneinschränkungen verfügt, wird ein leeres Array zurückgegeben.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Type" /> Objekt ist keinen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können. Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie erstellen und instanziieren Sie den Typ `G<int>` (`G(Of Integer)` in Visual Basic). Erhält eine <xref:System.Type> Objekt, das dies darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methodenrückgabe die generische Typdefinition.  
  
 Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, verwenden Sie die gleichen Typargumente, die <xref:System.Type.GetGenericTypeDefinition%2A> Methodenrückgabe identisch <xref:System.Type> Objekt für beide Typen.  
  
 Beim Aufrufen der <xref:System.Type.GetGenericTypeDefinition%2A> Methode auf eine <xref:System.Type> Objekt, das bereits eine generische Typdefinition darstellt gibt das aktuelle <xref:System.Type>.  
  
> [!IMPORTANT]
>  Ein Array von generischen Typen ist nicht selbst generisch. In der C#-Code `A<int>[] v;` oder Visual Basic-Code `Dim v() As A(Of Integer)`, den Typ der Variable `v` ist nicht generisch. Verwendung <xref:System.Type.IsGenericType%2A> zu bestimmen, ob ein Typ generisch ist, vor dem Aufruf ist <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz eines konstruierten Typs mithilfe des normalen instanzerstellung und verwendet dann die <xref:System.Type.GetType%2A> und <xref:System.Type.GetGenericTypeDefinition%2A> Methoden zum Abrufen von den konstruierten Typ und die generische Typdefinition. Dieses Beispiel verwendet die generische <xref:System.Collections.Generic.Dictionary%602> Typ, der den konstruierten Typ darstellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüssel.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ ist kein generischer Typ.  Das heißt, <see cref="P:System.Type.IsGenericType" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Der Hashcode für diese Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Hashcode für die `System.Windows.Forms.Button` Klasse.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <summary>Sucht die Schnittstelle mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
> [!NOTE]
>  Bei generischen Schnittstellen die `name` Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (\`) und die Anzahl von Typparametern. Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen. Z. B. mithilfe der Softwareoption `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach ``"IExample`1"``.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Type.GetInterface%28System.String%29> Methode zum Suchen der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Runtime.Serialization.IDeserializationCallback> Schnittstelle und Listen die Methoden der Schnittstelle.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> -methodenüberladung und die <xref:System.Type.GetInterfaceMap%2A> Methode.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Die aktuelle <see cref="T:System.Type" /> stellt einen Typ, die dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <param name="ignoreCase">
          <see langword="true" />ignorieren die Groß-/Kleinschreibung dieses Teils von <c>Namen</c> , die den einfachen Schnittstellennamen (die den Namespace angibt, muss sein Namespaceangabe) angibt.  
  
 - oder -   
  
 <see langword="false" />Groß-/Kleinschreibung gesucht werden soll für alle Teile der <c>Namen</c>.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ignoreCase` Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den Namespace. Der Teil des `name` , die angibt, der Namespace muss die korrekte Groß-/Kleinschreibung, oder die Schnittstelle nicht gefunden werden. Z. B. die Zeichenfolge "System.icomparable" sucht nach der <xref:System.IComparable> -Schnittstelle, die Zeichenfolge "system.icomparable" hingegen nicht.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
> [!NOTE]
>  Bei generischen Schnittstellen die `name` Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (\`) und die Anzahl von Typparametern. Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen. Z. B. mithilfe der Softwareoption `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach `"IExample`1"".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> Methode Groß-/Kleinschreibung nicht beachtet werden soll von der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%29> -methodenüberladung und die <xref:System.Type.GetInterfaceMap%2A> Methode.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Die aktuelle <see cref="T:System.Type" /> stellt einen Typ, die dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</param>
        <summary>Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</summary>
        <returns>Ein Objekt, das die Schnittstellenzuordnung für <paramref name="interfaceType" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die schnittstellenzuordnung gibt an, wie eine Schnittstelle zu den tatsächlichen Elementen auf einer Klasse zugeordnet ist, die diese Schnittstelle implementiert.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen konstruierten generischen Typ, Typ, die Parameter werden durch die entsprechenden Typargumente in den Elementen ersetzt die <xref:System.Reflection.InterfaceMapping> von dieser Methode zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Type.GetInterfaceMap%2A> Methode, um zu bestimmen, wie die <xref:System.IFormatProvider> Schnittstelle ordnet <xref:System.Globalization.CultureInfo> Methoden, und wie die <xref:System.IAppDomainSetup> Schnittstelle ordnet <xref:System.AppDomainSetup> Eigenschaften. Beachten Sie Folgendes: Da die <xref:System.IAppDomainSetup> -Schnittstelle definiert einen Satz von Eigenschaften dar, das zurückgegebene <xref:System.Reflection.InterfaceMapping> Objekt enthält separate <xref:System.Reflection.MethodInfo> Objekte für eine Eigenschaft Get- und Set-Accessoren.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" />wird nicht durch den aktuellen Typ implementiert.  
  
 - oder -   
  
 Die <paramref name="interfaceType" /> Parameter verweist nicht auf eine Schnittstelle.  
  
 - oder -   
  
 <paramref name="interfaceType" />ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Type" /> stellt einen generischen Typparameter, d. h. <see cref="P:System.Type.IsGenericParameter" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> implementierten oder geerbten Schnittstellen darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Schnittstellen implementiert oder geerbt hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetInterfaces%2A> Methode gibt keinen zurück Schnittstellen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Schnittstellen zurückgegeben werden, da, bei der Reihenfolge.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft den Typ der angegebenen Klasse ab und zeigt alle Schnittstellen, die der Typ implementiert oder erbt. Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgenden Compilerbefehle:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</param>
        <summary>Sucht die öffentlichen Member mit dem angegebenen Namen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanzmember.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Diese methodenüberladung wird Klasseninitialisierer (".cctor") nicht gefunden werden. Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle Member der `String` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für `name`, und <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`. Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle öffentlichen statischen Member der `myString` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="type">Der zu suchende Wert.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für `name`, <xref:System.Reflection.MemberTypes?displayProperty=nameWithType> für `type`, und <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`. Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle Methoden der `myString` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Diese methodenüberladung Ruft die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -methodenüberladung mit <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Es findet keine Klasseninitialisierer (".cctor"). Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers> -methodenüberladung, um die Erfassung von Informationen über alle öffentlichen Member einer bestimmten Klasse.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), (<see cref="F:System.Reflection.BindingFlags.Default" />) um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Member.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen. Nur geschützte und interne Member in Basisklassen werden zurückgegeben. Private Member in Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Beim Aufrufen dieser Methode nur mit der `Public` Flag oder nur die `NonPublic` Flag die angegebenen Member zurück, und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -methodenüberladung, um Informationen zu allen öffentlicher Instanzmember einer bestimmten Klasse zu sammeln.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <summary>Sucht die öffentliche Methode mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.  
  
 Wenn eine Methode überladen wird und verfügt über mehr als eine öffentliche Methode, die <xref:System.Type.GetMethod%28System.String%29> -Methode löst eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme. Im folgenden Beispiel wird eine Ausnahme ausgelöst, da es mehr als eine öffentliche Überladung von ist der <xref:System.Int32.ToString%2A?displayProperty=nameWithType> Methode.  Andererseits, da die `Person.ToString` methodenüberschreibungen <xref:System.Object.ToString%2A?displayProperty=nameWithType> und ist daher nicht überladen, die <xref:System.Type.GetMethod%28System.String%29> Methode kann zum Abrufen der <xref:System.Reflection.MethodInfo> Objekt.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:  
  
-   Rufen Sie die <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, und geben Sie einen `bindingAttr` Argument, das die Methode eindeutig identifiziert. Beispielsweise, wenn die Ausnahme ausgelöst wird, da ein Typ eine statische und eine Überladung für die Instanz hat, können Sie angeben einer `bindingAttr` Argument <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
-   Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods> Methode, um ein Array, das alle öffentlichen Methoden, die zu einem Typ gehören enthält abzurufen. Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen `name`.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Methode namens `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> um öffentliche Methoden in die Suche einbeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn eine Methode überladen wird und mehrere Überladungen die Einschränkungen erfüllt, angegeben durch die `bindingAttr` Argument, löst die Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme. Im folgenden Beispiel wird eine Ausnahme ausgelöst, da:  
  
-   Die `TestClass` Typ hat zwei öffentliche Instanz Überladungen der `DisplayValue` Methode `DisplayValue(String)` und `DisplayValue(String, Object[])`.  
  
-   Die `TestClass` Typ hat zwei öffentliche Instanz Überladungen der `Equals` -Methode, von denen geerbt wird, von <xref:System.Object>: `Equals(TestClass)` und `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:  
  
-   Ändern Sie die bindungseinschränkungen. Im vorherigen Beispiel versucht, eine öffentliche Instanz abzurufen `Equals` Methode, die vom Typ deklariert wird und nicht geerbt wurde erfolgreich abgerufen `Equals(TestClass)`.  
  
-   Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> Methode, um ein Array mit allen Methoden, die zu einem Typ gehören, die über die angegebene Bindungsattribute verfügen abzurufen. Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen `name`. Dieser Ansatz wird veranschaulicht, in dem vorherigen Beispiel Handler für das <xref:System.Reflection.AmbiguousMatchException> Ausnahme.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Methode, die den angegebenen Bindungsflags entspricht.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
 - oder -   
  
 Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Die `name` Parameter kann keine Typargumente enthalten. Z. B. den C#-Code `GetMethod("MyGenericMethod<int>")` sucht eine Methode mit dem Textnamen "`MyGenericMethod<int>`", anstatt für eine Methode namens `MyGenericMethod` , die ein generisches Argument des Typs hat `int`. Verwenden Sie stattdessen `GetMethod("MyGenericMethod")` mit dem entsprechenden Parameter in der `types` Array.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, eine Vielzahl von Argumenttypen angeben.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 Das folgende Beispiel ruft <xref:System.Reflection.MethodInfo> Objekte, die darstellen, die `Add` Methoden eines nicht generischen Typs (die <xref:System.Collections.ArrayList> Klasse), ein offener generischer Typ (die <xref:System.Collections.Generic.List%601> Klasse), und einen geschlossenen generischen Typs (die `List(Of String)` Typ.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 Im Beispiel definiert eine `GetAddMethod` Methode, die die entsprechende abruft <xref:System.Reflection.MethodInfo> Objekt. Bereitstellen der `types` Argument für einen offenen generischen Typ, ruft er die <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode. Bereitstellen der `types` Argument für einen geschlossenen generischen Typs, ruft er den Wert des der <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
 - oder -   
  
 Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMethod("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`. Verwenden Sie stattdessen `GetMethod("MyMethod")` mit dem entsprechenden Parameter in der `types` Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
 - oder -   
  
 Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, bindungseinschränkungen sowie eine Vielzahl von Argumenttypen angeben.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
 - oder -   
  
 Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `GetXXX` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, bindungseinschränkungen angeben, das Aufrufen von Konventionen sowie eine Vielzahl von Argumenttypen.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.  
  
 - oder -   
  
 <see langword="null" />. Wenn <c>Typen</c> ist <see langword="null" />, sind keine Übereinstimmung von Argumenten überprüft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Wenn `types` `null` ist, wird keine Übereinstimmung von Argumenten überprüft.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Methoden des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Methoden definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetMethods%2A> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.  
  
 Konstruktoren sind nicht im Array der Methoden, die durch diesen Aufruf zurückgegebene enthalten. Stellen Sie einen separaten Aufruf von `GetConstructors()` Konstruktormethoden abgerufen.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Methoden.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetMethods%2A> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen. Nur geschützte und interne Methoden in Basisklassen werden zurückgegeben. private Methoden in Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, aufrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Klasse mit zwei öffentliche Methoden und einer geschützten Methode, erstellt eine `Type` -Objekt entsprechende `MyTypeClass`Ruft alle öffentliche und nicht öffentlichen Methoden und ihre Namen angezeigt.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <summary>Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet.  
  
 Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`. Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl von generischen Argumenten angefügt werden soll. Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic). Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</summary>
        <returns>Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`. Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl der generischen Parameter angefügt werden soll. Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic). Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ein Ergebnis zurückgegeben.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> öffentliche geschachtelten Typen in die Suche eingeschlossen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.  
  
 Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <xref:System.Type.GetNestedType%2A> auf jeder Ebene.  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>und <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> werden ignoriert.  
  
 Beim Aufrufen dieser Methode nur mit der <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine öffentlichen Typen geschachtelt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.  
  
 Es werden nur die sofort im aktuellen Typ geschachtelten öffentlichen Typen zurückgegeben. die Suche ist nicht rekursiv.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine geschachtelte Klasse und ein `struct` in `MyClass`, und klicken Sie dann ruft Objekte der geschachtelten Typen mit dem Typ der `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das alle im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach geschachtelten Typen ist nicht rekursiv.  
  
 Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ein Ergebnis zurückgegeben.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> öffentliche geschachtelten Typen in die Suche eingeschlossen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.  
  
 Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <xref:System.Type.GetNestedTypes%2A> auf jeder Ebene.  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>und <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> werden ignoriert.  
  
 Beim Aufrufen dieser Methode nur mit der <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zwei geschachtelte öffentliche Klassen und zwei geschachtelte geschützten Klassen, und zeigt Informationen für Klassen, die die angegebenen bindungseinschränkungen entsprechen.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die alle öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Eigenschaften besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Überladung entspricht dem Aufrufen der <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> -Überladung mit einer `bindingAttr` Argument gleich `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# geschrieben und `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. Gibt alle öffentlichen Instanz und statische Eigenschaften, die sowohl die vom aktuellen Typ definiert <xref:System.Type> Objekt als auch solche, die von dessen Basistypen geerbt.  
  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die <xref:System.Type.GetProperties%2A> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetProperties`-Methode gezeigt.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <see cref="T:System.Type" />.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die sämtliche Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die <xref:System.Type.GetProperties%2A> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen. Nur geschützte und interne Eigenschaften für Basisklassen werden zurückgegeben. Private Eigenschaften für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Klasse namens `PropertyClass` sechs Eigenschaften enthält: sind zwei öffentliche werden eine private ist, ist eine geschützt, interne (`Friend` in Visual Basic), und eine interne geschützt ist (`Protected Friend` in Visual Basic). Es zeigt dann einige grundlegende Informationen (den Eigenschaftsnamen und den Typ, ob es sich um Lese-/Schreibzugriff und die Sichtbarkeit der seine `get` und `set` Accessoren) für die Eigenschaften, die die angegebenen bindungseinschränkungen entsprechen.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <summary>Sucht die öffentliche Eigenschaft mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.  
  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
 Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:  
  
-   Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern. Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen, blendet die `new` Modifizierer (`Shadows` in Visual Basic). Um die Mehrdeutigkeit zu beheben, verwenden die <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> -methodenüberladung, und fügen die <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> Flag, um die Suche auf Member zu beschränken, die nicht geerbt werden.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft die `Type` Objekt einer benutzerdefinierten Klasse ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Intern wird diese Eigenschaft in den Metadaten mit dem Namen "Item". bezeichnet Jeder Versuch zum Abrufen `PropertyInfo` über Reflektion ermöglicht diesen internen Namen angeben muss, um ordnungsgemäß Zurückgeben der `PropertyInfo` Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
 Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:  
  
-   Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern. Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen ausgeblendet mithilfe der `new` Modifizierer (`Shadows` in Visual Basic). Um die Mehrdeutigkeit zu lösen, enthalten <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> um die Suche auf Member zu beschränken, die nicht geerbt werden.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft in Übereinstimmung mit der angegebenen bindungseinschränkungen.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <summary>Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel definiert eine Klasse mit einer Eigenschaft, und ruft den Namen und Typ der Eigenschaft ab.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />ist <see langword="null" />, oder <paramref name="returnType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft die `Type` Objekt einer benutzerdefinierten Klasse ruft die Eigenschaft dieser Klasse ab und zeigt die Eigenschaftsnamen und den Typ der Eigenschaft entsprechend den Angaben von übergebenen Argumente `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet. Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Type` -Objekt entsprechende `MyPropertyClass`, und indizierte Eigenschaft dieser Klasse abgerufen wird, verwenden die Argumente an die `GetProperty` Methode.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.  
  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein. Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3. Sie können die Eigenschaft überladen.  
  
 In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens. Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
 - oder -   
  
 Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Typen</c> Array. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="types" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der aktuelle <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen. <xref:System.Type.GetType%2A>führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, in c# verwenden <xref:System.Type.GetType%2A> in Visual Basic oder c++.  
  
> [!NOTE]
>  Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%29> -Methode zurückkehrt `null`. Es wird keine Ausnahme auslöst. Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <xref:System.Type.GetType%2A> Methode, die eine `throwOnError` Parameter.  
  
 <xref:System.Type.GetType%2A>funktioniert nur für Assemblys, die von der Festplatte geladen. Beim Aufrufen <xref:System.Type.GetType%2A> zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType`flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName`Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und generische Typargumente. Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität. Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Umgekehrtes Apostroph (')|Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.|  
|Klammern ([])|Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.|  
|Komma (,)|Ist der Name der Assembly vorangestellt.|  
|Punkt (.)|Gibt die Namespacebezeichner.|  
|Pluszeichen (+)|Ist eine geschachtelte Klasse vorangestellt.|  
  
 Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird. Reflektion wird diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>. Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen. <xref:System.Type.GetType%2A>mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A>mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.  
  
 Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.  
  
 Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt. Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein. Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` fromMyAssembly.dll, mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird. Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen. Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen. Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Verwendung|  
|------------|---------|  
|Ein NULL-Werte zulässt<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")"|  
|Ein nicht verwalteter Zeiger auf`MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf`MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf`MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyType[]")`|  
|Ein eindimensionales Array mit einer unbekannten Untergrenze|`Type.GetType("MyType[*]")`|  
|Ein n-dimensionalen array|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.|  
|Ein Array von eindimensionale arrays|`Type.GetType("MyType[][]")`|  
|Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen|`Type.GetType("MyType[,]")`|  
|Ein generischer Typ mit einem Typargument|`Type.GetType("MyGenericType`1[MyType]")"|  
|Ein generischer Typ mit zwei Typargumenten|`Type.GetType("MyGenericType`2[MyType,AnotherType]")"|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet diese Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.IO.IOException" />, stattdessen.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError">
          <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen. <xref:System.Type.GetType%2A>führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic oder `typeid` in C++.  
  
 `GetType`funktioniert nur für Assemblys, die von der Festplatte geladen. Beim Aufrufen `GetType` zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType`flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`. Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName`Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, der Name der Assembly und die generische Argumente zurück. Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität. Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Umgekehrtes Apostroph (')|Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.|  
|Klammern ([])|Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.|  
|Komma (,)|Ist der Name der Assembly vorangestellt.|  
|Punkt (.)|Gibt die Namespacebezeichner.|  
|Pluszeichen (+)|Ist eine geschachtelte Klasse vorangestellt.|  
  
 Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird. Reflektion wird diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>. Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen. <xref:System.Type.GetType%2A>mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A>mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.  
  
 Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.  
  
 Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt. Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein. Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly.dll mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird. Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen. Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen. Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Verwendung|  
|------------|---------|  
|Ein NULL-Werte zulässt<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")"|  
|Ein nicht verwalteter Zeiger auf`MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf`MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf`MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einer unbekannten Untergrenze|`Type.GetType("MyArray[*]")`|  
|Ein n-dimensionalen array|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.|  
|Ein zweidimensionales Array von Arrays|`Type.GetType("MyArray[][]")`|  
|Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument|`Type.GetType("MyGenericType`1[MyType]")"|  
|Ein generischer Typ mit zwei Typargumenten|`Type.GetType("MyGenericType`2[MyType,AnotherType]")"|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet diese Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`. Wenn ein Objekt vom Typ auf eine Assembly, die nicht vorhanden ist verweist, wird in diesem Beispiel wird eine Ausnahme ausgelöst.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.IO.IOException" />, stattdessen.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError">
          <see langword="true" />, um eine Ausnahme auszulösen, wenn der Typ nicht gefunden werden kann; <see langword="false" />, um <see langword="null" /> zurückzugeben. Die Angabe von <see langword="false" /> unterdrückt außerdem einige andere Ausnahmebedingungen, jedoch nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase">
          <see langword="true" />Groß-/Kleinschreibung nicht beachtet werden soll für <c>TypeName</c>, <see langword="false" /> Groß-/Kleinschreibung gesucht werden soll für <c>TypeName</c>.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen. <xref:System.Type.GetType%2A>führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic oder `typeid` in C++.  
  
 `GetType`funktioniert nur für Assemblys, die von der Festplatte geladen. Beim Aufrufen `GetType` zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType`flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`. Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|Ereignis|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.|  
|Geschachtelten Typs|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName`Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und Typargumente. Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität. Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Umgekehrtes Apostroph (')|Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.|  
|Klammern ([])|Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.|  
|Komma (,)|Ist der Name der Assembly vorangestellt.|  
|Punkt (.)|Gibt die Namespacebezeichner.|  
|Pluszeichen (+)|Ist eine geschachtelte Klasse vorangestellt.|  
  
 Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird. Reflektion wird diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>. Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen. <xref:System.Type.GetType%2A>mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A>mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.  
  
 Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.  
  
 Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt. Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein. Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly.dll mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird. Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen. Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen. Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Verwendung|  
|------------|---------|  
|Ein NULL-Werte zulässt<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")"|  
|Ein nicht verwalteter Zeiger auf`MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf`MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf`MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einer unbekannten Untergrenze|`Type.GetType("MyArray[*]")`|  
|Ein n-dimensionalen array|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.|  
|Ein zweidimensionales Array von Arrays|`Type.GetType("MyArray[][]")`|  
|Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument|`Type.GetType("MyGenericType`1[MyType]")"|  
|Ein generischer Typ mit zwei Typargumenten|`Type.GetType("MyGenericType`2[MyType,AnotherType]")"|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn die <c>TypeResolver</c> -Parameter bereitgestellt wird, kann der Typname sein, eine beliebige Zeichenfolge, die <c>TypeResolver</c> aufgelöst werden kann. Wenn die <c>AssemblyResolver</c> Parameter bereitgestellt wird oder wenn die standardtypauflösung verwendet wird, <c>TypeName</c> muss ein Assembly qualifizierter Name (finden Sie unter <see cref="P:System.Type.AssemblyQualifiedName" />), es sei denn, der Typ ist in der aktuell ausgeführten Assembly oder in "mscorlib.dll", in dem Fall ist es ausreichend, des Typnamens von seinem Namespace qualifizierten.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly, die im angegebenen sucht und zurückgibt <c>TypeName</c>. Der Name der Assembly übergeben wird, um <c>AssemblyResolver</c> als ein <see cref="T:System.Reflection.AssemblyName" /> Objekt. Wenn <c>TypeName</c> enthält nicht den Namen einer Assembly <c>AssemblyResolver</c> wird nicht aufgerufen. Wenn <c>AssemblyResolver</c> ist nicht angegeben wird, Standardassemblyauflösung ausgeführt.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, sucht und gibt die vom angegebenen Typs <c>TypeName</c> aus der Assembly, die zurückgegebene <c>AssemblyResolver</c> oder von der Standardassemblyauflösung. Wenn keine Assembly bereitgestellt wird, die <c>TypeResolver</c> Methode kann eine bereitstellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen oder <see langword="null" />, wenn der Typ nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.  
  
> [!NOTE]
>  Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> -Methode zurückkehrt `null`. Es wird keine Ausnahme auslöst. Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <xref:System.Type.GetType%2A> Methode, die eine `throwOnError` Parameter.  
  
 Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung und Angeben von `false` für die `throwOnError` und `ignoreCase` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> wird in einen Typnamen und einen Assemblynamen (z. B., wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält) analysiert.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
 - oder -   
  
 <paramref name="typeName" />enthält einen ungültigen Assemblynamen.  
  
 - oder -   
  
 <paramref name="typeName" />ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn die <c>TypeResolver</c> -Parameter bereitgestellt wird, kann der Typname sein, eine beliebige Zeichenfolge, die <c>TypeResolver</c> aufgelöst werden kann. Wenn die <c>AssemblyResolver</c> Parameter bereitgestellt wird oder wenn die standardtypauflösung verwendet wird, <c>TypeName</c> muss ein Assembly qualifizierter Name (finden Sie unter <see cref="P:System.Type.AssemblyQualifiedName" />), es sei denn, der Typ ist in der aktuell ausgeführten Assembly oder in "mscorlib.dll", in dem Fall ist es ausreichend, des Typnamens von seinem Namespace qualifizierten.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly, die im angegebenen sucht und zurückgibt <c>TypeName</c>. Der Name der Assembly übergeben wird, um <c>AssemblyResolver</c> als ein <see cref="T:System.Reflection.AssemblyName" /> Objekt. Wenn <c>TypeName</c> enthält nicht den Namen einer Assembly <c>AssemblyResolver</c> wird nicht aufgerufen. Wenn <c>AssemblyResolver</c> ist nicht angegeben wird, Standardassemblyauflösung ausgeführt.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, sucht und gibt die vom angegebenen Typs <c>TypeName</c> aus der Assembly, die zurückgegebene <c>AssemblyResolver</c> oder von der Standardassemblyauflösung. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError">
          <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.  
  
 Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung und Angeben von `false` für die `ignoreCase` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> wird in einen Typnamen und einen Assemblynamen (z. B., wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält) analysiert.  
  
 - oder -   
  
 <paramref name="throwOnError" />ist <see langword="true" /> und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="typeName" />enthält einen ungültigen Assemblynamen.  
  
 - oder -   
  
 <paramref name="typeName" />ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, aber konnte nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn die <c>TypeResolver</c> -Parameter bereitgestellt wird, kann der Typname sein, eine beliebige Zeichenfolge, die <c>TypeResolver</c> aufgelöst werden kann. Wenn die <c>AssemblyResolver</c> Parameter bereitgestellt wird oder wenn die standardtypauflösung verwendet wird, <c>TypeName</c> muss ein Assembly qualifizierter Name (finden Sie unter <see cref="P:System.Type.AssemblyQualifiedName" />), es sei denn, der Typ ist in der aktuell ausgeführten Assembly oder in "mscorlib.dll", in dem Fall ist es ausreichend, des Typnamens von seinem Namespace qualifizierten.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly, die im angegebenen sucht und zurückgibt <c>TypeName</c>. Der Name der Assembly übergeben wird, um <c>AssemblyResolver</c> als ein <see cref="T:System.Reflection.AssemblyName" /> Objekt. Wenn <c>TypeName</c> enthält nicht den Namen einer Assembly <c>AssemblyResolver</c> wird nicht aufgerufen. Wenn <c>AssemblyResolver</c> ist nicht angegeben wird, Standardassemblyauflösung ausgeführt.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, sucht und gibt die vom angegebenen Typs <c>TypeName</c> aus der Assembly, die zurückgegebene <c>AssemblyResolver</c> oder von der Standardassemblyauflösung. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter, der angibt, ob die Groß-/Kleinschreibung nicht beachtet werden soll; der Wert der <c>IgnoreCase</c> an diesen Parameter übergeben wird.  
  
 Vorsicht übergeben werden keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError">
          <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase">
          <see langword="true" />Groß-/Kleinschreibung nicht beachtet werden soll für <c>TypeName</c>, <see langword="false" /> Groß-/Kleinschreibung gesucht werden soll für <c>TypeName</c>.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung und ihre zugeordneten Überladungen (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> und <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) ersetzt die standardmäßige Implementierung des der <xref:System.Type.GetType%2A> Methode mit flexibler Implementierungen. Durch Ihre eigenen Methoden, die aufgelöst werden Typnamen und die Namen der Assemblys, die sie enthalten, können Sie Folgendes tun:  
  
-   Steuern Sie, welche Version einer Assembly, die ein Typ aus geladen wird.  
  
-   Geben Sie einen anderen Speicherort für für einen Typnamen zu suchen, die keine Namen einer Assembly enthalten.  
  
-   Laden von Assemblys mit partiellen Assemblynamen.  
  
-   Zurückgeben von Unterklassen von <xref:System.Type?displayProperty=nameWithType> , die nicht von der common Language Runtime (CLR) erstellt werden.  
  
 Beispielsweise kann in versionstolerante dieser Methode suchen Sie nach einer "best fit"-Assembly mithilfe eines unvollständigen Namens. Andere Überladungen der <xref:System.Type.GetType%2A> Methode benötigt einen Assembly qualifizierten Typnamen, die die Versionsnummer enthält.  
  
 Alternative Implementierungen des Typsystems Unterklassen des zurückzugebenden müssen möglicherweise <xref:System.Type?displayProperty=nameWithType> , die von der CLR nicht erstellt werden, alle Typen, die von anderen Überladungen der zurückgegeben werden die <xref:System.Type.GetType%2A> Methode sind-Runtime-Typen.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Hinweise zur Verwendung  
 Überladung dieser Methode und ihre zugeordneten Überladungen analysieren `typeName` in den Namen eines Typs und den Namen einer Assembly, und klicken Sie dann den Namen aufzulösen. Auflösung des Assemblynamens tritt ein, bevor die Auflösung des Typnamens, da ein Typnamen im Kontext einer Assembly aufgelöst werden muss.  
  
> [!NOTE]
>  Wenn Sie mit dem Konzept der Assembly qualifizierten Typnamen nicht vertraut sind, finden Sie unter der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft.  
  
 Wenn `typeName` ist kein Assembly qualifizierter Name, Assemblyauflösung wird übersprungen. Nicht qualifizierte Typennamen können im Kontext von "mscorlib.dll" oder der aktuell ausgeführten Assembly aufgelöst werden, oder Sie können optional Bereitstellen einer Assembly in die `typeResolver` Parameter. Die Auswirkungen der ein- oder den Assemblynamen auslassen, für verschiedene Arten von namensauflösung, wie eine Tabelle in angezeigt werden der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt.  
  
 Allgemeine Verwendungshinweise:  
  
-   Übergeben Sie keine Methoden, um `assemblyResolver` oder `typeResolver` , wenn sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.  
  
    > [!CAUTION]
    >  Mithilfe der Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann zu einer Erhöhung von Berechtigungen für bösartigen Code führen.  
  
-   Wenn Sie weglassen der `assemblyResolver` und/oder `typeResolver` Parameter, der Wert der `throwOnError` Parameter übergeben wird, um die Methoden, die Standardlösung ausführen.  
  
-   Wenn `throwOnError` ist `true`, löst diese Methode eine <xref:System.TypeLoadException> beim `typeResolver` gibt `null`, und ein <xref:System.IO.FileNotFoundException> Wenn `assemblyResolver` gibt `null`.  
  
-   Diese Methode keine Ausnahmen ausgelöst werden, indem `assemblyResolver` und `typeResolver`. Sie sind verantwortlich für alle Ausnahmen, die von den Konfliktlöser Methoden ausgelöst werden.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Auflösen von Assemblys  
 Die `assemblyResolver` Methode empfängt einen <xref:System.Reflection.AssemblyName> -Objekt, das erzeugt wird, durch Analysieren der Zeichenfolge Assemblyname, der in enthalten ist `typeName`. Wenn `typeName` enthält keinen Namen einer Assembly `assemblyResolver` wird nicht aufgerufen und `null` übergeben `typeResolver`.  
  
 Wenn `assemblyResolver` ist nicht angegeben wird, Überprüfung wird verwendet, um die Assembly gesucht werden soll. Wenn `assemblyResolver` angegeben ist, die <xref:System.Type.GetType%2A> Methode führt keine Standardsuche; in diesem Fall müssen Sie sicherstellen, dass Ihre `assemblyResolver` können behandeln alle Assemblys, die Sie an diesen weitergegeben.  
  
 Die `assemblyResolver` -Methode zurückgeben sollte `null` Wenn die Assembly aufgelöst werden kann. Wenn `assemblyResolver` gibt `null`, `typeResolver` wird nicht aufgerufen, und keine weitere Verarbeitung erfolgt; darüber hinaus Wenn `throwOnError` ist `true`, eine <xref:System.IO.FileNotFoundException> ausgelöst wird.  
  
 Wenn die <xref:System.Reflection.AssemblyName> übergebene `assemblyResolver` ist eine partielle Name, eine oder mehrere Teile sind `null`. Wenn sie keine Version verfügt beispielsweise die <xref:System.Reflection.AssemblyName.Version%2A> Eigenschaft ist `null`. Wenn die <xref:System.Reflection.AssemblyName.Version%2A> -Eigenschaft, die <xref:System.Reflection.AssemblyName.CultureInfo%2A> -Eigenschaft, und die <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> alle-Methodenrückgabe `null`, und klicken Sie dann nur der einfache Namen der Assembly angegeben wurde. Die `assemblyResolver` Methode verwenden oder ignorieren Sie alle Teile des Assemblynamens.  
  
 Die Auswirkungen der verschiedenen Auflösung Assemblyoptionen werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und Assembly qualifizierten Typnamen.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Auflösen von Typen  
 Wenn `typeName` gibt keinen Namen einer Assembly `typeResolver` wird immer aufgerufen. Wenn `typeName` gibt den Namen einer Assembly `typeResolver` wird nur aufgerufen, wenn der Name der Assembly erfolgreich aufgelöst wurde. Wenn `assemblyResolver` oder Standardassembly gibt `null`, `typeResolver` wird nicht aufgerufen.  
  
 Die `typeResolver` -Methode empfängt drei Argumente:  
  
-   Die Assembly zu suchen oder `null` Wenn `typeName` enthält keinen Namen einer Assembly.  
  
-   Der einfache Name des Typs. Im Falle eines geschachtelten Typs ist dies der äußersten enthaltenden Typ. Im Falle eines generischen Typs ist dies der einfache Name des generischen Typs.  
  
-   Ein boolescher Wert, der `true` Wenn Typnamen die Groß-/Kleinschreibung ignoriert werden.  
  
 Die Implementierung bestimmt, wie diese Argumente verwendet werden. Die `typeResolver` -Methode zurückgeben sollte `null` , wenn den Typ nicht auflösen kann. Wenn `typeResolver` gibt `null` und `throwOnError` ist `true`, diese Überladung der <xref:System.Type.GetType%2A> löst eine <xref:System.TypeLoadException>.  
  
 Die Auswirkungen eines anderen Typs Optionen werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und Assembly qualifizierten Typnamen.  
  
#### <a name="resolving-nested-types"></a>Auflösen von geschachtelten Typen  
 Wenn `typeName` geschachtelter Typ, nur den Namen des äußersten übergeben wird, enthält Typ `typeResolver`. Wenn `typeResolver` diesen Typ zurückgibt, der <xref:System.Type.GetNestedType%2A> Methode rekursiv aufgerufen, bis der innersten geschachtelten Typ aufgelöst wurde.  
  
#### <a name="resolving-generic-types"></a>Auflösen von generischen Typen  
 Die <xref:System.Type.GetType%2A> rekursiv aufgerufen, um generische Typen aufzulösen: zuerst an, um den generischen Typ selbst zu beheben und dann seine Typargumente aufgelöst. Wenn ein Argument vom Typ generisch ist, wird <xref:System.Type.GetType%2A> rekursiv aufgerufen, um zu seiner Typargumente beheben und so weiter.  
  
 Die Kombination von `assemblyResolver` und `typeResolver` der Auflösung dieses alle Stufen in der Lage sein, dass Sie zur Verfügung stellen. Nehmen wir beispielsweise an, Sie geben eine `assemblyResolver` , steuert das Laden von `MyAssembly`. Angenommen, Sie möchten den generischen Typ aufgelöst `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). Sie können die folgenden Name des generischen Typs übergeben:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Beachten Sie, dass `MyType` ist das Argument nur Assembly qualifizierten Typnamen. Die Namen der <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String> Klassen sind nicht für die Assembly qualifizierten. Ihre `typeResolver` muss Handle kann entweder eine Assembly oder `null`, da er erhält `null` für <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String>. Sie können diesen Fall behandeln, durch Aufruf einer Überladung von der <xref:System.Type.GetType%2A> -Methode, die eine Zeichenfolge akzeptiert, da beide den nicht qualifizierten Typnamen in "mscorlib.dll" sind:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Die `assemblyResolver` Methode wird für den Wörterbuchtyp und den String-Datentyp nicht aufgerufen, da diese Namen nicht Assembly qualifiziert sind.  
  
 Nehmen wir jetzt an, die anstelle von `System.String`, ist der erste generische Argumenttyp `YourType`, aus `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Da diese Assembly weder "mscorlib.dll" als auch der aktuell ausgeführten Assembly ist, können Sie nicht auflösen `YourType` ohne ein Assembly qualifizierter Name. Da Ihre `assemblyResolve` werden rekursiv aufgerufen wird, muss er in diesem Fall können. Anstatt `null` für andere Assemblys als `MyAssembly`, führt es jetzt Laden einer Assembly, die mit dem angegebenen <xref:System.Reflection.AssemblyName> Objekt.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Zurück zur [Verwendungshinweise](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Auflösen von Typnamen mit Sonderzeichen  
 Bestimmte Zeichen eine besondere Bedeutung in assemblyqualifizierten Namen an. Wenn ein einfache Typname diese Zeichen enthält, verursachen die Zeichen Analysefehler aus, wenn der einfache Namen einer Assembly qualifizierte Name gehört. Um die Analysefehler zu vermeiden, müssen Sie die Sonderzeichen nicht mit einem umgekehrten Schrägstrich sein, bevor Sie die Assembly qualifizierte Name zu übergeben, können die <xref:System.Type.GetType%2A> Methode. Wenn ein Typ mit dem Namen wird z. B. `Strange]Type`, das Escape-Zeichen muss wie folgt vor die eckige Klammer hinzugefügt werden: `Strange\]Type`.  
  
> [!NOTE]
>  Namen mit solchen Sonderzeichen können nicht in Visual Basic oder c# erstellt werden, aber Sie können mithilfe von Microsoft intermediate Language (MSIL) oder durch Ausgeben von dynamischen Assemblys erstellt werden.  
  
 Die folgende Tabelle zeigt die Sonderzeichen für Typnamen.  
  
|Zeichen|Bedeutung|  
|---------------|-------------|  
|, (Komma)|Trennzeichen für die Assembly qualifizierten Namen.|  
|[] (eckige Klammern)|Als Suffix paarweise angegeben gibt Sie einen Arraytyp an. als Trennzeichen paarweise angegeben umfasst generische Argumentlisten und qualifizierte Assemblynamen.|  
|& (Und)|Gibt an, dass ein Typ ein Verweistyp ist, als Suffix.|  
|* (Sternchen)|Gibt an, dass ein Typ ein Zeigertyp ist, als Suffix.|  
|+ (plus)|Trennzeichen für geschachtelte Typen.|  
|\ (umgekehrter Schrägstrich)|Escape-Zeichen.|  
  
 Eigenschaften, z. B. <xref:System.Type.AssemblyQualifiedName%2A> Return Zeichenfolgen korrekt in Escapezeichen eingeschlossen. Müssen Sie ordnungsgemäß mit Escapezeichen versehene Zeichenfolgen zum Übergeben der <xref:System.Type.GetType%2A> Methode. Wiederum die <xref:System.Type.GetType%2A> Methode übergibt ordnungsgemäß mit Escapezeichen versehene Objektnamen `typeResolver` und Auflösung die Standardmethoden-Typ. Wenn Sie einen Namen, den Namen einer ohne Escapezeichen in Vergleichen `typeResolver`, müssen Sie die Escape-Zeichen entfernen.  
  
 Zurück zur [Verwendungshinweise](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Gemischte namensauflösung  
 Die folgende Tabelle enthält die Interaktionen zwischen `assemblyResolver`, `typeResolver`, und die standardmäßige namensauflösung für alle Kombinationen von Typ und Assemblynamen im `typeName`:  
  
|Inhalt des Typnamens|Assembly-Resolver-Methode|Typ-Resolver-Methode|Ergebnis|  
|---------------------------|------------------------------|--------------------------|------------|  
|Typ-assembly|NULL|NULL|Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung.|  
|Typ-assembly|bereitgestellt|NULL|`assemblyResolver`Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann. Wenn die Assembly aufgelöst wird, wird die <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> methodenüberladung wird verwendet, um den Typ aus der Assembly zu laden; andernfalls ist es versucht nicht, die den Typ aufzulösen.|  
|Typ-assembly|NULL|bereitgestellt|Konvertiert den Namen der Ausgabeassembly ein <xref:System.Reflection.AssemblyName> Objekt und der Aufruf der <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> -methodenüberladung, um die Assembly zu erhalten. Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.|  
|Typ-assembly|bereitgestellt|bereitgestellt|`assemblyResolver`Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann. Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.|  
|Typ|NULL, bereitgestellt wird,|NULL|Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung. Da der Assemblyname nicht angegeben wird, werden nur "mscorlib.dll" und der aktuell ausgeführten Assembly durchsucht. Wenn `assemblyResolver` angegeben wird, diese ignoriert wird.|  
|Typ|NULL, bereitgestellt wird,|bereitgestellt|`typeResolver`wird aufgerufen, und `null` für die Assembly übergeben wird. `typeResolver`Geben Sie einen Typ können aus beliebigen Assemblys, einschließlich der Assemblys, die sie für diesen Zweck lädt. Wenn `assemblyResolver` angegeben wird, diese ignoriert wird.|  
|Assembly|NULL, bereitgestellt wird,|NULL, bereitgestellt wird,|Ein <xref:System.IO.FileLoadException> ausgelöst wird, da der Assemblyname analysiert wird, als handele es sich um eine Assembly qualifizierten Typnamen an. Dies führt zu einem ungültigen Assemblynamen.|  
  
 Zurück zur: [Verwendungshinweise](#usage_notes), [Auflösen von Assemblys](#resolving_assemblies), [Auflösen von Typen](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> wird in einen Typnamen und einen Assemblynamen (z. B., wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält) analysiert.  
  
 - oder -   
  
 <paramref name="throwOnError" />ist <see langword="true" /> und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
 - oder -   
  
 <paramref name="typeName" />enthält einen ungültigen Assemblynamen.  
  
 - oder -   
  
 <paramref name="typeName" />ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, deren Typen bestimmt werden sollen.</param>
        <summary>Ruft die Typen der Objekte im angegebenen Array ab.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der entsprechenden Elemente in <paramref name="args" /> darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetTypeArray%2A> Methode, um die Typen der Elemente eines Arrays aufführen.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens eines der Elemente in <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</param>
        <summary>Ruft den zugrunde liegenden Typcode des angegebenen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der Code des zugrunde liegenden Typs oder <see cref="F:System.TypeCode.Empty" />, wenn <paramref name="type" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Erben von <xref:System.Type>, Sie können das Verhalten dieser Methode ändern, durch Überschreiben der <xref:System.Type.GetTypeCodeImpl%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.TypeCode> Enumeration verwendet werden kann. In einem Entscheidungsblock innerhalb der `WriteObjectInfo` -Methode, die <xref:System.TypeCode> des ein <xref:System.Object> Parameter wird untersucht und eine entsprechende Meldung in die Konsole geschrieben wird.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typcode dieser <see cref="T:System.Type" />-Instanz zurück.</summary>
        <returns>Der Typcode des zugrunde liegenden Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt die Implementierung für die `static` (in c#) oder `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> Methode. Beim Erben von <xref:System.Type>, Sie können diese Methode, um eine eigene Implementierung bereitstellen überschreiben <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
        <returns>
          <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.  Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der`__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Siehe das Beispiel veranschaulicht.  
  
 Die <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Überladung ignoriert alle Ausnahmen, die auftreten können, bei der Instanziierung einer <xref:System.Type> -Objekt auf Grundlage der `clsid` Argument. Beachten Sie, die keine Ausnahme ausgelöst wird, wenn `clsid` befindet sich nicht in der Registrierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="throwOnError">
          <see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
 - oder -   
  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>
          <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.  Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Siehe das Beispiel veranschaulicht.  
  
 Ausnahmen wie <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode. Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</summary>
        <returns>
          <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.  Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError">
          <see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
 - oder -   
  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>
          <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.  Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Ausnahmen wie <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode. Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> Methode gibt ein <see cref="T:System.Type" /> Objekt, das die GUID für ein bestimmtes verwaltetes Objekt entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel zeigt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Das Objekt, das auf den Typ verweist.</param>
        <summary>Ruft den Typ ab, auf den das angegebene Typhandle verweist.</summary>
        <returns>Der Typ, auf den das angegebene <see cref="T:System.RuntimeTypeHandle" /> verweist, oder <see langword="null" />, wenn die <see cref="P:System.RuntimeTypeHandle.Value" />-Eigenschaft von <paramref name="handle" /> den Wert <see langword="null" /> hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.GetTypeFromHandle%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt aus einer <xref:System.RuntimeTypeHandle> gebotenen die <xref:System.Type.GetTypeHandle%2A> Methode.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <see cref="T:System.Type" /> ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, für COM-Unterstützung. Versionsabhängige Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="throwOnError">
          <see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
 - oder -   
  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch Übergeben einer ProgID, der angibt, ob eine Ausnahme auslöst, wenn die ProgID ungültig ist. Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID sowie alle anwendbaren Ausnahmemeldung.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene ProgID ist nicht registriert.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens. Im Beispiel für die ClassID angezeigt, die ProgID oder löst eine Ausnahme aus, wenn die ProgID oder den Namen des Servers ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError">
          <see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
 - oder -   
  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens. Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID angeben, ob eine Ausnahme auslöst, wenn die ProgID oder den Namen des Servers ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene progID ist nicht registriert.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, für das das Typhandle abgerufen werden soll.</param>
        <summary>Ruft das Handle für den <see cref="T:System.Type" />-Wert eines angegebenen Objekts ab.</summary>
        <returns>Das Handle für den <see cref="T:System.Type" /> des angegebenen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert die Klasse `MyClass1`, ruft eine Instanz des Zertifikats ab und ruft die Common Language Runtime Handle des Objekts ab.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordnete GUID ab.</summary>
        <value>Die dem <see cref="T:System.Type" /> zugeordnete GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine GUID bezieht sich auf einen Typ mit dem <xref:System.Runtime.InteropServices.GuidAttribute> Attribut.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Klasse `MyClass1` mit einer öffentlichen Methode erstellt eine `Type` , Objekt entspricht `MyClass1`, und ruft die <xref:System.Guid> -Struktur unter Verwendung der `GUID` Eigenschaft von der `Type` Klasse.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]").. HasElementType gibt `true`, wohingegen Type.GetType("Int32"). HasElementType gibt `false`. HasElementType gibt auch `true` für "Int32 *" und "Int32 &".  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel gibt `true` oder `false` abhängig davon, ob das Objekt ein Array, ein Verweistyp oder ein Zeiger ist.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.HasElementType" />-Eigenschaft und bestimmt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder Zeiger ist oder als Verweis übergeben wird.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]").. HasElementTypeImpl gibt `true`, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt `false`. HasElementTypeImpl gibt auch `true` für "Int32 *" und "Int32 &".  
  
   
  
## Examples  
 Das folgende Beispiel definiert die Klasse `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode. Die Hauptklasse überprüft die `HasElementType` Eigenschaft und zeigt den Elementtyp an.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
 - oder -   
  
 Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
 - oder -   
  
 Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche ausgelassen wird, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> verwendet werden.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private und geschützte Member) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:  
  
-   `CreateInstance`Um einen Konstruktor aufzurufen. `name`wird ignoriert. Mit anderen Aufrufflags ist ungültig.  
  
-   `InvokeMethod`Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField`den Wert eines Felds abgerufen werden soll. Ungültig mit `SetField`.  
  
-   `SetField`den Wert eines Felds festgelegt. Ungültig mit `GetField`.  
  
-   `GetProperty`zum Abrufen einer Eigenschaft. Ungültig mit `SetProperty`.  
  
-   `SetProperty`Festlegen von Eigenschaften. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.  
  
 Wenn die Methode ausgewählt wurde, wird er aufgerufen. Eingabehilfen ist an diesem Punkt aktiviert. Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <xref:System.Reflection> immer der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String`, können Sie Code wie z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 die wird das Feld F für dieses neue Array zu initialisieren. Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.  
  
 Beim Aufruf einer `IDispatch` Member auf, Sie können die DispID anstelle des Namens des Elements, das Zeichenfolgenformat mithilfe angeben "[DispID = ##]". Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod". Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen. In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon. (Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
   
  
## Examples  
 Im folgenden Beispiel wird `InvokeMember` den Zugriff auf Member eines Typs.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
 - oder -   
  
 Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - oder -   
  
 Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
 - oder -   
  
 Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Code. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
 - oder -   
  
 Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
 - oder -   
  
 Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche ausgelassen wird, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> verwendet werden.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="culture">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <see cref="T:System.String" /> in einen <see cref="T:System.Double" /> erforderlich sein kann.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Globalization.CultureInfo> (die `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `culture`.  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:  
  
-   `CreateInstance`Um einen Konstruktor aufzurufen. `name`wird ignoriert. Mit anderen Aufrufflags ist ungültig.  
  
-   `InvokeMethod`Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField`den Wert eines Felds abgerufen werden soll. Ungültig mit `SetField`.  
  
-   `SetField`den Wert eines Felds festgelegt. Ungültig mit `GetField`.  
  
-   `GetProperty`zum Abrufen einer Eigenschaft. Ungültig mit `SetProperty`.  
  
-   `SetProperty`Festlegen von Eigenschaften. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.  
  
 Wenn die Methode ausgewählt wurde, wird er aufgerufen. Eingabehilfen ist an diesem Punkt aktiviert. Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. können private Konstruktoren, Methoden, Felder und Eigenschaften werden zugegriffen und durch Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String` Sie Code verwenden, z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 die wird das Feld F für dieses neue Array zu initialisieren. Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.  
  
 Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]". Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod". Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen. In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon. (Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
 - oder -   
  
 Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - oder -   
  
 Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
 - oder -   
  
 Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Code. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
 - oder -   
  
 Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
 - oder -   
  
 Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche ausgelassen wird, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> verwendet werden.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
 - oder -   
  
 Ein Nullverweis (Nothing in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" /> Objekte, die mit dem entsprechenden Element im verknüpften Attribute darstellen, die <c>Args</c> Array. Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.  
  
 Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</param>
        <param name="culture">Das <see cref="T:System.Globalization.CultureInfo" />-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.  
  
 - oder -   
  
 Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <param name="namedParameters">Ein Array mit den Namen der Parameter, der die Werte in der <c>Args</c> Arrays übergeben werden.</param>
        <summary>Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember`Mitglied Konstruktor oder eine Methodenmember aufruft, ruft ab oder legt ein Eigenschaftenelement, ruft ab oder legt einen Feldmember Daten oder abgerufen oder festgelegt ein Element von einen Arraymember angeben.  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.  
  
 Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]". Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod". Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen. In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.  
  
 Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> oder <xref:System.Globalization.CultureInfo> (die `modifiers` und `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers` und `culture`. `ParameterModifier`wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.  
  
 Jeder Parameter in der `namedParameters` Array Ruft den Wert in das entsprechende Element in der `args` Array. Wenn die Länge des `args` ist größer als die Länge des `namedParameters`, die restlichen Argumentwerte in der Reihenfolge übergeben.  
  
 Die `namedParameters` Array kann verwendet werden, um die Reihenfolge der Argumente in der ein Eingabearray zu ändern. Angenommen, die Methode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) und das Eingabearray `{ 42, "x" }`, das Eingabearray unverändert an den übergeben werden kann `args` Wenn das Array `{ "b", "a" }` angegeben wird, für die `namedParameters`.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:  
  
-   `BindingFlags.IgnoreCase`um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly`Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:  
  
-   `CreateInstance`Um einen Konstruktor aufzurufen. `name`wird ignoriert. Mit anderen Aufrufflags ist ungültig.  
  
-   `InvokeMethod`Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField`den Wert eines Felds abgerufen werden soll. Ungültig mit `SetField`.  
  
-   `SetField`den Wert eines Felds festgelegt. Ungültig mit `GetField`.  
  
-   `GetProperty`zum Abrufen einer Eigenschaft. Ungültig mit `SetProperty`.  
  
-   `SetProperty`Festlegen von Eigenschaften. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.  
  
 Wenn die Methode ausgewählt wurde, wird er aufgerufen. Eingabehilfen ist an diesem Punkt aktiviert. Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 `InvokeMember`kann verwendet werden, zum Aufrufen von Methoden mit Parametern, die über Standardwerte verfügen. Um diese Methoden zu binden, muss für die Reflektion <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> angegeben werden. Für einen Parameter, die über einen Standardwert verfügt, können Sie entweder einen anderen Wert angeben oder angeben <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> auf den Standardwert verwenden.  
  
 Betrachten Sie beispielsweise eine Methode wie MyMethod (Int, x, "float" y = 2.0). Klicken Sie zum Aufrufen dieser Methode mit nur das erste Argument als MyMethod(4), übergeben Sie eine der oben genannten Bindungsflags und zwei Argumente, d. h. 4 für das erste Argument übergeben und `Missing.Value` für das zweite Argument. Es sei denn, Sie verwenden `Missing.Value`, kann nicht ausgelassen werden optionale Parameter mit der `Invoke` Methode. Wenn Sie dies tun müssen, verwenden `InvokeMember` stattdessen.  
  
 Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <xref:System.Reflection> immer der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String`, können Sie Code wie z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z. B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 die wird das Feld F für dieses neue Array zu initialisieren. Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon. (Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
 - oder -   
  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
 - oder -   
  
 Das benannte Parameterarray ist größer als das Argumentarray.  
  
 - oder -   
  
 Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - oder -   
  
 Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
 - oder -   
  
 Es wurde kein Member gefunden, dessen Argumentnamen in <paramref name="namedParameters" /> angegeben sind.  
  
 - oder -   
  
 Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Code. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> abstrakt ist und überschrieben werden muss.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> abstrakt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAbstract%2A> -Eigenschaft gibt `true` in den folgenden Fällen:  
  
-   Der aktuelle Typ ist abstrakt. d. h. kann nicht instanziiert werden, aber kann nur als Basisklasse für abgeleitete Klassen dienen. Abstrakte Klassen werden in c# mit markiert die [abstrakte](~/docs/csharp/language-reference/keywords/abstract.md) Schlüsselwort in Visual Basic markiert sind mit den [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) Schlüsselwort.  
  
-   Der aktuelle Typ ist eine Schnittstelle.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Type> Objekte, die die folgenden Typen darstellen: Typ gibt enthält `true` , wenn das angegebene Objekt `abstract`ist, andernfalls gibt `false`.  
  
-   `AbstractClass`, eine abstrakte Klasse (eine Klasse als markiert `abstract` in C# geschrieben und `MustInherit` in Visual Basic).  
  
-   `DerivedClass`, eine Klasse, die von erben `AbstractClass`.  
  
-   `SingleClass`, einer nicht vererbbaren Klasse. Es ist definiert als `sealed` in C# geschrieben und `NotInheritable` in Visual Basic.  
  
-   `ITypeInfo`, eine Schnittstelle.  
  
-   `ImplementingClass`, eine Klasse, implementiert die `ITypeInfo` Schnittstelle.  
  
 Gibt die Methode `true` nur für `AbstractClass`, die abstrakte Klasse und `ITypeInfo`, die Schnittstelle.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value>
          <see langword="true" />, wenn für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein generischer Typ, der diese Eigenschaft bezieht sich auf die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die Feldinformationen ab und überprüft, ob die `AnsiClass` Attribut.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Typ ein Array ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsArray%2A> -Eigenschaft gibt `false` für die <xref:System.Array> Klasse. Sie gibt überdies `false` , wenn die aktuelle Instanz ist eine <xref:System.Type> Objekt, das einen Auflistungstyp oder eine Schnittstelle, die Auflistungen, wie z. B. ausgelegt darstellt <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Verwenden Sie z. B. Code, um ein Array zu prüfen:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Wenn der aktuelle Typ ein generischer Typ oder ein Typparameter in der Definition einer generischen Typ- oder Methodendefinition darstellt, gibt diese Eigenschaft immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.IsArray%2A> Eigenschaft.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsArray" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Array ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz von der <xref:System.Array> Klasse zurückgeben muss `false` , da es sich um ein Objekt, das kein Array ist.  
  
   
  
## Examples  
 Im folgende Beispiel überschreibt die `IsArrayImpl` Methode in der `MyTypeDelegator` -Klasse überprüft, ob eine Variable ein Array ist, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob eine Instanz eines angegebenen Typs mit einer Instanz des aktuellen Typs zugewiesen werden kann.</summary>
        <returns>
          <see langword="true" />, wenn eine der folgenden Bedingungen erfüllt ist:  
  
-   <paramref name="c" /> und die aktuelle Instanz haben denselben Typ.  
  
-   <paramref name="c" /> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet. <paramref name="c" />wird direkt von der aktuellen Instanz abgeleitet werden, wenn sie von der aktuellen Instanz erbt; <paramref name="c" /> stammt indirekt von der aktuellen Instanz, wenn sie von einer Folge von einer oder mehreren Klassen erbt, die von der aktuellen Instanz erben.  
  
-   Die aktuelle Instanz ist eine Schnittstelle, die von <paramref name="c" /> implementiert wird.  
  
-   <paramref name="c" /> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <paramref name="c" /> dar.  
  
     Im folgenden Beispiel wird die aktuelle Instanz einen <see cref="T:System.Type" /> -Objekt, das stellt die <see cref="T:System.IO.Stream" /> Klasse. <c>GenericWithConstraint</c> ist ein generischer Typ, dessen generischen Typparameter vom Typ muss <see cref="T:System.IO.Stream" />. Übergeben den generischen Typparameter, der <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> gibt an, dass eine Instanz des generischen Typparameters zugewiesen werden kann ein <see cref="T:System.IO.Stream" /> Objekt.  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" />Geben Sie einen Wert darstellt, und die aktuelle Instanz darstellt <c>Nullable&lt;c&gt; </c> (<c>Nullable (Of c)</c> in Visual Basic).  
  
 <see langword="false" />, wenn keine dieser Bedingungen erfüllt sind oder wenn <paramref name="c" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAssignableFrom%2A> Methode kann verwendet werden, um zu bestimmen, ob eine Instanz von `c` zugewiesen werden kann mit einer Instanz des aktuellen Typs, die Methode eignet sich am besten, wenn Sie Objekte verarbeiten, deren Typen zur Entwurfszeit nicht bekannt sind, und ermöglicht die bedingte Zuweisung, wie im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Diese Methode somit wird sichergestellt, dass eine Codezeile wie Folgendes zur Laufzeit, ohne Auslösen ausgeführt wird einer <xref:System.InvalidCastException> Ausnahme oder eine ähnliche Ausnahme:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
> [!NOTE]
>  Eine generische Typdefinition ist nicht von einem geschlossenen konstruierten Typ zugewiesen werden. D. h. Sie geschlossenen konstruierten Typs zuweisen können nicht `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) einer Variablen vom Typ `MyGenericList<T>`.  
  
 Wenn die `c` Parameter ist vom Typ <xref:System.Reflection.Emit.TypeBuilder>, das Ergebnis wird auf Grundlage des Typs, die erstellt werden soll. Im folgenden Codebeispiel wird veranschaulicht, dies mithilfe eines integrierten Typs mit dem Namen `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `IsAssignableFrom` -Methode definiert Klassen, Arrays Ganzzahlen und Generika.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value>
          <see langword="true" />, wenn für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als Annehmlichkeit bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.  
  
 Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> Enumerationswert in den Typ, damit die Laufzeit die geeignete Möglichkeit zum Klassenlayout bestimmen können.  
  
> [!NOTE]
>  Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch`MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz des Typs und zeigt die <xref:System.Type.IsAutoLayout%2A> Eigenschaft.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den tatsächlichen Typ zu erhalten, dereferenzieren den Typ, der als Verweis übergeben wurde, und rufen Sie anschließend <xref:System.Type.GetElementType%2A> für diesen Typ.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsByRef` Eigenschaft zu überprüfen, ob ein angegebenen Typs als Verweis übergeben wird. Im Beispiel wird die Klasse definiert `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode. Die Hauptklasse überprüft die `HasElementType` Eigenschaft und zeigt den Elementtyp an.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsByRef" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> eine Klasse ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für Klassen als auch für Delegaten. Es gibt `false` für Werttypen (für Strukturen und Enumerationen) auch wenn sie verschachtelt sind.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `true`. Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft `true` ist die generische Typdefinition einer Klassendefinition; d. h. kein definiert eine Schnittstelle oder ein Werttyp.  
  
> [!NOTE]
>  Diese Eigenschaft gibt `true` für `Type` Instanzen, die darstellen, die <xref:System.Enum> und <xref:System.ValueType> Klassen. Diese beiden Klassen sind die Basisklasse für Enumerationen und Werttypen, allerdings sind nicht Enumerationen oder Werttypen selbst. Weitere Informationen finden Sie unter der <xref:System.Type.IsValueType%2A> und <xref:System.Type.IsEnum%2A> Eigenschaften.  
  
 Die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswert kennzeichnet eine Typdeklaration als Klasse oder Schnittstelle. Klassen und Werttypen sind jedoch mit markierten der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Attribut. Wenn Sie den Wert der Eigenschaft Attributes aus und Verwenden des Typs Abrufen der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch Aufrufen der <xref:System.Type.IsValueType%2A> Eigenschaft. Im Beispiel für die <xref:System.Reflection.TypeAttributes> Enumeration enthält zusätzliche Informationen sowie beispielsweise.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz eines Typs und gibt an, ob der Typ eine Klasse ist.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.  
  
 Sie können auch eine COM‑Klasse laden und Abrufen eine `Type` Objekt für diese COM-Klasse, indem die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsCOMObject" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt. Sie können Instanzen eines konstruierten generischen Typs erstellen.</summary>
        <value>
          <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein konstruierter generischer Typ wies explizite Typen, die für alle generischen Typparameter angegeben. Es wird auch als ein geschlossener generischer Typ bezeichnet.  
  
 Wenn diese Eigenschaft den Wert `true`, können Sie Instanzen des aktuellen Typs erstellen, wenn es sich um `false`, nicht möglich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden. Ausführlichere Informationen über Remotekontext finden Sie unter <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsContextful" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
 Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsContextfulImpl` Methode.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für eine Enumeration, aber nicht für die <xref:System.Enum> -Typ selbst.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `IsEnum` Eigenschaft.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />ist ein Typ, der der zugrunde liegende Typ einer Enumeration sein kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</param>
        <summary>Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</summary>
        <returns>
          <see langword="true" />, wenn die COM-Typen äquivalent sind, andernfalls <see langword="false" />. Diese Methode gibt auch <see langword="false" /> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die common Language Runtime unterstützt das Einbetten von Typinformationen für COM-Typen direkt in verwaltete Assemblys, anstatt die verwalteten Assemblys zum Abrufen der Typinformationen für COM-Typen von Interop Assemblys. Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben. Jede verwaltete Assembly besitzt ein anderes <xref:System.Type>-Objekt, das eine Ansicht des COM-Typs darstellt. Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.  
  
 Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann. Die <xref:System.Type.IsEquivalentTo%2A> -Methode können Sie eine Assembly, um zu ermitteln, ein COM-Objekt, das von einer anderen Assembly abgerufen, die gleiche COM-Identität als eines der ersten eigenen eingebettete Interop-Assemblytyp hat und daher auf diesen Typ umgewandelt werden kann.  
  
 Weitere Informationen finden Sie unter [Typäquivalenz und eingebettete Interop-Typen](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als Annehmlichkeit bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.  
  
 Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> Enumerationswert in den Typ, um anzugeben, dass die Offsets, an dem die Felder starten, explizit angegeben werden.  
  
> [!NOTE]
>  Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz eines Typs und zeigt den Wert des seine <xref:System.Type.IsExplicitLayout%2A> Eigenschaft. Er verwendet die `MySystemTime` Klasse, die auch im Codebeispiel für <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>Objekte, die generischen Typparameter darstellen, abgerufen werden können, durch den Aufruf der <xref:System.Type.GetGenericArguments%2A> Methode eine <xref:System.Type> -Objekt, das eine generische Typdefinition darstellt, oder die <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> Methode eine <xref:System.Reflection.MethodInfo> -Objekt, das eine generische Methode darstellt Definition.  
  
-   Für eine generische Typ- bzw. Methodendefinition die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für jedes Element des sich ergebenden Array.  
  
-   Für einen geschlossenen konstruierten Typ oder Methode die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `false` für jedes Element des Arrays zurückgegebenes die <xref:System.Type.GetGenericArguments%2A> Methode.  
  
-   Für einen offenen konstruierten Typ oder eine Methode einige Elemente des Arrays möglicherweise bestimmte Typen und andere möglicherweise Typparameter. <xref:System.Type.IsGenericParameter%2A>Gibt `false` für die Typen und `true` für den Typparameter. Das Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft wird mit einer Mischung von Typen und die Typparameter eine generische Klasse veranschaulicht.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.IsGenericParameter%2A> Eigenschaft so testen Sie die generischen Typparameter in einem generischen Typ.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</summary>
        <value>
          <see langword="true" />Wenn der aktuelle Typ ein generischer Typ ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.IsGenericType%2A> -Eigenschaft können Sie bestimmen, ob ein <xref:System.Type> -Objekt einen generischen Typ darstellt. Verwenden der <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft können Sie bestimmen, ob ein <xref:System.Type> -Objekt ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ darstellt.  
  
> [!NOTE]
>  Die <xref:System.Type.IsGenericType%2A> -Eigenschaft gibt `false` Wenn nicht die unmittelbare Typ generisch ist. Angenommen, ein Array, dessen Elemente vom Typ sind `A<int>` (`A(Of Integer)` in Visual Basic) ist nicht selbst ein generischer Typ.  
  
 In der folgenden Tabelle werden die Invarianten Bedingungen für allgemeine Begriffe in generischen Reflektion verwendet zusammengefasst.  
  
|Begriff|Invariante|  
|----------|---------------|  
|generische Typdefinition|Die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft ist `true`.<br /><br /> Definiert einen generischen Typ an. Ein konstruierter Typ wird erstellt, durch Aufrufen der <xref:System.Type.MakeGenericType%2A> Methode auf eine <xref:System.Type> -Objekt, das eine generische Typdefinition darstellt, und ein Array der Argumente des Typs angeben.<br /><br /> <xref:System.Type.MakeGenericType%2A>kann nur für generische Typdefinitionen aufgerufen werden.<br /><br /> Generische Typdefinition ist ein generischer Typ (die <xref:System.Type.IsGenericType%2A> Eigenschaft `true`), das Gegenteil aber nicht "true".|  
|generischer Typ|Die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`.<br /><br /> Hierbei kann es sich um eine generische Typdefinition, ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ sein.<br /><br /> Beachten Sie, dass ein, dessen Elementtyp Arraytyp ist generisch ist nicht selbst ein generischer Typ. Dasselbe gilt für eine <xref:System.Type> Objekt, das einen Zeiger auf einen generischen Typ darstellt.|  
|Öffnen Sie konstruierten Typ|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> Beispiele sind ein generischer Typ, der nicht zugewiesene Typparameter verfügt, ein Typ, der in der Definition eines generischen Typs oder in einen offenen konstruierten Typ geschachtelt ist oder einen generischen Typ an, die ein Type-Argument für die die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft ist `true`.<br /><br /> Es ist nicht möglich, eine Instanz einer offenen konstruierten Typ erstellen.<br /><br /> Beachten Sie, dass nicht alle offene konstruierte Typen generisch sind. Angenommen, ein Array, dessen Elementtyp eine generische Typdefinition ist, ist nicht generisch, und ein Zeiger auf einen offenen konstruierten Typ ist nicht generisch.|  
|geschlossenen konstruierten Typs|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `false`.<br /><br /> Wenn hat untersuchten rekursiv, den Typ nicht zugewiesene generische Parameter.|  
|generischer Typparameter|Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft ist `true`.<br /><br /> Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.|  
|generisches Typargument|Kann beliebigen Typs, einschließlich einen generischen Typparameter ab.<br /><br /> Typargumente werden als Array von angegeben <xref:System.Type> -Objekte übergeben, um die <xref:System.Type.MakeGenericType%2A> Methode, wenn Sie einen konstruierten generischen Typ erstellen. Wenn Instanzen des resultierenden Typs erstellt werden, sind die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft muss `false` für alle Typargumente.|  
  
 Im folgenden Codebeispiel und Tabelle veranschaulichen einige dieser Begriffe und Invarianten. Die `Derived` -Klasse ist von besonderem Interesse, da Basistyp einen konstruierten Typ ist, eine Mischung von Typen und die Typparameter in der Liste der Typargumente hat.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 Die folgende Tabelle zeigt Beispiele, die in den Klassen zu erstellen und verwenden `Base`, `Derived`, und `G`. Wenn die C++- und C#-Code identisch ist, wird nur ein Eintrag angezeigt.  
  
|Beispiel|Invarianten|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Für den Typ der Variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A>ist `false` da `d` ist ein Array.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `false`.|  
|`T`, `U`, und `V` (bei allen Vorkommen)|<xref:System.Type.IsGenericParameter%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericType%2A>ist `false` , da es keine Möglichkeit gibt, die einen Typparameter auf generische Typen zu beschränken.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>ist `true` da `T`, `U`, und `V` selbst generische Typparameter sind. Dies bedeutet nichts über Typargumente nicht, die ihnen später zugewiesen werden.|  
|Der Typ des Felds`F`|<xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>ist `false` , da der Typparameter der einen Typ zugewiesen wurde `G`. Beachten Sie, dass dies dem Aufruf der <xref:System.Type.MakeGenericType%2A> Methode.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>ist `true` da der Typ des Felds `F` ist ein Typargument, das ein offener konstruierten Typ ist. Der konstruierte Typ geöffnet ist. da Typargument (d. h. `Base`) ist eine generische Typdefinition. Dies veranschaulicht die rekursive Charakter der <xref:System.Type.IsGenericType%2A> Eigenschaft.|  
|Die geschachtelte Klasse`Nested`|<xref:System.Type.IsGenericType%2A>ist `true`, obwohl die `Nested` -Klasse verfügt über keine generischen Typparameter von allein, weil sie in einem generischen Typ geschachtelt ist.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true`. Sie können also Aufrufen der <xref:System.Type.MakeGenericType%2A> -Methode, und übergeben Sie den Typparameter von einschließenden Typs `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>ist `true` , da der einschließende Typ, `Derived`, verfügt der generische Typparameter. Dies veranschaulicht die rekursive Charakter der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert, der die <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, und <xref:System.Type.ContainsGenericParameters%2A> Eigenschaften für die Typen, die im Abschnitt "Hinweise" beschrieben. Erläuterungen der Eigenschaftswerte finden Sie unter "Hinweise" der zugehörigen Tabelle.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können. Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie erstellen und instanziieren Sie den Typ `G<int>` (`G(Of Integer)` in Visual Basic), durch Aufrufen der <xref:System.Type.MakeGenericType%2A> Methode mit einer Liste mit generisches Argument der <xref:System.Int32> Typ. Erhält eine <xref:System.Type> Objekt, das dies darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methode ruft die generische Typdefinition zurück, erneut aus.  
  
 Verwenden der <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft, um zu bestimmen, ob Sie aus dem aktuellen Typ neue Typen erstellen können. Wenn die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft gibt `true`, Sie erreichen die <xref:System.Type.MakeGenericType%2A> Methode, um neue generische Typen zu erstellen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Informationen zu einem Typ, einschließlich, und zwar unabhängig davon, ob es sich um eine generische Typdefinition ist. Informationen werden für einen konstruierten Typ, dessen Definition eines generischen Typs und einem normalen Typ angezeigt.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch`MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das mit dem aktuellen Typ zu vergleichende Objekt.</param>
        <summary>Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <see cref="T:System.Type" /> ist.</summary>
        <returns>
          <see langword="true" />, wenn der aktuelle <see langword="Type" /> in der Vererbungshierarchie des von <paramref name="o" /> dargestellten Objekts vorhanden ist oder wenn der aktuelle <see langword="Type" /> eine Schnittstelle ist, die von <paramref name="o" /> implementiert wird. <see langword="false" />, wenn keine dieser Bedingungen zutrifft, wenn <paramref name="o" /> den Wert <see langword="null" /> hat oder wenn der aktuelle <see langword="Type" /> ein offener generischer Typ ist (d. h. <see cref="P:System.Type.ContainsGenericParameters" /> gibt <see langword="true" /> zurück).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
> [!NOTE]
>  Ein konstruierter Typ ist keine Instanz der generischen Typdefinition. D. h. `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) ist keine Instanz des `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsInstanceOfType`-Methode gezeigt.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> eine Schnittstelle ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> eine Typdeklaration als Klasse, Schnittstelle oder ein Wert unterscheidet.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Schnittstelle, für den Schnittstellentyp überprüft und gibt an, ob eine Klasse verfügt über die `IsInterface` Eigenschaftensatz.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als Annehmlichkeit bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.  
  
 Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> Enumerationswert in den Typ, um anzugeben, das Layout ist sequenziell.  
  
> [!NOTE]
>  Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Weitere Informationen finden Sie im Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz einer Klasse für die die <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> Enumerationswert in der <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Klasse festgelegt wurde, überprüft, ob die <xref:System.Type.IsLayoutSequential%2A> -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsMarshalByRef" />-Eigenschaft und bestimmt, ob der <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob der angegebene Typ Verweis gemarshallt wird, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Type" /> in einem anderen Typ geschachtelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsNested%2A> -Eigenschaft gibt `true` für alle geschachtelten Typen unabhängig von der Sichtbarkeit. Um zur gleichen Zeit Schachtelung und Sichtbarkeit zu testen, verwenden Sie die verwandten Eigenschaften <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, oder <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Die <xref:System.Reflection.TypeAttributes.VisibilityMask> Enumerationsmember wählt die Sichtbarkeitsattribute für einen Typ aus.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
> [!NOTE]
>  Die Sprachen c# und Visual Basic enthalten keine Semantik, mit denen Sie einen geschachtelten Typ definieren, der nur für geschützte Typen in der eigenen Assembly sichtbar ist. `protected internal`Sichtbarkeit in C# geschrieben und `Protected Friend` Sichtbarkeit in Visual Basic definieren einen geschachtelten Typ, der sowohl für geschützte Typen und Typen in der gleichen Assembly sichtbar ist.  
  
 Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte des gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
 Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sichtbarkeit eines Typs ist `protected internal` in c# oder `Protected Friend` in Visual Basic die <xref:System.Type.IsNestedFamORAssem%2A> -Eigenschaft gibt `true`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
 Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</summary>
        <value>
          <see langword="true" />, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen. Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> nicht als öffentlich deklariert ist.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Type" /> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nicht mit geschachtelten Typen. Verwenden Sie die <xref:System.Type.IsNestedPublic%2A> Eigenschaft stattdessen.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Dieses Beispiel verwenden bewirkt, dassdie `IsNotPublic` Eigenschaft, um die Sichtbarkeit des Typs abzurufen.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, warum Sie nicht verwenden können `IsPublic` und `IsNotPublic` für geschachtelte Klassen.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie darauf, nur für die Ergebnisse der `IsNestedPublic` und `IsNestedPrivate`. Die Ausgabe der Reflektion für dieses Codefragment würde wie folgt lauten:  
  
|Klasse|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|A|FALSE|false|FALSE|true|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsPointer` Eigenschaft.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPointer" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primitive Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPrimitive" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primitive Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob der angegebene Typ ein primitiver Typ ist, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als öffentlich deklariert ist.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Type" /> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie keine geschachtelten Typen. Verwenden Sie <xref:System.Type.IsNestedPublic%2A> stattdessen.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `true`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>Wählt die Sichtbarkeitsattribute an.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz des `MyTestClass`, überprüft, ob die `IsPublic` -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie darauf, nur für die Ergebnisse der <xref:System.Type.IsNestedPublic%2A> und <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als versiegelt deklariert ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als versiegelt deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von einem `sealed` Klasse, sucht der `IsSealed` -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" />, wenn er sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt. In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird. Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" /> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt. In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird. Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value>
          <see langword="true" />, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft gibt `true`, <xref:System.Type.IsSecurityCritical%2A> und <xref:System.Type.IsSecuritySafeCritical%2A> Eigenschaften zurückgeben `false`.  
  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt. Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird. Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> serialisierbar ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> serialisierbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz des `MyTestClass` -Klasse, das [Serializable]-Attribut festgelegt, und überprüft die `IsSerializable` -Eigenschaft für `true` oder `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</summary>
        <value>
          <see langword="true" />, wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Namen, die beginnen mit einem Unterstrich (_), Eigenschaftenaccessoren und Operatoren überladen von Methoden enthalten sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob der aktuelle <see cref="T:System.Type" /> vom angegebenen <see cref="T:System.Type" /> abgeleitet ist.</summary>
        <returns>
          <see langword="true" />, wenn der aktuelle <see langword="Type" /> von <paramref name="c" /> abgeleitet ist, andernfalls <see langword="false" />. Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="c" /> und der aktuelle <see langword="Type" /> gleich sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie erreichen die <xref:System.Type.IsSubclassOf%2A> Methode, um Folgendes festzulegen:  
  
-   Gibt an, ob eine Klasse von einem anderen abgeleitet ist.  
  
-   Ob ein Typ abgeleitet <xref:System.ValueType>. Allerdings die <xref:System.Type.IsValueType%2A> effizienter lässt sich bestimmen, ob ein Typ ein Werttyp ist.  
  
-   Ob ein Typ abgeleitet <xref:System.Enum>. Allerdings die <xref:System.Type.IsEnum%2A> Methode ist eine effizientere Methode zum bestimmen, ob ein Typ eine Enumeration ist.  
  
-   Gibt an, ob ein Typ ein Delegat ist, ob er entweder abgeleitet <xref:System.Delegate> oder <xref:System.MulticastDelegate>.  
  
 Die <xref:System.Type.IsSubclassOf%2A> Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird, oder gibt an, ob eine Klasse eine Schnittstelle implementiert. Verwenden der <xref:System.Type.IsAssignableFrom%2A> Methode für diesen Zweck, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Wenn das aktuelle <xref:System.Type> jedoch einen Typparameter darstellt, in der Definition einer generischen Typ- oder Methodendefinition, abgeleitet aus seiner Class-Einschränkung oder <xref:System.Object?displayProperty=nameWithType> hat keine klasseneinschränkung.  
  
> [!NOTE]
>  Außer in Verbindung mit Schnittstellen, <xref:System.Type.IsSubclassOf%2A> ist das Gegenteil von <xref:System.Type.IsAssignableFrom%2A>. D. h. wenn `t1.IsSubclassOf(t2)` ist `true`, klicken Sie dann `t2.IsAssignableFrom(t1)` ist auch `true`.  
  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Klasse namens `Class1` und eine abgeleitete Klasse mit dem Namen `DerivedC1`. Ruft die <xref:System.Type.IsSubclassOf%2A> Methode, um anzugeben, dass `DerivedC1` ist eine Unterklasse von `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value>
          <see langword="true" />, wenn für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wird verwendet, um die Zeichenfolge Formatattribute auszuwählen. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Werttyp ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werttypen sind Typen, die als Sequenzen von Bits dargestellt werden. Werttypen sind nicht Klassen oder Schnittstellen. Werttypen werden in einigen Programmiersprachen als "Strukturen" bezeichnet. Enumerationen sind ein besonderer Fall von Werttypen.  
  
 Diese Eigenschaft gibt `false` für die <xref:System.ValueType> Klasse, da <xref:System.ValueType> ist kein Werttyp selbst. Es ist die Basisklasse für alle Werttypen und aus diesem Grund zu einem beliebigen Werttyp zugewiesen werden kann. Dies ist nicht möglich, wenn <xref:System.ValueType> selbst wurde ein Werttyp. Werttypen sind geschachtelt, wenn sie ein Feld des Typs zugewiesen werden <xref:System.ValueType>.  
  
 Diese Eigenschaft gibt `true` für Enumerationen, jedoch nicht für die <xref:System.Enum> -Typ selbst. Ein Beispiel für dieses Verhalten finden Sie unter <xref:System.Type.IsEnum%2A>.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Variable vom Typ `MyEnum`, überprüft, ob die `IsValueType` -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsValueType" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, um die Implementierung von alternativen Typsysteme zu aktivieren. Es wird im Allgemeinen nicht im Anwendungscode verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf den <see cref="T:System.Type" /> aus Code von außerhalb der Assembly zugegriffen werden kann.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Teil der öffentlichen Schnittstelle einer Komponente-Assembly ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird testet zwei Klassen, von denen nur, die eine außerhalb der Assembly sichtbar ist.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.  
  
 **Hinweis** die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen. Überladung dieser Methode kann nur verwendet werden, um vektortypen zu erstellen, und es ist die einzige Möglichkeit, einen Vector-Typ zu erstellen. Verwenden der <xref:System.Type.MakeArrayType%28System.Int32%29> -methodenüberladung, um mehrdimensionale von Arraytypen zu erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
 - oder -   
  
 Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Die Anzahl von Dimensionen für das Array. Diese Zahl muss kleiner oder gleich 32 sein.</param>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
        <returns>Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.  
  
> [!NOTE]
>  Die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen. Überladung dieser Methode können Sie um einen Vector-Typ zu erstellen. Wenn `rank` beträgt 1, Überladung dieser Methode gibt einen mehrdimensionales Array-Typ, der an eine Dimension über zurück. Verwenden der <xref:System.Type.MakeArrayType> -methodenüberladung vektortypen zu erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> ist ungültig. Beispielsweise 0 oder ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
 - oder -   
  
 Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.  
  
 - oder -   
  
 <paramref name="rank" /> ist größer als 32.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeByRefType%2A> Methode bietet eine Möglichkeit zum Generieren von `ref` Typen (`ByRef` in Visual Basic) für Parameter aufgeführt sind.  
  
 Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, gibt diese Methode eine <xref:System.Type> Objekt darstellt `Int32&`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
 - oder -   
  
 Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</param>
        <summary>Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <see cref="T:System.Type" />-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeGenericType%2A> Methode können Sie Code schreiben, der spezifische Typen zugewiesen werden, um die Typparameter einer generischen Typdefinition, wodurch eine <xref:System.Type> -Objekt, das einen bestimmten konstruierten Typ darstellt. Sie können dies <xref:System.Type> Objekt, das zur Laufzeit Instanzen des konstruierten Typs zu erstellen.  
  
 Typen mit erstellt <xref:System.Type.MakeGenericType%2A> geöffnet sein können, d. h. einige ihrer Typargumente Typparameter von einschließenden generischen Methoden und Typen werden können. Sie können solche offen konstruierten Typen verwenden, wenn Ausgeben von dynamischen Assemblys. Betrachten Sie beispielsweise die Klassen `Base` und `Derived` in den folgenden Code.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Zum generieren `Derived` in einer dynamischen Assembly zum Erstellen von seinem Basistyps erforderlich ist. Rufen Sie hierzu die <xref:System.Type.MakeGenericType%2A> Methode auf eine <xref:System.Type> Objekt, das die Klasse darstellt `Base`, verwenden die generischen Typargumente <xref:System.Int32> und die Typparameter `V` aus `Derived`. Da die Typen und generischen Typparameter von dargestellt sind <xref:System.Type> Objekte aufweist, ein Array mit diesen beiden kann übergeben werden, um die <xref:System.Type.MakeGenericType%2A> Methode.  
  
> [!NOTE]
>  Einen konstruierten Typ wie z. B. `Base<int, V>` ist nützlich, wenn Code ausgeben, jedoch nicht die <xref:System.Type.MakeGenericType%2A> Methode für diesen Typ, da es sich nicht um eine generische Typdefinition ist. Um einen geschlossenen konstruierten Typ zu erstellen, der instanziiert werden kann, rufen Sie zuerst die <xref:System.Type.GetGenericTypeDefinition%2A> Methode zum Abrufen einer <xref:System.Type> Objekt, das die generische Typdefinition darstellt, und rufen dann <xref:System.Type.MakeGenericType%2A> mit den gewünschten Typargumenten.  
  
 Die <xref:System.Type> zurückgegebenes Objekt <xref:System.Type.MakeGenericType%2A> ist identisch mit der <xref:System.Type> abgerufen, indem die <xref:System.Object.GetType%2A> Methode den resultierenden konstruierten Typ, oder die <xref:System.Object.GetType%2A> -Methode einer jeglichen konstruierter Typ, der aus der gleichen generischen erstellt wurde mit den gleichen Typargumenten Typdefinition.  
  
> [!NOTE]
>  Ein Array von generischen Typen nicht selbst ein generischer Typ ist. Sie können nicht aufrufen <xref:System.Type.MakeGenericType%2A> Geben Sie auf ein Array wie z. B. `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). So erstellen Sie einen geschlossenen generischen Typs aus `C<T>[]`, rufen Sie <xref:System.Type.GetElementType%2A> zum Abrufen der generischen Typdefinition `C<T>`; Aufrufen <xref:System.Type.MakeGenericType%2A> für die generische Typdefinition, erstellen den konstruierten Typ aus, und rufen Sie schließlich die <xref:System.Type.MakeArrayType%2A> Methode auf den konstruierten Typ zum Erstellen des Arraytyps. Dasselbe gilt für Zeigertypen und `ref` Typen (`ByRef` in Visual Basic).  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Geschachtelte Typen  
 Wenn ein generischer Typ mit c#, C++ oder Visual Basic definiert ist, sind seine geschachtelten Typen alle generisch. Dies gilt auch, wenn die geschachtelten Typen keine eigenen Typparameter verfügen, da alle drei Sprachen die Typparameter von einschließenden Typen in der Typparameterliste des geschachtelten Typen enthalten. Betrachten Sie die folgenden Klassen:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Der Typparameterliste der geschachtelten Klasse `Inner` verfügt über zwei Typparameter `T` und `U`, das erste ist der Typparameter seiner einschließenden Klasse. Auf ähnliche Weise der Typparameterliste der geschachtelten Klasse `Innermost1` verfügt über drei Typparameter, `T`, `U`, und `V`, mit `T` und `U` aus den einschließenden Klassen stammen. Die geschachtelte Klasse `Innermost2` verfügt über zwei Typparameter `T` und `U`, die aus den einschließenden Klassen stammen.  
  
 Wenn die Parameterliste des einschließenden Typs mehrere Typparameter aufweist, werden alle Typparameter in der Reihenfolge in der Typparameterliste des geschachtelten Typs enthalten.  
  
 Um einen generischen Typ aus der generischen Typdefinition für einen geschachtelten Typ zu konstruieren, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit dem Array gebildet durch Verketten der Typ Argument Arrays aller einschließenden Typen, ab der äußersten generische Typ, und endet mit der Geben Sie Argumentarray des geschachtelten Typs selbst verfügt über eigene Typparameter. Zum Erstellen einer Instanz des `Innermost1`, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit einem Array mit drei Typen, T, U und V zugewiesen werden. Zum Erstellen einer Instanz von `Innermost2`, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit einem Array mit zwei Typen, zuzuweisenden T "und" U.  
  
 Die Sprachen weitergegeben, die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelten Typen zu definieren. Andernfalls würde die Typparameter nicht im Gültigkeitsbereich innerhalb des Texts der geschachtelten Typen sein. Es ist möglich, geschachtelte Typen definieren, ohne die Weitergabe der Typparameter von einschließenden Typen durch Ausgeben von Code in dynamischen Assemblys oder mithilfe der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Betrachten Sie folgenden Code für die MSIL-Assembler:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 In diesem Beispiel ist es nicht möglich, definieren Sie ein Feld vom Typ `T` oder `U` in Klasse `Innermost`, da die Typparameter nicht im Gültigkeitsbereich befinden. Der folgende Assemblercode definiert geschachtelte Klassen, die die Verhaltensweise, wäre in C++, Visual Basic und c# definiert:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) geschachtelte Klassen definiert, in hoch entwickelter Sprachen und untersuchen diese Benennungsschema.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.MakeGenericType%2A> Methode so erstellen Sie einen konstruierten Typ aus der Definition des generischen Typs für die <xref:System.Collections.Generic.Dictionary%602> Typ. Den konstruierte Typ darstellt, ein <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüssel.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keine generische Typdefinition dar. Das heißt, <see cref="P:System.Type.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im <paramref name="typeArguments" /> ist nicht identisch mit der Anzahl von Typparametern in der aktuellen generischen Typdefinition.  
  
 - oder -   
  
 Ein beliebiges Element von <paramref name="typeArguments" /> erfüllt nicht die Einschränkungen für den entsprechenden Typparameter des aktuellen generischen Typs angegeben.  
  
 - oder -   
  
 <paramref name="typeArguments" />enthält eine Element, das ein Zeigertyp (<see cref="P:System.Type.IsPointer" /> gibt <see langword="true" />), einen Typ von Ref (<see cref="P:System.Type.IsByRef" /> gibt <see langword="true" />), oder <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakePointerType%2A> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.  
  
 Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, gibt diese Methode eine <xref:System.Type> Objekt darstellt `Int32*`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
 - oder -   
  
 Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Reflection.MemberTypes" />-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</summary>
        <value>Ein <see cref="T:System.Reflection.MemberTypes" />-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft überschreibt <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Wenn Sie daher eine Reihe von untersuchen <xref:System.Reflection.MemberInfo> Objekte – z. B. das zurückgegebene Array <xref:System.Type.GetMembers%2A>– die <xref:System.Reflection.MemberInfo.MemberType%2A> -Eigenschaft gibt <xref:System.Reflection.MemberTypes?displayProperty=nameWithType> Wenn ein angegebenes Element ein geschachtelter Typ ist.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <xref:System.Reflection.MemberTypes?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die `MemberType` Feld als Parameter an die `GetMember` Methode:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt einen in den <see cref="T:System.Type" />-Informationen fehlenden Wert dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `Missing` Feld für den Aufruf durch Reflektion auf den Standardwert eines Parameters zu erhalten. Wenn die `Missing` Feld für den Parameterwert übergeben wird, und es ist kein Standardwert für diesen Parameter ein <xref:System.ArgumentException> ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `Missing` Feld zum Aufrufen einer Methode mit den Standardargumenten.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt die folgende Ausgabe:  
  
 eine = 10 b = 55.3 c = 12  
  
 eine = 10 b 1.3 c = 1 =  
  
 eine = 10 b 1.2 c = 1 =  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul (die DLL) ab, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</summary>
        <value>Das Modul, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt das Modul, in dem die generische Typdefinition definiert wurde. Angenommen, Sie erstellen eine Instanz von `MyGenericStack<int>`, die <xref:System.Type.Module%2A> -Eigenschaft für den konstruierten Typ gibt das Modul, in dem `MyGenericStack<T>` definiert ist.  
  
 Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert `T`.  
  
   
  
## Examples  
 Im folgenden Beispiel veranschaulicht die <xref:System.Type.Namespace%2A> und `Module` Eigenschaften und die <xref:System.Type.ToString%2A> Methode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace von <see cref="T:System.Type" /> ab.</summary>
        <value>Der Namespace des <see cref="T:System.Type" />; <see langword="null" />, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Namespace ist eine logische zur Entwurfszeit naming Annehmlichkeit, hauptsächlich zum Definieren von Bereich in einer Anwendung, und Organisieren von Klassen und anderen Typen in einer hierarchischen Struktur verwendet. Vom Standpunkt der Laufzeit gibt es keine Namespaces.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, gibt diese Eigenschaft den Namespace, die generische Typdefinition enthält. Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt den Namespace, die generische Typdefinition enthält, die definiert `T`.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel veranschaulicht die `Namespace` und <xref:System.Type.Module%2A> Eigenschaften und die <xref:System.Type.ToString%2A> Methode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</summary>
        <value>Das <see langword="Type" />-Objekt, über das dieses <see cref="T:System.Type" />-Objekt abgerufen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für <xref:System.Type> Objekte, die der Wert dieser Eigenschaft entspricht immer der Wert von der <xref:System.Type.DeclaringType%2A> Eigenschaft.  
  
   
  
## Examples  
 Dieses Beispiel zeigt den reflektierten Typ einer geschachtelten Klasse.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="throwIfNotFound">
          <see langword="true" />, damit eine <see cref="T:System.TypeLoadException" /> ausgelöst wird, wenn der Typ nicht gefunden wird. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird, wenn der Typ nicht gefunden wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase">
          <see langword="true" />Groß-/Kleinschreibung nicht beachtet werden soll für <c>TypeName</c>; <see langword="false" /> Groß-/Kleinschreibung gesucht werden soll für <c>TypeName</c>.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird. Der Typ wird für die Reflektion, nicht für Ausführung geladen.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwIfNotFound" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwIfNotFound" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Assembly mit dem Typ nicht in den reflektionsbezogenen Kontext geladen ist, mithilfe der <xref:System.Type.ReflectionOnlyGetType%2A> Methode ist gleichbedeutend mit dem ersten Laden der Assembly für die Reflektion, mit der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> -Methode, und Laden Sie dann durch Aufrufen des Typs der der Assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> Methode. Informationen über qualifizierte Assemblynamen finden Sie unter der <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> Eigenschaft. Weitere Informationen zum Angeben der Typnamen finden Sie unter der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung.  
  
 Wenn die Assembly bereits für Ausführung geladen wird, wird eine weitere Kopie in den reflektionsbezogenen Kontext geladen.  
  
 Die `throwIfNotFound` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwIfNotFound`. Wenn die Assembly nicht gültig ist, z. B. eine <xref:System.BadImageFormatException> wird ausgelöst, selbst wenn `throwIfNotFound` ist `false`.  
  
 Weitere Informationen zu den ReflectionOnly Kontext verwenden, finden Sie unter [wie: Laden von Assemblys in den Reflection-Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.  
  
 - oder -   
  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt ein Array mit <see cref="T:System.TypedReference" />-Objekten dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> enthält keinen Assemblynamen.  
  
 - oder -   
  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z.B. „MyType[,*,]“).  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
 - oder -   
  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 - oder -   
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, der das Layout des aktuellen Typs beschreibt.</summary>
        <value>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, das den allgemeinen Layoutaufbau des aktuellen Typs beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute>wird nicht zurückgegeben, durch die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode. Verwenden Sie stattdessen diese Eigenschaft zum Abrufen.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert zuerst eine Klasse, eine Struktur und eine Struktur mit speziellen Layoutattribute (innerhalb der Klasse werden die Strukturen geschachtelt). Anschließend wird die <xref:System.Type.StructLayoutAttribute%2A> -Eigenschaft zum Abrufen einer <xref:System.Runtime.InteropServices.StructLayoutAttribute> für jeden Typ, und zeigt die Eigenschaften der Attribute.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="String" /> zurück, der den Namen des aktuellen <see langword="Type" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Namen des aktuellen <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den voll gekennzeichneten common Language Runtime-Namespace und den Namen für alle primitiven Typen. Angenommen, die C#-Anweisung, `(long)0.Type().ToString()` "System. Int64" anstelle von "Int64" zurückgegeben.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ, den Typ und ihre Typargumente durch den Namespace und durch den geschachtelten Typ, aber nicht durch die Assembly qualifiziert werden. Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode gibt den nicht qualifizierten Namen des Typparameters zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel veranschaulicht die <xref:System.Type.Namespace%2A> und <xref:System.Type.Module%2A> Eigenschaften und die `ToString` Methode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <value>Das Handle für den aktuellen <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle`Kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt. Dieses Handle ist während der Prozesslebensdauer eindeutig. Das Handle ist gültig, nur in der Anwendungsdomäne, in der sie abgerufen wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel gibt das Handle des entsprechenden Typs zurück, und übergibt das Handle für eine Methode, die den Typ aus dem Handle abgerufen und angezeigt.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Initialisierer für den Typ ab.</summary>
        <value>Ein Objekt, das den Namen des Klassenkonstruktors von <see cref="T:System.Type" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasseninitialisierer stehen auch über die <xref:System.Type.FindMembers%2A> -Methode, oder über Überladungen des der <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, und <xref:System.Type.GetConstructors%2A> Methoden, die <xref:System.Reflection.BindingFlags> als Parameter.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, gibt diese Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</summary>
        <value>Der Systemtyp, der <see cref="T:System.Type" />zugrunde liegt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
