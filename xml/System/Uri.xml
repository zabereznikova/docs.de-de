<Type Name="Uri" FullName="System.Uri">
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Objektdarstellung eines URIs (Uniform Resource Identifier) und einfachen Zugriff auf die Teile des URIs bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein URI ist eine kompakte Darstellung einer Ressource, die für Ihre Anwendung im Intranet oder Internet verfügbar. Die <xref:System.Uri> Klasse definiert die Eigenschaften und Methoden für die Behandlung von URIs zu analysieren, vergleichen und kombinieren. Die <xref:System.Uri> Klasseneigenschaften sind schreibgeschützt; verwenden Sie zum Erstellen eines änderbaren Objekts die <xref:System.UriBuilder> Klasse.  
  
 Relative URIs (z. B. "/ /New/Index.htm") muss in Bezug auf einen Basis-URI erweitert werden, damit sie absolute sind. Die <xref:System.Uri.MakeRelative%2A> Methode wird bereitgestellt, um absolute URIs in relative URIs bei Bedarf zu konvertieren.  
  
 Die <xref:System.Uri> Konstruktoren sind nicht mit Escapezeichen versehen URI-Zeichenfolgen, die Zeichenfolge ist kein ordnungsgemäß formatierter URI einschließlich Schemabezeichner.  
  
 Die <xref:System.Uri> Eigenschaften zurückgeben eine kanonische datendarstellung in Escapezeichen Codierung mit allen Zeichen mit Unicode-Werten größer als 127 durch ihre hexadezimalen-Entsprechungen ersetzt. Versetzen Sie den URI in kanonische Form der <xref:System.Uri> Konstruktor führt die folgenden Schritte aus:  
  
-   Das URI-Schema konvertiert in Kleinbuchstaben.  
  
-   Konvertiert den Hostnamen in Kleinbuchstaben.  
  
-   Wenn der Hostname eine IPv6-Adresse ist, wird die kanonische IPv6-Adresse verwendet. ScopeId und andere optionalen IPv6-Daten werden entfernt.  
  
-   Entfernt Standard und leere Portnummern.

-   Escapezeichen (auch bekannt als Prozent-codierte Oktette), die einen reservierten Zweck haben (auch bekannt als wird ohne Escapezeichen) decodiert. Diese nicht reservierten Zeichen umfassen Groß- und Kleinbuchstaben (% 41 % 5A "und" % 61 % 7A), Dezimalstellen (30-% 39), Bindestrich (% 2D), Punkt (% 2E), Unterstrich (% 5F) und Tilde (% 7E).

-   Kanonisiert den Pfad für hierarchische URIs von Sequenzen wie z. B. /. /, /... /- und / / (fest, ob die Sequenz wird mit einem Escapezeichen versehen). Beachten Sie, dass einige Schemas für die diese Sequenzen nicht komprimiert werden sollen.
  
-   Für hierarchische URIs Wenn der Host nicht beendet wird, mit einem Schrägstrich (/) enthält, wird eine hinzugefügt.  
  
-   Standardmäßig werden alle reservierten Zeichen im URI in Übereinstimmung mit RFC 2396 mit Escapezeichen versehen. Dieses Verhalten ändert sich, wenn International Resource Identifiers oder internationale Domänennamen Analyse in der Groß-/Kleinschreibung reservierte Zeichen im URI aktiviert ist werden in Übereinstimmung mit RFC 3986 und RFC 3987 mit Escapezeichen versehen.

 Im Rahmen der Kanonisierung im Konstruktor für einige Schemas, die Punkt-zu-Segmente und die leere Segmente (/. /, /.. /- und / /), werden komprimiert (das heißt, sie werden entfernt). Die Schemas für die URI dieser Sequenzen komprimiert, umfassen http, Https, Tcp, net.pipe und net.tcp. Bei einigen anderen Schemas werden diese Sequenzen nicht komprimiert. Im folgenden wird diese Komprimierung wie in der Praxis aussieht.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("tcp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("tcp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, unescaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Dieser Code ausgeführt wird, gibt die folgende Ausgabe zurück, mit dem Escapezeichen Sequenzen ohne Escapezeichen, falls erforderlich, und klicken Sie dann komprimiert.

```  
http://myUrl/  
/  
```  
  
 Können Sie den Inhalt der Transformieren der <xref:System.Uri> Klasse aus einer Escapezeichen codierten URI-Verweis auf einen lesbaren URI-Verweis mithilfe der <xref:System.Uri.ToString%2A> Methode. Beachten Sie, dass möglicherweise einige reservierten Zeichen in der Ausgabe der mit Escapezeichen versehen werden die <xref:System.Uri.ToString%2A> Methode. Dieser dient zur Unterstützung von unmissverständliche Rekonstruktion eines URIs aus den Rückgabewert von <xref:System.Uri.ToString%2A>.  
  
 Einige URIs enthalten einen Fragmentbezeichner oder eine Abfrage oder beides. Ein Fragmentbezeichner ist jeglichem Text, ein Nummernzeichen folgt (#), nicht einschließlich die Nummernzeichen; der Fragmenttext wird gespeichert, der <xref:System.Uri.Fragment%2A> Eigenschaft. Abfrageinformationen ist jeglichem Text, ein Fragezeichen (?) im URI folgt. Der Abfragetext wird gespeichert, der <xref:System.Uri.Query%2A> Eigenschaft.  
  
 In .NET Framework, Version 1.1, die an einen Konstruktor angegebene Zeichenfolge ein unbekanntes Schema enthält und "" c: "\\", fügt die Uri-Klasse "/ /" hinter dem Doppelpunkt stehenden. Z. B. der URI `xyz:c:\abc` konvertiert `xyz://c:/abc`. In .NET Framework, Version 2.0, dieses Verhalten wurde entfernt, und die Beispielzeichenfolge in konvertiert `xyz:c:/abc`.  
  
> [!NOTE]
>  Die URI-Klasse unterstützt die Verwendung von IP-Adressen in beiden Quad-Schreibweise für IPv4-Protokoll und Hexadezimalschreibweise für IPv6-Protokoll. Denken Sie daran, schließen Sie die IPv6-Adresse in eckige Klammern, wie in http://[::1].  
  
## <a name="international-resource-identifier-support"></a>International Resource Identifier-Unterstützung  
 Webadressen werden in der Regel ausgedrückt mit uniform Resource Identifier, die aus einem sehr eingeschränkten Satz von Zeichen bestehen:  
  
-   ASCII-Großbuchstaben und -Kleinbuchstaben des englischen Alphabets  
  
-   Ziffern von 0 bis 9  
  
-   einer kleinen Anzahl weiterer ASCII-Symbole  
  
 Die Spezifikationen für URIs sind in RFC 2396, RFC 2732, RFC 3986 und RFC 3987 veröffentlicht von der Internet Engineering Task Force (IETF) dokumentiert.  
  
 Durch das ständige Wachstum des Internets wird es immer notwendiger, Ressourcen in anderen Sprachen als in Englisch zu bezeichnen. Bezeichner, die dies ermöglichen und die Nicht-ASCII-Zeichen (Zeichen des Unicode-/ISO-Zeichensatzes 10646) zulassen, werden als International Resource Identifiers (IRIs) bezeichnet. Die IRI-Spezifikationen werden in RFC 3987 dokumentiert, die von der IETF veröffentlicht wird. Wenn IRIs verwendet werden, kann eine URL Unicode-Zeichen enthalten.  
  
 Die vorhandene <xref:System.Uri> Klasse erweitert wurde in .NET Framework 3.5, 3.0 SP1 und 2.0 SP1 bereitstellen, unterstützen IRI gemäß RFC 3987. Benutzer von .NET Framework-Versionen vor Version 4.5 werden jede Änderung des Verhaltens gegenüber den .NET Framework 2.0 nicht angezeigt, es sei denn, sie IRI explizit aktivieren. Dadurch wird die Anwendungskompatibilität mit früheren Versionen von .NET Framework garantiert.  
  
 Die folgende Änderung ist erforderlich, um Unterstützung für IRI zu aktivieren:  
  
-   Geben Sie, ob Sie, dass Internationalized Domain Name (IDN) zu analysieren, die auf den Domänennamen angewendet und gibt an, ob die IRI-Analyse Regeln angewendet werden soll. Dies kann erfolgen, der *"Machine.config"* oder in der *"App.config"* Datei. Fügen Sie beispielsweise Folgendes ein:  
  
    ```  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Benutzer von .NET Framework 4.5 und höher haben immer IRI aktiviert. IRI-Analyse kann nicht geändert werden, mithilfe einer *config* Datei.  
  
 Beim Aktivieren von IDN werden alle Unicode-Bezeichnungen in einem Domänennamen in ihre Punycode-Entsprechungen konvertiert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“. So werden vorhandene DNS-Server im Internet unterstützt, da die meisten DNS-Server nur ASCII-Zeichen unterstützen (siehe RFC 3940).  
  
 Das Aktivieren von IRI und IDN wirkt sich auf den Wert der Eigenschaft <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> aus. Das Aktivieren von IRI und IDN kann auch das Verhalten der Methoden <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> und <xref:System.Uri.IsWellFormedOriginalString%2A> verändern.  
  
 Es gibt drei mögliche Werte für IDN abhängig von den DNS-Servern, die verwendet werden:  
  
-   IDN aktiviert = All  
  
     Dieser Wert wird alle Unicode-Domänennamen in ihre Punycode-Entsprechungen (IDN-Namen) konvertiert.  
  
-   IDN aktiviert = AllExceptIntranet  
  
     Dieser Wert wird allen Unicode-Domänennamen nicht auf dem lokalen Intranet verwenden Sie die Punycode-Entsprechungen (IDN-Namen) konvertiert. In diesem Fall sollte die DNS-Server, die für das Intranet verwendet werden um internationale Namen im lokalen Intranet zu behandeln, Unicode-namensauflösung unterstützen.  
  
-   IDN aktiviert = keine  
  
     Dieser Wert keine Unicode-Domänennamen mit Punycode konvertiert werden. Dies ist der Standardwert, der mit dem .NET Framework 2.0-Verhalten konsistent ist.  
  
 Wenn die IRI-Analyse aktiviert ist (IriParsing aktiviert = `true`) Normalisierung und zeichenüberprüfung gemäß den neuesten IRI-Regeln in RFC 3986 und RFC 3987 fertig sind. Wenn die IRI-Analyse deaktiviert ist, werden Normalisierung und zeichenüberprüfung (für IPv6-Literale) gemäß RFC 2396 und RFC 2732 ausgeführt.  In Versionen von .NET Framework vor Version 4.5, der Standardwert ist `false`. In .NET Framework Version 4.5 und höher, der Standardwert ist `true`, und der Aktivierungszustand IRI-Analyse kann nicht geändert werden, von den Einstellungen in einem *config* Datei.  
  
 IRI und IDN-Verarbeitung in die <xref:System.Uri> Klasse kann auch mithilfe von gesteuert werden die <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, und <xref:System.Configuration.UriSection?displayProperty=nameWithType> Konfigurationsklassen-Einstellung. Die Einstellung <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> aktiviert oder deaktiviert die IRI-Verarbeitung in der Klasse <xref:System.Uri>. Die Einstellung <xref:System.Configuration.IdnElement?displayProperty=nameWithType> aktiviert oder deaktiviert die IDN-Verarbeitung in der Klasse <xref:System.Uri>. Die Einstellung <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> steuert indirekt auch IDN. Die IRI-Verarbeitung muss aktiviert werden, damit die IDN-Verarbeitung überhaupt möglich ist. Ist die IRI-Verarbeitung deaktiviert, wird die IDN-Verarbeitung auf die Standardeinstellung festgelegt. Darin wird aus Kompatibilitätsgründen das .NET Framework 2.0-Verhalten verwendet, und IDN-Namen werden nicht verwendet.  
  
 Die Konfigurationseinstellung für die <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> und <xref:System.Configuration.IdnElement?displayProperty=nameWithType> wird einmal gelesen werden bei der ersten <xref:System.Uri?displayProperty=nameWithType> Klasse erstellt wird. Später vorgenommene Änderungen an den Konfigurationseinstellungen werden anschließend ignoriert.  
  
 Die Klasse <xref:System.GenericUriParser?displayProperty=nameWithType> wurde ebenfalls erweitert, um das Erstellen eines anpassbaren Parsers zu ermöglichen, der IRI und IDN unterstützt. Das Verhalten eines <xref:System.GenericUriParser?displayProperty=nameWithType>-Objekts wird durch Übergabe einer bitweisen Kombination von Werten angegeben, die in der <xref:System.GenericUriParserOptions?displayProperty=nameWithType>-Enumeration des <xref:System.GenericUriParser?displayProperty=nameWithType>-Konstruktors verfügbar sind. Der <xref:System.GenericUriParserOptions?displayProperty=nameWithType>-Typ gibt an, dass der Parser die in RFC 3987 angegebenen Analyseregeln für International Resource Identifiers (IRI) unterstützt. Durch die zuvor erläutert Konfigurationswerte wird bestimmt, ob IRI verwendet wird.  
  
 Der <xref:System.GenericUriParserOptions?displayProperty=nameWithType>-Typ gibt an, dass der Parser die IDN-Analyse von Hostnamen unterstützt. Durch die zuvor erläutert Konfigurationswerte wird bestimmt, ob IDN verwendet wird.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Bei Verwendung einer *Web.config *-Datei, die URIs zum Initialisieren der Anwendung, die zusätzlichen Zeit ist erforderlich, um die URIs zu verarbeiten, falls ihre Schemabezeichner nicht dem Standard entsprechende befinden. Initialisieren Sie in einem solchen Fall die betroffenen Teile der Anwendung, wenn die URIs benötigt werden, nicht zur Startzeit ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von der <xref:System.Uri> Klasse und verwendet er zum Erstellen einer <xref:System.Net.WebRequest> Instanz.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Aufgrund von Sicherheitsbedenken sollten Vorsicht von Ihrer Anwendung verwenden, beim Annehmen <see cref="T:System.Uri" /> Instanzen aus nicht vertrauenswürdigen Quellen und mit <paramref name="dontEscape" /> festgelegt <see langword="true" />. Sehen Sie sich eine URI-Zeichenfolge auf Gültigkeit durch Aufrufen der <see cref="M:System.Uri.IsWellFormedOriginalString" /> Methode.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Form einer Zeichenfolge in Klammern eingeschlossen werden muss. Z. B. "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> -Instanz anhand einer URI-Zeichenfolge. Es analysiert den URI, speichert sie im kanonischen Format und erstellt alle erforderlichen Escapecodierungen.  
  
 Dieser Konstruktor nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
 Dieser Konstruktor wird vorausgesetzt, dass die `string` Parameter verweist auf einen absoluten URI und entspricht dem Aufrufen der <xref:System.Uri.%23ctor%2A> Konstruktor mit <xref:System.UriKind> festgelegt <xref:System.UriKind.Absolute>. Wenn die `string` an den Konstruktor übergebene Parameter ist ein relativer URI, der dieses Konstruktors löst eine <xref:System.UriFormatException>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz mit dem URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>
          <paramref name="uriString" />ist leer.  
  
 - oder -   
  
 Das Schema im angegebenen <paramref name="uriString" /> ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 - oder -   
  
 <paramref name="uriString" />enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, die im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der angegebene Benutzername <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Host- oder Zertifizierungsstellenname in angegebene Domänenname <paramref name="uriString" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Die Portnummer, die im angegebenen <paramref name="uriString" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des <paramref name="uriString" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge angegebene Schema <paramref name="uriString" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in <paramref name="uriString" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Eine Instanz der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse mit den für die Serialisierung der neuen <see cref="T:System.Uri" />-Instanz erforderlichen Informationen.</param>
        <param name="streamingContext">Eine Instanz der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse, die die Quelle des serialisierten Streams enthält, der der neuen <see cref="T:System.Uri" />-Instanz zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse aus den angegebenen Instanzen der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse und der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor implementiert die <xref:System.Runtime.Serialization.ISerializable> eine Schnittstelle für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="serializationInfo" /> Parameter enthält einen <see langword="null" /> URI.</exception>
        <exception cref="T:System.UriFormatException">Die <paramref name="serializationInfo" /> Parameter enthält einen URI, der leer ist.  
  
 - oder -   
  
 Das angegebene Schema ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 - oder -   
  
 Der URI enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das im URI angegebene Kennwort ist ungültig.  
  
 - oder -   
  
 Der im URI angegebene Hostname ist ungültig.  
  
 - oder -   
  
 Das im URI angegebene Dateiname ist ungültig.  
  
 - oder -   
  
 Der im URI angegebene Benutzername ist ungültig.  
  
 - oder -   
  
 Der im URI angegebene Host- oder Zertifizierungsstellenname darf nicht mit umgekehrten Schrägstrichen enden.  
  
 - oder -   
  
 Die im URI angegebene Portnummer ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Der URI ist länger als 65.519 Zeichen.  
  
 - oder -   
  
 Das im URI angegebene Schema ist länger als 1.023 Zeichen.  
  
 - oder -   
  
 Der URI enthält eine ungültige Zeichenfolge.  
  
 - oder -   
  
 Der im URI angegebene MS-DOS-Pfad muss mit "c:" beginnen\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Form einer Zeichenfolge in Klammern eingeschlossen werden muss. Z. B. "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" />Wenn <c>UriString</c> ist vollständig mit Escapezeichen versehen wurde, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI, wobei die Verwendung der Escapezeichen explizit gesteuert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> -Instanz anhand einer URI-Zeichenfolge. Analysiert den URI, und speichert sie im kanonischen Format.  
  
 Die `dontEscape` -Parameter steuert, ob reservierte Zeichen übersetzt werden in Escapesequenzen. Dieser Parameter sollte festgelegt werden, um `true` nur, wenn Sie sicher, dass sind alle reservierte Zeichen im URI mit Escapezeichen versehen wurde haben. Festlegen des Werts auf `true` für ein URI, der nicht vollständig mit Escapezeichen versehen wurde zu unerwartetem Verhalten führen kann. Es wird dringend empfohlen, dass Sie diesen Parameter immer, um festlegen `false`.  
  
 Wenn `dontEscape` festgelegt ist, um `false`, der Konstruktor versieht reservierten Zeichen durch stellt sicher, dass alle Vorkommen des Prozentzeichens (%) eine gültige Escapesequenz eingehalten werden. Wenn die Zeichensequenz, die folgenden Prozentsatz nicht gültig ist, wird der Prozentsatz % 25 ersetzt.  
  
 Dieser Konstruktor nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz für die URI-http://www.contoso.com/Hello%20World.htm. Da der enthaltene URI vollständig mit Escapezeichen versehen und im kanonischen Format liegt der `dontEscape` Parameter kann festgelegt werden, um `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" />ist leer oder enthält nur Leerzeichen.  
  
 - oder -   
  
 Das Schema im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 <paramref name="uriString" />enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, die im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der angegebene Benutzername <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Host- oder Zertifizierungsstellenname in angegebene Domänenname <paramref name="uriString" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Die Portnummer, die im angegebenen <paramref name="uriString" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des <paramref name="uriString" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge angegebene Schema <paramref name="uriString" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in <paramref name="uriString" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Form einer Zeichenfolge in Klammern eingeschlossen werden muss. Z. B. "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Gibt an, ob die URI-Zeichenfolge ein relativer URI, ein absoluter URI oder unbestimmt ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI. Mit diesem Konstruktor können Sie angeben, ob die URI-Zeichenfolge ein relativer URI, ein absoluter URI oder unbestimmt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relative und absolute URIs weisen andere Einschränkungen auf ihr Format. Ein relativer URI ist z. B. ein Schema oder einer Autorität nicht erforderlich. Der Wert, der Sie, in angeben `uriKind` muss den Typ von URI übergebene entsprechen `uriString`. Jedoch wenn <xref:System.UriKind.RelativeOrAbsolute> angegeben ist, wird die URI-Zeichenfolge kann relativ oder absolut sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>
          <paramref name="uriString" />enthält einen relativen URI und <paramref name="uriKind" /> ist <see cref="F:System.UriKind.Absolute" />.  
  
 oder  
  
 <paramref name="uriString" />enthält einen absoluten URI und <paramref name="uriKind" /> ist <see cref="F:System.UriKind.Relative" />.  
  
 oder  
  
 <paramref name="uriString" /> ist leer.  
  
 - oder -   
  
 Das Schema im angegebenen <paramref name="uriString" /> ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 - oder -   
  
 <paramref name="uriString" />enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, die im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im angegebenen <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der angegebene Benutzername <paramref name="uriString" /> ist ungültig.  
  
 - oder -   
  
 Der Host- oder Zertifizierungsstellenname in angegebene Domänenname <paramref name="uriString" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Die Portnummer, die im angegebenen <paramref name="uriString" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des <paramref name="uriString" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge angegebene Schema <paramref name="uriString" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in <paramref name="uriString" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-URI.</param>
        <param name="relativeUri">Der relative URI, der dem Basis-URI hinzugefügt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage des angegebenen Basis-URIs und der relativen URI-Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> Instanz durch die Kombination der `baseUri` und `relativeUri`. Wenn `relativeUri` ist ein absoluter URI (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz ist nur mit erstellt `relativeUri`.  
  
 Dieser Konstruktor nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue Instanz der dem <xref:System.Uri> Klasse durch Kombinieren von der relativen URIs http://www.contoso.com und catalog/shownew.htm, um den absoluten URI http://www.contoso.com/catalog/shownew.htm zu bilden.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />ist kein absoluter <see cref="T:System.Uri" /> Instanz.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist leer oder enthält nur Leerzeichen.  
  
 - oder -   
  
 Im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, das im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Benutzername, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Im URI angegebene Host- oder Zertifizierungsstellenname Name durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Im URI angegebene Portnummer durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des URIS, die durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge der im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in der kombinierten URI <paramref name="baseUri" /> und <paramref name="relativeUri" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Ein absoluter <see cref="T:System.Uri" />, der die Basis für die neue <see cref="T:System.Uri" />-Instanz ist.</param>
        <param name="relativeUri">Ein relativer <see cref="T:System.Uri" /> -Instanz, die mit kombiniert wird <c>BaseUri</c>.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage der Kombination einer angegebenen <see cref="T:System.Uri" />-Instanz als Basis und einer relativen <see cref="T:System.Uri" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Uri> Instanz durch Kombination einer absoluten <xref:System.Uri> Instanz `baseUri`, mit einer relativen <xref:System.Uri> Instanz `relativeUri`. Wenn `relativeUri` ist ein absoluter <xref:System.Uri> Instanz (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz ist nur mit erstellt `relativeUri`.  
  
 Dieser Konstruktor nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 In diesem Beispiel erstellt eine Absolute <xref:System.Uri> Instanz `absoluteUri`, und eine Monatsintervall <xref:System.Uri> Instanz `relativeUri`. Ein neues <xref:System.Uri> Instanz `combinedUri`, wird von diesen beiden Instanzen erstellt.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" />ist kein absoluter <see cref="T:System.Uri" /> Instanz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />ist kein absoluter <see cref="T:System.Uri" /> Instanz.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist leer oder enthält nur Leerzeichen.  
  
 - oder -   
  
 Im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, das im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Benutzername, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Im URI angegebene Host- oder Zertifizierungsstellenname Name durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Im URI angegebene Portnummer durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des URIS, die durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge der im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in der kombinierten URI <paramref name="baseUri" /> und <paramref name="relativeUri" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-URI.</param>
        <param name="relativeUri">Der relative URI, der dem Basis-URI hinzugefügt werden soll.</param>
        <param name="dontEscape">
          <see langword="true" />Wenn <c>UriString</c> ist vollständig mit Escapezeichen versehen wurde, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage des angegebenen Basis-URIs und des angegebenen relativen URIs mit expliziter Steuerung der Escapesequenzen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> Instanz kombinierten `baseUri` und `relativeUri`. Wenn der URI übergeben `relativeUri` ist ein absoluter URI (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz ist nur mit erstellt `relativeUri`.  
  
 Die `dontEscape` -Parameter steuert, ob reservierte Zeichen übersetzt werden in Escapesequenzen. Dieser Parameter sollte festgelegt werden, um `true` nur, wenn Sie sicher, dass sind alle reservierte Zeichen im URI mit Escapezeichen versehen wurde haben. Festlegen des Werts auf `true` für ein URI, der nicht vollständig mit Escapezeichen versehen wurde zu unerwartetem Verhalten führen kann. Es wird dringend empfohlen, dass Sie diesen Parameter immer, um festlegen `false`. Wenn `dontEscape` festgelegt ist, um `false`, der Konstruktor versieht reservierten Zeichen durch stellt sicher, dass alle Vorkommen des Prozentzeichens (%) eine gültige Escapesequenz eingehalten werden. Wenn die Zeichensequenz, die folgenden Prozentsatz nicht gültig ist, wird der Prozentsatz % 25 ersetzt.  
  
 Dieser Konstruktor nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue Instanz der dem <xref:System.Uri> Klasse die relativen URIs http://www.contoso.com und Hello%20World.htm um einen absoluten URI zu bilden.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />ist kein absoluter <see cref="T:System.Uri" /> Instanz.</exception>
        <exception cref="T:System.UriFormatException">Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist leer oder enthält nur Leerzeichen.  
  
 - oder -   
  
 Im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der URI durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> enthält zu viele Schrägstriche.  
  
 - oder -   
  
 Das Kennwort, das im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Hostname im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Dateiname, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Der Benutzername, der im URI angegebene durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig.  
  
 - oder -   
  
 Im URI angegebene Host- oder Zertifizierungsstellenname Name durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> kann nicht mit umgekehrten Schrägstrichen Enden beendet werden.  
  
 - oder -   
  
 Im URI angegebene Portnummer durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> ist ungültig oder kann nicht analysiert werden.  
  
 - oder -   
  
 Die Länge des URIS, die durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 65.519 Zeichen.  
  
 - oder -   
  
 Die Länge der im URI angegebene Schema durch Kombinieren von gebildet <paramref name="baseUri" /> und <paramref name="relativeUri" /> länger als 1023 Zeichen.  
  
 - oder -   
  
 Es ist eine ungültige Zeichenfolge in der kombinierten URI <paramref name="baseUri" /> und <paramref name="relativeUri" />.  
  
 - oder -   
  
 Der angegebene MS-DOS-Pfad <paramref name="uriString" /> muss beginnen mit "c:"\\\\.</exception>
        <block subset="none" type="usage">
          <para>Aufgrund von Sicherheitsbedenken Ihre Anwendung sollte nicht aufrufen dieses Konstruktors mit URI-Zeichenfolgen aus nicht vertrauenswürdigen Quellen und mit <paramref name="dontEscape" /> festgelegt <see langword="true" />. Alternativ können Sie eine URI-Zeichenfolge auf Gültigkeit überprüfen, durch Aufrufen der <see cref="M:System.Uri.IsWellFormedOriginalString" /> Methode vor dem Aufruf dieses Konstruktors.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten Pfad des URIs ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit dem absoluten Pfad der Ressource.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.AbsolutePath%2A> Eigenschaft enthält die Pfadinformationen, die der Server verwendet, um die Anforderungen für Informationen zu beheben. In der Regel ist dies der Pfad zu der gewünschten Informationen im Dateisystem des Servers, obwohl auch angegeben werden können, die Anwendung oder ein Skript, das der Server ausgeführt werden muss, um die Informationen bereitzustellen.  
  
 Die Pfadinformationen umfasst nicht das Schema, den Hostnamen oder den Abfrageteil des URIS.  
  
   
  
## Examples  
 Im folgende Beispiel werden der Pfad /catalog/shownew.htm an die Konsole schreibt.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten URI ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit dem vollständigen URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.AbsoluteUri%2A> Eigenschaft enthält den gesamten URI gespeichert, der <xref:System.Uri> -Instanz, einschließlich aller Fragmente und Abfragezeichenfolgen.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den gesamten Inhalt des der <xref:System.Uri> Instanz in die Konsole. In diesem Beispiel wird http://www.contoso.com/catalog/shownew.htm?date=today in die Konsole geschrieben.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den DNS-Hostnamen (Domain Name System) oder die IP-Adresse und die Anschlussnummer für einen Server ab.</summary>
        <value>Ein <see cref="T:System.String" />, der die Zertifizierungsstellenkomponente des von dieser Instanz dargestellten URIs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Authority%2A> Eigenschaft ist in der Regel eine DNS-Hostname oder IP-Adresse. Diese Eigenschaft kann die Portnummer des enthalten, wenn es der Standardport für den URI unterscheidet. Wenn die <xref:System.Uri.Authority%2A> reservierte Zeichen enthält, werden diese als Escapezeichen in den String-Wert, der von dieser Eigenschaft zurückgegebene formatiert.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den Hostnamen (www.contoso.com) und die Portnummer (8080) des Servers in die Konsole.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den intern gespeicherten URI in kanonische Form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kanonische Version des URIS intern gespeichert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Methode gilt nur für absolute URIs handelt.</exception>
        <exception cref="T:System.UriFormatException">Der URI ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Hostname, der überprüft werden soll. Dies kann eine IPv4- oder IPv6-Adresse oder ein Internethostname sein.</param>
        <summary>Bestimmt, ob der angegebene Hostname ein gültiger DNS-Name ist.</summary>
        <returns>Ein <see cref="T:System.UriHostNameType" />, der den Typ des Hostnamens angibt. Wenn der Typ des Hostnamens nicht bestimmt werden kann oder der Hostname <see langword="null" /> oder eine Zeichenfolge der Länge 0 (null) ist, gibt diese Methode <see cref="F:System.UriHostNameType.Unknown" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.CheckHostName%2A> Methode überprüft, ob der angegebene Hostname die Anforderungen für einen gültigen Internethostnamen entspricht. Er führt jedoch keine, eine Host-Name-Suche, um zu überprüfen, ob das Vorhandensein des Hosts.  
  
   
  
## Examples  
 Das folgende Beispiel überprüft, ob der Hostname gültig ist.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Der Schemaname, der validiert werden soll.</param>
        <summary>Bestimmt, ob der angegebene Schemaname gültig ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der Schemaname gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft den Schemanamen für Gültigkeit gemäß RFC 2396 standardmäßig. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, überprüft diese Methode den Schemanamen für Gültigkeit gemäß RFC 3986 mit Escapezeichen. Der Schemaname muss mit einem Buchstaben beginnen und darf nur Buchstaben, Ziffern und die Zeichen ".", "+" oder "-".  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und überprüft, ob der Schemaname gültig ist.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das Aufrufen dieser Methode hat keine Auswirkung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Die erste <see cref="T:System.Uri" />.</param>
        <param name="uri2">Das zweite <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Eine bitweise Kombination der <see cref="T:System.UriComponents" /> Werte, der angibt, die Teile des <c>uri1</c> und <c>uri2</c> , verglichen werden soll.</param>
        <param name="compareFormat">Einer der <see cref="T:System.UriFormat" />-Werte, der das Escapezeichen angibt, das beim Vergleichen der URI-Komponenten verwendet wird.</param>
        <param name="comparisonType">Einer der <see cref="T:System.StringComparison" />-Werte.</param>
        <summary>Vergleicht die angegebenen Teile von zwei URIs gemäß den angegebenen Vergleichsregeln.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die lexikalische Beziehung zwischen den verglichenen <see cref="T:System.Uri" />-Komponenten angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="uri1" /> ist kleiner als <paramref name="uri2" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="uri1" /> ist gleich <paramref name="uri2" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="uri1" /> ist größer als <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn beide `uri1` und `uri2` sind `null`, diese Methode gibt 0 zurück. Beim Vergleichen von URI-Werte ist ein relativer URI ist immer kleiner als ein absoluter URI und einem nicht-Null-URI ist immer größer als ein null-URI. Für Fälle, in denen beide `uri1` und `uri2` sind nicht `null` und relativen URIs oder beides absolute URIs sind die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Methode vergleicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einem Hostnamen ab, der nach dem ungeschützt eingefügt wird, bei Bedarf sicher für DNS-Auflösung verwendet wird.</summary>
        <value>Ein <see cref="T:System.String" /> , den Teil des URIS in einem DNS-Auflösung oder die ursprüngliche Zeichenfolge für die Host anzeigbaren Format enthält, wenn er bereits für die Auflösung geeignet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für IPv6-Adressen, die Klammern ([]) entfernt und die <xref:System.Net.IPAddress.ScopeId%2A> Eigenschaft festgelegt wird, sofern diese angegeben wurde, wenn diese Instanz erstellt wurde.

Wenn Sie eine Zeichenfolge mit Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), klicken Sie dann DnsSafeHost mit Escapezeichen versehene gibt eine Zeichenfolge zurück. Eine beliebige Zeichenfolge mit Escapezeichen Merry unescape `DnsSafeHost` bevor diese Zeichenfolge für den DNS-Auflösung verwenden (siehe Beispiel). Wenn Sie eine ungültige Zeichenfolge ohne Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), klicken Sie dann DnsSafeHost ohne Escapezeichen gibt eine Zeichenfolge zurück.
  
 Die <xref:System.Uri.DnsSafeHost%2A> Eigenschaft ist abhängig von Konfigurationseinstellungen, wie weiter unten in diesem Thema erläutert. Konfigurationseinstellungen können nicht geändert werden, von Windows Store-Anwendungen, die zu inkonsistenten Ergebnissen führen können, wenn mit <xref:System.Uri.DnsSafeHost%2A>. Die <xref:System.Uri.IdnHost%2A> Eigenschaft wird bereitgestellt, als die bevorzugte Alternative zur Verwendung <xref:System.Uri.DnsSafeHost%2A>, da <xref:System.Uri.IdnHost%2A> ist garantiert immer sicher ist, unabhängig davon, welche aktuellen DNS *"App.config"* Einstellungen werden können.  
  
 Die <xref:System.Uri.DnsSafeHost%2A> Eigenschaft erweitert wurde in .NET Framework 3.5, 3.0 SP1 und 2.0 SP1 International Resource Identifier (IRI) bieten Unterstützung basierend auf RFC 3987. Derzeitige Benutzer werden keine Änderung gegenüber dem .NET Framework 2.0-Verhalten feststellen, außer IRI wird explizit aktiviert. Dadurch wird die Anwendungskompatibilität mit früheren Versionen von .NET Framework garantiert.  
  
 Um die Unterstützung für IRI aktivieren, sind die folgenden zwei Änderungen erforderlich:  
  
1.  Die folgende Zeile zum Hinzufügen der *"Machine.config"* Datei im Verzeichnis von .NET Framework 2.0  
  
     \<Name des Abschnitts = "Uri" type="System.Configuration.UriSection, System, Version = 2.0.0.0, Culture = Neutral, PublicKeyToken = b77a5c561934e089" / >  
  
2.  Geben Sie, ob Sie, dass Internationalized Domain Name (IDN) zu analysieren, die auf den Domänennamen angewendet und gibt an, ob die IRI-Analyse Regeln angewendet werden soll. Dies kann erfolgen, der *"Machine.config"* oder in der *"App.config"* Datei. Fügen Sie beispielsweise Folgendes ein:  
  
    ```  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Beim Aktivieren von IDN werden alle Unicode-Bezeichnungen in einem Domänennamen in ihre Punycode-Entsprechungen konvertiert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“. So werden vorhandene DNS-Server im Internet unterstützt, da die meisten DNS-Server nur ASCII-Zeichen unterstützen (siehe RFC 3940).  
  
 IDN aktiviert wird, betrifft nur den Wert des der <xref:System.Uri.DnsSafeHost%2A> Eigenschaft.  
  
 Es gibt drei mögliche Werte für IDN abhängig von den DNS-Servern, die verwendet werden:  
  
-   IDN aktiviert = All  
  
     Dieser Wert wird alle Unicode-Domänennamen in ihre Punycode-Entsprechungen (IDN-Namen) konvertiert.  
  
-   IDN aktiviert = AllExceptIntranet  
  
     Dieser Wert wird alle externen Unicode-Domänennamen mit Punycode-Entsprechungen (IDN-Namen) konvertiert werden. In diesem Fall sollte die DNS-Server, die für das Intranet verwendet werden um internationale Namen im lokalen Intranet zu behandeln, Unicode-Namen unterstützen.  
  
-   IDN aktiviert = keine  
  
     Dieser Wert keine Unicode-Domänennamen mit Punycode konvertiert werden. Dies ist der Standardwert, der mit dem .NET Framework 2.0-Verhalten konsistent ist.  
  
 Aktivieren die IRI-Analyse (IriParsing aktiviert = `true`) ist dies der Normalisierung und zeichenüberprüfung entsprechend der neuesten IRI Regeln in RFC 3987. Der Standardwert ist `false` und führen Sie die Normalisierung und Überprüfung gemäß RFC 2396 und RFC 2732 (für IPv6-Literale) Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.Host%2A>, der den Hostnamen oder die Adresse, die im URI angegebene zurückgibt und der Rückgabewert von <xref:System.Uri.DnsSafeHost%2A>, womit eine Adresse, die sicher im DNS-Auflösung verwendet werden kann.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Unescape-der Hostname wie in den Hinweisen erläutert wird, bevor aufgelöst werden kann. Können Sie die <xref:System.Uri.UnescapeDataString%2A> Methode, um die unescape-der Hostname, und Sie können ihn beheben, durch Aufrufen der <xref:System.Net.Dns.GetHostEntry%2A> Methode.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Die <see cref="T:System.Uri" />-Instanz oder ein URI-Bezeichner, der mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Überprüft zwei <see cref="T:System.Uri" />-Instanzen auf Gleichheit.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die zwei Instanzen denselben URI darstellen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Equals%2A> Methode vergleicht die beiden Instanzen ohne Berücksichtigung von Benutzerinformationen (<xref:System.Uri.UserInfo%2A>) und -Fragment (<xref:System.Uri.Fragment%2A>) teilen, die sie enthalten können. Angenommen, die URIs http://www.contoso.com/index.htm#search und http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> Methodenrückgabewert würde `true`.  
  
 Wenn eine <xref:System.Uri> Instanz wird mit einem Unicode-Hostnamen gebildet und `comparand` Parameter enthält einen <xref:System.Uri> Instanz oder Bezeichner, der mit einem Hostnamen gebildet wird, die den entsprechenden Punycode-Hostnamen dann muss <xref:System.Uri.Equals%2A> gibt `true` nur, wenn Sie Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) werden aktiviert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0 und 1.1 kann die <xref:System.Uri.Query%2A> wird ebenfalls ignoriert.  
  
> [!NOTE]
>  Die <xref:System.Uri.Equals%2A> Methode kann in einer abgeleiteten Klasse überschrieben werden; gehen Sie vorsichtig vor, wie die Methode eine böswillige Entität geändert werden kann. Sie sollten diese Methode nicht verwenden, sicherheitsüberprüfungen ausführen, es sei denn, Sie wissen, dass diese Instanz von einer vertrauenswürdigen Quelle stammt.  
  
   
  
## Examples  
 Dieses Beispiel erstellt zwei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `address1`und `address2` sind identisch, da die <xref:System.Uri.Fragment%2A> Teil wird für diesen Vergleich ignoriert. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">um zu verhindern, dass teilweise vertrauenswürdigen Code Ableiten von <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert alle unsicheren oder reservierten Zeichen in der Pfadkomponente in die entsprechenden Hexadezimaldarstellungen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Die vom Konstruktor übergebene URI ist ungültig. Diese Ausnahme kann auftreten, wenn der URI relativ ist oder ein URI zu viele Zeichen hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Die Zeichenfolge, die mit Escapezeichen versehen werden soll.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToEscape" /> mit Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig die <xref:System.Uri.EscapeDataString%2A> Methode konvertiert alle Zeichen mit Ausnahme von RFC 2396 nicht reservierten Zeichen in ihrer hexadezimalen Darstellung. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, die <xref:System.Uri.EscapeDataString%2A> Methode konvertiert alle Zeichen, mit Ausnahme von RFC 3986 nicht reservierte Zeichen in ihrer hexadezimalen Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Diese Methode setzt voraus, dass `stringToEscape` darin keine Escapesequenzen enthält.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen. Finden Sie unter folgenden RFCs eine Definition der reservierter und nicht reservierter Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Die Länge des <paramref name="stringToEscape" /> überschreitet 32766 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die in eine Darstellung mit Escapesequenzen umzuwandelnde Zeichenfolge.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Die Darstellung der Zeichenfolge mit Escapesequenzen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.EscapeString%2A> Methode konvertiert RFC 2396 reserviert und alle Zeichen mit einem Zeichenwert, der größer als 127 Zeichen in hexadezimaler Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Die Zeichenfolge, die mit Escapezeichen versehen werden soll.</param>
        <summary>Konvertiert eine URI-Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToEscape" /> mit Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Uri.EscapeUriString%2A> Methode, um eine URI-Zeichenfolge ohne Escapezeichen Parameter an Vorbereiten der <xref:System.Uri.%23ctor%2A> Konstruktor.  
  
 Wird standardmäßig die <xref:System.Uri.EscapeUriString%2A> Methode konvertiert alle Zeichen mit Ausnahme von RFC 2396 nicht reservierten Zeichen in ihrer hexadezimalen Darstellung. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, die <xref:System.Uri.EscapeUriString%2A> Methode konvertiert alle Zeichen, mit Ausnahme von RFC 3986 nicht reservierte Zeichen in ihrer hexadezimalen Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Diese Methode setzt voraus, dass `stringToEscape` darin keine Escapesequenzen enthält.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen. Finden Sie unter folgenden RFCs eine Definition der reservierter und nicht reservierter Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Die Länge des <paramref name="stringToEscape" /> überschreitet 32766 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das mit Escapezeichen versehene URI-Fragment ab.</summary>
        <value>Ein <see cref="T:System.String" />, der URI-Fragmentinformationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Fragment%2A> -Eigenschaft ruft einen Marker Fragment (#), in den URI einschließlich Fragment-Marker selbst nach Text ab. Der URI http://www.contoso.com/index.htm#main erhält die <xref:System.Uri.Fragment%2A> Eigenschaft #main zurück.  
  
 Die <xref:System.Uri.Fragment%2A> Eigenschaft gilt nicht in einem <xref:System.Uri.Equals%2A> Vergleich.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und das Fragmentinformationen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Die zu konvertierende Hexadezimalziffer (0-9, a-f, A-F).</param>
        <summary>Ruft den Dezimalwert einer Hexadezimalziffer ab.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der eine Zahl von 0 bis 15 enthält, die der angegebenen Hexadezimalziffer entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.FromHex%2A> Methode konvertiert ein Zeichen, das eine Hexadezimalziffer darstellt (0-9, a-f, A-F) in einen Dezimalwert (0 bis 15). Wenn `digit` ist es sich nicht um eine gültige hexadezimale steht ein <xref:System.ArgumentException> Ausnahme wird ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob ein Zeichen ein hexadezimales Zeichen ist und ist er, den entsprechenden decimal-Wert in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" />ist keine gültige hexadezimale Ziffer (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Eine bitweise Kombination der <see cref="T:System.UriComponents" />-Werte, die angeben, welche Teile der aktuellen Instanz dem Aufrufer zurückgegeben werden sollen.</param>
        <param name="format">Einer der <see cref="T:System.UriFormat" />-Werte, die steuern, wie Sonderzeichen mit Escapezeichen versehen werden.</param>
        <summary>Ruft die angegebenen Komponenten der aktuellen Instanz mit dem angegebenen Escapeverhalten für Sonderzeichen ab.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Komponenten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, und <xref:System.UriComponents.Path> Komponenten beinhalten keine Trennzeichen. Sie können Kombinieren der <xref:System.UriComponents.KeepDelimiter> Flag (mit dem bitweisen OR-Operator) mit einer dieser Werte zum Abrufen des Werts mit dem Trennzeichen. Für alle anderen <xref:System.UriComponents> Werte und Kombinationen von Werten, die Trennzeichen sind in den zurückgegebenen Wert enthalten.  
  
 Die Komponenten werden in der Reihenfolge zurückgegeben, die sie im URI angezeigt werden. Z. B. wenn <xref:System.UriComponents.Scheme> angegeben wird, wird zuerst angezeigt.  
  
 Bei der Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) aktiviert ist, wird die Anzahl der Zeichen zurückgegeben, der <xref:System.String> erhöht. Punycode-Namen, die zur Unterstützung von IRI verwendet nur ASCII-Zeichen enthalten, und beginnen immer mit dem Präfix Xn. Wenn IRI und IDN aktiviert sind, werden Unicode-Ersatzzeichen ordnungsgemäß durch behandelt die <xref:System.Uri.GetComponents%2A> Methode.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
> [!NOTE]
>  Wenn die <xref:System.Uri.GetComponents%2A> -Methode aufgerufen wird und `format` festgelegt <xref:System.UriFormat.Unescaped> , können keine den zurückgegeben Wert als Argument an eine <xref:System.Uri.%23ctor%2A> Konstruktor hat, erstellen Sie ein entsprechendes <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" />ist keine Kombination aus gültigen <see cref="T:System.UriComponents" /> Werte.</exception>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Uri" /> ist kein absoluter URI. Mit dieser Methode kann keine relativen URIs verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Hashcode für den URI ab.</summary>
        <returns>Ein <see cref="T:System.Int32" />, der den für diesen URI generierten Hashwert enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und gibt den Hashcode auf der Konsole.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Einer der <see cref="T:System.UriPartial" />-Werte, der den Schlussteil des zurückzugebenden URIs angibt.</param>
        <summary>Ruft den angegebenen Teil einer <see cref="T:System.Uri" />-Instanz ab.</summary>
        <returns>Ein <see cref="T:System.String" />, der den angegebenen Teil der <see cref="T:System.Uri" />-Instanz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.GetLeftPart%2A> Methode gibt eine Zeichenfolge mit den am weitesten links stehende Teil der URI-Zeichenfolge, die vom angegebenen Teils Endung `part`.  
  
 <xref:System.Uri.GetLeftPart%2A>enthält die Trennzeichen in den folgenden Fällen:  
  
-   <xref:System.UriPartial.Scheme>Schließt das Schematrennzeichen an.  
  
-   <xref:System.UriPartial.Authority>umfasst nicht die Pfadtrennzeichen.  
  
-   <xref:System.UriPartial.Path>enthält alle Trennzeichen in den ursprünglichen URI bis zu den Abfrage- oder Fragmentteil Trennzeichen an.  
  
-   <xref:System.UriPartial.Query>enthält die <xref:System.UriPartial.Path>, sowie die Abfrage und dem Trennzeichen.  
  
 Die folgenden Beispiele zeigen, einen URI und die Ergebnisse eines Aufrufs <xref:System.Uri.GetLeftPart%2A> mit <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, oder <xref:System.UriPartial.Query>.  
  
|URI|Schema|Autorität für die|Pfad|Abfrage|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/Index.htm?Date=Today|http://|http://www.contoso.com|http://www.contoso.com/Index.htm|http://www.contoso.com/Index.htm?Date=Today|  
|http://www.contoso.com/Index.htm#Main|http://|http://www.contoso.com|http://www.contoso.com/Index.htm|http://www.contoso.com/Index.htm|  
|mailto:user@contoso.com? Subject = Uri|Mailto:|mailto:user@contoso.com|mailto:user@contoso.com? Subject = Uri|\<keine >|  
|nntp://news.contoso.com/123456@contoso.com|NNTP: / /|NNTP://News.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|News:|news:123456@contoso.com|news:123456@contoso.com|\<keine >|  
|file://Server/filename.ext|file://|file://Server|file://Server/filename.ext|file://Server/filename.ext|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und den Pfad in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Uri" /> Instanz ist keine absolute Instanz.</exception>
        <exception cref="T:System.ArgumentException">Das angegebene <paramref name="part" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Uri" /> erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Uri" />.</param>
        <summary>Gibt die Daten zurück, die zum Serialisieren der aktuellen Instanz benötigt werden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Methoden zur cacheserialisierung verwenden zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Das in die Hexadezimaldarstellung zu konvertierende Zeichen.</param>
        <summary>Konvertiert ein angegebenes Zeichen in die entsprechende Hexadezimaldarstellung.</summary>
        <returns>Die Hexadezimaldarstellung des angegebenen Zeichens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel konvertiert ein Zeichen in die hexadezimale Entsprechung und in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" />ist größer als 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Die Hexadezimaldarstellung eines Zeichens.</param>
        <param name="index">Die Position im <c>Muster</c> , in denen die hexadezimaldarstellung eines Zeichens beginnt.</param>
        <summary>Konvertiert eine angegebene Hexadezimaldarstellung eines Zeichens in das Zeichen selbst.</summary>
        <returns>Das in Hexadezimalcodierung an Position <paramref name="index" /> dargestellte Zeichen. Wenn das Zeichen bei <paramref name="index" /> nicht hexadezimal codiert ist, wird das Zeichen bei <paramref name="index" /> zurückgegeben. Der Wert von <paramref name="index" /> wird erhöht, sodass er auf das nachfolgende Zeichen zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Codebeispiel wird bestimmt, ob ein Zeichen ist hexadezimal codiert und, wenn dies der Fall ist, das entsprechende Zeichen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 oder größer als oder gleich der Anzahl der Zeichen im <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hostkomponente dieser Instanz ab.</summary>
        <value>Ein <see cref="T:System.String" />, der den Hostnamen enthält. Das ist normalerweise der DNS-Hostname oder die IP-Adresse des Servers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Uri.Authority%2A> Eigenschaft, dieser Wert umfasst nicht die Portnummer an.  
  
   
  
## Examples  
 Im folgende Beispiel werden der Hostname (www.contoso.com) des Servers in die Konsole schreibt.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des im URI angegebenen Hostnamens ab.</summary>
        <value>Ein Member aus der <see cref="T:System.UriHostNameType" />-Enumeration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz und schreibt die <xref:System.Uri.HostNameType%2A> an die Konsole.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der zu RFC 3490 kompatible IDN (Internationale Domänenname) des Hosts, wofür ggf. Punycode verwendet wird. Dieser Zeichenfolge übereinstimmt, wird nach ggf. ohne Escapezeichen werden sicher für DNS-Auflösung verwendet.</summary>
        <value>Gibt den Hostnamen zurück, der entsprechend dem IDN-Standard mit Punycode formatiert ist.<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für die Verwendung von Netzwerkprotokollen auf niedrigerer Ebene bereitgestellt, die den Domänennamen in Punycode-Format zu erfordern. Wenn Code nicht mit diesem bestimmte Format erfordert, verwenden Sie <xref:System.Uri.Host%2A> für den Hostnamen.  
  
 Die veraltete <xref:System.Uri.DnsSafeHost%2A> Eigenschaft ist abhängig von *"App.config"* Einstellungen, mit denen vom Windows Store-Anwendungen geändert werden können. IdnHost dient als die bevorzugte Alternative zur Verwendung <xref:System.Uri.DnsSafeHost%2A>, da <xref:System.Uri.IdnHost%2A> ist garantiert immer sicher ist, unabhängig davon, welche aktuellen DNS *"App.config"* Einstellungen werden können.  

 Wenn Sie eine Zeichenfolge mit Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), klicken Sie dann IdnHost mit Escapezeichen versehene gibt eine Zeichenfolge zurück. Sie sollten alle mit Escapezeichen versehene Zeichenfolge aus IdnHost zurückgegeben werden, bevor diese Zeichenfolge für die DNS-Auflösung mit Escapezeichen. Beachten Sie, dass bei Verwendung eine ungültige Zeichenfolge ohne Escapezeichen zum Erstellen dieser Instanz (z. B. "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), und klicken Sie dann auf IdnHost ohne Escapezeichen gibt eine Zeichenfolge zurück.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die <see cref="T:System.Uri" />-Instanz absolut ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die <see cref="T:System.Uri" />-Instanz absolut ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist `true` Wenn die Zeichenfolge oder <xref:System.Uri> -Instanz, die an den Konstruktor übergeben wurde analysiert werden kann, als Absolute <xref:System.Uri> -Instanz, die ein Schema, eine Zertifizierungsstelle und einen Pfad enthält. Andernfalls die <xref:System.Uri> Instanz wird als relativer behandelt und kann das Schema oder andere URI-Komponenten weglassen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob ein Zeichen in einem Dateisystemnamen ungültig ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das angegebene Zeichen ungültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zeichen wird gemäß den Regeln für das NTFS-Dateisystem analysiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Die angegebene <see cref="T:System.Uri" />-Instanz, die getestet werden soll.</param>
        <summary>Bestimmt, ob die aktuelle <see cref="T:System.Uri" />-Instanz eine Basis der angegebenen <see cref="T:System.Uri" />-Instanz ist.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Uri" />-Instanz eine Basis von <paramref name="uri" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A>wird verwendet, um die aktuelle vergleichen <xref:System.Uri> Instanz mit einem angegebenen <xref:System.Uri> zu bestimmen, ob dieser URI eine Basis für den angegebenen <xref:System.Uri>. Beim Vergleichen von zwei <xref:System.Uri> -Objekten, die eine Basis-Beziehung, die Benutzerinformationen zu bestimmen (<xref:System.Uri.UserInfo%2A>) wird nicht ausgewertet. Beim Vergleichen von zwei URIs (uri1 und uri2) ist uri1 die Basis von uri2 aus, wenn Sie die beiden URIs, wenn Sie in uri2 alles nach dem letzten Schrägstrich (/) ignoriert werden sollen, identisch sind. Verwenden http://host/path/path/file?query als Basis-URI an, zeigt die folgende Tabelle, ob es sich um eine Basis für andere URIs handelt.  
  
|URI|http://Host/Path/Path/File?Query ist Basis von|  
|---------|------------------------------------------------------|  
|http://Host/Path/Path/File/|ja|  
|http://Host/path/path/#Fragment|ja|  
|http://Host/path/path/MoreDir/"|ja|  
|http://Host/path/path/OtherFile?Query|ja|  
|http://Host/path/path/|ja|  
|http://Host/Path/Path/File|ja|  
|http://Host/path/path|nein|  
|http://Host/path/path?Query|nein|  
|http://Host/path/path#Fragment|nein|  
|http://Host/Path/path2/|Nein|  
: //host/path/path2/MoreDir|Nein|  
|http://Host/Path/File|nein|  
  
   
  
## Examples  
 In diesem Beispiel wird eine <xref:System.Uri> -Instanz, die eine Basis stellt <xref:System.Uri> Instanz. Sie erstellt dann ein zweites <xref:System.Uri> Instanz aus einer Zeichenfolge. Sie ruft <xref:System.Uri.IsBaseOf%2A> zu bestimmen, ob die Basisinstanz die Basis der zweiten Instanz ist. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der Portwert im URI der Standardwert für dieses Schema ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der Wert in der <see cref="P:System.Uri.Port" />-Eigenschaft der Standardport für dieses Schema ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und überprüft, ob es sich um den Standardport verwendet.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob das angegebene Zeichen mit Escapezeichen versehen werden soll.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das angegebene Zeichen mit Escapezeichen versehen werden muss, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene <see cref="T:System.Uri" /> ein Datei-URI ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> einen Datei-URI darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsFile%2A> Eigenschaft `true` bei der <xref:System.Uri.Scheme%2A> -Eigenschaft gleich <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um einen Datei-URI ist.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Das Zeichen, das validiert werden soll.</param>
        <summary>Bestimmt, ob ein angegebenes Zeichen eine gültige Hexadezimalziffer ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das Zeichen eine gültige Hexadezimalziffer ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hexadezimale Ziffern sind die Ziffern 0 bis 9 und den Buchstaben A-F oder a-f.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob ein Zeichen ein hexadezimales Zeichen ist und ist er, den entsprechenden decimal-Wert in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Die zu überprüfende Zeichenfolge.</param>
        <param name="index">Die Position im <c>Muster</c> auf hexadezimale Codierung überprüft.</param>
        <summary>Bestimmt, ob ein Zeichen in einer Zeichenfolge hexadezimal codiert ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn <paramref name="pattern" /> an der angegebenen Position hexadezimal codiert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsHexEncoding%2A> -Methode überprüft auf hexadezimale Codierung das Muster "%hexhex" in einer Zeichenfolge, wobei "hex" eine Ziffer von 0 bis 9 oder ein Buchstabe von A-F (Groß-/Kleinschreibung).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, ob ein Zeichen ist hexadezimal codiert und, wenn dies der Fall ist, das entsprechende Zeichen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der angegebene <see cref="T:System.Uri" /> auf den lokalen Host verweist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn dieser <see cref="T:System.Uri" /> auf den lokalen Host verweist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A>Gibt `true` der URI, der beim Erstellen dieser Instanz angegeben war 127.0.0.1, Loopback oder "localhost", oder wenn der URI nicht angegeben haben Hostinformationen (z. B. file:///c:Dir/file.txt). Alle anderen URIs Return `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um einen lokalen Host verweist.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob das angegebene Zeichen ein reserviertes Zeichen ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das angegebene Zeichen ein reserviertes Zeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der angegebene <see cref="T:System.Uri" /> einen UNC-Pfad (Universal Naming Convention) darstellt.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> einen UNC-Pfad darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsUnc%2A> Eigenschaft `true` Wenn das angegebene <xref:System.Uri> Instanz ist ein UNC-Pfad (z. B. \\\server\folder oder file://server/folder). Gibt diese Eigenschaft immer `true` , wenn der URI das Schema file:// hat und eine Hostkomponente gibt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um einen UNC-Pfad handelt.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob die zum Erstellen dieses <see cref="T:System.Uri" /> verwendete Zeichenfolge wohlgeformt war und keine weiteren Escapezeichen eingefügt werden müssen.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die Zeichenfolge wohlgeformt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge gilt standardmäßig in Übereinstimmung mit RFC 2396 und RFC 2732 wohlgeformt sein. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, wird die Zeichenfolge als in Übereinstimmung mit RFC 3986 und RFC 3987 wohlgeformt sein  
  
 Die Zeichenfolge wird als fehlerhaft formuliert ist, verursacht die aufzurufende Methode "false" zurückgeben, wenn eine der folgenden Bedingungen auftreten.  
  
|Fehler|Beispiel|  
|-----------|-------------|  
|Die Zeichenfolge ist nicht ordnungsgemäß mit Escapezeichen versehen.|[http://www.contoso.com/Path???/File](http://www.contoso.com/path???/file) Name|  
|Die Zeichenfolge ist ein absoluter <xref:System.Uri> , die eine implizite Datei darstellt <xref:System.Uri>.|"c:"\\\directory\filename|  
|Die Zeichenfolge ist ein absoluter URI, der einen Schrägstrich vor dem Pfad nicht vorhanden ist.|file://c:/Directory/FileName|  
|Die Zeichenfolge enthält umgekehrte Schrägstriche ohne Escapezeichen, selbst wenn sie als Schrägstriche behandelt werden.|http:\\\host/path/file|  
|Die Zeichenfolge stellt einen hierarchischen absoluten <xref:System.Uri> und enthält nicht "://".|www.contoso.com/Path/File|  
|Der Parser für die <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> gibt an, dass die ursprüngliche Zeichenfolge nicht wohlgeformt ist.|Im Beispiel hängt von dem der URI-Schema ab.|  
  
 Standardmäßig verwendet die Zeichenfolge zum Erstellen dieses <xref:System.Uri> werden als wohlgeformte in Übereinstimmung mit RFC 2396 und RFC 2732 betrachtet.  
  
 Wenn International Resource Identifier (IRI) und Internationalized Domain Name (IDN)-Unterstützung aktiviert sind, wird die Zeichenfolge, die zum Erstellen dieses <xref:System.Uri> werden als wohlgeformte in Übereinstimmung mit RFC 3986 und RFC 3987 betrachtet. Punycode-Namen, die zur Unterstützung von IRI verwendet nur ASCII-Zeichen enthalten, und beginnen immer mit dem Präfix Xn.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Die Zeichenfolge, mit der ein <see cref="T:System.Uri" /> erstellt werden soll.</param>
        <param name="uriKind">Der Typ des der <see cref="T:System.Uri" /> in <c>UriString</c>.</param>
        <summary>Gibt an, ob eine Zeichenfolge wohlgeformt ist, indem versucht wird, einen URI aus der Zeichenfolge zu erstellen. Es wird sichergestellt, dass keine weiteren Escapezeichen in die Zeichenfolge eingefügt werden müssen.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die Zeichenfolge wohlgeformt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Versionen von .NET vor Version 4.5 wird standardmäßig die Zeichenfolge wohlgeformt ist, in Übereinstimmung mit RFC 2396 und RFC 2732 betrachtet. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert sind, gilt die Zeichenfolge wohlgeformt ist, in Übereinstimmung mit RFC 3986 und RFC 3987.  
  
 Ab .NET 4.5 ist Zeichenfolgen gelten immer als wohlgeformt gemäß RFC 3986 und RFC 3987 fest, ob IRI oder IDN aktiviert sind. Beachten Sie jedoch, dass dies nur ist für apps, die.NET 4.5 ausgerichtet, sind "true" oder höher. Apps, die .NET 4.0 als Ziel Kompatibilität Code aufrufen und die alte (vor 4.5) Verhalten auftreten.  
  
 Die Zeichenfolge wird als fehlerhaft formuliert ist, verursacht die aufzurufende Methode "false" zurückgeben, wenn eine der folgenden Bedingungen eintritt  
  
|Fehler|Beispiel|  
|-----------|-------------|  
|Die Zeichenfolge ist nicht ordnungsgemäß mit Escapezeichen versehen.|[http://www.contoso.com/Path???/File](http://www.contoso.com/path???/file) Name|  
|Die Zeichenfolge ist ein absoluter <xref:System.Uri> , die eine implizite Datei darstellt <xref:System.Uri>.|"c:"\\\directory\filename|  
|Die Zeichenfolge ist ein absoluter URI, der einen Schrägstrich vor dem Pfad nicht vorhanden ist.|file://c:/Directory/FileName|  
|Die Zeichenfolge enthält ohne Escapezeichen umgekehrter Schrägstriche, auch wenn sie als Schrägstriche behandelt werden|http:\\\host/path/file|  
|Die Zeichenfolge stellt einen hierarchischen absoluten <xref:System.Uri> und enthält nicht "://"|www.contoso.com/Path/File|  
|Der Parser für die <xref:System.Uri.Scheme%2A> gibt an, dass die ursprüngliche Zeichenfolge nicht wohlgeformt ist.|Im Beispiel hängt von dem der URI-Schema ab.|  
|Ab .NET 4.5, relativen URIs mit einem Doppelpunkt (': ') in ihre erste Segment gelten nicht wohlgeformt ist.|2013.05.29_14:33:41|  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Darstellung eines Dateinamens im lokalen Betriebssystem ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit der Darstellung eines Dateinamens im lokalen Betriebssystem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert ist ohne Escapezeichen. Wenn der Pfad als einen Windows-Dateipfad erkannt wird, werden alle Schrägstriche (/) durch umgekehrte Schrägstriche ersetzt (\\).  
  
 Für den URI `file://computer/file.ext`, wird der absolute Pfad `/file.ext` und der lokale Pfad ist `\\computer\file.ext`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und den lokalen Pfad in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">Der mit dem aktuellen URI zu vergleichende URI.</param>
        <summary>Bestimmt den Unterschied zwischen zwei <see cref="T:System.Uri" />-Instanzen.</summary>
        <returns>Wenn der Hostname und das Schema dieser URI-Instanz mit <paramref name="toUri" /> identisch sind, gibt diese Methode einen <see cref="T:System.String" /> zurück, der einen relativen URI darstellt, der beim Anfügen an die aktuelle URI-Instanz den <paramref name="toUri" />-Parameter liefert.  
  
 Wenn der Hostname oder das Schema nicht identisch ist, gibt diese Methode einen <see cref="T:System.String" /> zurück, der den <paramref name="toUri" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die URI-Instanz `toUri`, und die Ergebnisse eines Aufrufs <xref:System.Uri.MakeRelative%2A>.  
  
|Aktuelle URI-Instanz|`toUri`|Rückgabewert|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/Test/Test.htm|Test/Test.htm|  
|http://www.contoso.com/Test1/|http://www.contoso.com/|../|  
|http://www.contoso.com: 8000 /|http://www.contoso.com/Test/Test.htm|http://www.contoso.com/Test/Test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/Test1/Test1.txt|Test1/test1.txt|  
  
 Benutzerinformationen wird ignoriert, wenn in der URI vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 2 <xref:System.Uri> Instanzen. Der Unterschied in den Pfadinformationen wird in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Methode gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Der mit dem aktuellen URI zu vergleichende URI.</param>
        <summary>Bestimmt den Unterschied zwischen zwei <see cref="T:System.Uri" />-Instanzen.</summary>
        <returns>Wenn der Hostname und das Schema dieser URI-Instanz mit <paramref name="uri" /> identisch sind, gibt diese Methode einen relativen <see cref="T:System.Uri" /> zurück, der beim Anfügen an die aktuelle URI-Instanz <paramref name="uri" /> liefert.  
  
 Wenn der Hostname oder das Schema nicht identisch ist, gibt diese Methode einen <see cref="T:System.Uri" /> zurück, der den <paramref name="uri" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die URI-Instanz `toUri`, und die Ergebnisse eines Aufrufs <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Aktuelle URI-Instanz|`toUri`|Rückgabewert|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/Test/Test.htm|Test/Test.htm|  
|http://www.contoso.com/Test1/|http://www.contoso.com/|../|  
|http://www.contoso.com: 8000 /|http://www.contoso.com/Test/Test.htm|http://www.contoso.com/Test/Test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/Test1/Test1.txt|Test1/test1.txt|  
  
 Benutzerinformationen wird ignoriert, wenn in der URI vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 2 <xref:System.Uri> Instanzen. Der Unterschied in den Pfadinformationen wird in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Ein <see cref="T:System.Uri" /> Instanz für den Vergleich mit <c>uri2</c>.</param>
        <param name="uri2">Ein <see cref="T:System.Uri" /> Instanz für den Vergleich mit <c>uri1</c>.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Uri" />-Instanzen denselben Wert haben.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die <see cref="T:System.Uri" />-Instanzen äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung verwendet die <xref:System.Uri.Equals%2A> Methode, um zu bestimmen, ob die beiden <xref:System.Uri> -Instanzen äquivalent sind. <xref:System.Uri.UserInfo%2A>und <xref:System.Uri.Fragment%2A> Inhalt wird ignoriert, wenn es sich bei diesem Vergleich.  
  
   
  
## Examples  
 In diesem Beispiel erstellt drei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `Address1`und `Address2` sind identisch, da die <xref:System.Uri.Fragment%2A> Teil wird für diesen Vergleich ignoriert. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Ein <see cref="T:System.Uri" /> Instanz für den Vergleich mit <c>uri2</c>.</param>
        <param name="uri2">Ein <see cref="T:System.Uri" /> Instanz für den Vergleich mit <c>uri1</c>.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Uri" />-Instanzen verschiedene Werte haben.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die beiden <see cref="T:System.Uri" />-Instanzen ungleich sind, andernfalls <see langword="false" />. Wenn einer der Parameter <see langword="null" /> ist, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung verwendet die <xref:System.Uri.Equals%2A> Methode, um zu bestimmen, ob die beiden <xref:System.Uri> Instanzen sind kein Äquivalent. <xref:System.Uri.UserInfo%2A>und <xref:System.Uri.Fragment%2A> Inhalt wird ignoriert, wenn es sich bei diesem Vergleich.  
  
   
  
## Examples  
 In diesem Beispiel erstellt drei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `Address2`und `Address3` sind nicht identisch, weil `Address3` enthält eine <xref:System.Uri.Query%2A> , befindet sich nicht im `Address2`. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ursprüngliche URI-Zeichenfolge ab, die an den <see cref="T:System.Uri" />-Konstruktor übergeben wurde.</summary>
        <value>Ein <see cref="T:System.String" />, der exakt den URI enthält, der beim Erstellen dieser Instanz angegeben wurde, andernfalls <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn an den Konstruktor angegebene URI enthalten führenden oder nachgestellten Leerzeichen enthalten, werden diese Leerzeichen beibehalten.  
  
 Der von dieser Eigenschaft zurückgegebene Wert unterscheidet sich von <xref:System.Uri.ToString%2A> und <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A>Gibt den URI kanonisch ohne Escapezeichen Form zurück. <xref:System.Uri.AbsoluteUri%2A>Gibt die Form des URIS, die kanonisch mit Escapezeichen zurück.  
  
 Wenn die Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) aktiviert ist, <xref:System.Uri.OriginalString%2A> gibt die ursprüngliche, nicht normalisierte Zeichenfolge mit Punycode-Hostnamen zurück, sofern einer, zum Initialisieren verwendet wurde der <xref:System.Uri> Instanz. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
 Wenn eine <xref:System.Uri> Objekt serialisiert wird, die <xref:System.Uri.OriginalString%2A> wird nicht beibehalten. Der Serialisierungsprozess verwendet, die vollständig mit Escapezeichen versehene und kanonisierte <xref:System.Uri.AbsoluteUri%2A> Eigenschaft bei der Serialisierung. Für eine <xref:System.Uri> , eine IPv6-Adresse enthält, wird die IPv6-Adresse und die Bereichs-ID sind enthalten in der serialisierten <xref:System.Uri> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.OriginalString%2A>, womit die Zeichenfolge, die übergeben wurde, an den Konstruktor und Aufrufen von <xref:System.Uri.ToString%2A>, die die kanonische Form der Zeichenfolge zurückgibt.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den URI der aktuellen Instanz, um sicherzustellen, dass alle für einen gültigen URI erforderlichen Teile enthalten sind.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Die vom Konstruktor übergebene Uri ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die durch ein Fragezeichen (?) getrennten Werte der <see cref="P:System.Uri.AbsolutePath" />-Eigenschaft und der <see cref="P:System.Uri.Query" />-Eigenschaft ab.</summary>
        <value>Ein <see cref="T:System.String" />, der die durch ein Fragezeichen (?) getrennten Werte der <see cref="P:System.Uri.AbsolutePath" />-Eigenschaft und der <see cref="P:System.Uri.Query" />-Eigenschaft enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.PathAndQuery%2A> Eigenschaft enthält den absoluten Pfad auf dem Server und die mit der Anforderung gesendete Informationen. Es ist identisch mit der Verkettung der <xref:System.Uri.AbsolutePath%2A> und <xref:System.Uri.Query%2A> Eigenschaften.  
  
 Die <xref:System.Uri.PathAndQuery%2A> Eigenschaft gemäß RFC 2396 standardmäßig geschützt ist. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, die <xref:System.Uri.PathAndQuery%2A> Eigenschaft wird gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt die URI-Pfad (/ /catalog/shownew.htm) und Abfrage (Date = heute) Informationen an die Konsole.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anschlussnummer dieses URIs ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der die Portnummer für diesen URI enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Portnummer definiert, den Port des Protokolls zum Herstellen einer Verbindung mit dem Server, die im URI verwiesen wird. Wenn Sie ein Port nicht als Teil des URI angegeben ist die <xref:System.Uri.Port%2A> Eigenschaft gibt den Standardwert für das Protokoll zurück. Ist keine Standard-Portnummer, gibt diese Eigenschaft-1 zurück.  
  
   
  
## Examples  
 Im folgende Beispiel werden die URI-Portnummer an die Konsole schreibt. In diesem Fall ist der Wert die Standard-Portnummer für HTTP Port 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft im angegebenen URI enthaltene Abfrageinformationen ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit den im angegebenen URI enthaltenen Abfrageinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Query%2A> Eigenschaft enthält die im URI enthaltenen Abfrageinformationen. "Abfrageinformationen" getrennt von den Pfadinformationen durch ein Fragezeichen (?) und wird fortgesetzt, bis zum Ende des URIS. Die zurückgegebenen Informationen enthält das vorangestellte Fragezeichen.  
  
 Die Abfrageinformationen ist gemäß RFC 2396 standardmäßig mit Escapezeichen versehen. Wenn International Resource Identifiers (IRI) oder Internationalized Domain Name (IDN) analysieren aktiviert ist, wird die Abfrageinformationen gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" der <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt die Abfrage? Date = heute in der Konsole.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Schemas für diesen URI ab.</summary>
        <value>Ein <see cref="T:System.String" />, der das in Kleinbuchstaben umgewandelte Schema für diesen URI enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Scheme%2A> Eigenschaft gibt das Schema, das zur Initialisierung der <xref:System.Uri> Instanz. Diese Eigenschaft nicht, dass das Schema verwendet wird, zum Initialisieren der <xref:System.Uri> Instanz wurde erkannt.  
  
 Die folgende Tabelle zeigt einige Beispiele für mögliche Werte zurückgegeben werden, indem Sie die <xref:System.Uri.Scheme%2A> Eigenschaft.  
  
|Schema|Beschreibung|  
|------------|-----------------|  
|Datei|Die Ressource ist eine Datei auf dem lokalen Computer.|  
|ftp|Die Ressource wird über FTP zugegriffen.|  
|Gopher|Die Ressource wird über das Gopher-Protokoll zugegriffen.|  
|http|Die Ressource wird über HTTP zugegriffen werden.|  
|https|Die Ressource erfolgt über HTTP SSL-Verschlüsselung.|  
|LDAP|Die Ressource wird über das LDAP-Protokoll zugegriffen.|  
|mailto|Die Ressource ist eine e-Mail-Adresse und erfolgt über das SMTP-Protokoll.|  
|net.pipe|Die Ressource erfolgt über eine named Pipe.|  
|net.tcp|Die Ressource wird vom TCP-Endpunkt zugegriffen.|  
|news|Die Ressource wird über das NNTP-Protokoll zugegriffen.|  
|NNTP|Die Ressource wird über das NNTP-Protokoll zugegriffen.|  
|telnet|Die Ressource wird über das TELNET-Protokoll zugegriffen.|  
|uuid|Die Ressource erfolgt über einen eindeutigen Namen der UUID-Endpunkt für die Kommunikation mit einem Dienst.|  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den Namen des Schemas (http) an die Konsole für die http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Zeichen an, die das Schema des Kommunikationsprotokolls vom Adressteil des URIs trennen. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Zeichenfolge aus <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>, und eine Adresse. Ein <xref:System.Uri> Instanz wird dann aus der Zeichenfolge erstellt.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array mit den Pfadsegmenten ab, aus denen sich der angegebene URI zusammensetzt.</summary>
        <value>Ein <see cref="T:System.String" />-Array mit den Pfadsegmenten, aus denen sich der angegebene URI zusammensetzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Segments%2A> Eigenschaft gibt ein Array von Zeichenfolgen, die die "Segmente" (Teilzeichenfolgen), die den URI absoluten Pfad zu bilden. Das erste Segment wird abgerufen, durch die Analyse des absoluten Pfads vom ersten Zeichen bis zu einem Schrägstrich (/) oder das Ende des Pfads. Jedes zusätzliches Segment am ersten Zeichen, nach dem vorherigen Segment beginnt und endet mit dem nächsten Schrägstrich oder das Ende des Pfads. (Absolute Pfad des URIS enthält alles, was nach dem Host und Port und vor der Abfrage und das Fragment).  
  
 Das folgende Beispiel zeigt der absolute Pfad und die Segmente für zwei URIs an. Im zweiten Beispiel wird veranschaulicht, dass das Fragment und die Abfrage nicht Teil der absolute Pfad sind und sind daher nicht Segmente.  
  
 Absoluter URI  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Absoluter Pfad  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmente  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Absoluter URI  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#Page1?Answer=No  
  
 Absoluter Pfad  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmente  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Beachten Sie, da der absolute Pfad beginnt mit '/', das erste Segment es und nichts anderes enthält.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz mit 3 Segmente und auf dem Bildschirm angezeigt.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Uri" /> erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Uri" />.</param>
        <summary>Gibt die Daten zurück, die zum Serialisieren der aktuellen Instanz benötigt werden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Methoden zur cacheserialisierung verwenden zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine kanonische Zeichenfolgenentsprechung der angegebenen <see cref="T:System.Uri" />-Instanz ab.</summary>
        <returns>Eine <see cref="T:System.String" />-Instanz, die eine kanonische Darstellung der <see cref="T:System.Uri" />-Instanz enthält, die nicht mit Escapezeichen versehen wurde. #, ? und % sind die einzigen Zeichen, die mit Escapezeichen versehen sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebene Zeichenfolge enthält keine Portinformationen, wenn der Port für das Schema der Standardport ist.  
  
> [!NOTE]
>  Die zurückgegebene Zeichenfolge den <xref:System.Uri.ToString%2A> Methode darf Steuerzeichen, die den Zustand einer Konsolenanwendung beschädigt werden können. Können Sie die <xref:System.Uri.GetComponents%2A> Methode mit dem <xref:System.UriFormat?displayProperty=nameWithType> Format Steuerzeichen aus der zurückgegebenen Zeichenfolge zu entfernen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.OriginalString%2A>, womit die Zeichenfolge, die übergeben wurde, an den Konstruktor und Aufrufen von <xref:System.Uri.ToString%2A>, die die kanonische Form der Zeichenfolge zurückgibt.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">um zu verhindern, dass teilweise vertrauenswürdigen Code Ableiten von <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">Der <see cref="T:System.String" />, der den <see cref="T:System.Uri" /> darstellt.</param>
        <param name="uriKind">Der Typ des Uris.</param>
        <param name="result">Diese Methode gibt den erstellten <see cref="T:System.Uri" /> zurück.</param>
        <summary>Erstellt mit der angegebenen <see cref="T:System.Uri" />-Instanz und einer <see cref="T:System.String" /> einen neuen <see cref="T:System.UriKind" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-<see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Der relative <see cref="T:System.Uri" />, dargestellt als ein <see cref="T:System.String" />, der dem Basis-<see cref="T:System.Uri" /> hinzugefügt werden soll.</param>
        <param name="result">Enthält bei Rückgabe dieser Methode eine <see cref="T:System.Uri" /> aus erstellter <c>BaseUri</c> und <c>RelativeUri</c>. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt mit der angegebenen Basis und den relativen <see cref="T:System.Uri" />-Instanzen einen neuen <see cref="T:System.String" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-<see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Der relative <see cref="T:System.Uri" />, der dem Basis-<see cref="T:System.Uri" /> hinzugefügt werden soll.</param>
        <param name="result">Enthält bei Rückgabe dieser Methode eine <see cref="T:System.Uri" /> aus erstellter <c>BaseUri</c> und <c>RelativeUri</c>. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt mit der angegebenen Basis und den relativen <see cref="T:System.Uri" />-Instanzen einen neuen <see cref="T:System.Uri" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 Diese Methode erstellt den URI, fügt sie in kanonische Form und überprüft. Wenn eine nicht behandelte Ausnahme auftritt, fängt Sie von dieser Methode ab. Wenn Sie erstellen möchten eine <xref:System.Uri> und verwenden Sie eine der Ausnahmen erhalten die <xref:System.Uri.%23ctor%2A> Konstruktoren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu konvertierende <see cref="T:System.String" />.</param>
        <summary>Konvertiert die angegebene Zeichenfolge, indem alle Escapesequenzen durch die entsprechende Darstellung ohne Escapezeichen ersetzt werden.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Wert des <paramref name="path" />-Parameters ohne Escapezeichen enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Die Zeichenfolge, deren Escapezeichen entfernt werden sollen.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung ohne Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToUnescape" /> ohne Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode mit Vorsicht verwenden. Sind eine Zeichenfolge, die zuvor Escapezeichen entfernt wurden, kann dies zu Mehrdeutigkeiten und Fehlern führen.  
  
 Vielen Webbrowsern Leerzeichen innerhalb von URIs in Plus escape-Zeichen ("+") Allerdings ist die UnescapeDataString-Methode nicht plus-Zeichen in Leerzeichen konvertieren, da dieses Verhalten über alle URI-Schemas nicht standardmäßig vorhanden sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen URI entfernt und dann alle plus-Zeichen ("+") in Leerzeichen konvertiert.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI ein Zeiger auf eine Datei ist. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework, Version 1.1 ein "`file:///path`"URI wurde übersetzt"`file:/path`". Dies wurde für Version 2.0 korrigiert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über FTP (File Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das Gopher-Protokoll zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über HTTP (Hypertext Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über HTTPS (Secure Hypertext Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine E-Mail-Adresse ist und der Zugriff über SMTP (Simple Mail Transport Protocol) erfolgt. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das von Windows Communication Foundation (WCF) verwendete NetPipe-Schema zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das von Windows Communication Foundation (WCF) verwendete NetTcp-Schema zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine Internetnewsgroup ist, auf die über NNTP (Network News Transport Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine Internetnewsgroup ist, auf die über NNTP (Network News Transport Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NNTP <xref:System.Uri> Analysefehler in .NET Framework Version 1.1 wurden behoben.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass die URI-Zeichenfolge vor dem Erstellen der <see cref="T:System.Uri" />-Instanz vollständig mit Escapezeichen versehen war.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <paramref name="dontEscape" />-Parameter auf <see langword="true" /> festgelegt wurde, als die <see cref="T:System.Uri" />-Instanz erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.UserEscaped%2A> -Eigenschaftensatz auf `true` um anzugeben, dass die Zeichenfolge zum Erstellen der <xref:System.Uri> Instanz wurde vollständig mit Escapezeichen, bevor sie an den Konstruktor übergeben wurde, d. h., die `dontEscape` Parameter der Konstruktoraufruf auf festgelegtwurde`true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es vollständig mit Escapezeichen versehen wurde, wenn er erstellt wurde.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Benutzernamen, Kennwort oder weitere benutzerspezifische Informationen ab, die dem angegebenen URI zugeordnet sind.</summary>
        <value>Ein <see cref="T:System.String" />, der die dem URI zugeordneten Benutzerinformationen enthält. Der zurückgegebene Wert schließt nicht das '@'-Zeichen ein, das zum Begrenzen des Benutzerinformationsteils des URIs reserviert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Eigenschaft zurückgegebene Wert ist in der Regel im Format "Benutzername".  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und die Benutzerinformationen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz einen relativen URI darstellt, und diese Eigenschaft gilt nur für absolute URIs handelt.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
