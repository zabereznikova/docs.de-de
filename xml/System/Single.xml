<Type Name="Single" FullName="System.Single">
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit einfacher Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single> Werttyp stellt eine 32-Bit-Zahl mit einfacher Genauigkeit mit Werten, die im Bereich von negativen 3. 402823E38 bis positive 3. 402823E38 sowie positive oder negative 0 (null), <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>, und keine Zahl (<xref:System.Single.NaN>). Sie dient zur Darstellung von Werten, die extrem (z. B. die Abstände zwischen Planeten oder Galaxien) großen oder sehr klein ist (z. B. die Molekülmasse des ein Stoff in Kilogramm) sind und häufig (z. B. der Abstand zwischen Erde und eine andere Sonnensystem unpräzise sind ). Die <xref:System.Single> Typ den IEC 60559: 1989 (IEEE 754) für binäre Gleitkommaarithmetik standard entspricht.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Gleitkommadarstellung und Genauigkeit](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleitkommawerte und Ausnahmen](#Exceptions)  
  
-   [Typkonvertierung und einzelne Struktur](#Conversion)  
  
-   [Gleitkomma-Funktion](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType>Stellt Methoden zum Vergleichen von Instanzen dieses Typs, den Wert einer Instanz in die Zeichenfolgendarstellung zu konvertieren, und klicken Sie auf die angegebene Zeichenfolgendarstellung einer Zahl in eine Instanz dieses Typs zu konvertieren. Weitere Informationen dazu, wie die Darstellung von Werttypen Spezifikation Formatcodes gesteuert werden, finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md), [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md), und [benutzerdefinierte numerische Formatieren von Zeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Gleitkommadarstellung und Genauigkeit  
 Die <xref:System.Single> -Datentyp speichert Gleitkommawerten mit einfacher Genauigkeit in eine 32-Bit-Binärformat, wie in der folgenden Tabelle dargestellt:  
  
|Segment|Bits|  
|----------|----------|  
|Signifikanden oder Mantisse|0-22|  
|Exponent|23-30|  
|Zeichen (0 = positiv, 1 = negativ)|31|  
  
 Genauso wie Decimal Brüche nicht genau einige Bruchzahlen darstellen können (z. B. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), binary Brüche können nicht auf einige Bruchzahlen darstellen. 2/10, der genau durch.2 als Dezimalbruch dargestellt wird, wird z. B. durch.0011111001001100 als Binärbruch, mit dem Muster "1100" wiederholten unendlicher dargestellt. In diesem Fall stellt der Gleitkommawert eine ungenaue Darstellung der Zahl, die es darstellt. Zusätzliche mathematische Operationen auf der ursprünglichen Gleitkommawert häufig ausgeführt, wird der Mangel an Genauigkeit erhöht. Beispielsweise erzeugt, wenn die Ergebnisse der Multiplikation.3 von 10 und.3,.3 neun Mal hinzufügen, außerdem angezeigt wird das weniger präzise Ergebnis da hierbei acht weitere Vorgänge als Multiplikation. Beachten Sie, dass diese Abweichung vorliegt, offensichtlich ist, nur dann, wenn Sie die beiden anzeigen <xref:System.Single> Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), die, wenn nötig, zeigt alle 9 Ziffern von unterstützt die <xref:System.Single> Typ.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht genau als binäre Bruchzahlen dargestellt werden können, können Gleitkommazahlen ungefähre reelle Zahlen.  
  
 Alle Gleitkommazahlen haben eine begrenzte Anzahl von signifikanten Stellen, die auch bestimmt, wie genau ein Gleitkommawert mit eine reellen Zahl entspricht. Ein <xref:System.Single> Wert ist bis zu 7 Dezimalstellen, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Dies bedeutet, dass einige Gleitkommaoperationen, die Genauigkeit fehlen, um einen Gleitkommawert zu ändern. Das folgende Beispiel definiert einen großen Gleitkommawert mit einfacher Genauigkeit, und fügt dann das Produkt der <xref:System.Single.Epsilon?displayProperty=nameWithType> und eine Billiarde darauf. Allerdings ist das Produkt zu klein, um die ursprünglichen Gleitkommawert ändern. Die am wenigsten signifikante Ziffer ist, Zehntausendstel-, während die signifikanteste Ziffer des Produkts 1<sup>-312</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Der eingeschränkte Genauigkeit einer Gleitkommazahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit gleich angezeigt werden möglicherweise nicht gleich, da es sich bei ihrer letzten gültigen Ziffern unterscheiden. Im folgenden Beispiel werden eine Reihe von Zahlen addiert und deren Summe ist mit ihrer erwarteten insgesamt verglichen. Obwohl die beiden Werte angezeigt werden, auf die gleichen, einen Aufruf der `Equals` Methode gibt an, dass sie nicht sind.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Formatelemente in Ändern der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> -Anweisung aus `{0}` und `{1}` auf `{0:R}` und `{1:R}` anzuzeigenden alle signifikanten Ziffern der beiden <xref:System.Single> Werte, es ist klar, dass die beiden Werte ungleich sind, da von einem Genauigkeitsverlust während der Vorgänge hinzufügen. In diesem Fall kann das Problem gelöst werden, durch Aufrufen der <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode gerundet wird, die <xref:System.Single> Werte auf die gewünschte Genauigkeit vor dem Vergleich.  
  
-   Eine mathematische oder Vergleichsoperation Operation, die eine Gleitkommazahl verwendet möglicherweise nicht dasselbe Ergebnis ausgeben, wenn eine Dezimalzahl verwendet wird, da die binäre Gleitkommazahl möglicherweise nicht die Dezimalzahl Wert. In einem vorherigen Beispiel veranschaulicht dies durch das Ergebnis der Multiplikation.3 von 10 und das Hinzufügen von.3,.3 neun Mal anzeigen.  
  
     Wenn die Genauigkeit der numerischen Operationen mit Bruchwerten wichtig ist, verwenden Sie die <xref:System.Decimal> Geben Sie anstelle von der <xref:System.Single> Typ. Wenn die Genauigkeit der numerischen Operationen mit ganzzahligen Werten außerhalb des Gültigkeitsbereichs für die <xref:System.Int64> oder <xref:System.UInt64> Typen ist sehr wichtig, verwenden Sie die <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert kann nicht zurückkonvertiert, wenn eine Gleitkommazahl einbezogen ist. Ein Wert ist für den roundtripvorgang genannten, wenn ein Vorgang eine ursprüngliche Gleitkommazahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Format zurück in eine Gleitkommazahl transformiert und die endgültige Gleitkommazahl mit dem Original identisch ist Gleitkommazahl. Der Roundtrip kann fehlschlagen, da eine oder mehrere Ziffern verloren gehen oder bei der Konvertierung geändert werden. Im folgenden Beispiel drei <xref:System.Single> Werte in Zeichenfolgen konvertiert und in einer Datei gespeichert werden. Wie die Ausgabe zeigt, obwohl die Werte angezeigt werden, identisch sein, sind die wiederhergestellten Werte nicht gleich den ursprünglichen Werten.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     In diesem Fall die Werte können werden erfolgreich Roundtrip mithilfe der "G9" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) die vollständige Genauigkeit beibehalten <xref:System.Single> Werte, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single>Werte müssen weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> -Wert, der in eine entsprechende scheinbar konvertiert wird <xref:System.Double> häufig stimmt nicht mit der <xref:System.Double> Wert aufgrund der Unterschiede in der Genauigkeit. Im folgenden Beispiel wird das Ergebnis identisch Divisionsoperationen zugewiesen, um eine <xref:System.Double> Wert und eine <xref:System.Single> Wert. Nach der <xref:System.Single> Wert umgewandelt ist eine <xref:System.Double>, ein Vergleich der beiden Werte zeigt an, dass sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder die <xref:System.Double> -Datentyp anstelle von der <xref:System.Single> Datentyp aufweisen, oder verwenden die <xref:System.Math.Round%2A> Methode so, dass beide Werte die gleiche Genauigkeit verfügen.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet werden zwei <xref:System.Single> Werte müssen identische Werte darstellen. Jedoch aktivieren, aufgrund der Unterschiede in der Genauigkeit zwischen Werten oder aufgrund einer Unterbrechung der Genauigkeit von einer oder beide Werte, Gleitkommawerte, die häufig identisch sein soll aufgrund von Unterschieden in ihren letzten gültigen Ziffern berücksichtigt werden. Folglich aufruft, um die <xref:System.Single.Equals%2A> -Methode, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe von der <xref:System.Single.CompareTo%2A> Methode, um die Beziehung zwischen zwei bestimmen <xref:System.Single> Werte, häufig zu unerwarteten Ergebnissen führen. Dies wird im folgenden Beispiel ersichtlich, gleich, in denen zwei offensichtlich <xref:System.Single> hellste Werte ungleich sind, werden, weil der erste Wert 7 Dezimalstellen, während der zweite Wert 9 vorliegt.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die unterschiedlichen Codepfaden folgen und, die bearbeitet werden auf unterschiedliche Weise häufig, kosteneffizienter, berücksichtigt werden. Im folgenden Beispiel ein <xref:System.Single> Wert wird das Quadrat, und klicken Sie dann die Quadratwurzel berechnet wird, um den ursprünglichen Wert wiederherzustellen. Ein zweites <xref:System.Single> 3.51 multipliziert und Quadrat, bevor die Quadratwurzel des Ergebnisses durch 3.51 zum Wiederherstellen des ursprünglichen Werts dividiert wird. Scheinbar, dass die zwei Werte identisch sind, werden ein Aufruf der <xref:System.Single.Equals%28System.Single%29> Methode gibt an, dass sie nicht gleich sind. Mit der Standardformatzeichenfolge "G9" um eine Ergebniszeichenfolge zurückzugeben, die alle signifikanten Ziffern der einzelnen zeigt <xref:System.Single> Wert zeigt, dass der zweite Wert.0000000000001 ist kleiner als das erste.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen ein Genauigkeitsverlust ist wahrscheinlich das Ergebnis eines Vergleichs beeinflussen, verwenden Sie die folgenden Vorgehensweisen statt der <xref:System.Single.Equals%2A> oder <xref:System.Single.CompareTo%2A> Methode:  
  
-   Rufen Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass beide Werte die gleiche Genauigkeit enthalten. Im folgende Beispiel ändert ein vorherigen Beispiel für diesen Ansatz verwenden, sodass zwei Bruchzahlen äquivalent sind.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie, dass das Problem der Genauigkeit weiterhin, gilt um Werte für Mittelpunkt Rundung. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Ungefähre Gleichheit statt auf Gleichheit zu testen. Dieses Verfahren erfordert, dass Sie entweder ein absoluter definieren Menge nach dem die beiden Werte unterscheiden sich jedoch immer noch können identisch sein, oder, die Sie definieren eine relative Menge nach dem der kleinere Wert von der jeweils größere Wert voneinander abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType>In einigen Fällen als absolute ein Maß für den Abstand zwischen zwei verwendet <xref:System.Single> Werte beim Testen der Gleichheit.  Allerdings <xref:System.Single.Epsilon?displayProperty=nameWithType> misst den kleinstmöglichen Wert, der hinzugefügt oder davon subtrahiert werden kann ein <xref:System.Single> , dessen Wert ist 0 (null). Für die meisten Positive und negative <xref:System.Single> Werte, die den Wert des <xref:System.Single.Epsilon?displayProperty=nameWithType> ist zu klein, um erkannt zu werden. Aus diesem Grund mit Ausnahme der Werte, die NULL sind, wird nicht die Verwendung in Gleichheit empfohlen.  
  
     Im folgenden Beispiel wird den zweiten Ansatz zum Definieren einer `IsApproximatelyEqual` -Methode, die die relative Unterschied zwischen zwei Werten testet. Auch Unterschiede aufgezeigt, das Ergebnis der Aufrufe an die `IsApproximatelyEqual` Methode und die <xref:System.Single.Equals%28System.Single%29> Methode.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleitkommawerte und Ausnahmen  
 Operationen mit Gleitkommazahlen-Punktwerte lösen keine Ausnahmen, im Gegensatz zu Vorgängen mit ganzzahligen Typen ist, die Auslösen von Ausnahmen im Falle eines nicht zulässige Vorgänge wie z. B. Division durch 0 (null) oder einen Überlauf.  Stattdessen ist das Ergebnis einer Gleitkommaoperation in solchen Fällen können 0 (null), unendlich, negativ unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleitkommaoperation für das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann auftreten, wenn zwei sehr kleine Gleitkommazahlen, wie im folgenden Beispiel gezeigt multipliziert werden.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Wenn das Ergebnis einer Gleitkommaoperation als Maßeinheit des Bereichs von im Zielformat überschreitet, wird das Ergebnis des Vorgangs <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>je nach Bedarf für das Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, die führt zu einem Überlauf <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single.PositiveInfinity>, und das Ergebnis eines Vorgangs, die führt zu einem Überlauf <xref:System.Single.MinValue?displayProperty=nameWithType> ist <xref:System.Single.NegativeInfinity>, wie im folgende Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity>auch aus einer Division durch 0 (null) mit einer positiven Dividend ausgegeben und <xref:System.Single.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null), mit einem negativen Dividend.  
  
-   Wenn eine Gleitkommaoperation ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Single.NaN>. Beispielsweise <xref:System.Single.NaN> führt Sie aus den folgenden Vorgängen:  
  
    -   Division durch 0 (null), mit einer Dividende 0 (null). Beachten Sie, dass andere Fälle der Division durch 0 (null) Ergebnis entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>.  
  
    -   Alle Gleitkommaoperation mit die Eingabe ist ungültig. Versucht, z. B. gefunden wird, gibt die Quadratwurzel eines negativen Werts <xref:System.Single.NaN>.  
  
    -   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Typumwandlungen und einzelne Struktur  
 Die <xref:System.Single> Struktur werden kein explizite oder implizite Konvertierungsoperatoren definiert; stattdessen werden die Konvertierungen vom Compiler implementiert.  
  
 Die folgende Tabelle enthält die möglichen Konvertierungen mit einem Wert von den anderen primitiven numerischen Typen zu einem <xref:System.Single> Wert, es gibt auch an, ob die Konvertierung erweiternde oder einschränkende und ob das resultierende <xref:System.Single> möglicherweise weniger Genauigkeit als der ursprüngliche Wert.  
  
|Konvertierung von|Erweiternde/einschränkende|Mögliche Genauigkeitsverlust|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Nein|  
|<xref:System.Decimal>|Widening<br /><br /> Beachten Sie, dass c# Umwandlungsoperatoren erforderlich ist.|Ja. <xref:System.Decimal>unterstützt die Genauigkeit von 29 Ziffern. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Double>|Einschränkende; Werte außerhalb des Bereichs in konvertiert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Ja. <xref:System.Double>unterstützt die Genauigkeit von 17 Ziffern. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Int16>|Widening|Nein|  
|<xref:System.Int32>|Widening|Ja. <xref:System.Int32>unterstützt 10 Dezimalstellen an. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Int64>|Widening|Ja. <xref:System.Int64>unterstützt 19 Dezimalstellen an. <xref:System.Single> 9 unterstützt.|  
|<xref:System.SByte>|Widening|Nein|  
|<xref:System.UInt16>|Widening|Nein|  
|<xref:System.UInt32>|Widening|Ja. <xref:System.UInt32>unterstützt 10 Dezimalstellen an. <xref:System.Single> 9 unterstützt.|  
|<xref:System.UInt64>|Widening|Ja. <xref:System.Int64>unterstützt 20 Dezimalstellen an. <xref:System.Single> 9 unterstützt.|  
  
 Das folgende Beispiel konvertiert die minimalen oder maximalen Wert von anderen primitiven numerischen Typen zur ein <xref:System.Single> Wert.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Darüber hinaus die <xref:System.Double> Werte <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> konvertieren, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>zugeordnet.  
  
 Beachten Sie, dass die Konvertierung des Werts von einigen numerische Typen, die eine <xref:System.Single> Wert kann ein Genauigkeitsverlust umfassen. Wie im Beispiel veranschaulicht, ein Genauigkeitsverlust kann beim Konvertieren von <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, und <xref:System.UInt64> Werte <xref:System.Single> Werte.  
  
 Die Konvertierung von einem <xref:System.Single> -Wert an ein <xref:System.Double> ist eine erweiternde Konvertierung. Die Konvertierung kann zu einem Genauigkeitsverlust führen, wenn die <xref:System.Double> -Typ verfügt nicht über eine genaue Darstellung der <xref:System.Single> Wert.  
  
 Die Konvertierung von einem <xref:System.Single> auf einen Wert eines beliebigen primitiven numerischen Datentyps anderen Wert als eine <xref:System.Double> ist eine einschränkende Konvertierung und erfordert eine Umwandlungsoperator (in c#) oder eine Konvertierungsmethode (in Visual Basic). Werte, die außerhalb des Bereichs des Zieltyps Daten sind die durch des Zieltyps definiert sind `MinValue` und `MaxValue` Eigenschaften, verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Jedes beliebigen ganzzahligen Typs|Eine <xref:System.OverflowException> -Ausnahme aus, wenn die Konvertierung in einem überprüften Kontext auftritt.<br /><br /> Wenn die Konvertierung in einem nicht geprüften Kontext (die Standardeinstellung in c#) auftritt, wird der Konvertierungsvorgang ist erfolgreich, aber der Wert überläuft.|  
|<xref:System.Decimal>|Ein <xref:System.OverflowException> Ausnahme|  
  
 Darüber hinaus <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Auslösen einer <xref:System.OverflowException> für Konvertierungen in einem überprüften Kontext, aber diese Werte Überlauf beim Konvertieren zu einer ganzen Zahl in einem nicht geprüften Kontext zu ganzen Zahlen. Für die Konvertierung in <xref:System.Decimal>, sie immer lösen eine <xref:System.OverflowException>. Für die Konvertierung in <xref:System.Double>, konvertieren sie Sie in <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zugeordnet.  
  
 Beachten Sie, dass es sich bei einem Genauigkeitsverlust führen kann, aus der Konvertierung einer <xref:System.Single> Wert in einen anderen numerischen Typ. Bei der Konvertierung von nicht ganzzahligen <xref:System.Double> Werte, wie die Ausgabe des Beispiels zeigt, der Nachkommawert wird abgebrochen, wenn die <xref:System.Single> Wert (wie in Visual Basic) gerundet oder gekürzt (wie in c#). Für die Konvertierung in <xref:System.Decimal> und <xref:System.Single> Werte, die <xref:System.Double> Wert möglicherweise keine genaue Darstellung in den Zieldatentyp.  
  
 Das folgende Beispiel konvertiert eine Zahl von <xref:System.Single> Werte in verschiedene andere numerischen Typen. Die Konvertierungen erfolgen, in einem überprüften Kontext in Visual Basic (Standard) und in c# (aufgrund der der [überprüft](~/docs/csharp/language-reference/keywords/checked.md) Schlüsselwort). Die Ausgabe des Beispiels zeigt das Ergebnis für Konvertierungen in einem überprüften einem nicht geprüften Kontext. Führen Sie Konvertierungen in einem nicht geprüften Kontext in Visual Basic, durch die Kompilierung mit der `/removeintchecks+` Compilerschalter und in c# Auskommentieren der `checked` Anweisung.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung von numerischen Typen finden Sie unter [Typkonvertierung in .NET Framework](~/docs/standard/base-types/type-conversion.md) und [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleitkomma-Funktion  
 Die <xref:System.Single> Struktur und verwandte Typen bieten Ihnen Methoden, um die folgenden Kategorien von Vorgänge auszuführen:  
  
-   **Vergleich der Werte**. Sie erreichen die <xref:System.Single.Equals%2A> Methode, um zu bestimmen, ob zwei <xref:System.Single> Werte gleich sind, oder die <xref:System.Single.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten festzulegen.  
  
     Die <xref:System.Single> Struktur unterstützt auch einen kompletter Satz von Vergleichsoperatoren. Sie können z. B. auf Gleichheit oder Ungleichheit testen oder bestimmen, ob ein Wert größer als oder gleich einem anderen Wert ist. Wenn einer der Operanden ist ein <xref:System.Double>, <xref:System.Single> konvertierte Wert ist eine <xref:System.Double> vor dem Vergleich. Wenn einer der Operanden ein Ganzzahltyp ist, wird es in konvertiert eine <xref:System.Single> vor dem Vergleich. Obwohl diese Konvertierungen erweiternde sind, können sie ein Genauigkeitsverlust führen.  
  
    > [!WARNING]
    >  Aufgrund der Unterschiede in Genauigkeit zwei <xref:System.Single> Werte, die voraussichtlich identisch sein können berücksichtigt, werden die wirkt sich auf das Ergebnis des Vergleichs verwandeln. Finden Sie unter der [Testen auf Gleichheit](#Equality) Abschnitt, um weitere Informationen zum Vergleichen von zwei <xref:System.Single> Werte.  
  
     Sie können auch aufrufen, die <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, und <xref:System.Single.IsNegativeInfinity%2A> Methoden für diese speziellen Werte testen.  
  
-   **Mathematische Operationen**. Allgemeine arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division werden durch Sprachcompiler und Common Intermediate Language (CIL) Anweisungen anstelle von implementiert <xref:System.Single> Methoden. Wenn der andere Operand in einer mathematischen Operation ist ein <xref:System.Double>, die <xref:System.Single> konvertiert eine <xref:System.Double> vor dem Ausführen des Vorgangs und das Ergebnis des Vorgangs auch eine <xref:System.Double> Wert. Wenn der andere Operand ein ganzzahliger Typ ist, wird es in konvertiert eine <xref:System.Single> vor dem Ausführen des Vorgangs und das Ergebnis des Vorgangs auch eine <xref:System.Single> Wert.  
  
     Sie können andere mathematischen Operationen ausführen, durch den Aufruf `static` (`Shared` in Visual Basic) Methoden in der <xref:System.Math?displayProperty=nameWithType> Klasse. Dazu gehören zusätzliche Methoden, die häufig für arithmetische Operationen verwendet (z. B. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. B. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>), und Analysis (z. B. <xref:System.Math.Log%2A?displayProperty=nameWithType>).  In allen Fällen die <xref:System.Single> konvertierte Wert ist eine <xref:System.Double>.  
  
     Sie können auch den einzelnen Bit in Bearbeiten einer <xref:System.Single> Wert. Die <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Methode gibt die Bitmuster in ein Bytearray zurück.  Durch das übergeben dieses Bytearray, das <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> -Methode können Sie auch beibehalten, die <xref:System.Single> Wert des Bitmuster in einer 32-Bit-Ganzzahl.  
  
-   **Rundung**. Rundung wird häufig als eine Technik verwendet zur Verringerung der Auswirkungen der Unterschiede zwischen den Werten, die aufgrund von Problemen mit der gleitkommadarstellung und Genauigkeit. Runden Sie können eine <xref:System.Single> -Wert durch Aufrufen der <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode. Beachten Sie jedoch, dass die <xref:System.Single> konvertierte Wert ist eine <xref:System.Double> , bevor die Methode wird aufgerufen, und die Konvertierung kann ein Genauigkeitsverlust umfassen.  
  
-   **Formatieren von**. Sie Konvertieren einer <xref:System.Single> Wert in seine Zeichenfolgendarstellung durch Aufrufen der <xref:System.Single.ToString%2A> Methode oder mithilfe der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Funktion. Weitere Informationen dazu, wie die Zeichenfolgendarstellung von Gleitkommawerten Formatzeichenfolgen gesteuert werden, finden Sie unter der [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md) Themen.  
  
-   **Analysieren von Zeichenfolgen**. Sie können die angegebene Zeichenfolgendarstellung eines Gleitkommawerts auf Konvertieren einer <xref:System.Single> -Wert durch Aufrufen der <xref:System.Single.Parse%2A> oder <xref:System.Single.TryParse%2A> Methode. Wenn der Analysevorgang misslingt, die <xref:System.Single.Parse%2A> Methode eine Ausnahme auslöst, während die <xref:System.Single.TryParse%2A> -Methode zurückkehrt `false`.  
  
-   **Typkonvertierung**. Die <xref:System.Single> Struktur stellt eine explizite Implementierung für die <xref:System.IConvertible> -Schnittstelle, die Konvertierung zwischen jeder zwei standardmäßigen .NET Framework-Datentypen unterstützt. Sprachcompiler unterstützen auch die implizite Konvertierung von Werten für alle anderen standardmäßigen numerischen Datentypen mit Ausnahme der Konvertierung von <xref:System.Double> zu <xref:System.Single> Werte. Konvertierung eines Werts eines beliebigen standardmäßigen numerischen Typs außer einer <xref:System.Double> auf eine <xref:System.Single> ist eine erweiternde Konvertierung und die Verwendung einer Umwandlung Operator oder Konvertierung-Methode ist nicht erforderlich.  
  
     Konvertierung von 32-Bit und 64-Bit-Ganzzahlwerten kann jedoch einem Genauigkeitsverlust führen. Die folgende Tabelle enthält die Unterschiede in der Genauigkeit für 32-Bit, 64-Bit- und <xref:System.Double> Typen:  
  
    |Typ|Maximale Genauigkeit (Dezimalstellen)|Interne Genauigkeit (Dezimalstellen)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> und <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> und <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Das Problem der Genauigkeit am häufigsten wirkt sich auf <xref:System.Single> Werte, die konvertiert werden <xref:System.Double> Werte. Im folgenden Beispiel zwei Werte, die durch identische Divisionsoperationen erstellte ungleich sind, da einer der Werte einen Gleitkommawert mit einfacher Genauigkeit, die Konvertierung ist in einen <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Elemente, die angezeigt werden, so ändern Sie den Zustand der Instanz zurückgeben tatsächlich eine neue Instanz mit dem neuen Wert initialisiert. Als müssen mit einem beliebigen anderen Typ Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch ein Schloss auf Threadsicherheit geschützt werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Diese Instanz ist kleiner als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz ist gleich <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz und value sind beide keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Diese Instanz ist größer als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
 - oder -   
  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss `null` oder einer Instanz von <xref:System.Single>ist, andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Single>, unabhängig vom Wert wird als größer betrachtet `null`.  
  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommawerte abhängt, ist es üblich sind, um die Genauigkeit verloren gehen und deren Werte mit Ausnahme von ihren letzten gültigen Ziffern fast identisch sein. Deswegen den Rückgabewert der <xref:System.Single.CompareTo%2A> -Methode mag überraschenden vorkommen. Z. B. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert sollte den ursprünglichen Wert produzieren, führt jedoch im folgenden Beispiel der berechnete Wert beläuft sich auf größer als der ursprüngliche Wert. Anzeigen von alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der berechnete Wert der ursprüngliche Wert in der letzten gültigen Ziffern unterscheiden. Informationen zur Behandlung von solche Vergleiche, finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode implementiert wird, zur Unterstützung der <xref:System.IComparable> Schnittstelle. Beachten Sie, dass, obwohl ein <xref:System.Single.NaN> ist nicht als gleich einem anderen <xref:System.Single.NaN> (sogar selbst), die <xref:System.IComparable> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.CompareTo%2A> Methode.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.Single" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit einfacher Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit einfacher Genauigkeit und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Diese Instanz ist kleiner als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz ist gleich <paramref name="value" />.  
  
 - oder -   
  
 Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Diese Instanz ist größer als <paramref name="value" />.  
  
 - oder -   
  
 Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen als gleich betrachtet werden identisch sein. Es ist üblich für Gleitkommawerten mit einfacher Genauigkeit verloren und werden nahezu identisch, mit Ausnahme von ihren letzten gültigen Ziffern, insbesondere, wenn die Werte von mehreren mathematische Operationen abhängen. Deswegen den Rückgabewert der <xref:System.Single.CompareTo%2A> Methode manchmal mag überraschenden. Multiplikation durch einen beliebigen Wert gefolgt von einer Division durch den gleichen Wert erzeugt z. B. sollte den ursprünglichen Wert. Im folgenden Beispiel wird der berechnete Wert größer als der ursprüngliche Wert ist jedoch aktiviert. Anzeigen von alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der berechnete Wert der ursprüngliche Wert in der letzten gültigen Ziffern unterscheiden. Informationen zur Behandlung von solche Vergleiche, finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> Schnittstelle und führt etwas bessere Leistung als die <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> Methode, da sie keinen konvertieren die `value` Parameter für ein Objekt.  
  
 Beachten Sie, dass, obwohl ein Objekt, dessen Wert <xref:System.Single.NaN> ist nicht gleich einem anderen Objekt, dessen Wert, berücksichtigt <xref:System.Single.NaN> (sogar selbst), die <xref:System.IComparable%601> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Single.CompareTo%2A> Methode, in dem der Parametertyp weniger Bits aufweist (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführt, die den Parameter als einen Typ mit wie vielen Bits wie die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Single> und der Parametertyp ist <xref:System.Int32>. Der Microsoft C#-Compiler generiert Anweisungen, um die Darstellung des Werts des Parameters als eine <xref:System.Single> -Objekt, und generiert dann eine <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> Methode, die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen von numerischen Typen durchführt. Weitere Informationen finden Sie unter der [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generische Versionen der <xref:System.Single.CompareTo%2A> Methode für verschiedene Wert- und Referenztypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Single" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Single.Epsilon> Eigenschaft gibt den kleinsten positiven <xref:System.Single> Wert, der in numerischen Operationen oder Vergleichen signifikant ist bei den Wert des der <xref:System.Single> Instanz ist 0 (null). Z. B. der folgende Code zeigt, die 0 (null) und <xref:System.Single.Epsilon> gelten als ungleiche Werte während 0 (null) und die Hälfte der Wert der <xref:System.Single.Epsilon> als gleich betrachtet werden.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesagt, besteht die Gleitkommazahl mit einfacher Genauigkeit-Format einer Anmeldung, einer 23-Bit-Mantisse oder Signifikanden und einen 8-Bit-Exponenten. Wie im folgenden Beispiel wird gezeigt, verfügt über 0 (null), Exponenten-126 und einer Mantisse 0. <xref:System.Single.Epsilon>verfügt über einen Exponenten der-126 und einer Mantisse 1. Dies bedeutet, dass <xref:System.Single.Epsilon?displayProperty=nameWithType> ist die kleinste Positive <xref:System.Single> Wert, der größer als 0 (null) und stellt den kleinstmöglichen Wert und das kleinste mögliche Inkrement für eine <xref:System.Single> , deren Exponent ist-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Allerdings die <xref:System.Single.Epsilon> Eigenschaft ist für ein allgemeines Maß für die Genauigkeit des nicht die <xref:System.Single> geben; gilt nur für <xref:System.Single> Instanzen, die einen Wert von 0 (null) aufweisen.  
  
> [!NOTE]
>  Der Wert, der die <xref:System.Single.Epsilon> Eigenschaft ist nicht gleichbedeutend mit Epsilon für Computer, die Obergrenze des relativen Fehlers durch runden in Gleitkommazahlen dar.  
  
 Der Wert dieser Konstanten ist 1.4e-45.  
  
 Zwei offensichtlich gleichwertige Gleitkommazahlen möglicherweise aufgrund der Unterschiede in ihren letzten gültigen Ziffern nicht gleich. Z. B. den C#-Ausdruck, `(float)1/3 == (float)0.33333`, lässt nicht gleich vergleichen, da die Division auf der linken Seite maximalen Genauigkeit ausgeführt, während die Konstante auf der rechten Seite nur auf die angegebenen Ziffern präzise ist. Wenn Sie einen benutzerdefinierten Algorithmus, der bestimmt erstellen, ob zwei Gleitkommazahlen als gleich betrachtet werden können, müssen, verwenden Sie einen Wert größer als die <xref:System.Single.Epsilon> -Konstante, um die zulässigen absolute Differenz für die beiden Werte werden festzulegen als gleich betrachtet. (In der Regel ist dieser Unterschied deutlich größer als <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Anmerkungen zur Plattform  
 Auf ARM-Systemen, den Wert, der die <xref:System.Single.Epsilon> Konstante ist zu klein, um erkannt zu werden, damit er 0 (null) entspricht. Sie können einen alternative Epsilon-Wert, der gleich 1.175494351E definieren-38 stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Single" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.Equals%2A> Methode sollte mit Vorsicht verwendet werden, da zwei offensichtlich gleichwertig aufgrund der unterschiedlichen Genauigkeit der beiden Werte berücksichtigt werden können. Im folgenden Beispiel gemeldet, die die <xref:System.Single> .3333 Wert und die <xref:System.Single> Division zurückgegebenes 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Anstatt Vergleich, Gleichheit, eine empfohlene Verfahren besteht im Definieren einer zulässigen Rand Unterschied zwischen zwei Werten (z. B.. 01 % einer der Werte). Wenn der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich besagter Rand ist, der Unterschied ist wahrscheinlich aufgrund von Unterschieden bei der Genauigkeit, und daher die Werte als gleich wahrscheinlich sind. Im folgenden Beispiel wird diese Technik um zu.33333 und 1/3, die beiden zu vergleichenden <xref:System.Single> Werte, die im vorherigen Codebeispiel gefunden werden.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> minimale Ausdruck definiert, der ein positiver Wert sein, deren Gültigkeitsbereich in der Nähe von 0 (null) ist, muss der Unterschied größer sein <xref:System.Single.Epsilon>. In der Regel ist es oft größer als <xref:System.Single.Epsilon>.  
  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Folglich kann ein Vergleich von zwei bestimmten Zahlen zwischen verschiedenen Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.Equals%2A> Methode.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Single.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Single" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Single.Equals(System.Single)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Single.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Single" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und Aufrufe führt die <see cref="M:System.Single.Equals(System.Single)" /> -Methode, während der zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Single.Equals(System.Object)" /> Methode.  
  
 [!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Single" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> Schnittstelle, und führt etwas bessere Leistung als <xref:System.Single.Equals%2A> , da sie keinen konvertieren die `obj` Parameter für ein Objekt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Single.Equals%2A> Methode, in dem der Parametertyp weniger Bits aufweist (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführt, die den Parameter als einen Typ mit wie vielen Bits wie die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Single> und der Parametertyp ist <xref:System.Int32>. Der Microsoft C#-Compiler generiert Anweisungen, um die Darstellung des Werts des Parameters als eine <xref:System.Single> -Objekt, und generiert dann eine <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> Methode, die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen von numerischen Typen durchführt. Weitere Informationen finden Sie unter der [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die <xref:System.Single.Equals%2A> Methode sollte mit Vorsicht verwendet werden, da zwei offensichtlich gleichwertig aufgrund der unterschiedlichen Genauigkeit der beiden Werte berücksichtigt werden können. Im folgenden Beispiel gemeldet, die die <xref:System.Single> .3333 Wert und die <xref:System.Single> Division zurückgegebenes 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Eine Vergleichsmethode, der vermeidet Probleme im Zusammenhang mit Vergleich für Gleichheit umfasst eine akzeptable Rand Unterschied zwischen zwei Werten definieren (z. B.. 01 % einer der Werte). Wenn der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich besagter Rand ist, der Unterschied ist wahrscheinlich ein Ergebnis von Unterschieden im Genauigkeit werden, und daher die Werte als gleich wahrscheinlich sind. Im folgenden Beispiel wird diese Technik zum Vergleichen von.33333 und 1/3, die die beiden sind <xref:System.Single> Werte, die im vorherigen Codebeispiel gefunden werden.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> minimale Ausdruck definiert, der ein positiver Wert sein, deren Gültigkeitsbereich in der Nähe von 0 (null) ist, muss der Unterschied größer sein <xref:System.Single.Epsilon>. In der Regel ist es oft größer als <xref:System.Single.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie nicht verwenden <xref:System.Double.Epsilon> beim Vergleich von <xref:System.Double> Werte hinsichtlich ihrer Gleichheit.  
  
 Eine zweite Technik, die Probleme im Zusammenhang mit der Vergleich Gleichheit wird vermieden, wird durch Vergleichen des Unterschieds zwischen zwei Gleitkommazahlen mit einigen absoluten Wert. Wenn Sie den absoluten Wert kleiner oder gleich der Unterschied besteht darin, sind die Zahlen gleich. Wenn sie größer ist, sind die Zahlen ungleich. Eine Möglichkeit hierfür besteht darin nach dem Zufallsprinzip einen absoluten Wert auszuwählen. Allerdings ist dies problematisch, da eine akzeptable Rand Unterschied für die Größenordnung der hängt die <xref:System.Single> Werte. Eine zweite Möglichkeit nutzt ein Entwurf Bestandteil der Gleitkommaformat: der Unterschied zwischen den Komponenten der Mantisse in die Integer-Darstellung von zwei Gleitkommazahlen-Punktwerte gibt die Anzahl der möglichen Gleitkommawerte, die eine Trennung der zwei Werte. Beispielsweise den Unterschied zwischen 0,0 und <xref:System.Single.Epsilon> beträgt 1, da <xref:System.Single.Epsilon> ist der kleinste darstellbare Wert bei der Arbeit mit einem <xref:System.Single> , dessen Wert ist 0 (null). Im folgenden Beispiel wird diese Technik zum Vergleichen von.33333 und 1/3, die die beiden sind <xref:System.Double> Werte, die im vorangehenden Codebeispiel wird mit der <xref:System.Single.Equals%28System.Single%29> Methode gefunden werden. Beachten Sie, die im Beispiel wird die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> und <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> Methoden, um einen Gleitkommawert mit einfacher Genauigkeit in die Integer-Darstellung zu konvertieren.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleitkommazahlen über die dokumentierte Genauigkeit ist spezifisch für die Implementierung und die Version von .NET Framework. Daher möglicherweise ein Vergleich zweier Zahlen unterschiedlichen Ergebnissen abhängig von der Version von .NET Framework führen, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Single.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Single" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Single.Equals(System.Single)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Single.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Single" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und Aufrufe führt die <see cref="M:System.Single.Equals(System.Single)" /> -Methode, während der zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Single.Equals(System.Object)" /> Methode.  
  
 [!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Single" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /> entweder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.IsInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Single.NaN" />).</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /> Not-a-Number (<see cref="F:System.Single.NaN" />) ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.NaN> signalisiert, dass das Ergebnis des Vorgangs nicht definiert ist. Division von 0.0 durch 0.0 ergibt z. B. <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A>Gibt `false` Wenn eine <xref:System.Single> Wert lautet entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>. Um diese Werte zu testen, verwenden die <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, und <xref:System.Single.IsNegativeInfinity%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.IsNaN%2A> Methode.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.NegativeInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.IsNegativeInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.PositiveInfinity> um einen Überlauf zu signalisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.IsPositiveInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist positive 3.40282347E + 38.  
  
 Das Ergebnis eines Vorgangs, die überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single?displayProperty=nameWithType> von Addition und Multiplikation Potenzierung Vorgängen führt, wenn das Ergebnis überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.MaxValue> konstant.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist negativ 3. 402823e38.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist <xref:System.Single?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single?displayProperty=nameWithType> Subtraktion und Multiplikation Vorgänge ergibt das Ergebnis ist kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.MinValue> konstant.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt Not-a-Number (<see langword="NaN" />) dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt eine Methode oder einen Operator <xref:System.Single.NaN> Wenn das Ergebnis eines Vorgangs ist nicht definiert. Das Ergebnis der Division von 0 durch 0 (null) ist z. B. <xref:System.Single.NaN>, wie im folgende Beispiel gezeigt. (Aber beachten Sie, dass eine Zahl ungleich NULL durch 0 (null) geteilt entweder gibt <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>, je nachdem, auf das Vorzeichen des Divisors identisch.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Darüber hinaus Aufrufen einer Methode mit einer <xref:System.Single.NaN> Wert oder einen Vorgang auf eine <xref:System.Single.NaN> Wert gibt <xref:System.Single.NaN>, wie das folgende Beispiel zeigt.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Verwenden der <xref:System.Single.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Im allgemeinen <xref:System.Single> Operatoren können nicht verwendet werden, um <xref:System.Single.NaN?displayProperty=nameWithType> mit anderen <xref:System.Single> Werte, obwohl Methoden zum Zeichenfolgenvergleich (z. B. <xref:System.Single.Equals%2A> und <xref:System.Single.CompareTo%2A>) können. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Single> Vergleichsoperatoren und Methoden.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Single.NaN> konstant.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs ist kleiner als <xref:System.Single.MinValue>.  
  
 Verwendung <xref:System.Single.IsNegativeInfinity%2A> zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.NegativeInfinity> konstant.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_Equality%2A> Methode definiert, den Gleichheitsoperator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der den größer-als-oder-gleich-Operator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_Inequality%2A> Methode definiert den Ungleichheitsoperator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der den kleiner-als-oder-gleich-Operator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgenentsprechung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [*ws*] [*Anmeldung*] [*ganzzahligen Ziffern*[*,*]]*ganzzahligen Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein Minuszeichen oder Pluszeichen. Gültige Zeichen gemäß der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Es können nur mit einem vorangestellten Plus-oder Minuszeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Aufsetzend *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Tausendergruppen. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird der Einsatz einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausendertrennzeichen Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> methodenüberladung.  
  
 Die `s` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge mithilfe von den Formatierungsinformationen des einer bestimmten Kultur zu analysieren, verwenden die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> oder <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Single.Parse%2A> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A> -Methode, die ursprünglichen <xref:System.Single> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%29> Methode, um ein Array von Zeichenfolgen in entsprechende konvertieren <xref:System.Single> Werte.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />ist keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die im vorhanden sein können <c>s</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert, die die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbole), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. Abhängig vom Wert `style`, dauert auch die Form:  
  
 [*ws*] [*$*] [*Anmeldung*] [*ganzzahligen Ziffern*[*,*]]* ganzzahlige Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
 *ws*  
 Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 $  
 Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 *Anmelden*  
 Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 *ganzzahlige Ziffern*  
 Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.  
  
 ,  
 Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag  
  
 .  
 Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 *Dezimalstellen sind*  
 Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 E  
 Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.  
  
 *exponentielle Ziffern*  
 Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen wie positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das 1000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausender-Trennzeichen und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Einige Beispiele für `s` sind "100", "123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600", "-. 123" und "-Infinity".  
  
 Die `s` Parameter analysiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Rufen Sie zum Angeben der Kultur, deren Formatierungsinformationen, damit der Analysevorgang verwendet wird, der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> überladen.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Single.Parse%2A> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A> -Methode, die ursprünglichen <xref:System.Single> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode analysiert die zeichenfolgendarstellungen <xref:System.Single> Werte. Im Beispiel wird die Formatierungsinformationen für die Kultur En-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>s</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird normalerweise verwendet, um Text zu konvertieren, die in einer Vielzahl von Möglichkeiten, formatiert werden, können eine <xref:System.Single> Wert. Beispielsweise kann verwendet werden, konvertieren Sie den Text in einem Textfeld HTML in einen numerischen Wert von einem Benutzer eingegeben.  
  
 Die `s` Parameter wird der Einsatz einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die durch den angegebenen Kultur `provider`, oder sie können eine Zeichenfolge im Format enthalten:  
  
 [*ws*] [*Anmeldung*]*ganzzahligen Ziffern*[*.* [*Dezimalstellen*]] [-e [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die die Begriff "Ziffern" enthalten bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+).|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Aufsetzend *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Tausendergruppen. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formate finden Sie unter der [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md) Thema.  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> Methode aufgerufen wird, ruft er die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Die <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen zum Format von bietet die `s` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter benutzerdefinierte Formatierungsinformationen für den Analysevorgang angeben:  
  
-   Sie können übergeben ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können den tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null` oder ein <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Einige Beispiele für `s` sind "100", "123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600", "-. 123" und "-Infinity".  
  
   
  
## Examples  
 Im folgende Beispiel wird die Schaltfläche mit der click-Ereignishandler, der ein Web Form. Er verwendet das zurückgegebene Array die <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> Eigenschaft um Gebietsschema des Benutzers zu bestimmen. Klicken Sie dann instanziiert einen <xref:System.Globalization.CultureInfo> -Objekt, das diesem Gebietsschema entspricht. Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das zu gehört <xref:System.Globalization.CultureInfo> Objekt wird dann zum Übergeben der <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> Methode, um den Benutzer Konvertieren der Eingabe für eine <xref:System.Single> Wert.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />ist keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die im vorhanden sein können <c>s</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>s</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert, die die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbole), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die durch den angegebenen Kultur `provider`. Abhängig vom Wert `style`, dauert auch die Form:  
  
 [*ws*] [*$*] [*Anmeldung*] [*ganzzahligen Ziffern*,]*ganzzahligen Ziffern*[. [ *Dezimalstellen*]] [E [*Anmeldung*]*exponentiellen Ziffern*] [*ws*]  
  
 Elemente müssen in eckigen Klammern ([und]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Dezimalstellen* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag|  
|.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen wie positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das 1000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausender-Trennzeichen und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. In der Regel `provider` kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Methode instanziieren und Zurückgeben der <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`die <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet wird.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode analysiert die zeichenfolgendarstellungen <xref:System.Single> Werte. Jede Zeichenfolge in einem Array wird die Verwendung der Formatierungskonventionen der En-US, nl-NL und eine benutzerdefinierte Kultur analysiert. Die benutzerdefinierte Kultur definiert seine Gruppentrennzeichen als der Unterstrich ("_") und seine Gruppengröße als zwei.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />ist die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs übersteigt <xref:System.Single.MaxValue>.  
  
 Verwendung <xref:System.Single.IsPositiveInfinity%2A> zu bestimmen, ob ein Wert plus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Single.PositiveInfinity> konstant.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Single" />-Wert konvertiert werden soll.</param>
        <param name="provider">Ein Objekt, das Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString> -Methode formatiert einen <xref:System.Single> Wert in der Standardeinstellung ("G" oder Allgemeines) Format der aktuellen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Single.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Anmeldung] Ganzzahl-Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die die Begriff "Ziffern" enthalten bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. Jedes Element wird in der folgenden Tabelle aufgeführt:  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*Anmelden*|Ein negatives Vorzeichen oder Pluszeichen.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|'.'|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl angeben.|  
|'e'|Ein Kleinbuchstabe "e", der angibt, Exponentialschreibweise (wissenschaftlich).|  
|*exponentielle Ziffern*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardeinstellung <xref:System.Single.ToString%2A?displayProperty=nameWithType> zeichenfolgendarstellungen, die eine Anzahl von anzuzeigenden Methode <xref:System.Single> Werte.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Single.Parse%28System.String%29> Methode zusammen mit der <xref:System.Single.ToString> Methode.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Single> Wert in der Standardeinstellung ("G" oder Allgemeines) Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Single.ToString>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Single.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Anmeldung] Ganzzahl-Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern]  
  
 Optionale Elemente in eckigen Klammern eingeschlossen sind ([und]). Elemente, die den Begriff "Ziffern" bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. Die folgende Tabelle enthält jedes Element.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|sign|Ein negatives Vorzeichen oder Pluszeichen.|  
|ganzzahlige Ziffern|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|'.'|Eine kulturspezifische Dezimaltrennzeichen.|  
|Dezimalstellen sind|Eine Folge von Ziffern, die die Nachkommastellen der Zahl angeben.|  
|'e'|Ein Kleinbuchstabe "e", der angibt, Exponentialschreibweise (wissenschaftlich).|  
|exponentielle Ziffern|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert wird mit formatiert die <xref:System.Globalization.NumberFormatInfo> Daten für die aktuelle Kultur.  
  
 Konvertieren einer <xref:System.Single> Wert in die Zeichenfolgendarstellung einer angegebenen Kultur mit einer bestimmten Formatzeichenfolge Aufruf der <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Zeichenfolgendarstellung von zwei <xref:System.Single> Werte mit <xref:System.Globalization.CultureInfo> Objekte, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%29> -Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format mit den Konventionen der aktuellen Kultur. Wenn Sie die Standardeinstellung ("G" oder Allgemeines) verwenden möchten formatieren oder eine andere Kultur angegeben, Verwendung der anderen Überladungen der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung des Werts der aktuellen Instanz entsprechend den Angaben von `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerische Standardformatbezeichner außer D und X sowie eine beliebige Kombination von benutzerdefinierten Zahlenformatbezeichner sein. Wenn das Format `null` oder eine leere Zeichenfolge, die den Rückgabewert mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Wenn der Wert dieser Instanz größer als 7 Dezimalstellen hat <xref:System.Single.ToString%28System.String%29> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` mit Format "G9" an, die immer 9 Ziffern Genauigkeit oder "R" zurückgibt, wobei 7 Ziffern zurückgegeben, wenn die Anzahl mit weiterhin Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur dargestellt werden kann mit einer maximalen Genauigkeit.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen numerischen Wert und formatiert diese als Währungswert mit der "C" standardmäßige Zahlenformatzeichenfolge und als numerischen Wert auf drei Dezimalstellen mithilfe der standardmäßigen numerischen Formatierungszeichenfolge von "N". Die Ergebniszeichenfolgen werden mit den Konventionen der Kultur En-US formatiert. Weitere Informationen auf numerische Formatzeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 Das folgende Beispiel zeigt mehrere <xref:System.Single> Werte mit den einzelnen unterstützten numerischen Standardformatbezeichnern zusammen mit zwei benutzerdefinierte numerische Formatzeichenfolgen. Eines dieser benutzerdefinierten Formatzeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit führenden Nullen. Konvertieren Sie die numerischen Werte in Zeichenfolgen, wird im Beispiel die Formatierungskonventionen der Kultur En-US verwendet.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie die Standardeinstellungen Format oder Kultur verwenden möchten, verwenden Sie die andere Überladungen des der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Single.ToString%28System.String%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung des Werts der aktuellen Instanz entsprechend den Angaben von `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerische Standardformatbezeichner außer D und X sowie eine beliebige Kombination von benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge ist, der Rückgabewert für diese Instanz mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert wird formatiert, mit der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Wenn der Wert dieser Instanz größer als 7 Dezimalstellen hat <xref:System.Single.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` mit Format "G9" an, die immer 9 Ziffern Genauigkeit oder "R" zurückgibt, wobei 7 Ziffern zurückgegeben, wenn die Anzahl mit weiterhin Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur dargestellt werden kann mit einer maximalen Genauigkeit.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Single> -Wert mit den einzelnen unterstützten numerischen Standardformatbezeichnern für verschiedene Kulturen.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="result">Enthält nach Rückkehr dieser Methode Gleitkommazahl mit einfacher Genauigkeit gleich dem numerischen Wert oder Symbol in enthaltenen <c>s</c>, wenn die Konvertierung erfolgreich abgeschlossen wurde, oder NULL, wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn die <c>s</c> Parameter ist <see langword="null" /> oder <see cref="F:System.String.Empty" />, ist keine Zahl in einem gültigen Format oder eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" />. Dieser Parameter wird nicht initialisiert übergeben; Jeder Wert, der ursprünglich im bereitgestellten <c>Ergebnis</c> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgenentsprechung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, mit der Behandlung von Ausnahmen für Testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (Zeichenfolgenvergleich wird die Groß-/Kleinschreibung beachtet) oder eine Zeichenfolge der Form:  
  
 [ws] [anmelden] [ganzzahligen Ziffern,] ganzzahligen Ziffern [. [ Bruchstellen]] [-e [Anmeldung] exponentiellen-Ziffern] [ws]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*Anmelden*|Ein negatives Vorzeichen oder Pluszeichen.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*Dezimalstellen sind*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die die Nachkommastellen der Zahl angeben.|  
|*E*|Ein klein-oder Großbuchstaben und Zeichen "e", der Exponentialschreibweise (wissenschaftlich) angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird der Einsatz einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausendertrennzeichen Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> methodenüberladung.  
  
 Die `s` Parameter analysiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analysieren eine Zeichenfolge unter Verwendung der Formatierungsinformationen einer anderen Kultur angegeben, verwenden Sie die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> -methodenüberladung.  
  
 Normalerweise, wenn Sie übergeben die <xref:System.Single.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Single> zurückgegebene Wert. Jedoch möglicherweise wegen einem Genauigkeitsverlust die Werte sein nicht gleich.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> Methode, um die zeichenfolgenentsprechungen von numerischen Werten zu konvertieren <xref:System.Single> Werte. Es wird davon ausgegangen, dass die aktuelle Kultur "En-US".  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zulässige Format von <c>s</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>s</c>.</param>
        <param name="result">Enthält nach Rückkehr dieser Methode entspricht dem numerischen Wert oder Symbol in enthaltenen mit einfacher Genauigkeit Gleitkommazahl <c>s</c>, wenn die Konvertierung erfolgreich abgeschlossen wurde, oder NULL, wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn die <c>s</c> Parameter ist <see langword="null" /> oder <see cref="F:System.String.Empty" />, befindet sich nicht in einem mit kompatiblen Format <c>Stil</c>, eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> größeroder<see cref="F:System.Single.MaxValue" />, oder wenn <c>Stil</c> ist keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" /> -Enumerationskonstanten. Dieser Parameter wird nicht initialisiert übergeben; Jeder Wert, der ursprünglich im bereitgestellten <c>Ergebnis</c> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, mit der Behandlung von Ausnahmen für Testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> für die Kultur erkennbar `provider`. Darüber hinaus, abhängig vom Wert der `style`die `s` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [ws] [$] [anmelden] [ganzzahligen Ziffern,] [.fractional-Ziffern] [-e [Anmeldung] exponentiellen-Ziffern] Ganzzahl-Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Es stehen am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, indem die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode der `provider` Parameter. Das Währungssymbol stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*ganzzahlige Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern nicht vorhanden sein können, wenn Sekundenbruchteile Ziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen. Tausendertrennzeichen der aktuellen Kultur Trennzeichen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Dezimalstellen sind*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Dezimalstellen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, der angibt, dass `s` kann eine Zahl, die mit der Exponentialschreibweise darstellen. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn Style enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*exponentielle Ziffern*|Eine Folge von Ziffern zwischen 0 bis 9, die einen Exponenten angeben.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die nicht unbedingt in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags Auswirkungen auf die Elemente, die möglicherweise in vorhandene `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können auch Exponentialschreibweise. Dieses Flag allein unterstützt Werte im Formular *ganzzahligen Ziffern*E*exponentiellen Ziffern*; zusätzliche Flags sind erforderlich, um erfolgreich analysieren von Zeichenfolgen in Exponentialschreibweise mit Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die * $ * Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` Parameter keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (*,),* und Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Formatvorlagen außer `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> Methode aufgerufen wird, ruft er die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Die <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen zum Format von bietet die `s` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter benutzerdefinierte Formatierungsinformationen für den Analysevorgang angeben:  
  
-   Sie können übergeben ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können den tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der `s` interpretiert basierend auf den <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> Methode, um die Darstellung von Zahlen zu analysieren, das einen bestimmten nachrichtenstil haben und mit den Konventionen einer bestimmten Kultur formatiert sind.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />ist die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> Wert.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
