<Type Name="Environment" FullName="System.Environment">
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Informationen und Veränderungsmöglichkeiten für die aktuelle Umgebung und Plattform zur Verfügung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Environment> Klasse zum Abrufen von Informationen wie z. B. Befehlszeilenargumente, Exitcode, umgebungsvariableneinstellungen, Inhalt der Aufrufliste, die Zeit seit dem letzten Systemstarts, und die Version der common Language Runtime.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Liste mit Informationen über die aktuelle Umgebung angezeigt.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Befehlszeile für diesen Prozess ab.</summary>
        <value>Eine Zeichenfolge mit den Befehlszeilenargumenten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf den Programmnamen und keine Argumente in der Befehlszeile angegeben werden, wenn der aktuelle Prozess gestartet wurde.  
  
 Der Name des Programms Pfadinformationen enthalten kann, aber ist nicht erforderlich. Verwenden der <xref:System.Environment.GetCommandLineArgs%2A> Methode zum Abrufen der Befehlszeile Informationen analysiert und in ein Array von Zeichenfolgen gespeichert.  
  
 Die maximale Größe des Puffers Befehlszeile wird nicht auf einer bestimmten Anzahl von Zeichen festgelegt. Es hängt von der Windows-Betriebssystems, die auf dem Computer ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine eigenen Befehlszeile an.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Pfad des aktuellen Arbeitsverzeichnisses ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per Definition dieser Prozessstart im Stammverzeichnis eines lokalen oder einem Netzlaufwerk, der Wert dieser Eigenschaft ist den Namen des Laufwerks gefolgt von einem nachgestellten Schrägstrich (z. B. "C:\\"). Wenn dieser Prozess in einem Unterverzeichnis gestartet wird, ist der Wert dieser Eigenschaft den Pfad Laufwerk und Unterverzeichnis, ohne einen nachstehenden Schrägstrich (z. B. "C:\mySubDirectory").  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Festlegen der <xref:System.Environment.CurrentDirectory%2A> Eigenschaft.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, auf eine leere Zeichenfolge ("") festzulegen.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, auf <see langword="null." /> fetszulegen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Es wurde versucht, auf einen lokalen Pfad festzulegen, der nicht gefunden werden kann.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die entsprechende Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Schreiben in Dateien oder Verzeichnisse in einem Set-Vorgang. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad in eine Get-Vorgang. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Der an das Betriebssystem zurückzugebende Exitcode. Verwenden Sie 0 (null), um anzugeben, dass der Prozess erfolgreich abgeschlossen wurde.</param>
        <summary>Beendet den Prozess und gibt einen Exitcode an das Betriebssystem zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die `exitCode` Parameter verwendet eine nicht-NULL-Anzahl einen Fehler an. In der Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den Rückgabecode entsprechende Fehler basierend auf dem Szenario. Beispielsweise den Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei in das falsche Format zurück. Eine Liste der Exitcodes von Windows-Betriebssystems verwendet werden, finden Sie unter [Systemfehlercodes](http://msdn.microsoft.com/library/ms681381.aspx) in der Windows-Dokumentation.  
  
 Aufrufen der <xref:System.Environment.Exit%2A> -Methode unterscheidet sich von der Programmiersprache Ihrer Wahl des `return` Anweisung auf folgende Weise:  
  
-   <xref:System.Environment.Exit%2A>eine Anwendung beendet immer. Mithilfe der `return` -Anweisung kann eine Anwendung beendet werden nur dann, wenn er in den Einstiegspunkt der Anwendung, z. B. in dient der `Main` Methode.  
  
-   <xref:System.Environment.Exit%2A>eine Anwendung beendet sofort, selbst wenn andere Threads ausgeführt werden. Wenn die `return` Anweisung in den Einstiegspunkt der Anwendung aufgerufen wird, durch die Anwendung beenden, nachdem alle Vordergrundthreads beendet haben.  
  
-   <xref:System.Environment.Exit%2A>erfordert, dass der Aufrufer über die Berechtigung zum Aufrufen von nicht verwalteten Codes. Die `return` Anweisung hingegen nicht.  
  
-   Wenn <xref:System.Environment.Exit%2A> aus aufgerufen wird eine `try` oder `catch` blockieren, den Code in einem `finally` Block wird nicht ausgeführt. Wenn die `return` Anweisung verwendet wird, den Code in der `finally` Block wird ausgeführt.  
  
-   Wenn <xref:System.Environment.Exit%2A> wird aufgerufen, wenn im code eine [eingeschränkten Ausführungsbereich](~/docs/framework/performance/constrained-execution-regions.md) (CER) ausgeführt wird, CER ist nicht vollständig ausgeführt werden. Wenn die `return` Anweisung verwendet wird, CER wird die Ausführung beendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über ausreichende Sicherheitsberechtigungen zum Ausführen dieser Funktion.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit, nicht verwalteten Code aufrufen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Exitcode des Prozesses ab oder legt diesen fest.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Exitcode enthält. Der Standardwert ist 0 (null), was angibt, dass der Prozess erfolgreich abgeschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `Main` -Methode zurückkehrt `void`, können Sie diese Eigenschaft den Exitcode festlegen, die an die aufrufende Umgebung zurückgegeben werden. Wenn `Main` keinen zurückgibt `void`, diese Eigenschaft wird ignoriert. Der Anfangswert für diese Eigenschaft ist 0 (null).  
  
> [!WARNING]
>  Die <xref:System.Environment.ExitCode%2A> Eigenschaft ist eine 32-Bit-Ganzzahl mit Vorzeichen. Um zu verhindern, dass die Eigenschaft einen negativen Exitcode zurückgeben, sollten Sie nicht die Werte größer als oder gleich 0 x 80000000 verwenden.  
  
 Verwenden Sie eine Zahl ungleich 0 (null), einen Fehler an. In der Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den Rückgabecode entsprechende Fehler basierend auf dem Szenario. Beispielsweise zurück, der Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei in das falsche Format. Eine Liste der Exitcodes von Windows-Betriebssystems verwendet werden, finden Sie unter [Systemfehlercodes](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) in der Windows-Dokumentation.  
  
   
  
## Examples  
 Im folgenden finden eine einfache app, die mit dem Namen Double.exe, die einen Ganzzahlwert, der als Befehlszeilenargument übergeben verdoppelt. Der Wert weist Fehlercodes der <xref:System.Environment.ExitCode%2A> Eigenschaft, um fehlerbedingungen anzuzeigen. Beachten Sie, dass Sie einen Verweis auf die Assembly System.Numerics.dll, um das Beispiel zu kompilieren hinzufügen müssen.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Im Beispiel kann dann aufgerufen werden, z. B. Folgendes ein, was die Fehlercodes zugegriffen werden kann mithilfe einer Batchdatei aus der `ERRORLEVEL` Befehl.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Das folgende Beispiel zeigt eine Beispielausgabe an, durch Aufrufen der Batchdatei, erstellt.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Beachten Sie diesen Code für Double.exe in der Funktion im folgenden Beispiel identisch ist, mit dem Unterschied, dass der erste Wert einen Einstiegspunkt mit dem Namen definiert `Main` hat, die keinen Wert zurückgibt, während dieses Beispiel einen Einstiegspunkt mit dem Namen definiert `Main` , eine ganze Zahl zurückgibt.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Eine Zeichenfolge, die die Namen von 0 (null) oder mehr Umgebungsvariablen enthält. Jede Umgebungsvariable wird mit dem Prozentzeichen (%) angegeben.</param>
        <summary>Ersetzt den Namen aller Umgebungsvariablen, die in die angegebene Zeichenfolge eingebettet sind, durch die Zeichenfolgenentsprechung für den Wert der Variablen und gibt anschließend das Ergebnis als Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge, bei der alle Umgebungsvariablen durch ihren Wert ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM-Interop wird verwendet, um die Umgebungsvariablen mithilfe des Betriebssystems abzurufen. Die Umgebungsvariablen aufgrund eines COM-Fehlers nicht abgerufen werden können, verwendet das HRESULT, das die Ursache des Fehlers erklärt wird von mehreren möglichen Ausnahmen generiert. Das HRESULT, also abhängig die Ausnahme. Weitere Informationen zur Verarbeitung von HRESULT finden Sie im Abschnitt "Hinweise" der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> Methode.  
  
 Ersetzung erfolgt nur für Umgebungsvariablen, die festgelegt werden. Nehmen wir beispielsweise an `name` ist "MyENV = % MyENV%". Wenn die Umgebungsvariable MyENV auf 42 festgelegt ist, gibt diese Methode "MyENV = 42". Wenn MyENV nicht festgelegt ist, tritt keine Änderung; Diese Methode gibt "MyENV = % MyENV%".  
  
 Die Größe des Rückgabewerts ist auf 32 KB beschränkt.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie das Systemlaufwerk und Stamm Systemvariablen abgerufen.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf die Umgebungsvariablen in <paramref name="name" />. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet einen Prozess ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> -Methode schreibt den `message` Zeichenfolge in der Windows-Anwendungsereignisprotokoll wird ein Speicherabbild der Anwendung erstellt und beendet dann den aktuellen Prozess. Die `message` Zeichenfolge ist auch in Fehlerberichte an Microsoft enthalten.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und der Anwendungsverzeichnis ausführen `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel schreibt einen Protokolleintrag in die Windows-Anwendungsereignisprotokoll und beendet den aktuellen Prozess.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <param name="exception">Eine Ausnahme, die den Fehler darstellt, der die Beendigung verursacht hat. Dies ist in der Regel die Ausnahme in einem <see langword="catch" />-Block.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung und Ausnahmeinformationen in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet den Prozess, ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> -Methode schreibt den `message` Zeichenfolge in der Windows-Anwendungsereignisprotokoll wird ein Speicherabbild der Anwendung erstellt und beendet dann den aktuellen Prozess.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Fehlerberichte an Microsoft enthält `message` und `exception` Informationen, die Details zum Klassifizieren des Fehlers bereitstellt. Obwohl `exception` wird nicht behandelt, da der Prozess beendet wird, die Kontextinformationen, die die Ausnahme ausgelöst hat weiterhin abgerufen wird.  
  
 Wenn `exception` ist `null`, oder wenn `exception` wird nicht ausgelöst, diese Methode funktioniert genauso wie die <xref:System.Environment.FailFast%28System.String%29> -methodenüberladung.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und der Anwendungsverzeichnis ausführen `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Befehlszeilenargumenten für den aktuellen Prozess zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element ein Befehlszeilenargument enthält. Das erste Element ist der Name der ausführbaren Datei. Falls nachfolgende Elemente vorhanden sind, enthalten sie die restlichen Befehlszeilenargumente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das erste Element im Array enthält den Dateinamen des ausgeführten Programms an. Wenn der Dateiname nicht verfügbar ist, ist das erste Element gleich <xref:System.String?displayProperty=nameWithType>. Die übrigen Elemente enthalten, zusätzlichen Token in der Befehlszeile eingegeben wird.  
  
 Den Namen der Programmdatei kann, aber es ist nicht erforderlich, Pfadinformationen enthalten.  
  
 Befehlszeilenargumente werden durch Leerzeichen getrennt. Doppelte Anführungszeichen (") können Sie die Leerzeichen in einem Argument enthalten. Das einfache Anführungszeichen ('), stellt diese Funktionalität jedoch nicht bereit.  
  
 Wenn ein doppeltes Anführungszeichen auf zwei oder eine gerade Anzahl umgekehrter Schrägstriche folgt, wird jedes vorhergehende Paar umgekehrter wird durch einen umgekehrten Schrägstrich ersetzt, und das doppelte Anführungszeichen wird entfernt. Wenn ein doppeltes Anführungszeichen auf eine ungerade Anzahl umgekehrter Schrägstriche, z. B. nur einen beachtet jedes vorangehende-Paar wird durch einen umgekehrten Schrägstrich ersetzt, und der verbleibenden umgekehrten Schrägstrich wird entfernt; in diesem Fall wird das Anführungszeichen jedoch nicht entfernt.  
  
 In der folgenden Tabelle wird gezeigt, wie Befehlszeilenargumente begrenzt werden können, und es wird davon ausgegangen `MyApp` wie die aktuelle ausgeführte Anwendung.  
  
|Geben Sie an der Befehlszeile|Resultierende Befehlszeilenargumente|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Verwenden Sie zum Abrufen der Befehlszeile als einzelne Zeichenfolge die <xref:System.Environment.CommandLine%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Anwendung Befehlszeilenargumente.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das System unterstützt keine Befehlszeilenargumente.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name der Umgebungsvariablen.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Der Wert der von <paramref name="variable" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Methode ruft eine Umgebungsvariable aus der Umgebungsblock, der nur den aktuellen Prozess ab. Dies entspricht dem Aufrufen der <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>. Der Umgebungsblock des aktuellen Prozesses umfasst die folgenden Umgebungsvariablen:  
  
-   Alle pro Computer Umgebungsvariablen, die zum Zeitpunkt der Prozess, die zusammen mit ihren Werten erstellt wurde definiert sind.  
  
-   Alle benutzerspezifische Umgebungsvariablen, die zum Zeitpunkt definiert sind wird der Prozess, mit den entsprechenden Werten erstellt.  
  
-   Alle Variablen, die an den prozessblock hinzugefügt werden, während der Prozess ausgeführt wird, durch den Aufruf eines der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einem `target` Wert <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>.  
  
 Wenn Umgebungsvariablen erstellt werden, nachdem der Prozess gestartet wurde, können Sie diese Methode verwenden, um nur diese Variablen abzurufen, die durch den Aufruf erstellt wurden die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einem `target` Wert.<xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>.  
  
 Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 Umgebungsvariablen wird die Groß-/Kleinschreibung nicht berücksichtigt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.GetEnvironmentVariable%2A> Methode zum Abrufen der `windir` Umgebungsvariable, die den Pfad des Windows-Verzeichnisses enthält.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` aus dem Prozess Umgebung-Block. Im Beispiel wird erstellt, wenn die Variable nicht vorhanden ist, dessen und seinen Wert abruft. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt wird, ruft er auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> Methode mit dem jedes Mitglied der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur von der aktuellen Umgebung prozessblock abgerufen werden kann. Abschließend, wenn im Beispiel wird die Variable erstellt, es wird gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf den Wert der Lesen <paramref name="variable" />. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Der Wert der von den Parametern <paramref name="variable" /> und <paramref name="target" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `target` Parameter gibt an, ob die Umgebungsvariable vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer abgerufen wird. Alle Umgebungsvariablen Erweiterungen pro Benutzer und pro Computer werden automatisch in den Umgebungsblock des aktuellen Prozesses kopiert. Beibehalten, jedoch nur hinzugefügt, um den Umgebungsblock des aktuellen Prozesses Umgebungsvariablen nur für die Dauer des Prozesses.  
  
 Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 Umgebungsvariablen wird die Groß-/Kleinschreibung nicht berücksichtigt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die Ziele Prozess, Benutzer und Computer, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für die Benutzer und Computer enthält, und die Umgebungsvariablen löscht.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> ist kein gültiger <see cref="T:System.EnvironmentVariableTarget" />-Wert.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf den Wert der Lesen <paramref name="variable" /> Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 oder  
  
 für Vollzugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Namen und Werte der Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Namen und Werte für die Umgebungsvariablen werden gespeichert als Schlüssel-Wert-Paare in der zurückgegebenen <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.OutOfMemoryException">Im Puffer ist nicht genügend Arbeitsspeicher.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für die Fähigkeit zum Lesen der Namen und Werte der Umgebungsvariablen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte.</param>
        <summary>Ruft die Namen und Werte aller Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen aus der durch den <paramref name="target" />-Parameter angegebenen Quelle enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `target` Parameter gibt an, ob die Quelle des aktuellen Prozesses, den Registrierungsschlüssel für den aktuellen Benutzer oder die Registrierungsschlüssel für den lokalen Computer ist.  
  
 Die Namen und Werte der Umgebungsvariablen werden als Schlüssel/Wert-Paare in der zurückgegebenen gespeichert <xref:System.Collections.IDictionary> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die Ziele Prozess, Benutzer und Computer, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für die Benutzer und Computer enthält, und die Umgebungsvariablen löscht.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs für den angegebenen Wert des <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" />enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf die Namen und Werte der Umgebungsvariablen Wenn lesen <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 oder  
  
 für Vollzugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">Eine Enumerationskonstante, die einen besonderen Systemordner bezeichnet.</param>
        <summary>Ruft den Pfad des durch die angegebene Enumeration bezeichneten besonderen Systemordners ab.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
 Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad auf einen besonderen Systemordner, z. B. Programme, Programme, System oder starten, die Zugriff auf gemeinsame Daten verwendet werden kann. Besondere Ordner werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows installieren.  
  
 Die `folder` -Parameter kennzeichnet den speziellen Ordner zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie unter der [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Environment.GetFolderPath%2A> Methode zum Zurückgeben und Anzeigen des zugeordnete Pfads der `folder` Parameter.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" />ist kein Mitglied der <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">Eine Enumerationskonstante, die einen besonderen Systemordner bezeichnet.</param>
        <param name="option">Gibt Optionen an, die zum Zugreifen auf einen besonderen Ordner verwendet werden sollen.</param>
        <summary>Ruft den Pfad zum besonderen Systemordner ab, der von der angegebenen Enumeration bezeichnet wird, und verwendet eine angegebene Option zum Zugreifen auf besondere Ordner.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
 Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad auf einen besonderen Systemordner, z. B. Programme, Programme, System oder starten, die Zugriff auf gemeinsame Daten verwendet werden kann. Besondere Ordner werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows installieren.  
  
 Die `folder` -Parameter kennzeichnet den speziellen Ordner zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie unter der [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" />ist kein Mitglied von<see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Namen der logischen Laufwerke des aktuellen Computers zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element den Namen eines logischen Laufwerks enthält. Beispielsweise, wenn die Festplatten eines Computers Laufwerk ist das erste logische Laufwerk, lautet das erste zurückgegebene Element "" c: "\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Vorgehensweise beim Anzeigen von logischen Laufwerke des aktuellen Computers mithilfe der <xref:System.Environment.GetLogicalDrives%2A> Methode.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die derzeitige Anwendungsdomäne entladen wird oder die Common Language Runtime (CLR) heruntergefahren wird.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle Anwendungsdomäne entladen oder die CLR heruntergefahren wird, andernfalls <see langword="false." />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die CLR eine Anwendungsdomäne entladen wurde, wird der Finalizer für alle Objekte, die über einen Finalizer-Methode in der Anwendungsdomäne ausgeführt. Wenn die CLR heruntergefahren wird, wird für alle Objekte, die über einen Finalizer-Methode im Finalizer-Thread gestartet. Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `true` nur, nachdem der Finalizer-Thread gestartet wurde. Wenn die Eigenschaft zurückgibt `true`, können Sie bestimmen, ob eine Anwendungsdomäne entladen wird oder die CLR selbst wird durch den Aufruf heruntergefahren die <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> Methode. Diese Methode gibt `true` wenn Finalizer aufgerufen werden, da die Anwendungsdomäne entladen wird oder `false` , wenn die CLR heruntergefahren wird.  
  
 Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `false` Wenn im Finalizer-Thread nicht gestartet wurde.  
  
 Mithilfe dieser Eigenschaft können Sie bestimmt, ob Sie den Zugriff auf statische Variablen in Ihrem Code zur Finalisierung verfolgt. Wenn eine Anwendungsdomäne oder die CLR heruntergefahren wird, können nicht zuverlässig greifen Sie jedes Objekt, das über eine Methode zur Finalisierung verfolgt verfügt und, auf das von einem statischen Feld verwiesen wird. Dies ist, wenn diese Objekte möglicherweise bereits freigegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist.</summary>
        <value>
          <see langword="true" />, wenn das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der aktuelle Prozess ein 64-Bit-Prozess ist.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Prozess ein 64-Bit-Prozess ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den NetBIOS-Namen dieses lokalen Computers ab.</summary>
        <value>Eine Zeichenfolge mit dem Namen dieses Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name dieses Computers wird beim Systemstart eingerichtet, wenn der Name aus der Registrierung gelesen werden. Wenn diese Computer ein Knoten in einem Cluster ist, wird der Name des Knotens zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen des Computers, der das Codebeispiel ausgeführt wird. (Der Name des Computers wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Name dieses Computers kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die COMPUTERNAME-Umgebungsvariable. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für diese Umgebung definierte Zeichenfolge für einen Zeilenumbruch ab.</summary>
        <value>Eine Zeichenfolge für Nicht-Unix-Plattformen, die "\r\n" enthält, oder eine Zeichenfolge für Unix-Plattformen, die "\n" enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Eigenschaftswert des <xref:System.Environment.NewLine%2A> ist eine Konstante, die speziell für die aktuelle Plattform und Implementierung von .NET Framework angepasst wird. Weitere Informationen über die Escapezeichen in den Wert der Eigenschaft finden Sie unter [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Die Funktionalität von bereitgestellten <xref:System.Environment.NewLine%2A> ist oft, was mit den Begriffen Zeilenumbruch, Zeilenvorschub, Zeilenumbruch, Carriage return, Wagenrücklauf, CRLF und Zeilenende gemeint ist.  
  
 <xref:System.Environment.NewLine%2A>in Verbindung mit sprachspezifischen neue-Zeile-Unterstützung, z. B. das Escapezeichen "\r" und "\n" in Microsoft C#- und C/C++ verwendet werden können oder `vbCrLf` in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A>wird automatisch angefügt Text verarbeitet, indem Sie die <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> und <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> Methoden.  
  
   
  
## Examples  
 Im folgende Beispiel werden drei durch Zeilenumbrüche getrennte Zeilen angezeigt.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.OperatingSystem" />-Objekt ab, das den Bezeichner und die Versionsnummer der aktuellen Plattform enthält.</summary>
        <value>Ein Objekt, das den Bezeichner und die Versionsnummer der Plattform enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Beginnend mit Windows 8 die <xref:System.Environment.OSVersion%2A> Eigenschaft gibt die gleiche Haupt-und Nebenversionsnummern Zahlen für alle Windows-Plattformen. Aus diesem Grund wird nicht empfohlen, dass Sie den Wert dieser Eigenschaft bestimmt die Version des Betriebssystems abzurufen.  
  
 In der Regel die <xref:System.Environment.OSVersion%2A> Eigenschaft wird verwendet, um sicherzustellen, dass eine app auf einigen Basisversion der ein älteres Betriebssystem ausgeführt wird, in denen eine bestimmte Funktion eingeführt wurde. Wenn dies der Fall ist, sollten Sie eine Überprüfung der Version ausführen, indem Sie testen, ob die aktuelle Betriebssystemversion zurückgegebene der <xref:System.Environment.OSVersion%2A> Eigenschaft ist gleich oder größer als die basisbetriebssystemversion. Weitere Informationen finden Sie unter der <xref:System.Version> klassenthema.  
  
 Über Windows 8 die <xref:System.Environment.OSVersion%2A> Eigenschaft gibt die Version von Windows gemeldeten [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) Funktion. Eine Liste der Versionen des Windows-desktop-Betriebssystem und ihre zugehörigen Versionsnummern, finden Sie unter [Betriebssystemversion](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) im Windows Developer Center.  
  
> [!NOTE]
>  Die <xref:System.Environment.OSVersion%2A> -Eigenschaft meldet die gleichen Versionsnummer (6.2.0.0) für beide [!INCLUDE[win8](~/includes/win8-md.md)] und [!INCLUDE[win81](~/includes/win81-md.md)] und die gleiche Haupt-und Nebenversionsnummern Anzahl für Windows 10.  
  
 In einigen Fällen die <xref:System.Environment.OSVersion%2A> Eigenschaft möglicherweise nicht die Version des Betriebssystems, die die für die Funktion "Windows-Anwendungskompatibilität Modus" angegebenen Version entspricht zurück.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Plattform-ID und die Versionsnummer des Computers, der das Codebeispiel ausgeführt wird.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft war nicht in der Lage, die Systemversion abzurufen.  
  
 - oder -   
  
 Der abgerufene Plattformbezeichner ist kein Mitglied von <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Prozessoren im aktuellen Computer ab.</summary>
        <value>Die 32-Bit-Ganzzahl mit Vorzeichen, die die Anzahl von Prozessoren im aktuellen Computer angibt. Es ist kein Standardwert vorhanden. Wenn der aktuelle Computer mehrere Prozessorgruppen enthält, gibt diese Eigenschaft die Anzahl logischer Prozessoren zurück, die für die Common Language Runtime (CLR) verfügbar sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Prozessorgruppen und logischen Prozessoren, finden Sie unter [Prozessorgruppen](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.ProcessorCount%2A> Eigenschaft.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert zugewiesen <c>Variable</c>.</param>
        <summary>Erstellt, ändert oder löscht eine im aktuellen Prozess gespeicherte Umgebungsvariable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Überladung mit dem Wert des <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType> für die `target` Argument.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung des Löschens einer Umgebungsvariablen weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable benannt, indem die `variable` Parameter nicht vorhanden ist, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`. Wenn sie vorhanden ist, wird ihr Wert geändert werden. Da die Umgebungsvariable in der Umgebungsblock, der nur den aktuellen Prozess definiert ist, bleibt er nicht bestehen, nachdem der Prozess beendet wurde.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 werden der Name der Umgebungsvariablen berücksichtigt und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 der Umgebungsvariablen zugewiesen sind, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. Wenn `variable` vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang kann nicht ausgeführt werden. `value`ist leer, wenn eine der folgenden Bedingungen berücksichtigt:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Er besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
   
  
## Examples  
 Das folgende Beispiel testet, ob eine Umgebungsvariable namens `APPDOMAIN` im aktuellen Prozess vorhanden ist. Wenn dies nicht der Fall ist, wird erstellt und legt seinen Wert auf "True" fest. Wenn der Wert des der `APPDOMAIN` Umgebungsvariable ist "True", ruft es die `Message.Display` Methode in eine neue Anwendungsdomäne. Andernfalls führt er die `Message.Display` Methode in der aktuellen Anwendungsdomäne.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Wenn Sie das Beispiel zum ersten Mal ausführen, zeigt die Meldung "In der Domäne Domäne2 wird ausgeführt" in der Konsole. Wenn Sie die Umgebungsvariable mit dem Befehl über die Befehlszeile festlegen:  
  
 `Set AppDomain=False`  
  
 Das Beispiel zeigt die Meldung "in der Domäne ausführen *Programmname*.exe", wobei *Programmname* ist der Name der ausführbaren Datei.  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` aus dem Prozess Umgebung-Block. Wenn die Variable nicht vorhanden ist, wird im Beispiel erstellt die Variable und ihren Wert abruft. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt wird, ruft er auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> Methode mit dem jedes Mitglied der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur von der aktuellen Umgebung prozessblock abgerufen werden kann. Abschließend, wenn im Beispiel wird die Variable erstellt, es wird gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" />enthält einer Zeichenfolge der Länge 0 (null), ein anfängliches Hexadezimalzeichen 0 (null) Zeichen (0 x 00) oder ein Gleichheitszeichen ("=").  
  
 - oder -   
  
 Die Länge des <paramref name="variable" /> oder <paramref name="value" /> ist größer als oder gleich 32.767 Zeichen.  
  
 - oder -   
  
 Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf Umgebungsvariablen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert zugewiesen <c>Variable</c>.</param>
        <param name="target">Einer der Enumerationswerte, der den Standort der Umgebungsvariablen angibt.</param>
        <summary>Erstellt, ändert oder löscht eine Umgebungsvariable, die im aktuellen Prozess oder im Registrierungsschlüssel des für den aktuellen Benutzer oder den lokalen Computer reservierten Windows-Betriebssystems gespeichert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode können Sie eine Umgebungsvariable zu definieren, die für alle Prozesse verfügbar ist, die auf einem Computer ausgeführt (die <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType> Wert), an alle Prozesse, die von einem Benutzer ausgeführt (die <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType> Wert), oder für den aktuellen Prozess (der <xref:System.EnvironmentVariableTarget.Process> Wert). Umgebungsvariablen pro Computer und pro Benutzer werden in der Umgebungsblock, der den aktuellen Prozess kopiert. Umgebungsvariablen, die für den aktuellen Prozess Umgebungsblock eindeutig sind jedoch beibehalten, nur verwendet werden, bis der Prozess beendet wird.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung des Löschens einer Umgebungsvariablen weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable benannt, indem die `variable` Parameter nicht vorhanden ist, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`.  Wenn sie vorhanden ist, wird ihr Wert geändert werden.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 werden der Name der Umgebungsvariablen berücksichtigt und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 der Umgebungsvariablen zugewiesen sind, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. `value`ist leer, wenn eine der folgenden Bedingungen berücksichtigt:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Er besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
 Wenn `variable` vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang kann nicht ausgeführt werden. Seien Sie vorsichtig, wenn `target` ist <xref:System.EnvironmentVariableTarget.Machine>, weil Sie versehentlich eine Umgebungsvariable löschen können, die den gesamten lokalen Computer, nicht nur den aktuellen Prozess oder Benutzer betreffen.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User>, wird die Umgebungsvariable im Schlüssel HKEY_CURRENT_USER\Environment der Registrierung des lokalen Computers gespeichert. Es wird auch in Instanzen von Datei-Explorer kopiert, die als aktueller Benutzer ausgeführt werden. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die der Benutzer vom Datei-Explorer startet.  
  
 Auf ähnliche Weise, wenn `target` ist <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>, wird die Umgebungsvariable im HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment Schlüssel der Registrierung des lokalen Computers gespeichert. Es wird auch für alle Instanzen von Datei-Explorer kopiert. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die vom Datei-Explorer gestartet werden.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User> oder <xref:System.EnvironmentVariableTarget.Machine>, andere Anwendungen werden benachrichtigt, von der Set-Vorgang durch einen Windows- `WM_SETTINGCHANGE` Nachricht.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType> oder <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>, es wird empfohlen, die die Länge der `value` weniger als 2048 Zeichen lang sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, es wird überprüft, ob die Registrierung des Betriebssystems der Benutzer und Computer-Umgebungsvariablen enthält, und die Umgebung löscht Variablen.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" />enthält einer Zeichenfolge der Länge 0 (null), ein anfängliches Hexadezimalzeichen 0 (null) Zeichen (0 x 00) oder ein Gleichheitszeichen ("=").  
  
 - oder -   
  
 Die Länge des <paramref name="variable" /> ist größer als oder gleich 32.767 Zeichen.  
  
 - oder -   
  
 <paramref name="target" />ist nicht Mitglied der <see cref="T:System.EnvironmentVariableTarget" /> Enumeration.  
  
 - oder -   
  
 <paramref name="target" />ist <see cref="F:System.EnvironmentVariableTarget.Machine" /> oder <see cref="F:System.EnvironmentVariableTarget.User" />, und die Länge des <paramref name="variable" /> ist größer als oder gleich 255.  
  
 - oder -   
  
 <paramref name="target" />ist <see cref="F:System.EnvironmentVariableTarget.Process" /> und die Länge des <paramref name="value" /> ist größer als oder gleich 32.767 Zeichen.  
  
 - oder -   
  
 Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf Umgebungsvariablen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuellen Stapelüberwachungsinformationen ab.</summary>
        <value>Eine Zeichenfolge, die Stapelüberwachungsinformationen enthält. Dieser Wert kann <see cref="F:System.String.Empty" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.StackTrace%2A> Eigenschaft Listen Methodenaufrufe in umgekehrter chronologischer Reihenfolge, d. h. den letzte Aufruf der Methode wird zunächst beschrieben und Stapelüberwachungsinformationen eine Zeile für jeden Methodenaufruf auf dem Stapel aufgeführt ist. Allerdings die <xref:System.Environment.StackTrace%2A> Eigenschaft möglicherweise nicht so viele Methodenaufrufe erwartungsgemäß da der Code, die auftreten, während der Optimierung gemeldet.  
  
> [!NOTE]
>  Verwenden Sie für eine hierarchische Ansicht der Stapelüberwachungsinformationen von-Klasse, die <xref:System.Diagnostics.StackTrace> Klasse.  
  
 Die <xref:System.Environment.StackTrace%2A> Eigenschaft formatiert die Stapelüberwachungsinformationen für jeden Methodenaufruf wie folgt:  
  
 "am `FullClassName`.`MethodName` (`MethodParams`) in `FileName` : Linie `LineNumber` "  
  
 Das Literal "at" drei Leerzeichen vorangestellt ist, und die gesamte Teilzeichenfolge, beginnend mit "in" wird ausgelassen, wenn keine Debugsymbole verfügbar sind. Die Platzhalter `FullClassName`, `MethodName`, `MethodParams`, `FileName`, und `LineNumber`, durch tatsächliche Werte ersetzt werden und wie folgt definiert:  
  
 FullClassName  
 Der vollständige Name der Klasse, einschließlich des Namespaces.  
  
 `MethodName`  
 Der Name der Methode.  
  
 `MethodParams`  
 Die Liste der Typnamen/Parameterpaaren. Jedes Paar wird getrennt durch ein Komma (","). Diese Informationen werden ausgelassen, wenn `MethodName` nimmt keine Parameter.  
  
 `FileName`  
 Der Name der Quelle-Datei, in der `MethodName` -Methode deklariert ist. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 `LineNumber`  
 Die Nummer der Zeile im `FileName` , enthält den Quellcode aus `MethodName` für die Anweisung, die in der Aufrufliste ist. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 Die <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Zeichenfolge beendet, wird jede Zeile der stapelüberwachung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.StackTrace%2A> Eigenschaft.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch die Berechtigung geschützten Ressource. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll qualifizierten Pfad des Systemverzeichnisses ab.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel des zurückgegebenen Werts ist die Zeichenfolge "C:\WinNT\System32".  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Systemverzeichnis des Computers, der das Codebeispiel ausgeführt wird. (Das Verzeichnis "System" wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Bytes in der Speicherseite des Betriebssystems ab.</summary>
        <value>Die Anzahl der Bytes in einer Arbeitsspeicherauslagerung des Betriebssystems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Informationen kann nützlich sein, wenn bestimmt wird, ob verwendet die <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions?displayProperty=nameWithType> option bei der Arbeit mit Speicherabbilddateien.  
  
 In Windows, dieser Wert ist die `dwPageSize` Element in der `SYSTEM_INFO` Struktur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf System- und Umgebungsvariablen. Zugeordnete Ausnahme:  
  
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, die seit dem Systemstart verstrichen sind.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die seit dem letzten Start des Computers vergangene Zeit in Millisekunden enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft wird von der systemtimer abgeleitet und wird als eine 32-Bit-Ganzzahl mit Vorzeichen gespeichert. Beachten Sie Folgendes: Da Systemzeitgeber, der Auflösung des abgeleitet ist die <xref:System.Environment.TickCount%2A> Eigenschaft ist auf die Auflösung des Systemzeitgebers, in der Regel im Bereich von 10 bis 16 Millisekunden beschränkt.  
  
> [!IMPORTANT]
>  Da der Wert des der <xref:System.Environment.TickCount%2A> Eigenschaftswert ist eine 32-Bit-Ganzzahl mit Vorzeichen, wenn das System ständig ausgeführt wird <xref:System.Environment.TickCount%2A> erhöht, von 0 bis <xref:System.Int32?displayProperty=nameWithType> ca. 24,9 Tage, gehen Sie dann zu <xref:System.Int32?displayProperty=nameWithType>, ist eine negative Zahl Erhöhen Sie dann wieder auf 0 (null), während der nächsten 24,9 Tage. Sie können dieses Problem umgehen, indem die Windows [z. B.](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) -Funktion, die setzt auf 0 (null), nach ungefähr 49,7 Tage oder durch Aufrufen der [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) Funktion.  
  
 <xref:System.Environment.TickCount%2A>unterscheidet sich von der <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Eigenschaft, die die Anzahl der 100-Nanosekunden-Intervalle darstellt, die seit 1/1/0001, 00:00 Uhr vergangen sind.  
  
 Verwenden der <xref:System.DateTime.Now%2A?displayProperty=nameWithType> Eigenschaft, die das aktuelle Datum und die Uhrzeit auf diesem Computer abgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die positiven zurückgegebene Wertebereich Abrufen der <xref:System.Environment.TickCount%2A> Eigenschaft. Die <xref:System.Environment.TickCount%2A> Eigenschaft Zyklen zwischen <xref:System.Int32.MinValue?displayProperty=nameWithType>, dies ist eine negative Zahl ist, und <xref:System.Int32.MaxValue?displayProperty=nameWithType> alle 49,8 Tage. In diesem Codebeispiel wird das Vorzeichenbit, um eine nicht negative Zahl, die zwischen 0 (null) navigieren entfernt und <xref:System.Int32.MaxValue> einmal 24,9 Tagen.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Netzwerkdomänennamen ab, der dem aktuellen Benutzer zugeordnet ist.</summary>
        <value>Der Netzwerkdomänenname, der dem aktuellen Benutzer zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert die "\\" Zeichen und seinen Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> -Eigenschaft zum Abrufen der Domänenname des Benutzers, ohne den Benutzernamen und das <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen ohne den Domänennamen zu erhalten.  Wenn der Domänenname und Benutzername eines Benutzers CORPORATENETWORK\john, sind beispielsweise die <xref:System.Environment.UserDomainName%2A> Eigenschaft gibt "CORPORATENETWORK" zurück.  
  
 Die <xref:System.Environment.UserDomainName%2A> -Eigenschaft versucht zunächst, die Domäne-Komponente des Windows-Kontoname für den aktuellen Benutzer abrufen. Wenn dieser Versuch fehlschlägt, wird diese Eigenschaft zum Abrufen der Domänenname, der vom angegebenen Benutzernamen zugeordnet versucht die <xref:System.Environment.UserName%2A> Eigenschaft. Wenn dieser Versuch schlägt fehl, da der Host-Computer nicht zu einer Domäne angehört, wird der Name des Hostcomputers zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Das Betriebssystem unterstützt nicht das Abrufen des Netzwerkdomänennamens.</exception>
        <exception cref="T:System.InvalidOperationException">Der Netzwerkdomänenname kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die USERDOMAIN-Umgebungsvariable. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Prozess im interaktiven Modus ausgeführt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.UserInteractive%2A> Eigenschaftsberichte `false` für einen Windows-Prozess oder einen Dienst wie IIS, der ohne Benutzeroberfläche ausgeführt wird. Wenn diese Eigenschaft ist `false`, modale Dialogfelder nicht anzeigen oder Meldungsfelder, da keine grafische Benutzeroberfläche für den Benutzer für die Interaktion mit vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Benutzernamen der Person ab, die derzeit beim Windows-Betriebssystem angemeldet ist.</summary>
        <value>Der Benutzername der Person, die bei Windows angemeldet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Environment.UserName%2A> Eigenschaft zur Identifizierung des Benutzers für den aktuellen Thread, für das System und Anwendung für die Sicherheit oder Access. Sie können auch verwendet werden, um eine bestimmte Anwendung für jeden Benutzer anzupassen.  
  
 Die <xref:System.Environment.UserName%2A> Eigenschaft dient als Wrapper für einen Aufruf an eine Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) Funktion. Die Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert die "\\" Zeichen und seinen Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> -Eigenschaft zum Abrufen der Domäne des Benutzernamens und der <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen zu erhalten.  
  
 Wenn eine ASP.NET-Anwendung in einer Entwicklungsumgebung ausgeführt wird. die <xref:System.Environment.UserName%2A> Eigenschaft gibt den Namen des aktuellen Benutzers zurück. In einer veröffentlichten ASP.NET-Anwendung gibt diese Eigenschaft den Namen der das Konto des Anwendungspools (z. B. Default AppPool).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Benutzernamen der Person, die den aktuellen Thread gestartet.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die USERNAME-Umgebungsvariable. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Version" />-Objekt ab, das die Nummern für Haupt- und Nebenversion, Build und Revision der Common Language Runtime beschreibt.</summary>
        <value>Ein Objekt, das die Version der Common Language Runtime anzeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den .NET Framework-Versionen 4, 4.5, 4.5.1 und 4.5.2 gibt die <xref:System.Environment.Version%2A?displayProperty=nameWithType>Eigenschaft ein <xref:System.Version>-Objekt zurück, dessen Zeichenfolgedarstellung die Form `4.0.30319.xxxxx`besitzt. Für die [!INCLUDE[net_v46](~/includes/net-v46-md.md)], dessen Punktversionen sowie der .NET Framework-4.7, er hat das Format `4.0.30319.42000`.  
  
> [!WARNING]
>  Für die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höher, wir empfehlen nicht mit der <xref:System.Environment.Version%2A> Eigenschaft zum Erkennen von der Version der Laufzeit; stattdessen können Sie die Version der common Language Runtime zu bestimmen, durch Abfragen der Registrierungs. Weitere Informationen finden Sie unter [wie: Bestimmen der installierten .NET Framework-Versionen sind](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Weitere Informationen über die Version der common Language Runtime, die mit jeder Version von .NET Framework installiert ist, finden Sie unter [-Versionen und-Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Version der common Language Runtime. (Die Version wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers ab, der dem Prozesskontext zugeordnet ist.</summary>
        <value>Eine 64-Bit-Ganzzahl mit Vorzeichen, die die Größe des dem Prozesskontext zugeordneten physischen Speichers in Bytes angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Größe des Workingsets des Computers, der das Codebeispiel ausgeführt wird.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
