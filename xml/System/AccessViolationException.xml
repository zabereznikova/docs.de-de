<Type Name="AccessViolationException" FullName="System.AccessViolationException">
  <TypeSignature Language="C#" Value="public class AccessViolationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit AccessViolationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.AccessViolationException" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Die Ausnahme, die bei dem Versuch ausgelöst wird, im geschützten Speicher zu lesen oder zu schreiben.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwalteter bzw. unsicherer Code tritt eine zugriffsverletzung auf, wenn der Code versucht, das Lesen und Schreiben in den Arbeitsspeicher, die nicht zugewiesen wurde, oder auf die er keinen Zugriff. Dieser Fehler tritt gewöhnlich auf, wenn ein Zeiger auf einen ungültigen Wert aufweist. Nicht alle Lese- und Schreibvorgänge, die aufgrund ungültiger Zeiger aufgetreten sind, führen zu Zugriffsverletzungen. Eine Zugriffsverletzung gibt somit an, dass mehrere Lese- und Schreibvorgänge aufgrund ungültiger Zeiger aufgetreten sind und dass der Arbeitsspeicher u. U. beschädigt sein kann. Zugriffsverletzungen geben daher fast immer schwerwiegenden Programmierfehler. Ein <xref:System.AccessViolationException> durch diese schwerwiegende Fehler eindeutig identifiziert wird.  
  
 Im Programme aus Leerzeichen bestehen überprüfbaren verwalteten Code alle Verweise entweder gültig oder null und zugriffsverletzungen sind nicht möglich. Jeder Vorgang, der versucht, einen null-Verweis in überprüfbarem Code löst eine <xref:System.NullReferenceException> Ausnahme. Ein <xref:System.AccessViolationException> tritt nur bei überprüfbarer verwalteter Code mit nicht verwaltetem Code oder mit unsicherem verwalteten Code interagiert.  
  
## <a name="troubleshooting-accessviolationexception-exceptions"></a>Problembehandlung bei Ausnahmen AccessViolationException  
 Ein <xref:System.AccessViolationException> Ausnahme kann auftreten, nur in unsicherem verwalteten Code oder bei überprüfbar verwalteten Code interagiert mit nicht verwaltetem Code:  
  
-   Eine zugriffsverletzung, die in unsicherem verwalteten Code auftritt, ausgedrückt werden kann, entweder als eine <xref:System.NullReferenceException> Ausnahme oder ein <xref:System.AccessViolationException> Ausnahme, je nach Plattform.  
  
-   Eine zugriffsverletzung in nicht verwaltetem Code, der bis zu verwaltetem Code ausgelöst wird immer in umschlossen ein <xref:System.AccessViolationException> Ausnahme.  
  
 In beiden Fällen können Sie identifizieren und beheben Sie die Ursache für die <xref:System.AccessViolationException> Ausnahme wie folgt:  
  
 Stellen Sie sicher, dass der Arbeitsspeicher, auf den Sie zugreifen möchten, belegt wurde.  
 Ein <xref:System.AccessViolationException> immer von geschütztem Arbeitsspeicher – d. h. Zugriff auf, um Zugriff auf Speicher, die nicht zugeordnet ist, oder, ist nicht im Besitz von einem Prozess, Versuch ausgelöst wird.  
  
 Bei der automatischen Speicherverwaltung handelt es sich um einen Dienst, der von der Common Language Runtime zur Verfügung gestellt wird. Wenn verwalteter Code auf die gleiche Funktionalität wie Unmanagede Code bereitstellt, möchten Sie möglicherweise zu verwaltetem Code wechseln, um diese Funktionalität zu nutzen. Weitere Informationen finden Sie unter [automatische Speicherverwaltung](~/docs/standard/automatic-memory-management.md).  
  
 Stellen Sie sicher, dass der Arbeitsspeicher, auf den Sie zugreifen möchten, nicht beschädigt worden ist.  
 Wenn aufgrund ungültiger Zeiger mehrere Lese- und Schreibvorgänge erfolgt sind, kann das möglicherweise zu einer Beschädigung des Arbeitsspeichers führen. Dies tritt normalerweise beim Lesen oder Schreiben in Adressen außerhalb einer vordefinierten Puffer.  
  
## <a name="accessviolationexception-and-trycatch-blocks"></a>AccessViolationException und Try/Catch-Blöcke  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.AccessViolationException> von der common Language Runtime ausgelöste Ausnahmen werden nicht behandelt, durch die `catch` -Anweisung in einem strukturierten Ausnahmehandler bei der Ausnahme außerhalb von der common Language reservierten Speichers auftreten Common Language Runtime. So behandeln ein <xref:System.AccessViolationException> Ausnahme, wenden Sie die <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> -Attribut auf die Methode, die in der die Ausnahme ausgelöst wird. Diese Änderung wirkt sich nicht <xref:System.AccessViolationException> Ausnahmen vom Benutzercode, den abgefangen werden weiterhin können ein `catch` Anweisung. Für Code geschrieben, die für frühere Versionen von .NET Framework, die Sie verwenden möchten, neu kompilieren und ohne Änderung ausgeführt wird, auf die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], können Sie hinzufügen, die [ \<LegacyCorruptedStateExceptionsPolicy >](~/docs/framework/configure-apps/file-schema/runtime/legacycorruptedstateexceptionspolicy-element.md) Element Ihre App-Konfigurationsdatei. Beachten Sie, dass Sie auch die Benachrichtigung der Ausnahmen empfangen können, wenn Sie einen Handler für definiert haben die <xref:System.AppDomain.FirstChanceException?displayProperty=nameWithType> oder <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> Ereignis.  
  
## <a name="version-information"></a>Versionsinformationen  
 In der .NET Framework 2.0 und höheren Versionen wird diese Ausnahme ausgelöst. In früheren Versionen von .NET Framework wird durch eine zugriffsverletzungen in nicht verwaltetem Code oder unsicherem verwalteten Code dargestellt eine <xref:System.NullReferenceException> in verwaltetem Code. Ein <xref:System.NullReferenceException> wird auch ausgelöst, wenn ein null-Verweis in verwaltetem Code überprüft, ein Vorfall, der keine: beschädigte Daten, beinhaltet dereferenziert ist und es keine Möglichkeit zur Unterscheidung zwischen den zwei Situationen, in den Versionen 1.0 oder 1.1 gibt.  
  
 Administratoren können die ausgewählte Anwendungen, um das Verhalten der .NET Framework, Version 1.1 wiederherzustellen. Platzieren Sie die folgende Zeile in der [ &lt;Runtime&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) Abschnitt der Konfigurationsdatei für die Anwendung:  
  
```  
<legacyNullReferenceExceptionPolicy enabled = "1"/>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AccessViolationException" />-Klasse mit einer vom System generierten Meldung, die den Fehler beschreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A> -Eigenschaft der neuen Instanz mit einer vom System gelieferten Meldung, die den Fehler beschreibt, wie z. B. "hat versucht, lesen und Schreiben von geschütztem Arbeitsspeicher. Dies ist häufig ein Hinweis, dass andere Arbeitsspeicher beschädigt worden ist." Diese Meldung berücksichtigt die aktuelle Systemkultur.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.AccessViolationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Die lokalisierte Zeichenfolge mit der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AccessViolationException" />-Klasse mit einer angegebenen Meldung, die den Fehler beschreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.AccessViolationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Die in `message` angegebene Fehlermeldungszeichenfolge.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AccessViolationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt, das die Daten des serialisierten Objekts enthält.</param>
        <param name="context">Der <see cref="T:System.Runtime.Serialization.StreamingContext" />, der die Kontextinformationen über die Quelle oder das Ziel enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AccessViolationException" />-Klasse mit serialisierten Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird während der Deserialisierung aufgerufen, um das über einen Stream übertragene Ausnahmeobjekt wiederherzustellen. Weitere Informationen finden Sie unter [XML- und SOAP-Serialisierung](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
        <param name="innerException">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn die <c>"InnerException"</c> -Parameter ist kein <see langword="null" />, die aktuelle Ausnahme wird ausgelöst, eine <see langword="catch" /> Block, der die innere Ausnahme behandelt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AccessViolationException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme, die als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst wird, muss in der <xref:System.Exception.InnerException%2A>-Eigenschaft über einen Verweis auf die vorhergehende Ausnahme verfügen. Die <xref:System.Exception.InnerException%2A>-Eigenschaft gibt den gleichen Wert zurück, der an den Konstruktor übergeben wird, oder `null`, wenn die <xref:System.Exception.InnerException%2A>-Eigenschaft den Wert der inneren Ausnahme nicht an den Konstruktor übergibt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.AccessViolationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Die in `message` angegebene Fehlermeldungszeichenfolge.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
