<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Text als Sequenz von UTF-16-Codeeinheiten dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Eine Zeichenfolge ist eine sequenzielle Auflistung von Zeichen, die zum Darstellen von Text verwendet wird. Ein <xref:System.String> Objekt ist eine sequenzielle Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekte, die darstellen, eine Zeichenfolge; ein <xref:System.Char?displayProperty=nameWithType> -Objekt entspricht einer Codeeinheit UTF-16. Der Wert, der die <xref:System.String> Objekt befindet sich der Inhalt der sequenziellen Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekte und Wert unveränderlich ist (d. h., sie ist schreibgeschützt). Weitere Informationen über die Unveränderlichkeit von Zeichenfolgen, finden Sie unter der [Unveränderlichkeit und der StringBuilder-Klasse](#Immutability) weiter unten in diesem Thema. Die maximale Größe einer <xref:System.String> Objekt im Arbeitsspeicher ist 2 GB oder ungefähr 1 Milliarde Zeichen.  
  
 In diesem Abschnitt  
  
 [Instanziieren ein String-Objekt](#Instantiation)   
 [Char-Objekte und Unicode-Zeichen](#Characters)   
 [Zeichenfolgen und Unicode-Standard](#Unicode)   
 [Zeichenfolgen und eingebettete Null-Zeichen](#EmbeddedNulls)   
 [Zeichenfolgen und Indizes](#Indexes)   
 [NULL-Zeichenfolgen und leere Zeichenfolgen](#Nulls)   
 [Unveränderlichkeit und der StringBuilder-Klasse](#Immutability)   
 [Ordnungszahl im Vergleich zu kulturabhängige Operationen](#CultureSensitive)   
 [Normalisierung](#Normalization)   
 [Zeichenfolgenoperationen nach Kategorie](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instanziieren ein String-Objekt  
 Instanziieren Sie ein <xref:System.String> Objekt auf folgende Weise:  
  
-   Durch Zuweisen eines Zeichenfolgenliterals zu einer <xref:System.String> Variable. Dies ist die am häufigsten verwendete Methode zum Erstellen einer Zeichenfolge. Im folgenden Beispiel wird die Zuordnung zum Erstellen von mehreren Zeichenfolgen. Beachten Sie, dass in C# geschrieben, da der umgekehrte Schrägstrich (\\) ist ein Escapezeichen, literal umgekehrte Schrägstriche in einer Zeichenfolge müssen mit Escapezeichen versehen werden, oder die gesamte Zeichenfolge muss @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Durch Aufrufen einer <xref:System.String> Klassenkonstruktor. Im folgende Beispiel werden Zeichenfolgen durch Aufrufen von mehreren Klassenkonstruktoren instanziiert. Beachten Sie, dass einige der Konstruktoren Zeiger auf Zeichen oder mit Vorzeichen Bytearrays als Parameter enthalten. Visual Basic unterstützt keine Aufrufe dieser Konstruktoren. Ausführliche Informationen zu <xref:System.String> Konstruktoren finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Mithilfe des Operators für zeichenfolgenverkettung (+ in C# geschrieben und & oder + in Visual Basic) So erstellen Sie eine einzelne Zeichenfolge aus einer beliebigen Kombination <xref:System.String> Instanzen und Zeichenfolgenliterale. Das folgende Beispiel veranschaulicht die Verwendung der der Operator für zeichenfolgenverkettung.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Abrufen einer Eigenschaft oder eine Methode aufrufen, die eine Zeichenfolge zurückgibt. Das folgende Beispiel verwendet die Methoden der <xref:System.String> Klasse, um eine Unterzeichenfolge aus einer größeren Zeichenfolge zu extrahieren.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Durch Aufrufen einer Formatierungsmethode um einen Wert oder ein Objekt in seine Zeichenfolgendarstellung zu konvertieren. Im folgenden Beispiel wird die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Funktion, um die Zeichenfolgendarstellung von zwei Objekten in eine Zeichenfolge einzubetten.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char-Objekte und Unicode-Zeichen  
 Jedes Zeichen in einer Zeichenfolge wird durch einen skalaren Unicodewert, auch als einen Unicode-Codepunkt oder den Ordinalwert des Unicode-Zeichens (numerisch) definiert. Jeden Codepunkt mithilfe von UTF-16-Codierung codiert ist, und der numerische Wert der einzelnen Elemente der Codierung wird dargestellt, indem ein <xref:System.Char> Objekt.  
  
> [!NOTE]
>  Beachten Sie Folgendes: Da ein <xref:System.String> -Instanz besteht aus einer sequenziellen Auflistung von UTF-16-Codeeinheiten, es ist möglich, erstellen Sie eine <xref:System.String> -Objekt, das keine Unicode-Zeichenfolge wohlgeformt ist. Beispielsweise ist es möglich, eine Zeichenfolge zu erstellen, die ein niedriges Ersatzzeichen ohne entsprechenden hohes Ersatzzeichen ist. Obwohl einige Methoden, z. B. die Methoden der Codierung und Decodierung von Objekten in der <xref:System.Text> Namespace, möglicherweise führt Überprüfungen, um sicherzustellen, dass Zeichenfolgen wohlgeformt sind <xref:System.String> Klassenmember gewährleisten nicht, dass eine Zeichenfolge wohlgeformt ist.  
  
 Ein einzelnes <xref:System.Char> Objekt stellt normalerweise eine einzelne Codepunkt, d. h. den numerischen Wert der <xref:System.Char> Codepunkt entspricht. Z. B. den Codepunkt für das Zeichen "a" ist U + 0061 ist. Allerdings erfordert ein Codepunkt möglicherweise mehr als eine codiertes Element (mehr als ein <xref:System.Char> Objekt). Die Unicode-Standard definiert zwei Typen von Zeichen, die entsprechen mit mehreren <xref:System.Char> Objekte: Graphemes und ergänzende Unicode-Codepunkten, die die zusätzlichen Ebenen von Unicode-Zeichen entsprechen.  
  
-   Eine zwischen graphemgruppen wird durch ein Basiszeichen gefolgt von mindestens Kombinationszeichen dargestellt. Das Zeichen "ä" wird beispielsweise dargestellt, durch ein <xref:System.Char> Objekt, dessen Codepunkt U + 0061 ist, gefolgt von einem <xref:System.Char> Objekt, dessen Codepunkt U + 0308. Diese Zeichen kann auch über einen einzelnen definiert <xref:System.Char> Objekt, das einen Codepunkt U + 00E4 verfügt. Wie im folgenden Beispiel wird gezeigt, gibt ein kulturabhängiger Vergleich, Gleichheit, dass diese zwei Darstellungen gleich sind, obwohl Sie ein Ordinalvergleich durch normaler nicht der Fall ist. Wenn die beiden Zeichenfolgen normalisiert werden, gibt hingegen ein ordinalen Vergleich auch, dass sie gleich sind. (Weitere Informationen zum Normalisieren von Zeichenfolgen finden Sie unter der [Normalisierung](#Normalization) Abschnitt.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Eine Unicode ergänzende Codepunkt (ein Ersatzzeichenpaar) wird durch eine <xref:System.Char> -Objekt, dessen Codepunkt ein hohes Ersatzzeichen ist, gefolgt von einer <xref:System.Char> -Objekt, dessen Codepunkt ein niedriges Ersatzzeichen ist. Die Codeeinheiten der hohe Ersatzzeichen zwischen U + D800 und U + DBFF liegt. Die Codeeinheiten der niedrige Ersatzzeichen liegen zwischen U + DC00 und U + DFFF. Ersatzzeichenpaare werden verwendet, um Zeichen in die 16 ergänzenden Unicode-Ebenen darstellen. Das folgende Beispiel erstellt ein Ersatzzeichen und übergibt es an die <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> Methode, um zu bestimmen, ob es sich um ein Ersatzzeichenpaar ist.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Zeichenfolgen und Unicode-Standard  
 Zeichen in einer Zeichenfolge von UTF-16-codierte Codeeinheiten, die entsprechen dargestellt sind <xref:System.Char> Werte.  
  
 Jedes Zeichen in einer Zeichenfolge verfügt über eine Kategorie zugeordneten Unicode-Zeichen, die in .NET Framework durch dargestellt wird die <xref:System.Globalization.UnicodeCategory> Enumeration. Die Kategorie eines Zeichens oder ein Ersatzzeichenpaar kann bestimmt werden, durch Aufrufen der <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode.  
  
 .NET Framework behält eine eigene Tabelle von Zeichen und ihrer entsprechenden Kategorien, der sicherstellt, dass eine Version von .NET Framework, die auf anderen Plattformen ausgeführt Kategorieinformationen identische Zeichen zurückgibt. Die folgende Tabelle enthält die Versionen von .NET Framework und die Versionen im Unicode-Standard, auf denen ihre Zeichenkategorien basieren.  
  
|.NET Framework-Version|Version des Unicode-Standards|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Die Version 4.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[Die Version 8.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode8.0.0/)|  
  
 Darüber hinaus unterstützt .NET Framework Zeichenfolgenvergleich und Sortierung basierend auf den Unicode-Standard. In Versionen von .NET Framework über die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework verwaltet eine eigenen Tabelle von Zeichenfolgendaten. Dies gilt auch, beginnend mit .NET Framework-Versionen der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] auf Windows 7 ausgeführt wird. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] auf Windows 8 und höheren Versionen von Windows-Betriebssystem ausgeführt wird, die die Common Language Runtime-Delegaten Zeichenfolge Vergleichs- und Sortiervorgänge für das Betriebssystem. Die folgende Tabelle enthält die Versionen von .NET Framework und die Versionen im Unicode-Standard, auf welches Zeichen Vergleich und Sortierung basieren.  
  
|.NET Framework-Version|Version des Unicode-Standards|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Die Version 4.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]und höher unter Windows 7|[Die Version 5.0.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]und höher unter Windows 8 und höheren Windows-Betriebssysteme|[Die Version 6.3.0 im Unicode-Standard](http://www.unicode.org/versions/Unicode6.3.0/)|  
  
<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Zeichenfolgen und eingebettete Null-Zeichen  
 In .NET Framework eine <xref:System.String> Objekt kann eingebettete Null-Zeichen, die Anzahl der im Rahmen der Länge der Zeichenfolge enthalten. Jedoch in einigen Sprachen wie C# und C++, ein Null-Zeichen gibt das Ende einer Zeichenfolge, die nicht als einen Teil der Zeichenfolge und wird als Teil der Länge der Zeichenfolge nicht gezählt. Dies bedeutet, dass die folgenden allgemeinen Annahmen, die C- und C++-Programmierer oder Bibliotheken, die in C oder C++ geschriebene über Zeichenfolgen, die möglicherweise nicht unbedingt gültig, wenn Sie zugewiesen sind <xref:System.String> Objekte:  
  
-   Der zurückgegebene Wert den `strlen` oder `wcslen` Funktionen entspricht nicht unbedingt <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Die Zeichenfolge, die erstellt, indem die `strcpy_s` oder `wcscpy_s` Funktionen ist nicht unbedingt identisch mit der Zeichenfolge erstellt, indem die <xref:System.String.Copy%2A?displayProperty=nameWithType> Methode.  
  
 Sie sollten sicherstellen, dass diese systemeigene C- und C++-Code, der instanziiert <xref:System.String> Benutzerobjekten und Code, der übergeben wird <xref:System.String> Objekte über Platform aufrufen, sollte Sie nicht davon ausgegangen, dass ein eingebettetes Null-Zeichen das Ende der Zeichenfolge markiert.  
  
 Eingebettete Null-Zeichen in einer Zeichenfolge werden ebenfalls anders behandelt werden, wenn eine Zeichenfolge sortiert (oder verglichen) und eine Zeichenfolge durchsucht wird. NULL-Zeichen werden ignoriert, wenn kulturabhängige Vergleiche zwischen zwei Zeichenfolgen, einschließlich vergleichen, die mit der invarianten Kultur ausgeführt. Diese sind nur für die Ordinalvergleiche von ordinal oder Groß-/Kleinschreibung berücksichtigt. Andererseits, eingebettete Null-Zeichen werden immer berücksichtigt, wenn eine Zeichenfolge mit Methoden wie z. B. Suche <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, und <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Zeichenfolgen und Indizes  
 Ein Index ist die Position des eine <xref:System.Char> Objekt (nicht in ein Unicode-Zeichen) in einem <xref:System.String>. Ein Index ist eine nullbasierte, nicht negative Zahl, die von der ersten Position in der Zeichenfolge beginnt, der Indexposition 0 (null) ist. Eine Reihe von Methoden wie z. B. <xref:System.String.IndexOf%2A> und <xref:System.String.LastIndexOf%2A>, zurückgeben den Index eines Zeichens oder einer Teilzeichenfolge in der Zeichenfolgeninstanz.  
  
 Die <xref:System.String.Chars%2A> Eigenschaft ermöglicht den Zugriff auf einzelne <xref:System.Char> Objekte durch ihre Indexposition in der Zeichenfolge. Da die <xref:System.String.Chars%2A> Eigenschaft ist die Standardeigenschaft (in Visual Basic) oder Indexer (in c#), können Sie die einzelnen zugreifen <xref:System.Char> Objekte in einer Zeichenfolge durch folgenden Code verwenden. Dieser Code sucht nach Leerzeichen oder Satzzeichen in eine Zeichenfolge, um zu bestimmen, wie viele Wörter die Zeichenfolge enthält.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Da die <xref:System.String> -Klasse implementiert die <xref:System.Collections.IEnumerable> -Schnittstelle, Sie können auch durchlaufen die <xref:System.Char> Objekte in einer Zeichenfolge mit einer `foreach` Konstrukt, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Aufeinander folgende Indexwerte entspricht möglicherweise nicht aufeinander folgenden Unicode-Zeichen, da ein Zeichen möglicherweise Unicode codiert als mehr als ein <xref:System.Char> Objekt. Insbesondere kann eine Zeichenfolge mehreren Zeichen Einheiten von Text enthalten, die durch ein Basiszeichen gefolgt durch eine oder mehrere Kombinationszeichen oder von Ersatzzeichenpaaren gebildet werden. Arbeiten mit Unicode-Zeichen anstelle von <xref:System.Char> verwenden Sie die Objekte, die <xref:System.Globalization.StringInfo?displayProperty=nameWithType> und <xref:System.Globalization.TextElementEnumerator> Klassen. Das folgende Beispiel veranschaulicht den Unterschied zwischen Code, mit der Funktionsweise <xref:System.Char> Benutzerobjekten und Code, die mit Unicode-Zeichen. Die Anzahl der Zeichen oder Textelemente in der jedes Wort im Satz verglichen. Die Zeichenfolge enthält zwei Sequenzen von eines Basiszeichens gefolgt von einer Kombination von Zeichen.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Dieses Beispiel funktioniert mit Textelemente mithilfe der <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> Methode und die <xref:System.Globalization.TextElementEnumerator> Klasse, um die Textelemente einer Zeichenfolge aufgelistet. Sie können auch ein Array, das durch Aufrufen der Startindex des jedes Textelement enthält Abrufen der <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zum Arbeiten mit Einheiten eher Text als einzelne <xref:System.Char> -Werte finden Sie in der <xref:System.Globalization.StringInfo> Klasse.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>NULL-Zeichenfolgen und leere Zeichenfolgen  
 Eine Zeichenfolge, die deklariert wurde, jedoch wurde kein Wert zugewiesen ist `null`. Beim Aufrufen von Methoden für diese Zeichenfolge löst eine <xref:System.NullReferenceException>. Eine null-Zeichenfolge unterscheidet sich von einer leeren Zeichenfolge, d. h. eine Zeichenfolge, deren Wert "" oder <xref:System.String.Empty?displayProperty=nameWithType>. In einigen Fällen löst eine Ausnahme aus, wenn Sie eine null-Zeichenfolge oder eine leere Zeichenfolge als Argument in einem Methodenaufruf übergeben. Z. B. eine null-Zeichenfolge zu übergeben der <xref:System.Int32.Parse%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.ArgumentNullException>, und übergeben einer leeren Zeichenfolge löst eine <xref:System.FormatException>. In anderen Fällen kann ein Methodenargument eine null-Zeichenfolge oder eine leere Zeichenfolge sein. Wenn Sie bereit sind z. B. eine <xref:System.IFormattable> Implementierung für eine Klasse, eine null-Zeichenfolge und eine leere Zeichenfolge mit der allgemeine Formatbezeichner ("G") entsprechen soll.  
  
 Die <xref:System.String> Klasse enthält die folgenden zwei Hilfsmethoden, mit denen Sie überprüfen, ob eine Zeichenfolge ist `null` oder leer:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, der angibt, ob eine Zeichenfolge entweder ist `null` oder gleich <xref:System.String.Empty?displayProperty=nameWithType>. Diese Methode entfällt die Notwendigkeit, den folgenden Code verwenden:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, der angibt, ob eine Zeichenfolge ist `null`, gleich <xref:System.String.Empty?displayProperty=nameWithType>, oder ausschließlich aus Leerzeichen besteht. Diese Methode entfällt die Notwendigkeit, den folgenden Code verwenden:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IsNullOrEmpty%2A> Methode in der <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> Implementierung eines benutzerdefinierten `Temperature` Klasse. Die Methode unterstützt die Formatzeichenfolgen "G", "C", "F" und "K". Wenn eine leere Zeichenfolge oder ein Format, dessen Wert eine Zeichenfolge ist `null` übergeben wird an die Methode wird der Wert in der Formatzeichenfolge "G" geändert.  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Unveränderlichkeit und der StringBuilder-Klasse  
 Ein <xref:System.String> Objekt heißt unveränderlich (schreibgeschützt), da der Wert kann nicht geändert werden, nachdem es erstellt wurde. Methoden, die angezeigt werden, so ändern Sie eine <xref:System.String> Objekt zurückgeben tatsächlich ein neues <xref:System.String> -Objekt, das die Änderung enthält.  
  
 Da Zeichenfolgen unveränderlich sind, so lange Zeichenfolge-manipulationsroutinen, die ausführen hinzugefügten oder gelöschten, was angezeigt wird, sein, dass eine einzelne Zeichenfolge erhebliche Leistungseinbußen genauen kann wiederholt. Der folgende Code verwendet beispielsweise einen Zufallszahlengenerator So erstellen Sie eine Zeichenfolge mit 1000 Zeichen im Bereich 0 x 0001, 0x052F an. Obwohl der Code zum Verketten von Zeichenfolgen zu verwenden wird, um ein neues Zeichen in die vorhandene Zeichenfolge mit dem Namen Anfügen `str`, tatsächlich wird ein neuer <xref:System.String> Objekt für jeden Verkettungsvorgang.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Können Sie die <xref:System.Text.StringBuilder> -Klasse statt der <xref:System.String> Klasse für Vorgänge, die mehrere Änderungen an den Wert einer Zeichenfolge vornehmen. Im Gegensatz zu Instanzen der <xref:System.String> Klasse <xref:System.Text.StringBuilder> Objekte sind änderbar; beim Verketten, Anfügen oder Teilzeichenfolgen aus einer Zeichenfolge zu löschen, werden die Vorgänge auf einer einzelnen Zeichenfolge. Nach Abschluss des Ändern des Werts einer <xref:System.Text.StringBuilder> -Objekts können Sie erreichen die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode in eine Zeichenfolge zu konvertieren. Im folgende Beispiel ersetzt die <xref:System.String> zum Verketten von 1000 zufälligen Zeichen im Bereich 0 x 0001 bis 0x052F mit im vorherigen Beispiel verwendet eine <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordnungszahl im Vergleich zu kulturabhängige Operationen  
 Mitglieder der <xref:System.String> Klasse ordinal oder kulturabhängige (linguistische) Vorgänge ausführen, auf eine <xref:System.String> Objekt. Ein ordinal Vorgang ausgeführt wird, nach dem numerischen Wert der einzelnen <xref:System.Char> Objekt. Eine kulturabhängige Operation wird der Wert von der <xref:System.String> -Objekt, und nimmt kulturspezifische Groß-/Kleinschreibung, Sortierung Formatierung und Analyse Regeln berücksichtigt. Kulturabhängige Operationen im Kontext einer explizit deklarierten Kultur oder die implizite aktuelle Kultur ausgeführt werden. Die zwei Arten von Vorgängen können sehr unterschiedliche Ergebnisse erzeugen, wenn sie auf die gleiche Zeichenfolge ausgeführt werden.  
  
 .NET Framework unterstützt auch kulturunabhängige linguistische Zeichenfolgenoperationen mit der invarianten Kultur (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), die lose basiert auf den kultureinstellungen des der englischen Sprache, die unabhängig von der Region. Im Gegensatz zu anderen <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> Einstellungen, die von der invarianten Kultur ist sichergestellt, dass auf einem einzelnen Computer, von System zu System und in .NET Framework-Versionen konsistent bleiben. Die invariante Kultur kann als eine Art schwarzes Kästchen, die Stabilität von Zeichenfolgenvergleichen wird sichergestellt, dass Sicht- und Reihenfolge in allen Kulturen gleich.  
  
> [!IMPORTANT]
>  Wenn Ihre Anwendung eine sicherheitsentscheidung zu einer symbolischen Bezeichner, z. B. einen Dateinamen stellt oder Pipes benannte oder zu persistente Daten, z. B. die textbasierten Daten in eine XML-Datei, sollten der Vorgang einen ordinalen Vergleich anstelle einer kulturabhängigen Vergleich verwenden. Grund hierfür ist ein kulturabhängiger Vergleich aktiviert ist, je nach Kultur unterschiedliche Ergebnisse führen kann hingegen ein ordinalen Vergleich ausschließlich auf den binären Wert der verglichenen Zeichen abhängig ist.  
  
> [!IMPORTANT]
>  Die meisten Methoden zum Ausführen von Zeichenfolgenoperationen enthalten eine Überladung, die einen vom Typ Parameter <xref:System.StringComparison>, können Sie angeben, ob die Methode einen ordinalen oder kulturabhängigen Vorgang ausführt. Im Allgemeinen sollten Sie diese Überladung, um den Zweck der Methode Methodenaufrufs eindeutig anzugeben aufrufen. Best Practices und Anleitungen für die Verwendung von Ordnungszahlen und kulturabhängige Operations mit Zeichenfolgen finden Sie unter [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md).  
  
 Vorgänge für [Schreibweise](#casing), [analysieren und formatieren](#parsing), [Vergleich und Sortierung](#comparison), und [Testen auf Gleichheit](#equality) kann ordinal oder kulturabhängig sein. Den folgenden Abschnitten werden die einzelnen Kategorien des Vorgangs.  
  
> [!TIP]
>  Sie sollten immer eine methodenüberladung aufrufen, die den Zweck der Methode Methodenaufrufs eindeutig macht. Z. B. statt der <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode einen kulturabhängiger Vergleich von zwei Zeichenfolgen durchgeführt wird, wird mit den Konventionen der aktuellen Kultur, rufen Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Methode mit einem Wert von <xref:System.StringComparison?displayProperty=nameWithType> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
<a name="casing"></a>   
### <a name="casing"></a>Schreibweise  
 Regeln Groß-und Kleinschreibung bestimmen, wie die Groß-/Kleinschreibung von einem Unicode-Zeichen ändern. z. B. von Klein-in Großbuchstaben konvertiert wurden. Häufig wird ein Schreibweise Vorgang vor einem Zeichenfolgenvergleich ausgeführt. Beispielsweise kann eine Zeichenfolge in Großbuchstaben konvertiert werden, damit es mit einer anderen Zeichenfolge in Großbuchstaben verglichen werden kann. Sie können die Zeichen in einer Zeichenfolge durch den Aufruf in Kleinbuchstaben konvertieren die <xref:System.String.ToLower%2A> oder <xref:System.String.ToLowerInvariant%2A> Methode, und Sie können diese durch Aufrufen von Großbuchstaben konvertieren die <xref:System.String.ToUpper%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Darüber hinaus können Sie die <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in titelschreibung.  
  
 Schreibweise Vorgänge können auf den Regeln der aktuellen Kultur, einer angegebenen Kultur oder der invarianten Kultur basieren. Da schreibungszuordnungen abhängig von der verwendeten Kultur variieren können, kann das Ergebnis der Schreibweise Vorgänge basierend auf der Kultur variieren. Die tatsächliche Unterschiede in Groß-/Kleinschreibung gibt drei Arten:  
  
-   Unterschiede in der Groß-/Kleinschreibung Zuordnung von LATIN CAPITAL LETTER I (U + 0049), kleine Buchstaben LATEINISCH I (U + 0069), LATIN CAPITAL LETTER I mit Punkt oben (U + 0130) und LATIN kleine Buchstaben ohne Punkte I (U + 0131). Das tr-TR (Türkisch (Türkei)) und az-Latn-AZ (Aserbaidschan, Lateinisch) Kulturen im tr, az und az-Latn neutralen Kulturen die kleinbuchstabenentsprechung von LATIN CAPITAL LETTER I ist LATIN kleine Buchstaben ohne Punkte I und der entsprechende Großbuchstabe LATIN kleine Buchstaben I LATIN CAPITAL LETTER I mit Punkt oben ist. In anderen Kulturen einschließlich der invarianten Kultur, kleine Buchstaben LATEINISCH I und LATIN CAPITAL LETTER ich und Großbuchstaben, Kleinbuchstaben Entsprechungen sind.  
  
     Im folgenden Beispiel wird veranschaulicht, wie ein Zeichenfolgenvergleich entwickelt um zu verhindern, dass bei der normalen Dateisystemzugriffs fehlschlagen können, wenn es auf einem Vergleich kulturabhängig Groß-/Kleinschreibung beruht. (Die Groß-/ Kleinschreibungskonventionen der invarianten Kultur sollte verwendet werden.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Unterschiede in der Groß-/Kleinschreibung Zuordnungen zwischen der invarianten Kultur und alle anderen Kulturen. In diesen Fällen gibt die Regeln der Groß-und Kleinschreibung der invarianten Kultur verwenden, so ändern Sie ein Zeichen in Groß-oder Kleinbuchstaben desselben Zeichens zurück. Für alle anderen Kulturen wird ein anderes Zeichen zurückgegeben. Einige der betroffenen Zeichen sind in der folgenden Tabelle aufgeführt.  
  
    |Zeichen|Wenn in geändert|Rückgabe|  
    |---------------|-------------------|-------------|  
    |NM-ZEICHEN (U + 00B5)|Großbuchstaben|GRIECHISCH GROSSBUCHSTABE MU (U +-39C)|  
    |LATIN CAPITAL LETTER ICH PUNKT OBEN (U + 0130)|Kleinbuchstaben|KLEINE LATEINISCHE BUCHSTABEN I (U + 0069)|  
    |LATEINISCHE KLEINBUCHSTABEN OHNE PUNKTE ICH (U + 0131)|Großbuchstaben|LATIN CAPITAL LETTER ICH (U + 0049)|  
    |KLEINES LATEINISCHES LANGE S (U + 017F.)|Großbuchstaben|LATIN CAPITAL LETTER S (U + 0053)|  
    |LATIN CAPITAL LETTER D MIT KLEINEN BUCHSTABEN Z MIT HÁČEK (U + 01C 5)|Kleinbuchstaben|KLEINES LATEINISCHES DZ MIT HÁČEK (U + 01C 6)|  
    |KOMBINIEREN VON YPOGRAMMENI (U + 0345)|Großbuchstaben|GRIECHISCH GROSSBUCHSTABE IOTA (U + 0399)|  
  
-   Unterschiede in der Groß-/Kleinschreibung Zuordnungen von zwei Buchstaben bestehende gemischter Groß-/Kleinschreibung-Paaren im ASCII-Zeichenbereich. In den meisten Kulturen entspricht ein zweistelliger gemischter Groß-/Kleinschreibung-Paar an das entsprechende Paar aus zwei Buchstaben bestehende Groß- oder Kleinbuchstaben. Dies gilt nicht für die folgenden zwei Buchstaben bestehende-Paare in der folgenden Kulturen, da in jedem Fall an einen Digraph verglichen werden:  
  
    -   "lJ" und "nJ" in die Kultur hr-HR (Kroatisch (Kroatien)).  
  
    -   "cH" in der Cs-CZ (Tschechisch (Tschechische Republik)) und Kulturen sk-SK (Slowakisch (Slowakei)).  
  
    -   "aA" in der Kultur da-DK (Dänisch (Dänemark)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" und "zS" in der Kultur Hu-HU (Ungarisch (Ungarn)).  
  
    -   "cH" und "lL" in der Kultur es-ES_tradnl (Spanisch (Spanien, Traditionelle Sortierung)).  
  
    -   "cH", "gI", "kH", "nG", "nH", "pH", "qU", "tH" und "tR" in der Kultur des vi-VN (Vietnamesisch (Vietnam)).  
  
     Es ist jedoch ungewöhnlich, die eine Situation, in der ein kulturabhängiger Vergleich dieser Paare Probleme erstellt, auftreten, da diese Paare feste Zeichenfolgen oder Bezeichner nicht üblich sind.  
  
 Das folgende Beispiel veranschaulicht einige der Unterschiede in Regeln Groß-und Kleinschreibung zwischen Kulturen beim Konvertieren von Zeichenfolgen in Großbuchstaben.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Analysieren und formatieren  
 Formatierung und Analyse sind umgekehrte Vorgänge. Formatierungsregeln bestimmen, wie einen Wert, z. B. ein Datum und Uhrzeit oder einer Zahl in die Zeichenfolgendarstellung konvertieren während Analyseregeln bestimmen, wie eine Zeichenfolgendarstellung auf einen Wert wie ein Datum und eine Uhrzeit konvertiert. Kulturelle Konventionen hängen sowohl Formatierung und Analyse für Regeln. Das folgende Beispiel veranschaulicht die Mehrdeutigkeit, die auftreten kann, wenn eine kulturspezifische Datumszeichenfolge zu interpretieren. Ohne zu wissen, die Konventionen der Kultur, die verwendet wurde, um eine Datumszeichenfolge zu erzeugen, ist es nicht möglich, zu wissen, ob 03/01/2011, 3/1/2011 und 01/03/2011 3. Januar 2011 oder am 1. März 2011 darstellen.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Auf ähnliche Weise wie im folgenden Beispiel wird gezeigt, kann eine einzelne Zeichenfolge verschiedene Datumsangaben abhängig von der Kultur erzeugen, deren Konventionen in der Analysevorgang verwendet werden.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Zeichenfolgenvergleich und-Sortierung  
 Konventionen für den Vergleich und Sortierung von Zeichenfolgen variieren Kulturen. Beispielsweise kann die Sortierreihenfolge für Phonetics oder für die visuelle Darstellung der Zeichen basieren. In ostasiatischen Sprachen werden Zeichen anhand der Anzahl der Striche und der Radikale der Ideogramme sortiert. Die Sortierung hängt außerdem von der Reihenfolge ab, die das Alphabet der jeweiligen Sprache bzw. Kultur aufweist. Im Dänischen gibt es beispielsweise das Zeichen "Æ", das im Alphabet nach dem Zeichen "Z" einsortiert ist. Darüber hinaus Vergleiche können Groß- und Kleinschreibung beachtet werden, und in einigen Fällen Regeln Groß-und Kleinschreibung unterscheiden sich auch von Kultur. Ordinalvergleich verwendet andererseits, die Unicode-Codepunkten der einzelnen Zeichen in eine Zeichenfolge, die beim Vergleichen und Sortieren von Zeichenfolgen.  
  
 Sortierregeln, die bestimmen, dass die alphabetische Reihenfolge von Unicode-Zeichen und wie zwei Zeichenfolgen miteinander vergleichen. Z. B. die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Methode vergleicht zwei Zeichenfolgen, die auf der Grundlage der <xref:System.StringComparison> Parameter. Wenn der Parameterwert ist <xref:System.StringComparison?displayProperty=nameWithType>, die Methode führt einen linguistischen Vergleich, der die Konventionen der aktuellen Kultur; verwendet, wenn der Parameterwert ist <xref:System.StringComparison?displayProperty=nameWithType>, die Methode führt einen Ordinalvergleich. Folglich, wie im folgenden Beispiel gezeigt, wenn die aktuelle Kultur "USA" Englisch, der erste Aufruf der <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (mithilfe von kulturabhängigen Vergleich) Methode betrachtet "a" kleiner als "A", aber der zweite Aufruf von derselben Methode (mit Ordinalvergleich) betrachtet "a" größer als "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework unterstützt Word, String und Ordinalsortierung:  
  
-   Bei einer Wortsortierung wird ein kulturabhängiger Vergleich von Zeichenfolgen durchgeführt, bei dem bestimmten nicht alphanumerischen Unicode-Zeichen u. U. bestimmte Gewichtungen zugeordnet sind. Beispielsweise ggf. wird der Bindestrich (-) eine sehr geringe Gewichtung zugeordnet, sodass "Coop" und "Co-op" in einer sortierten Liste nebeneinander angezeigt werden. Eine Liste der <xref:System.String> Methoden, die zwei Zeichenfolgen mithilfe von Word-Sortierregeln, Vergleichen finden Sie unter der [Zeichenfolgenoperationen nach Kategorie](#ByCategory) Abschnitt.  
  
-   Eine Sortierung Zeichenfolge führt auch einen kulturabhängigen Vergleich. Es ähnelt der eine Sortierung Wort identisch, es keine spezielle Fälle gibt und alle nicht alphanumerische Symbole, vor den alphanumerischen Unicode-Zeichen stammen. Zwei Zeichenfolgen können verglichen werden, mithilfe von Zeichenfolgensortierregeln durch Aufrufen der <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> methodenüberladungen, die über eine `options` Parameter bereitgestellte Wert <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Beachten Sie, dass dies die einzige Methode, die .NET Framework zum Vergleichen von zwei Zeichenfolgen mithilfe von Zeichenfolgensortierregeln bereitstellt.  
  
-   Eine Ordinalsortierung vergleicht Zeichenfolgen anhand des numerischen Werts jedes <xref:System.Char>-Objekts in der Zeichenfolge. Ein ordinalen Vergleich ist automatisch die Groß-/Kleinschreibung beachtet, da die Groß- und Kleinbuchstaben Versionen eines Zeichens unterschiedliche Codepunkte aufweisen. Wenn die Anfrage nicht wichtig ist, können Sie einen ordinalen Vergleich angeben, der Groß-und Kleinschreibung berücksichtigt. Dies entspricht dem Konvertieren der Zeichenfolge in Großbuchstaben unter Verwendung der invarianten Kultur und anschließend einen Ordinalvergleich ausführen, auf dem Ergebnis. Eine Liste der <xref:System.String> Methoden, die zwei Zeichenfolgen mithilfe von ordinalen Sortierregeln Vergleichen finden Sie unter der [Zeichenfolgenoperationen nach Kategorie](#ByCategory) Abschnitt.  
  
 Ein kulturabhängiger Vergleich ist ein Vergleich, der explizit oder implizit verwendet eine <xref:System.Globalization.CultureInfo> -Objekts, einschließlich der invarianten Kultur, die von angegeben wird die <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> Eigenschaft. Die implizite Kultur ist die aktuelle Kultur, der durch angegeben ist die <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaften. Es gibt erhebliche Variation in der Sortierreihenfolge der alphabetischen Zeichen (d. h. Zeichen, für die die <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> -Eigenschaft gibt `true`) zwischen Kulturen. Sie können angeben, dass einen kulturabhängiger Vergleich, der die Konventionen einer bestimmten Kultur durch Angabe verwendet eine <xref:System.Globalization.CultureInfo> -Objekt an eine Methode zum Zeichenfolgenvergleich wie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Sie können angeben, dass einen kulturabhängiger Vergleich, der durch Angabe der Konventionen der aktuellen Kultur verwendet <xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, oder ein Member des der <xref:System.Globalization.CompareOptions> Enumeration außer <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> oder <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> an eine entsprechende Überladung der der <xref:System.String.Compare%2A> Methode. Ein kulturabhängiger Vergleich eignet sich in der Regel für die Sortierung hingegen ein ordinalen Vergleich nicht ist. Ein ordinalen Vergleich eignet sich im Allgemeinen zu bestimmen, ob zwei Zeichenfolgen gleich sind (d. h. für die Bestimmung der Identität) dagegen ein kulturabhängigen Vergleich nicht ist.  
  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen ordinalen Vergleich kulturabhängig. Im Beispiel ergibt drei Zeichenfolgen, "Apple", "Æble" und "AEble" ordinalen Vergleich mit den Konventionen der Kulturen da-DK "und" En-US (von denen jede die Standardkultur ist, zum Zeitpunkt der <xref:System.String.Compare%2A> -Methode aufgerufen wird). Da die dänische Sprache das Zeichen "Æ" als ein einzelner Buchstabe behandelt und sortiert es im Alphabet nach "Z", ist die Zeichenfolge "Æble" größer als "Apple". "Æble" ist jedoch nicht äquivalent zu "AEble", interpretiert, damit "Æble" auch "AEble" größer ist. Der Kultur En-US interpretiert als äquivalent zu "AE", die erläutern, warum "Æble" kleiner als "Apple", aber "AEble" gleich ist jedoch nicht der Buchstabe "Æ" enthalten. Ordinalvergleich durch, hält andererseits, "Apple" niedriger sein als "Æble" und "Æble" größer als "AEble" sein.  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Verwenden Sie die folgenden allgemeinen Richtlinien, um eine entsprechende Sortierung oder Zeichenfolge Vergleichsmethode auszuwählen:  
  
-   Wenn Sie basierend auf der Kultur des Benutzers die Zeichenfolgen, die sortiert werden soll, sollten basierend auf den Konventionen der aktuellen Kultur sortiert werden. Wenn die Kultur des Benutzers geändert wird, wird die Reihenfolge der sortierten Zeichenfolgen auch entsprechend geändert. Eine Thesaurus-Anwendung sollte beispielsweise immer Wörter, die basierend auf der Kultur des Benutzers sortieren.  
  
-   Gegebenenfalls die Zeichenfolgen, die sortiert werden basierend auf den Konventionen einer bestimmten Kultur bestellen Sie diese durch Angabe einer <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur für eine Vergleichsmethode darstellt. Beispielsweise sollen in eine Anwendung, Studenten eine bestimmte Sprache zu unterrichten, Zeichenfolgen, um sortiert zu werden basierend auf den Konventionen einer Kulturen, die diese Sprache spricht.  
  
-   Wenn Sie die Reihenfolge von Zeichenfolgen zwischen Kulturen unverändert bleiben soll, sollten Sie in beliebiger Reihenfolge basierend auf den Konventionen der invarianten Kultur oder verwenden einen Ordinalvergleich durch. Beispielsweise würde eine Ordinalsortierung verwenden, um die Namen der Dateien, Prozesse, Mutexe zu organisieren oder named Pipes.  
  
-   Einen Vergleich, der eine sicherheitsentscheidung (z. B., ob ein Benutzernamen gültig ist) umfasst, sollten Sie immer einen Ordinalzahlen Test auf Gleichheit ausführen, durch Aufruf einer Überladung von der <xref:System.String.Equals%2A> Methode.  
  
> [!NOTE]
>  Der kulturabhängige Sortierung und Groß-/Kleinschreibung in Zeichenfolgenvergleich verwendete Regeln hängen von der Version von .NET Framework. In der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] unter der [!INCLUDE[win8](~/includes/win8-md.md)] Betriebssystem, Sortierung, Groß-/Kleinschreibung, Normalisierung und Unicode-Zeicheninformationen entspricht dem Standard Unicode 6.0. Auf anderen Betriebssystemen entspricht die Unicode 5.0-Standard es.  
  
 Weitere Informationen zum Word Zeichenfolge und Ordinalsortierung finden Sie unter der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Thema. Weitere Empfehlungen dazu, wann jeder Regel verwenden, finden Sie unter [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md).  
  
 Normalerweise rufen Sie nicht Zeichenfolge Vergleichsmethoden, z. B. <xref:System.String.Compare%2A> direkt auf die Sortierreihenfolge von Zeichenfolgen zu bestimmen. Stattdessen werden die Methoden zum Zeichenfolgenvergleich Methoden wie z. B. beim Sortieren aufgerufen <xref:System.Array.Sort%2A?displayProperty=nameWithType> oder <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. Im folgenden Beispiel wird vier verschiedene Sortieroperationen (Word-Sortierung verwenden, die aktuelle Kultur, Word-Sortierung mit der invarianten Kultur Ordinalsortierung und Zeichenfolge Sortieren mit der invarianten Kultur) ohne expliziten Aufruf einer Methode zum Zeichenfolgenvergleich, obwohl sie den Typ des Vergleichs mit angeben. Beachten Sie, dass jede Art von Sortierreihenfolge erzeugt eine eindeutige Sortierung von Zeichenfolgen im Array.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  .NET Framework verwendet intern Sortierschlüssel Culturallysensitive Zeichenfolgenvergleich zu unterstützen. Jedem Zeichen in einer Zeichenfolge sind mehrere Sortiergewichtungskategorien zugeordnet, darunter nach Skript, alphabetischer Folge, Groß-/Kleinschreibung und diakritischer Gewichtung. Ein Sortierschlüssel, dargestellt durch die <xref:System.Globalization.SortKey> Klasse, ein Repository mit diesen Gewichtungen für eine bestimmte Zeichenfolge enthält. Wenn eine große Anzahl von suchen oder Sortiervorgänge auf den gleichen Satz von Zeichenfolgen in Ihre app ausgeführt wird, können Sie die Leistung verbessern, indem generieren und zu speichern Sortierschlüssel für alle Zeichenfolgen, die verwendet werden. Wenn eine Sortierung oder ein Vergleich erforderlich ist, verwenden Sie den Sortierschlüssel anstelle von Zeichenfolgen. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.SortKey>-Klasse.  
  
 Wenn Sie eine Konvention, die Zeichenfolge Vergleich angeben, Sortieren Sie Methoden wie z. B. <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> führen Sie eine Sortierung kulturabhängig, Groß-/Kleinschreibung für Zeichenfolgen. Im folgende Beispiel wird veranschaulicht, wie die Reihenfolge der sortierten Zeichenfolgen in einem Array ändern die aktuelle Kultur auf auswirkt. Erstellt ein Array von drei Zeichenfolgen. Zuerst wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "en-US" festgelegt, und die <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>-Methode wird aufgerufen. Die sich daraus ergebende Sortierreihenfolge basiert auf den Sortierkonventionen für die Kultur Englisch (USA). Als Nächstes wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "da-DK" festgelegt und die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode erneut aufgerufen. Die sich daraus ergebende Sortierreihenfolge unterscheidet sich von den Ergebnissen für "en-US", da die Sortierkonventionen für "Dänisch (Dänemark)" verwendet werden.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Wenn der primäre Zweck in Vergleichen von Zeichenfolgen ist, um zu bestimmen, ob sie gleich sind, rufen Sie die <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode. Sie sollten in der Regel verwenden <xref:System.String.Equals%2A> einen Ordinalvergleich ausführen. Die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode dient in erster Linie zum Sortieren von Zeichenfolgen.  
  
 Zeichenfolgensuchmethoden, z. B. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, auch können kulturabhängig oder Ordnungszahl Zeichenfolgenvergleiche ausführen. Das folgende Beispiel veranschaulicht die Unterschiede zwischen der Ordinalzahl und kulturabhängige Vergleiche mit der <xref:System.String.IndexOf%2A> Methode. Eine kulturabhängige Suche, in der die aktuelle Kultur Englisch (Vereinigte Staaten) ist, betrachtet die Teilzeichenfolge "Oe" entsprechend der Ligatur "œ". Da Sie ein bedingten Bindestrich (U + 00AD) eine Breite von NULL-Zeichen ist, behandelt die Suche den bedingten Bindestrich als Entsprechung zu <xref:System.String.Empty> und findet eine Übereinstimmung am Anfang der Zeichenfolge. Eine Ordinalsuche ist in beiden Fällen andererseits, keine Übereinstimmung gefunden.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Suchen von Zeichenfolgen  
 Zeichenfolgensuchmethoden, z. B. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, auch ausführen, kulturabhängig oder Ordnungszahl Zeichenfolgenvergleiche zu bestimmen, ob ein Zeichen oder eine Teilzeichenfolge in einer angegebenen Zeichenfolge gefunden wird.  
  
 Die Suche Methoden in der <xref:System.String> -Klasse, die für ein einzelnes Zeichen wie z. B. Suchen der <xref:System.String.IndexOf%2A> Methode oder zu einem Satz von Zeichen, wie z. B. die <xref:System.String.IndexOfAny%2A> -Methode, eine Ordinalsuche Portverweise. Um eine kulturabhängige Suche nach einem Zeichen auszuführen, rufen Sie eine <xref:System.Globalization.CompareInfo> Methode z. B. <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> oder <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Beachten Sie, dass die Ergebnisse der Suche nach einem Zeichen mit einem ordinalen und kulturabhängige Vergleich sehr unterschiedlich sein können. Beispielsweise könnte eine Suche für ein zusammengesetztes Unicode-Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) entspricht jedem Vorkommen der Komponenten in der richtigen Reihenfolge, z. B. "AE" (U + 041U + 0045), abhängig von der Kultur. Das folgende Beispiel veranschaulicht den Unterschied zwischen der <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> und <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> Methoden bei der Suche nach einem einzelnen Zeichen. Die Ligatur "Æ" (U + 00E6) wird in der Zeichenfolge "Luftbild" bei Verwendung der Konventionen der Kultur En-US, jedoch nicht, wenn die Konventionen der Kultur da-DK verwendet oder wenn Sie einen Ordinalvergleich ausführen gefunden.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Andererseits, <xref:System.String> -Klassenmethoden, die Suche nach einer Zeichenfolge statt eines Zeichens eine kulturabhängige Suche ausführen, wenn Suchoptionen durch einen Parameter vom Typ nicht explizit angegeben werden <xref:System.StringComparison>. Die einzige Ausnahme ist <xref:System.String.Contains%2A>, die eine Ordinalsuche durchführt.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Verwenden der <xref:System.String.Compare%2A?displayProperty=nameWithType> Methode, um die Beziehung der beiden Zeichenfolgen in der Sortierreihenfolge festzulegen. Dies ist normalerweise eine kulturabhängige Operation. Im Gegensatz dazu rufen Sie die <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode auf Gleichheit. Da der Test auf Gleichheit Benutzereingaben mit einigen bekannten Zeichenfolge, z. B. einen gültigen Benutzernamen, ein Kennwort oder einen Dateisystempfad, in der Regel verglichen wird er in der Regel eine Ordinalzahl Vorgang.  
  
> [!WARNING]
>  Es ist möglich, die Gleichheit zu prüfende durch Aufrufen der <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode und bestimmen, ob der Rückgabewert 0 (null) ist. Dieses Vorgehen wird jedoch nicht empfohlen. Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, sollten Sie eine der Überladungen der Aufrufen der <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode. Die bevorzugte Überladung aufrufen, ist entweder die Instanz <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> -Methode oder die statische <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, da beide Methoden enthalten eine <xref:System.StringComparison?displayProperty=nameWithType> Parameter, der den Typ des Vergleichs explizit angibt.  
  
 Das folgende Beispiel veranschaulicht die Gefahr der Ausführung eines kulturabhängigen Vergleichs, Gleichheit, wenn eine Ordinalzahl einer sollte stattdessen verwendet werden. In diesem Fall ist der Zweck des Codes zu Dateisystemzugriff von URLs zu verhindern, die mit "FILE://" oder "file://" beginnt, durch Ausführen des Anfangs einer URL mit der Zeichenfolge "FILE://" Groß-und Kleinschreibung unterschieden. Jedoch wenn ein kulturabhängiger Vergleich unter Verwendung der Kultur Türkisch (Türkei) in einer URL, die mit "file://" beginnt, ausgeführt wird, fehlschlägt, der Vergleich Gleichheit, weil der türkischen Sprache entsprechende Großbuchstabe den Kleinbuchstaben "i" "İ" anstelle von "I" ist. Daher wird Dateisystemzugriff versehentlich zulässig. Andererseits, ein ordinalen Vergleich durchgeführt wird, wird der Vergleich Gleichheit ist erfolgreich, und Dateisystemzugriff verweigert wird.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalisierung  
 Mehrere Darstellungen müssen einige Unicodezeichen. Beispielsweise kann eine der folgenden Codepunkte den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Mehrere Darstellungen für ein einzelnes Zeichen erschweren suchen, sortieren, Abgleich und andere Zeichenfolgenoperationen.  
  
 Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung eines Unicode-Zeichens für jede der entsprechende binäre Darstellung zurückgibt. Normalisierung können mehrere Algorithmen, so genannte Normalisierung Formulare, die verschiedenen Regeln entsprechen. .NET Framework unterstützt Unicode-Normalisierung Forms C, D, KC und KD. Wenn Sie Zeichenfolgen in der gleichen Normalisierungsform normalisiert wurden, können sie mithilfe von ordinalen Vergleich verglichen werden.  
  
 Ein ordinalen Vergleich ist ein binärer Vergleich von der Unicode-Skalarwert des entsprechenden <xref:System.Char> Objekte in jeder Zeichenfolge. Die <xref:System.String> Klasse enthält eine Reihe von Methoden, die einen Ordinalvergleich durch, u. a. folgende ausführen können:  
  
-   Überladung von der <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, und <xref:System.String.LastIndexOf%2A> Methoden, die umfasst eine <xref:System.StringComparison> Parameter. Die Methode führt einen ordinalen Vergleich aus, wenn Sie angeben, dass der Wert <xref:System.StringComparison?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase> für diesen Parameter.  
  
-   Die Überladungen der <xref:System.String.CompareOrdinal%2A> Methode.  
  
-   Methoden, mit denen Ordinalvergleich standardmäßig, wie z. B. <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, und <xref:System.String.Split%2A>.  
  
-   Methoden, die für die Suche eine <xref:System.Char> Wert oder für die Elemente in einem <xref:System.Char> Array in eine Zeichenfolgeninstanz. Solche Methoden umfassen <xref:System.String.IndexOf%28System.Char%29> und <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Sie können bestimmen, ob eine Zeichenfolge in der Normalisierungsform C, durch Aufrufen normalisiert wird der <xref:System.String.IsNormalized?displayProperty=nameWithType> -Methode, oder Sie rufen die <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> Methode, um zu bestimmen, ob eine Zeichenfolge in einer angegebenen Normalisierungsform normalisiert wird. Sie können auch aufrufen, die <xref:System.String.Normalize?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in der Normalisierungsform C, oder Sie können Aufrufen der <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in einer angegebenen Normalisierungsform. Ausführliche Informationen zu normalisieren, und Vergleichen von Zeichenfolgen finden Sie die <xref:System.String.Normalize> und <xref:System.String.Normalize%28System.Text.NormalizationForm%29> Methoden.  
  
 Das folgende einfache Beispiel veranschaulicht die Normalisierung von Zeichenfolgen. Er definiert den Buchstaben "ố" auf drei verschiedene Arten in drei verschiedenen Zeichenfolgen und einen ordinalen Vergleich Gleichheit verwendet, um zu bestimmen, dass jede Zeichenfolge von den anderen beiden Zeichenfolgen unterscheidet. Er jede Zeichenfolge wird dann an den Formularen unterstützten Normalisierung konvertiert, und führt erneut einen ordinalen Vergleich einer Zeichenfolge in einer angegebenen Normalisierungsform. In jedem Fall zeigt der zweite Test auf Gleichheit an, dass die Zeichenfolgen gleich sind.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Weitere Informationen zur Normalisierung und Normalisierung Forms finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, als auch [Unicode Standard Annex #15: Unicode-Normalisierung Forms](http://unicode.org/reports/tr15/) und [Normalisierung – häufig gestellte Fragen](http://www.unicode.org/faq/normalization.html) auf die Unicode.org-Website.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Zeichenfolgenoperationen nach Kategorie  
 Die <xref:System.String> Klasse enthält Elemente für das Vergleichen von Zeichenfolgen, Testen von Zeichenfolgen auf Gleichheit, Suchen von Zeichen oder Teilzeichenfolgen in einer Zeichenfolge, die Änderung einer Zeichenfolge, die Teilzeichenfolgen in einer Zeichenfolge, die Kombination von Zeichenfolgen, Formatieren von Werten, Kopieren einer Zeichenfolge und Normalisieren einer Zeichenfolge zu extrahieren.  
  
### <a name="comparing-strings"></a>Vergleichen von Zeichenfolgen  
 Sie können Zeichenfolgen vergleichen, um ihre relative Position in der Sortierreihenfolge bestimmen mithilfe der Folgendes <xref:System.String> Methoden:  
  
-   <xref:System.String.Compare%2A>Gibt eine ganze Zahl, die die Beziehung aus einer Zeichenfolge in eine zweite Zeichenfolge in der Sortierreihenfolge angibt.  
  
-   <xref:System.String.CompareOrdinal%2A>Gibt eine ganze Zahl, die die Beziehung von einer Zeichenfolge mit einer zweiten Zeichenfolge basierend auf einem Vergleich ihrer Codepunkte angibt.  
  
-   <xref:System.String.CompareTo%2A>Gibt eine ganze Zahl, die die Beziehung von der aktuellen Zeichenfolgeninstanz in eine zweite Zeichenfolge in der Sortierreihenfolge angibt. Die <xref:System.String.CompareTo%28System.String%29> Methode stellt der <xref:System.IComparable> und <xref:System.IComparable%601> Implementierungen für die <xref:System.String> Klasse.  
  
### <a name="testing-strings-for-equality"></a>Testen von Zeichenfolgen auf Gleichheit  
 Rufen Sie die <xref:System.String.Equals%2A> Methode, um zu bestimmen, ob zwei Zeichenfolgen gleich sind. Die Instanz <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> und der statischen <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> Überladungen können Sie angeben, ob der Vergleich kulturabhängig oder Ordinalzahl ist, und gibt an, ob Fall berücksichtigt oder ignoriert wird. Die meisten Tests Gleichheit Ordinalvergleiche darstellen, und Vergleiche auf Gleichheit, die bestimmen, den Zugriff auf eine Systemressource (z. B. ein Dateisystemobjekt) sollten immer ordinal sein.  
  
### <a name="finding-characters-in-a-string"></a>Suchen von Zeichen in einer Zeichenfolge  
 Die <xref:System.String> Klasse enthält zwei Arten von Suchmethoden:  
  
-   Methoden, mit denen eine <xref:System.Boolean> Wert, um anzugeben, ob eine bestimmte Teilzeichenfolge in einer Zeichenfolgeninstanz vorhanden ist. Dazu gehören die <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, und <xref:System.String.StartsWith%2A> Methoden.  
  
-   Methoden, die die Anfangsposition einer Teilzeichenfolge in einer Zeichenfolgeninstanz angeben. Dazu gehören die <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, und <xref:System.String.LastIndexOfAny%2A> Methoden.  
  
> [!WARNING]
>  Wenn Sie für eine bestimmte Teilzeichenfolge, anstatt ein bestimmtes Muster eine Zeichenfolge suchen möchten, sollten Sie reguläre Ausdrücke verwenden. Weitere Informationen hierzu finden Sie unter [Reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Ändern einer Zeichenfolge  
 Die <xref:System.String> Klasse enthält die folgenden Methoden, die zum Ändern des Werts einer Zeichenfolge angezeigt werden:  
  
-   <xref:System.String.Insert%2A>Fügt eine Zeichenfolge in der aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.PadLeft%2A>Fügt eine oder mehrere Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge ein.  
  
-   <xref:System.String.PadRight%2A>Fügt eine oder mehrere Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge ein.  
  
-   <xref:System.String.Remove%2A>Löscht eine Teilzeichenfolge aus dem aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.Replace%2A>ersetzt eine Teilzeichenfolge durch eine andere Teilzeichenfolge in der aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.ToLower%2A>und <xref:System.String.ToLowerInvariant%2A> konvertiert alle Zeichen in einer Zeichenfolge in Kleinbuchstaben.  
  
-   <xref:System.String.ToUpper%2A>und <xref:System.String.ToUpperInvariant%2A> konvertiert alle Zeichen in einer Zeichenfolge in Großbuchstaben konvertiert wurden.  
  
-   <xref:System.String.Trim%2A>Entfernt alle Vorkommen von einem Zeichen am Anfang und Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimEnd%2A>Entfernt alle Vorkommen eines Zeichens vom Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimStart%2A>Entfernt alle Vorkommen eines Zeichens vom Anfang einer Zeichenfolge.  
  
> [!IMPORTANT]
>  Alle Zeichenfolgenmethoden Änderung eine neue zurückgeben <xref:System.String> Objekt. Ändern sie nicht den Wert der aktuellen Instanz.  
  
### <a name="extracting-substrings-from-a-string"></a>Extrahieren von Teilzeichenfolgen aus einer Zeichenfolge  
 Die <xref:System.String.Split%2A?displayProperty=nameWithType> Methode trennt eine einzelne Zeichenfolge in mehrere Zeichenfolgen zu trennen. Überladungen der Methode ermöglichen Ihnen die Angabe mehrerer Trennzeichen, um die maximale Anzahl von Teilzeichenfolgen zu bestimmen, von dem die Methode extrahiert, und um zu bestimmen, ob leere Zeichenfolgen (die auftreten, wenn es sich bei Trennzeichen nebeneinander angeordnet sind) für die zurückgegebenen Zeichenfolgen enthalten sind.  
  
### <a name="combining-strings"></a>Kombinieren von Zeichenfolgen  
 Die folgenden <xref:System.String> Methoden für das Verketten von Zeichenfolgen verwendet werden können:  
  
-   <xref:System.String.Concat%2A>werden ein oder mehrere Teilzeichenfolgen in einer einzelnen Zeichenfolge kombiniert.  
  
-   <xref:System.String.Join%2A>verkettet eine oder mehrere Teilzeichenfolgen in ein einzelnes Element und fügt ein Trennzeichen zwischen den Teilzeichenfolgen.  
  
### <a name="formatting-values"></a>Formatieren von Werten  
 Die <xref:System.String.Format%2A?displayProperty=nameWithType> Methode verwendet die Funktion für kombinierte Formatierung, um einen oder mehrere Platzhalter in einer Zeichenfolge durch die Zeichenfolgendarstellung für einige Objekte oder Werte zu ersetzen. Die <xref:System.String.Format%2A> Methode wird häufig verwendet, um die folgenden Aktionen ausführen:  
  
-   So betten Sie die Darstellung eines numerischen Werts in einer Zeichenfolge ein.  
  
-   Die Zeichenfolgendarstellung eines Werts für Datum und Uhrzeit in eine Zeichenfolge eingebettet werden sollen.  
  
-   Die angegebene Zeichenfolgendarstellung eines Enumerationswerts in eine Zeichenfolge eingebettet werden sollen.  
  
-   So betten Sie die Zeichenfolgendarstellung eines Objekts ein, die unterstützt die <xref:System.IFormattable> Schnittstelle in einer Zeichenfolge.  
  
-   Rechtsbündig oder eine Teilzeichenfolge in einem Feld innerhalb einer größeren Zeichenfolge linksbündig.  
  
 Ausführliche Informationen zum Formatieren von Operationen und Beispiele finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
### <a name="copying-a-string"></a>Kopieren einer Zeichenfolge  
 Sie können die folgenden Aufrufen <xref:System.String> Methoden, um eine Kopie einer Zeichenfolge zu erstellen:  
  
-   <xref:System.String.Clone%2A>Gibt einen Verweis auf ein vorhandenes <xref:System.String> Objekt.  
  
-   <xref:System.String.Copy%2A>erstellt eine Kopie einer vorhandenen Zeichenfolge an.  
  
-   <xref:System.String.CopyTo%2A>Kopiert einen Teil einer Zeichenfolge in ein Zeichenarray.  
  
### <a name="normalizing-a-string"></a>Eine Zeichenfolge normalisieren  
 Im Unicode-Format kann ein einzelnes Zeichen mehrere Codepunkte haben. Normalisierung konvertiert diese äquivalenten Zeichen in der gleichen binäre Darstellung. Die <xref:System.String.Normalize%2A?displayProperty=nameWithType> -Methode führt die Normalisierung und die <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> Methode bestimmt, ob eine Zeichenfolge normalisiert wird.  
  
 Weitere Informationen und ein Beispiel finden Sie unter der [Normalisierung](#Normalization) weiter oben in diesem Thema.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Abschnitt  
  
 [Überladener Konstruktorsyntax](#Syntax)   
 [Parameter](#Params)   
 [Ausnahmen](#Exceptions)   
 [Welche Methode werden aufgerufen?](#Tasks)   
 [Erstellen von Zeichenfolgen](#Creating_Strings)   
 [Behandlung von Zeichenfolgen](#Repetitive)   
 Beispiele für Zeichenfolgen instanziieren:   
 [Mit der Zeichenfolge Zuweisung](#Ctor1_Example)  
 [Verwenden ein Array von Zeichen](#Ctor2_Example)  
 [Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen](#Ctor3_Example)  
 [Mithilfe eines Zeigers auf ein Array von Zeichen](#Ctor4_Example)  
 [Verwenden einen Zeiger und einen Bereich eines Arrays](#Ctor5_Example)  
 [Mithilfe eines Zeigers auf ein Bytearray mit Vorzeichen](#Ctor6_Example)  
[Versionsinformationen](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Überladener Konstruktorsyntax  
 Konstruktoren Zeichenfolgen in zwei Kategorien unterteilen: ohne Zeigerparametern, und die mit Zeigerparametern. Die Konstruktoren, die Zeiger verwenden, sind nicht CLS-kompatibel. Darüber hinaus Visual Basic unterstützt nicht die Verwendung von Zeigern und C#-Code, der Zeiger verwendet wird, um in einem unsicheren Kontext ausgeführt werden muss. Weitere Informationen finden Sie unter [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Weitere Anleitungen zum Auswählen einer Überladung finden Sie unter [welche Methode aufrufen?](#Tasks)  
  
 `String(Char[] value)`  
 Initialisiert die neue Instanz mit dem durch ein Array von Unicode-Zeichen angegebenen Wert. Dieser Konstruktor kopiert Unicode-Zeichen ([Beispiel](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Initialisiert die neue Instanz mit dem Wert durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben ([Beispiel](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Initialisiert die neue Instanz mit dem Wert von einem angegebenen Unicode-Zeichen angegeben wiederholt eine festgelegte Anzahl von Malen ([Beispiel](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Nicht CLS-kompatibel) ** Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die durch ein Null-Zeichen beendet wird (U + 0000 oder '\0'). ([Beispiel](#Ctor4_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel) ** Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben. Der Konstruktor übernimmt die Unicode-Zeichen aus `value` ab Index `startIndex` und endet am Index `startIndex`  +  `length` – 1 ([Beispiel](#Ctor5_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value)`  
 **(Nicht CLS-kompatibel) ** Der neue Instanz mit den durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert initialisiert. Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge mit der aktuellen Codepage des Systems codiert (d. h. die festgelegte Codierung <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Der Konstruktor verarbeitet Zeichen aus `value` ab der Position des Zeigers angegeben wird, bis ein Null-Zeichen (0 x 00) erreicht ist ([Beispiel](#Ctor6_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel) ** Initialisiert die neue Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und eine Länge angegeben.  Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge mit der aktuellen Codepage des Systems codiert (d. h. die festgelegte Codierung <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Der Konstruktor verarbeitet Zeichen aus dem Wert beginnenden `startIndex` und endet bei `startIndex`  +  `length` – 1 ([Beispiel](#Ctor6_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Nicht CLS-kompatibel) ** Initialisiert die neue Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge angegeben und ein <xref:System.Text.Encoding> Objekt.  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parameter  
 Hier ist eine vollständige Liste der von verwendeten Parameter <xref:System.String> Konstruktoren, die keine Zeigerparameter enthalten. Die Parameter, die durch jede Überladung verwendet wird finden Sie in der obigen Syntax für Überladung.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Ein Array von Unicode-Zeichen.|  
|`c`|<xref:System.Char>|Ein Unicode-Zeichen.|  
|`startIndex`|<xref:System.Int32>|Die Anfangsposition im `value` des ersten Zeichens in der neuen Zeichenfolge.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl der Zeichen in `value` in der neuen Zeichenfolge eingeschlossen werden sollen.<br /><br /> Standardwert:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Die Häufigkeit, mit des Zeichens `c` wird in der neuen Zeichenfolge wiederholt. Wenn `count` NULL ist, wird der Wert des neuen Objekts <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Hier ist eine vollständige Liste der von verwendeten Parameter <xref:System.String> Konstruktoren, die einen Zeigerparameter enthalten. Die Parameter, die durch jede Überladung verwendet wird finden Sie in der obigen Syntax für Überladung.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - oder - <br /><br /> <xref:System.SByte>\*|Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen oder ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Wenn `value` ist `null` oder ein leeres Array, der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Der Index des Arrayelements, der das erste Zeichen in der neuen Zeichenfolge definiert.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl von Arrayelementen zu verwenden, um die neue Zeichenfolge zu erstellen. Wenn die Länge 0 (null) ist, wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Standardwert:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Ein Objekt, der angibt, wie die `value` Array codiert ist.<br /><br /> Standardwert: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, oder die aktuelle ANSI-Codepage des Systems|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Ausnahmen  
 Hier ist eine Liste der von Konstruktoren, die kein Zeigerparametern ausgelösten Ausnahmen.  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` ist `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, oder `count` ist kleiner als 0 (null).<br /><br /> - oder - <br /><br /> Die Summe der `startIndex` und `length` ist größer als die Anzahl der Elemente im `value`.<br /><br /> - oder - <br /><br /> `count` ist kleiner als Null.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Hier ist eine Liste der Ausnahmen von Konstruktoren, die Zeigerparameter enthalten.  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value`Gibt ein Array, das ein ungültiges Unicode-Zeichen enthält.<br /><br /> - oder - <br /><br /> `value`oder `value`  +  `startIndex` gibt eine Adresse, die weniger als 64 KB ist.<br /><br /> - oder - <br /><br /> Ein neues <xref:System.String> Instanz konnte nicht initialisiert werden, aus der `value` Bytearray, da `value` nicht der Standardeinstellung codepagecodierung verwendet.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.ArgumentNullException>|`value` ist NULL.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder - <br /><br /> `startIndex`oder `length` ist kleiner als 0 (null), `value`  +  `startIndex` verursacht einen Zeigerüberlauf, oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder - <br /><br /> Die Länge der neuen Zeichenfolge ist zu groß zum zuordnen.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.AccessViolationException>|`value`, oder `value`  +  `startIndex`  +  `length` – 1, gibt eine ungültige Adresse an.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode werden aufgerufen?  
  
|Beschreibung|Aufruf oder verwenden|  
|--------|-----------------|  
|Erstellen Sie eine Zeichenfolge.|Zuweisung von einem Zeichenfolgenliteral oder eine vorhandene Zeichenfolge ([Beispiel](#Ctor1_Example))|  
|Erstellen Sie eine Zeichenfolge aus einer gesamten Zeichenarray.|<xref:System.String.%23ctor%28System.Char%5B%5D%29>([Beispiel](#Ctor2_Example))|  
|Erstellt einen Zeichenfolge aus einem Teil eines Arrays von Zeichen.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge, die das gleiche Zeichen mehrmals wiederholt.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge von einem Zeiger auf eine Unicode- oder ein Array mit Breitzeichen.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Erstellen Sie eine Zeichenfolge aus einem Abschnitt eine Unicode-oder Breitzeichen Array mithilfe der Zeiger.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Erstellen Sie eine Zeichenfolge aus einer C++ `char` Array.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - oder - <br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Erstellen Sie eine Zeichenfolge aus ASCII-Zeichen.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Erstellen von Zeichenfolgen  
 Die am häufigsten verwendeten Verfahren zur Erstellung von Zeichenfolgen programmgesteuert einfache Zuweisung, wie im veranschaulicht [in diesem Beispiel](#Ctor1_Example). Die <xref:System.String> Klasse enthält auch vier Typen von Konstruktorüberladungen, mit denen Sie die Zeichenfolgen aus folgenden Werten zu erstellen:  
  
-   Aus einem Zeichenarray von (ein Array von UTF-16-codierte Zeichen). Sie können ein neues erstellen <xref:System.String> Objekt aus der Zeichen in das gesamte Array oder einem Teil davon. Die <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiert alle Zeichen im Array, an der neuen Zeichenfolge. Die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor kopiert die Zeichen aus dem Index `startIndex` Index `startIndex`  +  `length` – 1, um die neue Zeichenfolge. Wenn `length` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Wenn Code wiederholt Zeichenfolgen, die den gleichen Wert haben instanziiert, können Sie die Leistung der Anwendung verbessern, ein alternativen Verfahren zum Erstellen von Zeichenfolgen mit. Weitere Informationen finden Sie unter [Behandlung von Zeichenfolgen von](#Repetitive).  
  
-   Von einem einzelnen Zeichen, doppelte 0 (null), in einer oder mehrere Male, indem die <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> Konstruktor. Wenn `count` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Von einem Zeiger auf ein Zeichenarray mit Null endende, durch die Verwendung der <xref:System.String.%23ctor%28System.Char%2A%29> oder <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor. Das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Der Konstruktor übernimmt eine Sequenz von Unicode-Zeichen ab, aus dem angegebenen Zeiger oder des angegebenen Zeigers plus `startIndex` und fortgesetzt, bis zum Ende des Arrays oder für `length` Zeichen. Wenn `value` ist ein null-Zeiger oder `length` NULL ist, wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>. Wenn der Kopiervorgang wird, bis zum Ende des Arrays fortgesetzt, und das Array ist nicht für die Null-terminierte, ist das Verhalten des Konstruktors systemabhängig. Diese Situation kann eine zugriffsverletzung verursachen.  
  
     Wenn das Array eingebetteten Null-Zeichen enthält (U + 0000 oder '\0') und die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, enthält die Zeichenfolgeninstanz `length` Zeichen einschließlich eines beliebigen eingebettete NULL-Werte. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Methode. Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, wird der Konstruktor eine Zeichenfolge mit zehn Zeichen, z. B. zwei eingebetteten NULL-Werte instanziiert. Andererseits, wenn im selben Array übergeben wird, um die <xref:System.String.%23ctor%28System.Char%2A%29> Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthalten.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Das Array muss es sich um Unicode-Zeichen enthalten. In C++ ist dies bedeutet, dass das Zeichenarray muss entweder als die verwaltete definiert <xref:System.Char>[]-Typ oder die nicht verwaltete`wchar_t`[]-Typ.  
  
     Wenn die <xref:System.String.%23ctor%28System.Char%2A%29> Überladung wird aufgerufen, und das Array ist nicht für die Null-terminiert ist, oder wenn die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung wird aufgerufen und `startIndex`  +  `length`-1 umfasst einen Bereich, der es außerhalb des Arbeitsspeichers für die Sequenz von Zeichen, d. h. zugewiesen das Verhalten des Konstruktors systemabhängig, und eine zugriffsverletzung auftreten. Darüber hinaus in der Intel Itanium-Prozessor aufruft, um die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor Auslösen einer <xref:System.DataMisalignedException> Ausnahme. In diesem Fall rufen die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> stattdessen.  
  
-   Von einem Zeiger auf ein Bytearray mit Vorzeichen. Das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Die Abfolge von Bytes interpretiert werden kann, mithilfe der Standardcodepage, die Codierung, oder eine Codierung, die im Konstruktoraufruf angegeben werden kann. Wenn der Konstruktor versucht, eine Zeichenfolge aus einem gesamten Array zu instanziieren, das keine Null-terminiert ist, oder wenn der Bereich des Arrays von `value`  +  `startIndex` auf `value`  +  `startIndex`  +  `length` -1 befindet sich außerhalb des Arbeitsspeichers für das Array zugeordnet und das Verhalten dieses Konstruktors ist systemabhängig eine zugriffsverletzung auftreten.  
  
     Die drei Konstruktoren, die einen Bytewert mit Vorzeichen Array als Parameter enthalten dienen in erster Linie zum Konvertieren einer C++ `char` array in eine Zeichenfolge, wie im folgenden Beispiel gezeigt:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Wenn das Array enthält Null-Zeichen ('\0') oder die Bytes, dessen Wert 0 ist, und der <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, enthält die Zeichenfolgeninstanz `length` Zeichen einschließlich eines beliebigen eingebettete NULL-Werte. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Methode. Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, wird der Konstruktor eine Zeichenfolge mit zehn Zeichen, z. B. zwei eingebetteten NULL-Werte instanziiert. Andererseits, wenn im selben Array übergeben wird, um die <xref:System.String.%23ctor%28System.SByte%2A%29> Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthalten.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Da die <xref:System.String.%23ctor%28System.SByte%2A%29> und <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktoren interpretieren `value` mithilfe der voreingestellten ANSI-Codepage Aufrufen dieser Konstruktoren mit identischer Bytearrays Zeichenfolgen verschiedene Werte für das entsprechende System erstellen kann.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Behandlung von Zeichenfolgen  
 Apps, die analysiert oder häufig Decodieren von Streams von Text, verwenden die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor oder die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um Sequenzen von Zeichen in eine Zeichenfolge zu konvertieren. Wiederholt Erstellen neuer Zeichenfolgen mit demselben Wert anstatt zu erstellen und Wiederverwenden von einer Zeichenfolge wird Arbeitsspeicher vergeudet. Wenn Sie wahrscheinlich den gleichen Zeichenfolgenwert wiederholt zu erstellen, indem die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor, auch wenn Sie nicht in kennen zu gelangen, was identisch Zeichenfolgenwerte sein können, können Sie stattdessen eine Nachschlagetabelle verwenden.  
  
 Nehmen wir beispielsweise an, Sie lesen und Analysieren einen Datenstrom von Zeichen aus einer Datei, die XML-Tags und Attribute enthält. Wenn Sie den Stream analysieren, treten wiederholt bestimmte Token (d. h. Sequenzen von Zeichen, die eine symbolische Bedeutung haben). Token, die Zeichenfolgen "0", "1", "true" und "false" werden wahrscheinlich in einem XML-Stream häufig auftreten.  
  
 Statt jedes Token in einer neuen Zeichenfolge konvertieren, können Sie erstellen eine <xref:System.Xml.NameTable?displayProperty=nameWithType> Objekt, das häufig auftretende Zeichenfolgen. Die <xref:System.Xml.NameTable> Objekt verbessert die Leistung, da es gespeicherte Zeichenfolgen abruft, ohne temporären Speicher zu belegen. Wenn Sie ein Token auftritt, verwenden Sie die <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Token aus der Tabelle abzurufen. Wenn das Token vorhanden ist, gibt die Methode die entsprechende Zeichenfolge zurück. Wenn das Token nicht vorhanden ist, verwenden Sie die <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Token in die Tabelle einzufügen und die entsprechende Zeichenfolge abgerufen.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Beispiel 1: Verwenden von zeichenkettenzuweisung  
 Das folgende Beispiel erstellt eine neue Zeichenfolge durch ein Zeichenfolgenliteral zuweisen. Es erstellt eine zweite Zeichenfolge, durch den Wert der ersten Zeichenfolge zuweisen. Dies sind die beiden am häufigsten verwendeten Arten, instanziieren Sie ein neues <xref:System.String> Objekt.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Beispiel 2: Verwenden ein Array von Zeichen  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt aus einem Zeichenarray von.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Beispiel 3: Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt aus einen Teil ein Zeichenarray und zum Erstellen eines neuen <xref:System.String> -Objekt, das mehrere Vorkommen eines einzelnen Zeichens enthält.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Beispiel 4: Mithilfe eines Zeigers auf ein Array von Zeichen  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt von einem Zeiger auf ein Array von Zeichen. Das C#-Beispiel muss kompiliert werden, mithilfe der `/unsafe` Compilerschalter.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Beispiel 5: Instanziieren eine Zeichenfolge mit einem Zeiger und einen Bereich eines Arrays  
 Im folgende Beispiel werden die Elemente eines Arrays von Zeichen für einen Punkt oder ein Ausrufezeichen untersucht. Wenn eine gefunden wird, instanziiert es eine Zeichenfolge aus der Zeichen im Array, die das interpunktionssymbol vorausgehen. Wenn dies nicht der Fall ist, es wird eine Zeichenfolge mit den gesamten Inhalt des Arrays instanziiert. Das C#-Beispiel muss kompiliert werden, mithilfe der `/unsafe` Compilerschalter.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Beispiel 6: Instanziieren einer Zeichenfolge von einem Zeiger auf ein Bytearray mit Vorzeichen  
 Im folgende Beispiel wird veranschaulicht, wie Sie eine Instanz von erstellen können die <xref:System.String> -Klasse mit der <xref:System.String.%23ctor%28System.SByte%2A%29> Konstruktor.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Versionsinformationen  
 .NET Framework  
 Alle Überladungen werden unterstützt: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Alle Überladungen werden unterstützt: 4, 3.5 SP1  
  
 Portable Klassenbibliothek  
 Alle Überladungen ohne eine <xref:System.SByte> `*` Parameter werden unterstützt.  
  
 .NET für Windows Store-Apps  
 Alle Überladungen ohne eine <xref:System.SByte> `*` Parameter werden unterstützt: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />Gibt ein Array, das ein ungültiges Unicode-Zeichen enthält oder <paramref name="value" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch ein Array von Unicode-Zeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit NULL endendes Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der neuen zu initialisierenden Zeichenfolge, die durch das NULL-Abschlusszeichen von <paramref name="value" /> bestimmt wird, ist zu groß für die Zuordnung.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> gibt eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Ein Unicode-Zeichen.</param>
        <param name="count">Wie oft <c>c</c> auftritt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein angegebenes so oft wie angegeben wiederholtes Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <c>Wert</c>.</param>
        <param name="length">Die Anzahl der Zeichen in <c>Wert</c> verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen, durch die Position des ersten Zeichens innerhalb dieses Arrays und durch eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />oder <paramref name="length" /> ist kleiner als 0 (null), <paramref name="value" />  +  <paramref name="startIndex" /> verursacht einen Zeigerüberlauf, oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />Gibt ein Array, das ein ungültiges Unicode-Zeichen enthält oder <paramref name="value" />  +  <paramref name="startIndex" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <c>Wert</c>.</param>
        <param name="length">Die Anzahl der Zeichen in <c>Wert</c> verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 Die Summe der <paramref name="startIndex" /> und <paramref name="length" /> ist größer als die Anzahl der Elemente im <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <param name="startIndex">Die Anfangsposition in <c>Wert</c>.</param>
        <param name="length">Die Anzahl der Zeichen in <c>Wert</c> verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und die Länge angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 Durch die angegebene Adresse <paramref name="value" />  +  <paramref name="startIndex" /> ist zu groß für die aktuelle Plattform; d. h. der Berechnung der Adresse ist übergelaufen.  
  
 - oder -   
  
 Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Durch die angegebene Adresse <paramref name="value" />  +  <paramref name="startIndex" /> ist kleiner als 64K.  
  
 - oder -   
  
 Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="startIndex">Die Anfangsposition in <c>Wert</c>.</param>
        <param name="length">Die Anzahl der Zeichen in <c>Wert</c> verwenden.</param>
        <param name="enc">Ein Objekt, das angibt, wie das Array verweist <c>Wert</c> codiert ist. Wenn <c>Enc</c> ist <see langword="null" />, ANSI-Codierung ausgegangen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <see cref="T:System.Text.Encoding" />-Objekt angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und Informationen über diese und andere umfassende Verwendung `String` Konstruktorüberladungen, finden Sie unter der <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 Durch die angegebene Adresse <paramref name="value" />  +  <paramref name="startIndex" /> ist zu groß für die aktuelle Plattform; d. h. der Berechnung der Adresse ist übergelaufen.  
  
 - oder -   
  
 Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Durch die angegebene Adresse <paramref name="value" />  +  <paramref name="startIndex" /> ist kleiner als 64K.  
  
 - oder -   
  
 Eine neue Instanz der <see cref="T:System.String" /> konnte nicht initialisiert werden, mithilfe von <paramref name="value" />davon ausgegangen, dass <paramref name="value" /> codiert wird nach den Angaben von <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine Position in der aktuellen Zeichenfolge.</param>
        <summary>Ruft das <see cref="T:System.Char" />-Objekt an einer angegebenen Zeichenposition innerhalb des aktuellen <see cref="T:System.String" />-Objekts ab.</summary>
        <value>Das Objekt an der <paramref name="index" />-Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` Parameter ist nullbasiert.  
  
 Diese Eigenschaft gibt die <xref:System.Char> Objekt an der Position, die gemäß der `index` Parameter. Allerdings kann ein Unicode-Zeichen dargestellt werden, von mehreren <xref:System.Char>. Verwenden der <xref:System.Globalization.StringInfo?displayProperty=nameWithType> -Klasse zum Arbeiten mit Unicode-Zeichen anstelle von <xref:System.Char> Objekte. Weitere Informationen finden Sie im Abschnitt "Char-Objekte und Unicode-Zeichen" in der <xref:System.String> -Klassenübersicht.  
  
 In c# ist die <xref:System.String.Chars%2A> Eigenschaft ist für einen Indexer. In Visual Basic ist es die Standardeigenschaft eines der <xref:System.String> Klasse. Jede <xref:System.Char> Objekt in der Zeichenfolge kann zugegriffen werden, indem Sie Code wie den folgenden.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie mit diesem Indexer in einer Routine verwenden können, um eine Zeichenfolge zu überprüfen.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> ist größer oder gleich der Länge dieses Objekts oder kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf diese Instanz von <see cref="T:System.String" /> zurück.</summary>
        <returns>Diese Instanz von <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist eine unabhängige Kopie dieser Instanz; Es ist einfach eine andere Ansicht der gleichen Daten. Verwenden der <xref:System.String.Copy%2A> oder <xref:System.String.CopyTo%2A> Methode zum Erstellen eines separaten <xref:System.String> Objekt mit demselben Wert wie diese Instanz.  
  
 Da die <xref:System.String.Clone%2A> -Methode einfach die vorhandene Zeichenfolgeninstanz zurückgibt, ist es ratsam, um sie direkt aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Überladungen der Methode <xref:System.String.Compare%2A> geben eine 32-Bit-Ganzzahl mit Vorzeichen zurück, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
|Wert|Bedingung|  
|-----------|---------------|  
|Kleiner als 0 (null)|Die erste Teilzeichenfolge steht die zweite Teilzeichenfolge in der Sortierreihenfolge vor.|  
|Zero|Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder `length` ist 0 (null).|  
|Größer als 0 (null)|Die erste Teilzeichenfolge folgt die zweite Teilzeichenfolge in der Sortierreihenfolge an.|  
  
> [!WARNING]
>  Wann immer möglich, sollten Sie eine Überladung der Aufrufen der <xref:System.String.Compare%2A> Methode, enthält eine <xref:System.StringComparison> Parameter. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" />vorausgeht <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" />Tritt auf, in der gleichen Position wie <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" />folgt <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode, um drei Gruppen von Zeichenfolgen zu vergleichen.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Im folgenden Beispiel die `ReverseStringComparer` Klasse das Auswerten von zwei Zeichenfolgen mit veranschaulicht die <xref:System.String.Compare%2A> Methode.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn auf der folgende Code ausführen, beispielsweise die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später, wenn ein kulturabhängiger Vergleich von "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD), dass die beiden Zeichenfolgen äquivalent sind.  
  
 [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)]
 [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  
  
 Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> -Methode, und übergeben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die `comparisonType` Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" />vorausgeht <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" />Tritt auf, in der gleichen Position wie <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" />folgt <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, dass die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> Methode entspricht der Verwendung <xref:System.String.ToUpper%2A> oder <xref:System.String.ToLower%2A> beim Vergleichen von Zeichenfolgen.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn auf der folgende Code ausführen, beispielsweise die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher und ein Vergleich kulturabhängig, Groß-/Kleinschreibung "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.  
  
 [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)]
 [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  
  
 Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> -Methode, und übergeben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" />vorausgeht <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" />befindet sich in derselben Position wie <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" />folgt <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder mit Wörtern (kulturabhängig) oder (kulturunabhängige) Ordinalsortierung.  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Versionen des Buchstabens "I". Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" />vorausgeht <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" />Tritt auf, in der gleichen Position wie <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" />folgt <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die `culture` Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Kultur ein Vergleichs auswirken kann. Tschechisch - Tschechische Republik Kultur ist, ist "ch" ein einzelnes Zeichen, das größer als "d" ist. Allerdings auf Englisch - USA-Kultur "ch" besteht aus zwei Zeichen, und "c" ist kleiner als "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Angenommen, der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher vornehmen, wobei Groß-und Kleinschreibung unterschieden von "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) die invariante Kultur gibt an, dass die beiden Zeichenfolgen äquivalent sind.  
  
 [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)]
 [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  
  
 Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> -Methode, und übergeben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="culture">Die Kultur, die kulturspezifische Vergleichsinformationen liefert.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Zeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung zwischen <paramref name="strA" /> und <paramref name="strB" /> angibt, wie in der folgenden Tabelle veranschaulicht wird.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" />vorausgeht <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" />Tritt auf, in der gleichen Position wie <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" />folgt <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die `culture` Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen. Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, dass Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden soll, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen, die vorausgehen Sie, und führen Sie es.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode dient in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen identisch sind (d. h., wenn der Zweck des Methodenaufrufs So testen Sie nach dem Rückgabewert 0 (null)). Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Der Vergleich kann weiter angegeben werden, durch die `options` -Parameter, der einen oder mehrere Member besteht aus den <xref:System.Globalization.CompareOptions> Enumeration. Jedoch, da der Zweck dieser Methode ist einen kulturabhängige Zeichenfolgenvergleich, für die Durchführung der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Werte haben keine Auswirkungen.  
  
 Können eine oder beide Vergleichswerten `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich sind.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht zwei Zeichenfolgen auf drei verschiedene Arten: Verwenden von linguistischen Vergleich für die Kultur En-US Verwenden für die Kultur En-US linguistische Groß-/ kleinschreibungsvergleich; und verwenden einen Ordinalvergleich durch. Es wird veranschaulicht, wie die drei Methoden des Vergleichs drei unterschiedlichen Ergebnissen führen.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> vorausgeht Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen in der gleichen Position in der Sortierreihenfolge auftreten oder <paramref name="length" /> 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> folgt die Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen in `strA` am `indexA` und `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an Position 0 (null) ist. Die Länge der ersten Teilzeichenfolge ist gleich der Länge des `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
 - oder -   
  
 Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> vorausgeht Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen in der gleichen Position in der Sortierreihenfolge auftreten oder <paramref name="length" /> 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> folgt die Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen in `strA` am `indexA`, und klicken Sie in `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an Position 0 (null) ist. Die Länge der ersten Teilzeichenfolge ist gleich der Länge des `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Der Pfadname muss auf eine invariante Weise verglichen werden soll. Zu diesem Zweck der richtige Code lautet wie folgt.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Vergleiche der beiden Teilzeichenfolgen, die unterscheiden sich nur im Fall ausgeführt. Der erste Vergleich die Groß-/Kleinschreibung ignoriert, und die zweite Vergleich berücksichtigt.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
 - oder -   
  
 Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> vorausgeht Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen in der gleichen Position in der Sortierreihenfolge auftreten oder der <paramref name="length" /> -Parameter ist 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> Follllows die Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen in `strA` am `indexA` und `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an position 0 (null) ist, nicht an der position einer. Die Länge der ersten Teilzeichenfolge ist gleich der Länge des `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder mit Wörtern (kulturabhängig) oder (kulturunabhängige) Ordinalsortierung.  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
 - oder -   
  
 Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> vorausgeht Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen in der gleichen Position in der Sortierreihenfolge auftreten oder <paramref name="length" /> 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> folgt die Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen in `strA` am `indexA`, und klicken Sie in `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an position 0 (null) ist, nicht an der position einer. Die Länge der ersten Teilzeichenfolge ist gleich der Länge des `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die `culture` Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen. Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Kann einem oder beiden verglichenen Elemente `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
 Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht zwei mit verschiedenen anderen Kulturen und ignorieren die Groß-/Kleinschreibung der Teilzeichenfolgen. Die Auswahl der Kultur auswirkt, wie der Buchstabe "I" ist im Vergleich.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
 - oder -   
  
 Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Anfangsposition der Teilzeichenfolge innerhalb <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Anfangsposition der Teilzeichenfolge innerhalb <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Teilzeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Teilzeichenfolgen angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> vorausgeht Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen in der gleichen Position in der Sortierreihenfolge auftreten oder <paramref name="length" /> 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> folgt die Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen in `strA` an Position `indexA` und `strB` an Position `indexB`. Die Länge der ersten Teilzeichenfolge ist die Länge des `strA` minus `indexA`. Die Länge der zweiten Teilzeichenfolge ist die Länge des `strB` minus `indexB`.  
  
 Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die `culture` Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen. Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, dass Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden soll, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen, die vorausgehen Sie, und führen Sie es.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode dient in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob zwei Teilzeichenfolgen identisch sind (d. h., wenn der Zweck des Methodenaufrufs So testen Sie nach dem Rückgabewert 0 (null)). Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Eine oder beide der `strA` und `strB` kann `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich sind.  
  
 Der Vergleich kann weiter angegeben werden, durch die `options` -Parameter, der einen oder mehrere Member besteht aus den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration. Jedoch, da der Zweck dieser Methode ist einen kulturabhängige Zeichenfolgenvergleich, für die Durchführung der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Werte haben keine Auswirkungen.  
  
 Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode, um den Nachnamen der beiden Personen verglichen werden soll. Anschließend werden diese in alphabetischer Reihenfolge aufgeführt.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> ist größer als <paramref name="strA" /><see langword=".Length" />.  
  
 - oder -   
  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see langword=".Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
 - oder -   
  
 Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt. Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="strA" /> ist kleiner als <paramref name="strB" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="strA" /> und <paramref name="strB" /> sind gleich.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="strA" /> ist größer als <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt ein Groß-/ kleinschreibungsvergleich mithilfe von ordinalen Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Um mithilfe von ordinalen Sortierregeln Groß-und Kleinschreibung unterschieden auszuführen, rufen die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Methode mit der `comparisonType` Argument festgelegt wird, um <xref:System.StringComparison?displayProperty=nameWithType>.  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> ist eine statische Methode `strA` und `strB` kann `null`. Wenn beide Werte sind `null`, die Methode gibt 0 (null), der angibt, dass `strA` und `strB` gleich sind. Wenn nur einer der Werte ist `null`, die Methode berücksichtigt, die nicht-Null-Wert größer sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird und ordinalen Vergleich von zwei Zeichenfolgen unterscheiden sich nur hinsichtlich der Fall.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Der Startindex der Teilzeichenfolge in <c>StrA</c>.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Der Startindex der Teilzeichenfolge in <c>StrB</c>.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht Teilzeichenfolgen zweier angegebener <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Teilzeichenfolgen ausgewertet werden.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> ist kleiner als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die Teilzeichenfolgen sind gleich, oder <paramref name="length" /> 0 (null).  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die Teilzeichenfolge in <paramref name="strA" /> ist größer als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Die Anzahl der Zeichen im Vergleich ist kleiner als die Länge des `strA` weniger `indexA`, die Länge des `strB` weniger `indexB`, und `length`.  
  
 Diese Methode führt ein Groß-/ kleinschreibungsvergleich mithilfe von ordinalen Sortierregeln. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Um mithilfe von ordinalen Sortierregeln Groß-und Kleinschreibung unterschieden auszuführen, rufen die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> Methode mit der `comparisonType` Argument festgelegt wird, um <xref:System.StringComparison?displayProperty=nameWithType>.  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> ist eine statische Methode `strA` und `strB` kann `null`. Wenn beide Werte sind `null`, die Methode gibt 0 (null), der angibt, dass `strA` und `strB` gleich sind. Wenn nur einer der Werte ist `null`, die Methode berücksichtigt, die nicht-Null-Wert größer sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, dass <xref:System.String.CompareOrdinal%2A> und <xref:System.String.Compare%2A> unterschiedliche Sortierreihenfolgen verwenden.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> ist nicht <see langword="null" /> und <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="strB" /> ist nicht <see langword="null" /> und <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
 - oder -   
  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.String" /> und gibt eine ganze Zahl zurück, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder <see cref="T:System.String" /> aufgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beide Überladungen der der <xref:System.String.CompareTo%2A> -Methode führen in der Vergleich kulturabhängig und Groß-/Kleinschreibung beachtet. Diese Methode können keine kulturunabhängige bzw. Ordinalvergleichsregeln Vergleiche ausführen. Aus Gründen der Übersichtlichkeit des Codes, sollten Sie vermeiden die <xref:System.String.CompareTo%2A> Methode, und rufen die <xref:System.String.Compare%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als <see cref="T:System.String" /> ausgewertet wird.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Object" /> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="value" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Diese Instanz tritt vor <paramref name="value" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz hat die gleiche Position in der Sortierreihenfolge als <paramref name="value" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Diese Instanz folgt <paramref name="value" />.  
  
 - oder -   
  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`muss ein <xref:System.String> Objekt.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen gleich sind. Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> Methode mit einem <xref:System.Object>. Weil er versucht, vergleichen Sie eine <xref:System.String> -Instanz, auf eine `TestClass` -Objekt löst die Methode eine <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.Object)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn auf der folgende Code ausführen, beispielsweise die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher und ein Vergleich des "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.  
  
 [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  
  
 Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.String" />-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie die angegebene Zeichenfolge aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="strB" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Diese Instanz tritt vor <paramref name="strB" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Diese Instanz hat die gleiche Position in der Sortierreihenfolge als <paramref name="strB" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Diese Instanz folgt <paramref name="strB" />.  
  
 - oder -   
  
 <paramref name="strB" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen gleich sind. Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode.  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> Schnittstelle und führt etwas bessere Leistung als die <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> -Methode, da sie keinen zu bestimmen, ob die `strB` Argument ist eine änderbare Werttyp, der mittels Boxing konvertiert werden muss, und es muss keine umgewandelt seine Parameter aus einem <xref:System.Object> auf eine <xref:System.String>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> Methode, um die aktuellen Zeichenfolgeninstanz mit einer anderen Zeichenfolge vergleichen.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 Im folgende Beispiel werden die generische und nicht generischen Versionen der CompareTo-Methode für verschiedene Wert- und Referenztypen veranschaulicht.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.String)" /> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn auf der folgende Code ausführen, beispielsweise die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher und ein Vergleich des "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.  
  
 [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  
  
 Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Ein Auflistungsobjekt, das <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementiert und dessen generisches Typargument <see cref="T:System.String" /> ist.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" />.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="values" /> ein leeres <see langword="IEnumerable(Of String)" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet jedes Objekt in `values`; Trennzeichen nicht hinzugefügt. Als Trennzeichen zwischen den einzelnen Membern der angeben `values`, rufen Sie die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 Ein <xref:System.String.Empty> Zeichenfolge anstelle der null-Element im verwendet `values`.  
  
 Wenn `values` ist eine leere `IEnumerable(Of String)`, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>. Wenn `values` ist `null`, löst die Methode eine <xref:System.ArgumentNullException> Ausnahme.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>ist eine bequeme Methode, mit der jedes Element in verketten kann eine `IEnumerable(Of String)` Auflistung ohne zunächst die Elemente in einem Array von Zeichenfolgen konvertiert. Dies ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ). Das folgende Beispiel übergibt eine `List(Of String)` Objekt, das die klein-oder Großbuchstaben und Buchstaben des Alphabets an einen Lambda-Ausdruck, die Buchstaben, die einem bestimmten Buchstaben enthält auswählt (d. h. im Beispiel "M") größer oder gleich sind. Die `IEnumerable(Of String)` -Auflistung, die von zurückgegeben wird das <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> an die Methode übergeben wird die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode, um das Ergebnis als einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis, das eine <xref:System.Collections.Generic.List%601> Objekt des Typs <xref:System.String>, übergibt sie dann an die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das darzustellende Objekt oder <see langword="null" />.</param>
        <summary>Erstellt die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts von <paramref name="arg0" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="arg0" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Concat%28System.Object%29> Methode stellt `arg0` als Zeichenfolge durch Aufrufen der parameterlosen `ToString` Methode.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Ein Objektarray, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen der Elemente in einem angegebenen <see cref="T:System.Object" />-Array.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte der Elemente in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet jedes Objekt in `args` durch Aufrufen der parameterlosen `ToString` Methode des Objekts; alle Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String?displayProperty=nameWithType>wird anstelle eines null-Objekts im Array verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.String.Concat%2A> Methode mit einem <xref:System.Object> Array.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode wird von C++-Code nicht aufgerufen. Der C++-Compiler löst Aufrufe von <see cref="Overload:System.String.Concat" /> deren Objektparameter für vier oder mehr als ein Aufruf von <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Zeichenfolgeninstanzen.</param>
        <summary>Verkettet die Elemente eines angegebenen <see cref="T:System.String" />-Arrays.</summary>
        <returns>Die verketteten Elemente von <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet jedes Objekt in `values`; Trennzeichen nicht hinzugefügt.  
  
 Eine <xref:System.String.Empty> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.String.Concat%2A> Methode mit einem <xref:System.String> Array.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen zweier angegebener Objekte.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" /> und <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `arg0` und `arg1` durch Aufrufen der parameterlosen `ToString` Methode `arg0` und `arg1`; Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String?displayProperty=nameWithType>ist anstelle von null-Argument verwendet.  
  
 Wenn entweder der Argumente Verweis auf ein Array ist, verkettet die Methode eine Zeichenfolgendarstellung dieses Arrays, anstelle von Membern (z. B. "System.String[]").  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" /> und <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0` und `str1`; Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Eine <xref:System.String.Empty> Zeichenfolge anstelle von null-Argument verwendet wird.  
  
   
  
## Examples  
 Im folgende Beispiel werden die ersten, mittleren und den Nachnamen einer Person-Name verkettet.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen von drei angegebenen Objekten.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `arg0`, `arg1`, und `arg2` durch Aufrufen der parameterlosen `ToString` -Methode aller Objekte; Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String?displayProperty=nameWithType>ist anstelle von null-Argument verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0`, `str1`, und `str2`; Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Eine <xref:System.String.Empty> Zeichenfolge anstelle von null-Argument verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Concat%2A> Methode zum Verketten von drei Zeigern auf Zeichenfolgen, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <param name="arg3">Das vierte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgenentsprechungen von vier angegebenen Objekten sowie aller in einer optionalen Parameterliste variabler Länger angegebenen Objekte.</summary>
        <returns>Die verkettete Zeichenfolgendarstellung aller Werte in der Parameterliste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese API ist nicht CLS-kompatibel. Die CLS-kompatible Alternative ist <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Die C#- und Visual Basic-Compiler automatisch auflösen, einen Aufruf dieser Methode als Aufruf <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Die Methode verkettet jedes Objekt in der Parameterliste durch Aufrufen der parameterlosen `ToString` Methode Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>ist anstelle von null-Argument verwendet.  
  
> [!NOTE]
>  Der letzte Parameter von der <xref:System.String.Concat%2A> Methode ist eine optionale durch Trennzeichen getrennte Liste von einem oder mehreren zusätzlichen Objekten zu verketten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode, um eine Liste der Variablenparameter verketten. In diesem Fall wird die Methode mit neun Parametern aufgerufen.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Diese Methode ist mit markiert die <see langword="vararg" /> Schlüsselwort, das bedeutet, dass es sich um eine Variable Anzahl an Parametern unterstützt. Die Methode kann aufgerufen werden, von Visual C++, aber es kann nicht von c# oder Visual Basic-Code aufgerufen werden. Die C#- und Visual Basic-Compiler lösen Aufrufe an <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> als Aufrufe von <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <param name="str3">Die vierte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0`, `str1`, `str2`, und `str3`; Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Eine <xref:System.String.Empty> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel definiert ein Array von Wörter und ihre einzelnen Buchstaben in einem Array von Zeichenfolgen speichert, um sie zu verschlüsseln. Er ruft dann die <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> Methode, um die verschlüsselte Wörter zu segmentieren.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente der <c>Werte</c>.</typeparam>
        <param name="values">Ein Auflistungsobjekt, das die <see cref="T:System.Collections.Generic.IEnumerable`1" />-Schnittstelle implementiert.</param>
        <summary>Verkettet die Member einer <see cref="T:System.Collections.Generic.IEnumerable`1" />-Implementierung.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet jedes Objekt in `values`; Trennzeichen nicht hinzugefügt.  
  
 Eine <xref:System.String.Empty> Zeichenfolge anstelle von null-Argument verwendet wird.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>ist eine bequeme Methode, mit der jedes Element in verketten kann eine <xref:System.Collections.Generic.IEnumerable%601> Auflistung ohne die Elemente zunächst in Zeichenfolgen konvertiert. Es ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ), wie im Beispiel veranschaulicht. Die Zeichenfolgendarstellung für jedes Objekt in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine sehr einfache `Animal` Klasse enthält den Namen des Animal und die Reihenfolge, zu dem er gehört. Zudem definiert der Code eine <xref:System.Collections.Generic.List%601> Objekt enthält eine Anzahl von `Animal` Objekte. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Erweiterungsmethode aufgerufen, um das Extrahieren der `Animal` -Objekte, deren `Order` Eigenschaft "Rodent" entspricht. Das Ergebnis wird zum Übergeben der <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode und in der Konsole angezeigt.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine angegebene untergeordnete Zeichenfolge in dieser Zeichenfolge vorkommt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige). Die Suche beginnt an der ersten Zeichenposition der Zeichenfolge und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Um zu bestimmen, ob eine Zeichenfolge, enthält eine angegebene untergeordnete Zeichenfolge mit einem anderen Knotentyp als Ordinalvergleich (z. B. ein kulturabhängiger Vergleich oder Ordinalvergleich Groß-/Kleinschreibung), können Sie eine benutzerdefinierte Methode erstellen. Das folgende Beispiel veranschaulicht einen solchen Ansatz. Definiert eine <xref:System.String> Extension-Methode, enthält eine <xref:System.StringComparison> Parameter und gibt an, ob eine Zeichenfolge eine Teilzeichenfolge enthält, bei Verwendung der angegebenen Form des Zeichenfolgenvergleichs.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Im folgende Beispiel ruft dann die `Contains` Erweiterungsmethode, um zu bestimmen, ob eine Teilzeichenfolge in einer Zeichenfolge gefunden wird, wenn Ordinalvergleich und Groß-/Kleinschreibung Ordinalvergleich verwenden.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Wenn Sie die Position der Teilzeichenfolge interessiert sind `value` in der aktuellen Instanz ist, rufen Sie die <xref:System.String.IndexOf%2A> Methode zum Abrufen der Anfangsposition des ersten Vorkommens, oder Sie können Aufrufen der <xref:System.String.LastIndexOf%2A> Methode zum Abrufen der ab position seine Letztes auftreten. Das Beispiel enthält einen Aufruf an die <xref:System.String.IndexOf%28System.String%29> Methode, wenn eine Teilzeichenfolge in einer Zeichenfolgeninstanz gefunden wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Zeichenfolge "Fuchs" eine Teilzeichenfolge des ein Zitat vertraut ist. Wenn "Fuchs" in der Zeichenfolge gefunden werden, wird auch die Anfangsposition angezeigt.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die zu kopierende Zeichenfolge.</param>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.String" /> mit demselben Wert wie eine angegebene Instanz von <see cref="T:System.String" />.</summary>
        <returns>Eine neue Zeichenfolge mit demselben Wert wie <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Copy%2A> Methode gibt ein <xref:System.String> Objekt hat den gleichen Wert wie die ursprüngliche Zeichenfolge, aber einen anderen Objektverweis darstellt. Es unterscheidet sich vom eines Zuweisungsvorgangs, das wodurch einen Zeichenfolgenverweis auf eine zusätzliche Objektvariable zugewiesen. Das Beispiel veranschaulicht den Unterschied.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Zeichenfolgenobjekte mit unterschiedlichen Werten erstellt. Wenn sie ruft die <xref:System.String.Copy%2A> Methode zum Zuweisen von des ersten Werts in der zweiten Zeichenfolge gibt die Ausgabe an, dass die Zeichenfolgen unterschiedliche Objektverweise darstellen, obwohl jetzt ihre Werte gleich sind. Andererseits, wenn die erste Zeichenfolge, die zweite Zeichenfolge zugewiesen wird, werden die beiden Zeichenfolgen identische Werte haben, da sie den gleichen Objektverweis darstellen.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Der Index des ersten Zeichens in dieser Instanz, das kopiert werden soll.</param>
        <param name="destination">Ein Array von Unicode-Zeichen, in das Zeichen in dieser Instanz kopiert werden.</param>
        <param name="destinationIndex">Der Index im <c>Ziel</c> bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der Zeichen in dieser Instanz, auf Kopieren <c>Ziel</c>.</param>
        <summary>Kopiert eine angegebene Anzahl von Zeichen von einer angegebenen Position in dieser Instanz an eine angegebene Position in einem Array von Unicode-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert `count` Zeichen aus der `sourceIndex` Position dieser Instanz in die `destinationIndex` position `destination` Zeichenarray. Diese Methode ändert nicht die Größe der `destination` Zeichenarray; muss eine ausreichende Anzahl von Elementen für die kopierten Zeichen oder die Methode löst eine <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex`und `destinationIndex` sind nullbasiert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.CopyTo%2A> Methode.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="sourceIndex" /> identifiziert keine Position in der aktuellen Instanz.  
  
 - oder -   
  
 <paramref name="destinationIndex" /> identifiziert keinen gültigen Index im <paramref name="destination" />-Array.  
  
 - oder -   
  
 <paramref name="count" /> ist größer als die Länge der Teilzeichenfolge von <paramref name="sourceIndex" /> bis zum Ende dieser Instanz  
  
 - oder -   
  
 <paramref name="count" /> ist größer als die Länge des Teilarrays von <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destination" />-Arrays.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die leere Zeichenfolge dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist die Zeichenfolge der Länge 0 (null), "".  
  
 Im Anwendungscode ist dieses Feld am häufigsten in Zuweisungen verwendet, um eine String-Variable auf eine leere Zeichenfolge zu initialisieren. So testen Sie, ob der Wert einer Zeichenfolge entweder `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, verwenden Sie die <xref:System.String.IsNullOrEmpty%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> mit dem Ende dieser Instanz übereinstimmt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teilzeichenfolge am Ende dieser Instanz, die gleiche Länge wie `value`, und gibt einen Wert zurück, ob sie gleich sind. Gleich, `value` muss ein Verweis auf die gleiche Instanz oder Übereinstimmung mit dem Ende dieser Instanz.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel gibt an, ob jede Zeichenfolge in ein Array mit einem Punkt endet (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 Das folgende Beispiel definiert eine `StripEndTags` Methode, verwendet die <xref:System.String.EndsWith%28System.String%29> Methode, um HTML-Endtags vom Ende einer Zeile zu entfernen. Beachten Sie, dass die `StripEndTags` Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-Endtags am Ende der Zeile entfernt werden.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der bestimmt, wie diese Zeichenfolge und <c>Wert</c> verglichen werden.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.EndsWith%2A> -Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge und gibt einen Wert, der angibt, ob sie gleich sind. Als gleich ansehen `value` ein Verweis auf die gleiche Zeichenfolge ist, eine leere Zeichenfolge (""), oder mit das Ende dieser Zeichenfolge übereinstimmt. Der Typ des Vergleichs von ausgeführten der <xref:System.String.EndsWith%2A> Methode hängt vom Wert von der `comparisonType` Parameter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet. Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmt, wie diese Instanz und <c>Wert</c> verglichen werden. Wenn <c>Kultur</c> ist <see langword="null" />, die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge, die gleiche Länge wie `value`, und gibt einen Wert, der angibt, ob sie gleich sind. Gleich, `value` muss ein Verweis auf die gleiche Instanz oder mit dem Ende dieser Zeichenfolge übereinstimmt.  
  
 Diese Methode vergleicht Word (kulturabhängige) mit der angegebenen Groß-/Kleinschreibung und Kultur entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Ende einer anderen Zeichenfolge auftritt. Die <xref:System.String.EndsWith%2A> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein angegebenes Objekt, das ebenfalls ein <see cref="T:System.String" />-Objekt sein muss, denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> ein <see cref="T:System.String" /> ist und denselben Wert wie diese Instanz hat; andernfalls <see langword="false" />.  Wenn <paramref name="obj" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein anderes angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Instanz denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="value" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode. Vergleicht das Title-Schreibweise angegeben Wort "File" ein Wort entspricht, dessen Entsprechung in Kleinbuchstaben, dessen Entsprechung in Großbuchstaben und ein Wort, das LATEINISCH kleine Buchstaben ohne Punkte I enthält (U + 0131) anstelle von kleinen Buchstaben LATEINISCH I (U + 0069). Da die <xref:System.String.Equals%28System.String%29> -Methode führt einen Ordinalvergleich durch, nur für der Vergleich mit einer identischen Wort gibt `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="a" /> und <paramref name="b" /> <see langword="null" /> sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die angeben, wie die Zeichenfolgen verglichen werden.</param>
        <summary>Bestimmt, ob diese Zeichenfolge und ein angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Zeichenfolge denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen ignorieren die Groß-/Kleinschreibung die zwei verglichenen Zeichenfolgen oder Word oder Ordinalsortierung verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von Zeichenfolgen, die der Großbuchstabe "I", einen Kleinbuchstaben "i" und ohne Punkte "ı" besteht. Er ruft dann die <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> Methode, um sie miteinander vergleichen mit jedem möglichen <xref:System.StringComparison> -Enumerationswert.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedes Mitglied der <xref:System.StringComparison> Enumeration.  Die Vergleiche, die Konventionen der Kulturen Nord-Sami (Schweden oberen) und Englisch (Vereinigte Staaten) verwenden. Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Nord-Sami (Schweden Nord) berücksichtigt werden.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für den Vergleich angibt.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns>
          <see langword="true" />, wenn der Wert des <paramref name="a" />-Parameters dem Wert des <paramref name="b" />-Parameters entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen ignorieren die Groß-/Kleinschreibung die zwei verglichenen Zeichenfolgen oder Word oder Ordinalsortierung verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedes Mitglied der <xref:System.StringComparison> Enumeration.  Die Vergleiche, die Konventionen der Kulturen Nord-Sami (Schweden oberen) und Englisch (Vereinigte Staaten) verwenden. Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Nord-Sami (Schweden Nord) berücksichtigt werden.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert auf der Grundlage der angegebenen Formate den Wert von Objekten in Zeichenfolgen und fügt sie in eine andere Zeichenfolge ein.  
  
 Wenn Sie noch nicht mit sind die <see cref="Overload:System.String.Format" /> -Methode finden Sie unter der [Einstieg in die String.Format-Methode](#Starting) Abschnitt, um eine kurze Übersicht über.  
  
 Finden Sie unter der ["Hinweise"](#Format_Syntax) Abschnitt für die vollständige Dokumentation aller <see cref="Overload:System.String.Format" /> Überladungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Abschnitt  
  
 [Erste Schritte mit der String.Format-Methode](#Starting)   
 [Überladene Methodensyntax](#Format_Syntax)   
 [Parameter](#Format_Params)   
 [Rückgabewert](#Format_Returns)   
 [Ausnahmen](#Format_Exceptions)   
 [Welche Methode werden aufgerufen?](#FTaskList)   
 [In Kürze die Format-Methode](#Format_Brief)   
 [Das Formatelement](#FormatItem)   
 [Formatierung von Argumenten](#HowFormatted)   
 [Formatelemente, die den gleichen Index aufweisen.](#SameIndex)   
 [Formatierung und Kultur](#Format_Culture)   
 [Benutzerdefinierte Formatierung Vorgänge](#Format_Custom)   
 Beispiele:   
 [Formatieren ein einzelnes argument](#Format1_Example)  
 [Formatieren von zwei Argumenten](#Format2_Example)  
 [Formatieren von drei Argumenten](#Format3_Example)  
 [Formatieren von mehr als drei Argumente](#Format4_Example)  
 [Kulturabhängige Formatierung](#Format5_Example)  
 [Eine benutzerdefinierte Formatierungsvorgang](#Format6_Example)  
 [Eine Konstante Glied-Anbieter und römische Zahlzeichen Formatierer](#Format7_Example)  
[Versionsinformationen](#Format_Versions)  
[String.Format Fragen und Antworten](#QA)  
  
<a name="Starting"></a>   
## <a name="getting-started-with-the-stringformat-method"></a>Erste Schritte mit der String.Format-Methode  
 Verwendung <xref:System.String.Format%2A?displayProperty=nameWithType> , wenn den Wert eines Objekts, eine Variable oder ein Ausdruck in eine andere Zeichenfolge eingefügt werden müssen. Sie können beispielsweise den Wert des Einfügen einer <xref:System.Decimal> Wert in eine Zeichenfolge, die es dem Benutzer als einzelne Zeichenfolge anzuzeigen:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Und Sie können die Formatierung des Werts steuern:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Neben dem formatieren, können Sie auch die Ausrichtung und Abstand steuern.  
  
 Eine Zeichenfolge eingefügt.  
 <xref:System.String.Format%2A?displayProperty=nameWithType>beginnt mit einer Formatzeichenfolge, gefolgt von Objekten oder Ausdrücke, die in Zeichenfolgen konvertiert und an einem angegebenen Speicherort gespeichert, in der Formatzeichenfolge eingefügt werden. Zum Beispiel:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Die `{0}` im Format Zeichenfolge eines Formatelements ist. `0`ist der Index des Objekts, dessen Zeichenfolgenwert an dieser Position eingefügt werden soll. (Indizes beginnen bei 0.) Wenn das einzufügende Objekt nicht um eine Zeichenfolge ist ihre `ToString` Methode wird aufgerufen, um es zu einem vor dem Einfügen in die Ergebniszeichenfolge konvertieren.  
  
 Hier ist ein weiteres Beispiel, das zwei Formatelemente und zwei Objekte in der Objektliste verwendet:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Sie können beliebig viele Formatelemente und wie viele Objekte in der Objektliste, wie Sie möchten, solange der Index der jedes Formatelement kein übereinstimmendes Objekt in der Objektliste verfügt. Ferner müssen nicht Gedanken machen, rufen Sie über die Überlastung; der Compiler wird für Sie ausgewählt.  
  
 Steuern der Formatierung  
 Führen Sie den Index in einem Formatelement mit einer Formatzeichenfolge steuern, wie ein Objekt formatiert ist. Beispielsweise `{0:d}` betrifft die Formatzeichenfolge "d" das erste Objekt in der Objektliste. Hier ist ein Beispiel mit einem einzelnen Objekt und zwei Elemente formatieren:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Eine Anzahl von Typen unterstützen Formatzeichenfolgen, einschließlich aller numerische Typen (sowohl [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-numeric-format-strings.md) Formatieren von Zeichenfolgen), alle Datumsangaben und Uhrzeiten (Bot h [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Formatieren von Zeichenfolgen) und Zeitintervalle (beide [zusammen d](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-timespan-format-strings.md) Formatieren von Zeichenfolgen), alle Enumerationstypen [Enumerationstypen](~/docs/standard/base-types/enumeration-format-strings.md), und                                          [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx). Sie können auch Unterstützung für Formatzeichenfolgen für Ihre eigenen Typen hinzufügen.  
  
 Steuern der Abstand  
 Sie können die Breite der Zeichenfolge, die in die Ergebniszeichenfolge eingefügt wird, wie z. B. mit der Syntax definieren `{0,12}`, eine Zeichenfolge mit 12 Zeichen eingefügt. In diesem Fall wird die Zeichenfolgendarstellung des ersten Objekts rechtsbündig im Feld 12 Zeichen.  (Ist die Zeichenfolgendarstellung des ersten Objekts maximal 12 Zeichen lang sein, jedoch die bevorzugte Feldbreite wird ignoriert, und die gesamte Zeichenfolge wird in die Ergebniszeichenfolge eingefügt.)  
  
 Das folgende Beispiel definiert ein Feld 6 Zeichen zum Speichern der Zeichenfolge "Year" und einige Jahr Zeichenfolgen, sowie ein Feld 15-Zeichen für die Zeichenfolge "Auffüllung" und einige Daten auffüllen. Beachten Sie, dass die Zeichen rechtsbündig in das Feld.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 Steuern der Ausrichtung  
 Standardmäßig sind Zeichenfolgen in ihren Feld rechtsbündig ausgerichtet, wenn Sie eine Feldbreite anzugeben. Um Zeichenfolgen in einem Feld linksbündig, Sie voranstellen die Feldbreite ein negatives Vorzeichen, z. B. `{0,-12}` so definieren Sie einen 12-stelligen-Feld rechtsbündig ausgerichtet.  
  
 Im folgende Beispiel ähnelt der vorherigen Abfrage, außer dass sie sowohl Daten als auch Bezeichnungen linksbündig ausgerichtet.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType>Verwenden der Funktion für kombinierte Formatierung. Weitere Informationen finden Sie unter [Zusammengesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="Format_Syntax"></a>   
## <a name="overloaded-method-syntax"></a>Überladene Methodensyntax  
 Weitere Anleitungen zum Auswählen einer Überladung finden Sie unter [welche Methode aufrufen?](#FTaskList)  
  
 `String String.Format(String format, Object arg0)`  
 Ersetzt die Formatelemente durch die Zeichenfolgendarstellung eines angegebenen Objekts ([Beispiel](#Format1_Example)).  
  
 `String String.Format(String format, Object arg0, Object arg1)`  
 Ersetzt die Formatelemente durch die Zeichenfolgendarstellung von zwei angegebenen Objekten ([Beispiel](#Format2_Example)).  
  
 `String String.Format(String format, Object arg0, Object arg1, Object arg2)`  
 Ersetzt die Formatelemente durch die Zeichenfolgendarstellung von drei angegebenen Objekten ([Beispiel](#Format3_Example)).  
  
 `String String.Format(String format, params Object[] args)`  
 Ersetzt die Formatelemente durch die zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array ([Beispiel](#Format4_Example)).  
  
 `String String.Format(IFormatProvider provider, String format, params Object[] args)`  
 Ersetzt die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in einem angegebenen Array und der angegebenen kulturspezifischen Formatierungsinformationen verwendet ([Beispiel](#Format5_Example)) oder benutzerdefinierte Formatierung Informationen ([Beispiel](#Format6_Example)).  
  
<a name="Format_Params"></a>   
## <a name="parameters"></a>Parameter  
 Dies ist eine vollständige Liste der Parameter für die <xref:System.String.Format%2A> -Methode; Weitere Informationen finden Sie die Syntax der Überladung oben für die Parameter, die durch jede Überladung verwendet. Nur die `format` Parameter wird verwendet, indem Sie alle Überladungen.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`format`|<xref:System.String>|Eine kombinierte Formatzeichenfolge, die eine oder mehrere Formatelemente enthält (siehe [das Formatelement](#FormatItem)).|  
|`arg0`|<xref:System.String>|Der erste oder nur zu formatierende Objekt.|  
|`arg1`|<xref:System.String>|Das zweite zu formatierende Objekt.|  
|`arg2`|<xref:System.String>|Das dritte zu formatierende Objekt.|  
|`args`|<xref:System.String>[]|NULL oder mehr Objekte zum Formatieren in einer durch Trennzeichen getrennte Liste oder als Array angegeben.|  
|`provider`|<xref:System.IFormatProvider>|Ein Objekt, das benutzerdefinierte oder kulturspezifische Formatierungsinformationen bereitstellt.|  
  
<a name="Format_Returns"></a>   
## <a name="return-value"></a>Rückgabewert  
 Typ: <xref:System.String>  
Eine Kopie des `format` in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Argumente ersetzt wurden.  
  
<a name="Format_Exceptions"></a>   
## <a name="exceptions"></a>Ausnahmen  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`format` ist `null`.|Alle Überladungen.|  
|<xref:System.FormatException>|`format` ist ungültig.<br /><br /> - oder - <br /><br /> Der Index eines Formatelements ist kleiner als 0 oder größer als oder gleich der Anzahl von Argumenten in der Argumentliste.|Alle Überladungen.|  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode werden aufgerufen?  
  
|Beschreibung|Call|  
|--------|----------|  
|Ein oder mehrere Objekte mit den Konventionen der aktuellen Kultur zu formatieren.|Mit Ausnahme der Überladungen, die eine `provider` Parameter, die verbleibenden <xref:System.String.Format%2A> Überladungen enthalten einen <xref:System.String> Parameter gefolgt von mindestens einem Objektparameter. Aus diesem Grund Sie keine ermitteln, welche <xref:System.String.Format%2A> Überladung, die Sie aufrufen möchten. Der Sprachcompiler wählt die entsprechende Überladung aus der Überladungen, die keine `provider` basierend auf Ihrer Typargumentliste-Parameter. Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, der Compiler Ruft die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> Methode.|  
|Ein oder mehrere Objekte mit den Konventionen einer bestimmten Kultur zu formatieren.|Jede <xref:System.String.Format%2A> Überladung, die mit beginnt ein `provider` Parameter gefolgt von einer <xref:System.String> Parameter und mindestens einen Parameter-Objekt. Aus diesem Grund Sie keine um zu bestimmen, welche spezifischen <xref:System.String.Format%2A> Überladung, die Sie aufrufen möchten. Der Sprachcompiler wählt die entsprechende Überladung aus der Überladungen, die über eine `provider` basierend auf Ihrer Typargumentliste-Parameter. Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, der Compiler Ruft die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode.|  
|Führen Sie einem benutzerdefinierten Formatierungsvorgang eine mit einer <xref:System.ICustomFormatter> Implementierung oder ein <xref:System.IFormattable> Implementierung.|Einer der vier Überladungen mit einem `provider` Parameter. Compiler wählt die entsprechende Überladung aus der Überladungen, die über eine `provider` basierend auf Ihrer Typargumentliste-Parameter.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>In Kürze die Format-Methode  
 Jeder Überladung der <xref:System.String.Format%2A> -Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) nullbasierte indizierte Platzhaltern, so genannten Formatelementen, in eine zusammengesetzte Formatzeichenfolge eingeschlossen. Jedes Formatelement wird zur Laufzeit durch die Zeichenfolgendarstellung des entsprechenden Arguments in einer Parameterliste ersetzt. Wenn der Wert des Arguments `null`, ersetzt das Formatelement mit <xref:System.String.Empty?displayProperty=nameWithType>. Beispielsweise beim folgenden Aufruf der <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode enthält eine Formatzeichenfolge mit drei Formatelemente, {0}, \ {1\}, \ {2\} und eine Liste der Typargumente mit drei Elementen.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Das Formatelement  
 Einem Formatelement hat folgende Syntax:  
  
```  
  
{  
index[,alignment][ :formatString] }  
```  
  
 Klammern bezeichnen optionale Elemente. Die öffnende und schließende geschweifte Klammern sind erforderlich. (Um enthalten eine literale öffnende bzw. schließende geschweifte Klammer in der Formatzeichenfolge finden im Abschnitt "Geschweiften Klammern mit Escapezeichen zu versehen" die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Artikel.)  
  
 Beispielsweise die einem Formatelement in das Format, die ein Currency-Wert kann wie folgt angezeigt:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
  
 Einem Formatelement beinhaltet die folgenden Elemente:  
  
 *Index*  
 Der nullbasierte Index des Arguments, dessen zeichenfolgedarstellung werden an dieser Position in der Zeichenfolge enthalten. Wenn dieses Argument `null`, keine leere Zeichenfolge wird an dieser Position in der Zeichenfolge enthalten sein.  
  
 *Ausrichtung*  
 Dies ist optional. Eine Ganzzahl mit Vorzeichen, die die Gesamtlänge des Felds angibt, in der das Argument eingefügt wird und ob sie rechtsbündig (eine positive ganze Zahl) oder linksbündig ausgerichtet (eine negative ganze Zahl). Wenn Sie weglassen *Ausrichtung*, die Zeichenfolgendarstellung des entsprechenden Arguments in einem Feld keine führenden oder nachgestellten Leerzeichen eingefügt wird.  
  
 Wenn der Wert der *Ausrichtung* ist kleiner als die Länge des Arguments eingefügt werden, *Ausrichtung* wird ignoriert, und die Länge der Zeichenfolgendarstellung des Arguments wird als Feldbreite verwendet.  
  
 *"FormatString"*  
 Dies ist optional. Eine Zeichenfolge, die das Format der Ergebniszeichenfolge das entsprechende Argument angibt. Wenn Sie weglassen *"FormatString"*, das entsprechende Argument des parameterlosen `ToString` Methode wird aufgerufen, um die Zeichenfolgendarstellung zu erzeugen. Bei Angabe von *"FormatString"*, muss das Argument, das Formatelement verweist implementieren die <xref:System.IFormattable> Schnittstelle. Die Formatzeichenfolgen unterstützen die folgenden Anweisungstypen:  
  
-   Alle Ganzzahl- und Gleitkommatypen. (Siehe [standardmäßige numerische Formatzeichenfolgen](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> und <xref:System.DateTimeOffset>. (Siehe [Formatzeichenfolgen Standardformatbezeichner für Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Alle Enumerationstypen. (Siehe [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan>-Werte sind. (Siehe [TimeSpan-Standardformatzeichenfolgen](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte TimeSpan-Formatzeichenfolgen](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Siehe die <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Methode.)  
  
 Beachten Sie jedoch, dass jeder beliebige benutzerdefinierter Typ implementieren, kann <xref:System.IFormattable> oder Erweitern eines vorhandenen Typs <xref:System.IFormattable> Implementierung.  
  
 Im folgenden Beispiel wird die `alignment` und `formatString` Argumente formatierte Ausgabe zu erzeugen.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Formatierung von Argumenten  
 Formatelement werden sequenziell vom Anfang der Zeichenfolge verarbeitet. Jedes Formatelement verfügt über einen Index, der ein Objekt in der Argumentliste der Methode entspricht. Die <xref:System.String.Format%2A> Methode ruft das Argument und seine Zeichenfolgendarstellung wie folgt abgeleitet:  
  
-   Wenn das Argument ist `null`, fügt die Methode <xref:System.String.Empty?displayProperty=nameWithType> in der Ergebniszeichenfolge.  
  
-   Beim Aufrufen der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> überladen und die `provider` -Parameter implementiert die <xref:System.ICustomFormatter> -Schnittstelle, wird das Argument zu übergeben der `provider` des Objekts <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode. Wenn die Formatelement enthält eine *"FormatString"* Argument, es wird als erstes Argument an die Methode übergeben. Wenn die <xref:System.ICustomFormatter> Implementierung kann Formatierung Dienstleistungen, es gibt die Zeichenfolgendarstellung des Arguments zurück; zurückgegeben, andernfalls `null` und der nächste Schritt ausgeführt wird.  
  
-   Wenn das Argument implementiert die <xref:System.IFormattable> -Schnittstelle, die <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> -Implementierung aufgerufen wird.  
  
-   Das Argument des parameterlosen `ToString` -Methode, die überschrieben oder geerbt von der <xref:System.Object> Klasse, die aufgerufen wird.  
  
 Ein Beispiel für die Aufrufe fängt die <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> Methode und ermöglicht Ihnen, welche Informationen finden Sie unter der <xref:System.String.Format%2A> -Methode übergibt, einer Formatierungsmethode für jedes Formatelement in einer zusammengesetzten Formatzeichenfolge finden Sie unter [Beispiel 7: Intercept-Anbieter und römische Zahlzeichen Formatierer](#Format7_Example).  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Formatelemente, die den gleichen Index aufweisen.  
 Die <xref:System.String.Format%2A> -Methode löst eine <xref:System.FormatException> -Ausnahme aus, wenn der Index eines Elements Index größer als oder gleich der Anzahl von Argumenten in der Argumentliste ist. Allerdings `format` zählen mehr Formatelementen, die als Argumente vorhanden sind, solange mehrere Formatelemente denselben Index verfügen. Im Aufruf der <xref:System.String.Format%28System.String%2CSystem.Object%29> Methode im folgenden Beispiel wird die Liste der Typargumente hat ein einzelnes Argument, aber die Formatzeichenfolge enthält zwei Formatelemente: eine zeigt den Dezimalwert einer Zahl und das andere seinem Hexadezimalwert.  
  
 [!code-csharp[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatierung und Kultur  
 Im Allgemeinen Objekte in der Argumentliste mit den Konventionen der aktuellen Kultur, die von zurückgegeben wird, deren zeichenfolgendarstellungen konvertiert werden die <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft. Sie können dieses Verhalten steuern, indem eine der Überladungen der Aufrufen <xref:System.String.Format%2A> , umfasst eine `provider` Parameter. Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, die benutzerdefinierte und kulturspezifische Formatierungsinformationen bereitstellt, die verwendet wird, um die Formatierung Mittel zu verarbeiten.  
  
 Die <xref:System.IFormatProvider> Schnittstelle verfügt über einen einzelnen Member, <xref:System.IFormatProvider.GetFormat%2A>, die für das Objekt, das Formatierungsinformationen liefert zurückgeben verantwortlich ist. .NET Framework verfügt über drei <xref:System.IFormatProvider> Implementierungen, die kulturspezifische Formatierung bereitstellen:  
  
-   <xref:System.Globalization.CultureInfo>. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methodenrückgabe eine kulturspezifische <xref:System.Globalization.NumberFormatInfo> Objekt zum Formatieren von numerischen Werten und eine kulturspezifische <xref:System.Globalization.DateTimeFormatInfo> Objekt zum Formatieren von Datums-und Uhrzeitwerte.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, der kulturabhängige Formatierung von Datums-und Uhrzeitwerte verwendet wird. Die <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> Methodenrückgabe selbst.  
  
-   <xref:System.Globalization.NumberFormatInfo>, der kulturabhängige Formatierung von numerischen Werten verwendet wird. Die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Eigenschaft gibt sich selbst zurück.  
  
<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Benutzerdefinierte Formatierung Vorgänge  
 Sie können auch eine der Überladungen der Aufrufen der <xref:System.String.Format%2A> -Methode, die über eine `provider` Parameter <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Überladung, um die benutzerdefinierte Formatierung Vorgänge auszuführen. Sie konnten z. B. eine ganze Zahl als eine ID oder eine Telefonnummer formatieren. Benutzerdefinierte Formatierung Ausführen Ihrer `provider` Argument muss sowohl implementieren die <xref:System.IFormatProvider> und <xref:System.ICustomFormatter> Schnittstellen. Wenn die <xref:System.String.Format%2A> -Methode übergeben ein <xref:System.ICustomFormatter> Implementierung als die `provider` Argument, die <xref:System.String.Format%2A> Methodenaufrufe seine <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Implementierung und fordert ein Objekt vom Typ <xref:System.ICustomFormatter>. Er ruft dann das zurückgegebene <xref:System.ICustomFormatter> des Objekts <xref:System.ICustomFormatter.Format%2A> Methode so formatieren Sie jedes Formatelement in der zusammengesetzte Zeichenfolge übergeben.  
  
 Weitere Informationen zum Bereitstellen von Lösungen für benutzerdefinierte Formatierung finden Sie unter [wie: definieren und benutzerdefinierten numerischen Formatanbietern verwenden](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) und <xref:System.ICustomFormatter>. Ein Beispiel für die ganze Zahlen in formatierte benutzerdefinierte Zahlen umwandelt, finden Sie unter [Beispiel 6: eine benutzerdefinierte Formatierungsvorgang](#Format6_Example). Ein Beispiel, das römische Ziffern Bytes ohne Vorzeichen konvertiert werden, finden Sie unter [Beispiel 7: einen Intercept-Anbieter und römische Zahlzeichen Formatierer](#Format7_Example).  
  
<a name="Format1_Example"></a>   
## <a name="example-1-formatting-a-single-argument"></a>Beispiel 1: Formatieren eines einzelnen Arguments  
 Im folgenden Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%29> Methode, um ein einzelnes Alter in der Mitte einer Zeichenfolge einzubetten.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  
  
<a name="Format2_Example"></a>   
## <a name="example-2-formatting-two-arguments"></a>Beispiel 2: Formatieren von zwei Argumenten  
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> anzuzeigenden Zeit und die Temperatur Datenspeichern in eine generische Methode <xref:System.Collections.Generic.Dictionary%602> Objekt. Beachten Sie, dass die Formatzeichenfolge drei Formatelemente, obwohl nur zwei Objekte so formatieren Sie vorhanden sind. Ursache hierfür ist das erste Objekt in der Liste (ein Wert für Datum und Uhrzeit) durch zwei Formatelementen verwendet wird: das erste Format Element zeigt die Zeit, während die zweite zeigt das Datum an.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
  
<a name="Format3_Example"></a>   
## <a name="example-3-formatting-three-arguments"></a>Beispiel 3: Formatieren von drei Argumenten  
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode, um eine Zeichenfolge zu erstellen, die das Ergebnis ein boolescher Wert veranschaulicht `And` -Operation mit zwei ganzzahligen Werten. Beachten Sie, dass die Formatzeichenfolge sechs Formatelemente enthält, aber die Methode verfügt über nur drei Elemente in der Parameterliste, da jedes Element auf zwei unterschiedliche Arten formatiert wird.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
  
<a name="Format4_Example"></a>   
## <a name="example-4-formatting-more-than-three-arguments"></a>Beispiel 4: Formatieren von mehr als drei Argumente  
 Dieses Beispiel erstellt eine Zeichenfolge, die Daten auf den Höchst- und Tiefsttemperatur an einem bestimmten Datum enthält. Die zusammengesetzte Formatierungszeichenfolge verfügt über fünf Formatelemente im C#-Beispiel und sechs in Visual Basic-Beispiel. Zwei der die Formatelemente definieren die Breite der Zeichenfolgendarstellung des Werts auf ihre entsprechenden, und das erste Formatelement enthält auch Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolge.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Sie können auch die Objekte, die als Array formatiert werden übergeben und nicht als eine Argumentliste.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  
  
<a name="Format5_Example"></a>   
## <a name="example-5-culture-sensitive-formatting"></a>Beispiel 5: Kulturabhängige Formatierung  
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode, um die Zeichenfolgendarstellung für einige Datums-und Uhrzeitwerte und numerische Werte anzeigen, indem Sie verschiedene Kulturen verwenden.  
  
 [!code-csharp[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  
  
<a name="Format6_Example"></a>   
## <a name="example-6-a-custom-formatting-operation"></a>Beispiel 6: Eine benutzerdefinierte Formatierungsvorgang  
 In diesem Beispiel definiert einen Formatanbieter, der einen ganzzahligen Wert als die Kontonummer eines Kunden in der Form X-Xxxxx-Xx formatiert.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
## <a name="example-7-an-intercept-provider-and-roman-numeral-formatter"></a>Beispiel 7: Einen Intercept-Anbieter und das römische Zahlzeichen Formatierer  
 In diesem Beispiel wird einen benutzerdefiniertes Format-Anbieter, implementiert die <xref:System.ICustomFormatter> und <xref:System.IFormatProvider> Schnittstellen zwei Dinge tun:  
  
-   Es zeigt die Parameter, dessen <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> Implementierung. Dies ermöglicht es, zu welchen Parameter finden Sie unter der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode für die benutzerdefinierte Formatierung Implementierung für jedes Objekt, das er versucht, formatieren Sie übergeben wird. Dies kann nützlich sein, wenn Sie Ihre Anwendung debuggen.  
  
-   Wenn das Objekt zu formatierenden ein Byte ohne Vorzeichen-Wert, der mit der Standardformatzeichenfolge "R" formatiert werden, formatiert das benutzerdefinierte Formatierungsprogramm den numerischen Wert als eine römische Zahlzeichen an.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="Format_Versions"></a>   
## <a name="version-information"></a>Versionsinformationen  
 .NET Framework  
 Alle Überladungen werden unterstützt: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Alle Überladungen werden unterstützt: 4, 3.5 SP1  
  
 Portable Klassenbibliothek  
 Nur <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> und <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> werden unterstützt  
  
 .NET für Windows Store-Apps  
 Nur <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> und <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> in Windows 8 unterstützt werden  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format Fragen und Antworten  
  
### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Wo finde ich eine Liste der vordefinierten Formatierungszeichenfolgen, die mit Formatelementen verwendet werden können?  
  
-   Alle Ganzzahl- und Gleitkommatypen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Datum und Uhrzeit-Werte finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte Datums- und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Enumerationswerte finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Für <xref:System.TimeSpan> -Werte finden Sie in [TimeSpan-Standardformatzeichenfolgen](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte TimeSpan-Formatzeichenfolgen](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Für <xref:System.Guid> -Werte finden Sie im Abschnitt "Hinweise" der <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Referenzseite.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Wie können die Ausrichtung des Ergebniszeichenfolgen werden gesteuert, die Formatelemente ersetzen?  
 Die allgemeine Syntax eines Formatelements ist:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 wobei *Ausrichtung* ist eine Ganzzahl mit Vorzeichen, die die Breite des Felds definiert. Wenn dieser Wert negativ ist, wird Text im Feld linksbündig ausgerichtet. Wenn er positiv ist, ist Text rechtsbündig ausgerichtet.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Wie können die Anzahl der Ziffern nach dem Dezimaltrennzeichen werden gesteuert?  
 Alle [standardmäßige numerische Formatzeichenfolgen](~/docs/standard/base-types/standard-numeric-format-strings.md) außer "D" (die mit nur ganze Zahlen verwendet wird), "G", "R" und "X" ermöglichen ein Genauigkeitsbezeichner angegeben, die die Anzahl von Dezimalstellen in der Ergebniszeichenfolge definiert. Im folgenden Beispiel wird die standardmäßige numerische Formatzeichenfolgen, die Anzahl der Dezimalstellen in der Ergebniszeichenfolge steuern.  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Bei Verwendung einer [benutzerdefinierte numerische Formatzeichenfolge](~/docs/standard/base-types/custom-numeric-format-strings.md), den Formatbezeichner "0" zum Steuern der Anzahl von Dezimalstellen in der Ergebniszeichenfolge an, wie im folgenden Beispiel gezeigt verwenden.  
  
 [!code-csharp[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Wie können die Anzahl von ganzzahligen Ziffern werden gesteuert?  
 Standardmäßig werden Formatierungsvorgänge nur ganze Zahlen ungleich 0 (null) angezeigt. Wenn Sie ganze Zahlen formatieren, können Sie ein Genauigkeitsbezeichner angegeben, mit der "D" und "X" standard verwendete Formatzeichenfolgen, die Anzahl der Ziffern steuern.  
  
 [!code-csharp[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Sie können eine ganze Zahl oder Gleitkommazahl mit führenden Nullen, um eine Ergebniszeichenfolge, die mit einer angegebenen Anzahl von ganzzahligen Ziffern zu erstellen, indem Sie mit dem Wert "0" Auffüllen [benutzerdefinierte numerische Formatbezeichner](~/docs/standard/base-types/custom-numeric-format-strings.md), wie das folgende Beispiel zeigt.  
  
 [!code-csharp[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Wie viele Elemente kann ich in der Formatliste aufnehmen?  
 Es gibt keine praktische Begrenzung. Der zweite Parameter von der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode wird mit markiert die <xref:System.ParamArrayAttribute> -Attribut, das Ihnen ermöglicht, eine durch Trennzeichen getrennte Liste oder einem Objektarray als Ihrer Formatliste enthalten.  
  
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Wie schließen literal geschweifte Klammern ("{" und "}") in der Ergebniszeichenfolge?  
 Z. B. wie Sie, dass die folgenden Methodenaufruf aus Auslösen einer <xref:System.FormatException> Ausnahme?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Eine einzelne öffnende oder schließende geschweifte Klammer wird immer als Anfang oder Ende eines Formatelements interpretiert. Um als Zeichenliteral interpretiert werden, müssen sie mit Escapezeichen versehen werden. Sie eine geschweifte Klammer durch Hinzufügen von einem anderen geschweifte Klammer mit Escapezeichen versehen ("{{" und "}}" anstelle von "{" und "}"), wie im folgenden Methodenaufruf:  
  
 [!code-csharp[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Geschweifte Klammern selbst mit Escapezeichen sind jedoch leicht fehlinterpretiert. Es wird empfohlen, dass Sie die geschweiften Klammern, in der Formatliste einschließen und Formatelemente zum Einfügen in die Ergebniszeichenfolge wie im folgenden Beispiel gezeigt verwenden.  
  
 [!code-csharp[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Warum wird meine Aufruf der Methode String.Format FormatException ausgelöst?  
 Die häufigste Ursache der Ausnahme ist, dass der Index eines Formatelements ein Objekt in der Formatliste entsprechen nicht. In der Regel bedeutet dies, dass haben Sie die Indizes der Formatelemente misnumbered, oder Sie vergessen haben, ein Objekt in der Formatliste enthalten. In einigen Fällen ist die Ausnahme das Ergebnis ein Tippfehler; Angenommen, ein typische Fehler falsch ist "[" (die öffnende spitze Klammer) anstelle von "{" (die linke geschweifte Klammer).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Wenn die Methode Format(System.IFormatProvider,System.String,System.Object[]) Parameterarrays, warum mein Code eine Ausnahme auslöst unterstützt, wenn ich ein Array verwenden?  
 Im folgenden Codebeispiel löst eine <xref:System.FormatException> Ausnahme:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Dies ist ein Problem der Compiler überladungsauflösung gelten. Da der Compiler ein Array von Ganzzahlen in einem Objektarray konvertieren kann, behandelt das Array von Ganzzahlen als ein einziges Argument, damit aufruft die <xref:System.String.Format%28System.String%2CSystem.Object%29> Methode. Die Ausnahme wird ausgelöst, da es vier Formatelemente aber nur ein einzelnes Element in der Formatliste gibt.  
  
 Da weder Visual Basic oder c# ein Array von Ganzzahlen in einem Objektarray konvertieren kann, müssen Sie die Konvertierung ausführen selbst vor dem Aufruf der <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> Methode. Im folgende Beispiel stellt eine Implementierung bereit.  
  
 [!code-csharp[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt ein oder mehrere Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der alle Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Das Formatelement in <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist nicht 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt das Formatelement in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines entsprechenden Objekts in einem angegebenen Array.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 oder größer als oder gleich der Länge der <paramref name="args" /> Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung des angegebenen Objekts. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> oder <paramref name="arg0" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 (null) oder größer als oder gleich 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 oder größer als oder gleich der Länge der <paramref name="args" /> Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist nicht 0 (null) oder 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />, <paramref name="arg0" /> oder <paramref name="arg1" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 (null) oder größer als oder gleich 2.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Ein [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Format` -Methode, finden Sie unter der <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />, <paramref name="arg0" />, <paramref name="arg1" /> oder <paramref name="arg2" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
 - oder -   
  
 Der Index eines Formatelements ist kleiner als 0 (null) oder größer als oder gleich 3.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Objekt ab, das die einzelnen Zeichen dieser Zeichenfolge durchlaufen kann.</summary>
        <returns>Ein Enumeratorobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Anstatt Aufrufen der <xref:System.String.GetEnumerator%2A> Methode zum Abrufen einer <xref:System.CharEnumerator> Objekt, das Sie dann verwenden, um eine Zeichenfolge aufzulisten, verwenden Sie stattdessen Ihre Sprachkonstrukt Iteration (in c# in C + c++ / CLR, und in Visual Basic).                   [Foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in c# [für jede](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) in C + c++ / CLR und [für jede](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).  
  
 Diese Methode können Sie die einzelnen Zeichen in einer Zeichenfolge durchlaufen werden kann. Z. B. Visual Basic `For Each` und C#- `foreach` Anweisungen rufen Sie diese Methode zum Zurückgeben einer <xref:System.CharEnumerator> Objekt, das nur-Lese-Zugriff auf die Zeichen dieser Zeichenfolgeninstanz bereitstellen kann.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft die Zeichen in mehreren Zeichenfolgen und zeigt Informationen zu den einzelnen Zeichen. Er verwendet die Iteration Sprachkonstrukt statt einen Aufruf der <xref:System.String.GetEnumerator%2A> Methode.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Zeichenfolge zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten des <xref:System.String.GetHashCode%2A> ist abhängig von seiner Implementierung, die von einer Version der common Language Runtime in einen anderen ändern kann. Ein Grund, warum dies vorkommen kann, wird zum Verbessern der Leistung von <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Wenn zwei Zeichenfolgenobjekte gleich sind, die <xref:System.String.GetHashCode%2A> -Methode identische Werte zurück. Es ist jedoch kein eindeutigen Hashcodewert für jeden eindeutigen Zeichenfolgenwert. Andere Zeichenfolgen können den gleichen Hashcode zurückgeben.  
>   
>  Der Hashcode selbst ist nicht garantiert stabil. Hashcodes für identische Zeichenfolgen können über den .NET Framework-Versionen und Plattformen (z. B. 32-Bit- und 64-Bit) für eine einzelne Version von .NET Framework unterscheiden. In einigen Fällen können sie auch nach Anwendungsdomäne unterscheiden. Dies bedeutet, dass zwei nachfolgende Ausführungen desselben Programms möglicherweise unterschiedliche Hashcodes zurückgeben.  
>   
>  Als Ergebnis Codes niemals außerhalb der Anwendungsdomäne verwendet werden sollte in der sie erstellt wurden, sollten niemals als Felder in einer Auflistung verwendet werden, und sie nie beibehalten werden soll.  
>   
>  Verwenden Sie schließlich den Hashcode nicht statt eines Werts von einer kryptografischen Hashfunktion zurückgegeben, wenn Sie einen kryptografisch starken Hash benötigen. Verwenden Sie für kryptografische Hashes eine abgeleitete Klasse die <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse.  
>   
>  Weitere Informationen zu Hashcodes finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Bei desktop-apps können Sie die [ \<UseRandomizedStringHashAlgorithm >-Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) zum Generieren eindeutiger Hashcodes für die eine pro Anwendungsdomäne. Dies kann verringern Sie die Anzahl der Konflikte und verbessern die allgemeine Leistung der Einfüge- und Suchvorgänge, die Hashtabellen verwenden. Das folgende Beispiel zeigt, wie Sie die [ \<UseRandomizedStringHashAlgorithm >-Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definiert eine zum Generieren eindeutiger Hashcodes für eine pro Anwendungsdomäne. Dies kann verringern Sie die Anzahl der Konflikte und verbessern die allgemeine Leistung der Einfüge- und Suchvorgänge, die Hashtabellen verwenden. Das folgende Beispiel zeigt, wie Sie die. Definiert eine `DisplayString` Klasse, die eine private Zeichenfolgenkonstante enthält `s`, dessen Wert ist "This is String". Außerdem enthält sie eine `ShowStringHashCode`-Methode, die den Zeichenfolgenwert und dessen Hashcode zusammen mit dem Namen der Anwendungsdomäne anzeigt, in der die Methode ausgeführt wird.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Wenn Sie das Beispiel ausführen, ohne eine Konfigurationsdatei anzugeben, wird die folgende Ausgabe angezeigt. Beachten Sie, dass die Hashcodes für die Zeichenfolge in den zwei Anwendungsdomänen identisch sind.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Wenn Sie jedoch die folgende Konfigurationsdatei im Verzeichnis des Beispiels hinzufügen und dann das Beispiel ausführen, unterscheiden sich die Hashcodes je nach Anwendungsdomäne.  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Wenn die Konfigurationsdatei vorhanden ist, zeigt das Beispiel die folgende Ausgabe an:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Hashcodes sind zum Einfügen und Abrufen von Schlüsseln Objekten effizient Hashtabellen verwendet. Hashcodes jedoch nicht eindeutig Zeichenfolgen identifiziert. Identische Zeichenfolgen haben gleich Hashcodes, aber die common Language Runtime kann auch den gleichen Hashcode in andere Zeichenfolgen zuweisen. Darüber hinaus variieren Hashcodes von .NET Framework-Version, von der Plattform in eine einzelne Version und nach Anwendungsdomäne. Aus diesem Grund sollten Sie nicht serialisieren oder Code Hashwerte beibehalten noch sollten Sie verwenden diese als Schlüssel in einer Hashtabelle oder dem Wörterbuch.  
  
 Weitere Informationen zur Verwendung von Hashcodes und `GetHashCode` -Methode finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.GetHashCode%2A> Methode, die mit verschiedenen Eingabezeichenfolgen.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Der Rückgabewert von <see cref="M:System.String.GetHashCode" /> ist plattformabhängig. Es unterscheidet sich auf die 32-Bit und 64-Bit-Versionen von .NET Framework. Sie können auch die unterscheidet sich zwischen verschiedenen Versionen von .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.TypeCode" /> für das <see cref="T:System.String" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.TypeCode> Enumerationskonstante, die für die <xref:System.String> Typ.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie suchen können eine <xref:System.String> für ein Zeichen unter Verwendung der <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur. Die Suche beginnt an der ersten Zeichenposition dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%29> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%29> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher sind in jedem Fall, da der bedingte Bindestrich ein ignorierbares Zeichen ist das Ergebnis das gleiche wie bei der bedingten Bindestrich in nicht enthalten war `value`. Bei der Suche nach nur einen bedingten Bindestrich gibt die Methode 0 (null), um anzugeben, dass es eine Übereinstimmung am Anfang der Zeichenfolge gefunden wurde.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach "n" in "Animal". Da die Zeichenfolge Indizes auf 0 (null) statt auf 1 beginnen die <xref:System.String.IndexOf%28System.String%29> Methode gibt an, dass die "n" an Position 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> Methode, um die Anfangsposition des Namens einer Eindringens in einem Satz zu bestimmen. Anschließend wird dieser Position verwendet, um ein Adjektiv einfügen, die in den Satz der Tier beschreibt.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um den ersten Index einer Teilzeichenfolge innerhalb einer Zeichenfolgeninstanz mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Die Suche erfolgt von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />ist kleiner als 0 (null) oder größer als die Länge der Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur. Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> immer Methodenrückgabe `startIndex`, also die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach allen Vorkommen einer angegebenen Zeichenfolge in eine Zielzeichenfolge.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um den ersten Index einer Teilzeichenfolge, die auftritt, nach einer bestimmten Zeichenposition mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird.  
  
 Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da der bedingte Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn der bedingte Bindestrich wurden nicht in der Suchzeichenfolge in enthalten. Eine ordinale Suche erfolgreich sucht den bedingten Bindestrich in eine Zeichenfolge und gibt an, dass er nicht vorhanden ist aus der zweiten Zeichenfolge.  
  
 [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)]
 [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
 - oder -   
  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur. Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> immer Methodenrückgabe `startIndex`, also die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index der alle Vorkommen der Zeichenfolge "he" in einer Teilzeichenfolge einer anderen Zeichenfolge. Beachten Sie, dass die Anzahl der Zeichen, die durchsucht werden für jede Iteration Suche neu berechnet werden muss.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
 - oder -   
  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um die Vergleichsregeln eines der aktuellen Kultur verwenden, um diesen Vorgang auszuführen, rufen die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge und den Typ der Suche an, die für die angegebene Zeichenfolge verwendet werden soll.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> immer Methodenrückgabe <paramref name="startIndex" />, also die Zeichenposition, an dem die Suche beginnt.  
  
 Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" beginnend mit der dritten Position des Zeichens in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
 [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)]
 [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge, die Anzahl der Zeichen in der aktuellen Zeichenfolge und den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
 - oder -   
  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> immer Methodenrückgabe <paramref name="startIndex" />, also die Zeichenposition, an dem die Suche beginnt.  
  
 Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn sie einen Ordinalvergleich ausführt, sucht es die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt, wenn ein kulturabhängiger Vergleich ausgeführt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
 [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)]
 [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet. Wenn `anyOf` wird ein leeres Array, die Methode findet eine Übereinstimmung am Anfang der Zeichenfolge (d. h. am index 0 (null)).  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht die erste Vokal in einer Zeichenfolge.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). Die `startIndex` -Parameter kann von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
 Die Suche erfolgt von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="startIndex" />ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Nummerierung beginnt bei 0 (null). Die `startIndex` -Parameter kann von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "Aid" in einer Teilzeichenfolge einer anderen Zeichenfolge.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 <paramref name="count" /> + <paramref name="startIndex" />ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Indexposition für das Einfügen.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine angegebene Zeichenfolge an einer angegebenen Indexposition in dieser Instanz eingefügt wird.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz mit einem an der Position <paramref name="value" /> eingefügten <paramref name="startIndex" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `startIndex` ist gleich der Länge dieser Instanz `value` am Ende dieser Instanz angefügt wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt Sie eine neue Zeichenfolge zurück, in dem `value` in der aktuellen Instanz eingefügt wird.  
  
 Beispielsweise ist der Rückgabewert der `"abc".Insert(2, "XYZ")` "AbXYZc" ist.  
  
   
  
## Examples  
 Das folgende Beispiel fügt ein Leerzeichen in der vierten Zeichenposition (das Zeichen am Index 3) einer Zeichenfolge.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Die folgende Konsolenanwendung fordert den Benutzer zur Eingabe von mindestens Adjektive um zwei Tieren zu beschreiben. Er ruft dann die <xref:System.String.Insert%2A> Methode, um die in eine Zeichenfolge vom Benutzer eingegebenen Text einzufügen.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />ist negativ oder größer als die Länge dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Eine im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft den Verweis des Systems auf den angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Der Verweis des Systems auf <paramref name="str" />, wenn dieser im Internpool vorhanden ist, andernfalls ein neuer Verweis auf eine Zeichenfolge mit dem Wert von <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime behält Zeichenfolgenspeicher durch Verwalten einer Tabelle, die als Internpool, die einen einzelnen Verweis auf jedes eindeutigen Zeichenfolgenliterals deklariert oder programmgesteuert erstellt, in Ihrem Programm enthält bezeichnet wird. Folglich vorhanden eine Instanz einer Literalzeichenfolge mit einem bestimmten Wert nur einmal im System.  
  
 Z. B. Wenn Sie mehrere Variablen mit die gleiche literale Zeichenfolge zuweisen, die Laufzeit ruft den gleichen Verweis auf die Literalzeichenfolge aus Internpool und jede Variable zugewiesen.  
  
 Die <xref:System.String.Intern%2A> Methode verwendet den Internpool zum Suchen nach einer Zeichenfolge, die gleich dem Wert des `str`. Wenn solch eine Zeichenfolge vorhanden ist, wird der Verweis im Internpool zurückgegeben. Wenn die Zeichenfolge nicht vorhanden ist, einen Verweis auf `str` dem Internpool hinzugefügt wird, wird dieser Verweis zurückgegeben.  
  
 Im folgenden Beispiel wird der Zeichenfolge s1 mit die Wert "MyTest", bereits Internpool, da es sich um ein Literal im Programm handelt. Die <xref:System.Text.StringBuilder?displayProperty=nameWithType> Klasse generiert ein neues Zeichenfolgenobjekt, das den gleichen Wert wie s1 verfügt. Ein Verweis auf diese Zeichenfolge wird in s2 zugewiesen. Die <xref:System.String.Intern%2A> Methode sucht eine Zeichenfolge, die den gleichen Wert wie s2 hat. Da solch eine Zeichenfolge vorhanden ist, gibt die Methode die gleichen Verweis, der s1 zugeordnet ist. Dann wird dieser Verweis s3 zugewiesen. Die Verweise s1 und s2 sind ungleich, da sie auf unterschiedliche Objekte verweisen. Verweise s1 und s3 hingegen sind gleich, da sie auf die gleiche Zeichenfolge verweisen.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Vergleichen Sie diese Methode, um die <xref:System.String.IsInterned%2A> Methode.  
  
## <a name="version-considerations"></a>Version-Überlegungen  
 In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]die <xref:System.String.Intern%2A> Methode auf das Verhalten in .NET Framework 1.0 und 1.1 im Hinblick auf die leere Zeichenfolge Internalisierung zurückgesetzt. Im folgenden Beispiel wird die Variable `str1` erhält einen Verweis auf <xref:System.String.Empty>, und die Variable `str2` erhält den Verweis auf <xref:System.String.Empty> zurückgegeben, die durch Aufrufen der <xref:System.String.Intern%2A> Methode nach der Konvertierung einer <xref:System.Text.StringBuilder>Objekt, dessen Wert <xref:System.String.Empty> in eine Zeichenfolge. Klicken Sie dann die Verweise, die in enthaltenen `str1` und `str2` auf Gleichheit verglichen werden.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 In der [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], und [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` und `str2` gleich sind. In der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] und [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` und `str2` ungleich sind.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie versuchen, den Gesamtumfang des Arbeitsspeichers zu reduzieren die Anwendung belegt, sollten Sie bedenken, die eine Zeichenfolge Internalisierung zwei unerwünschte Nebeneffekte hat. Zunächst der zugeordnete Arbeitsspeicher für Internpool <xref:System.String> Objekte wird ist wahrscheinlich nicht freigegeben, bis die common Language Runtime (CLR) beendet wird. Der Grund hierfür ist, die die CLR-Verweis auf die im Internpool vorhanden <xref:System.String> Objekts können nach Ihrer Anwendung oder sogar der Anwendungsdomäne beibehalten, beendet wird. Um eine Zeichenfolge internalisiert, müssen Sie zweitens zunächst die Zeichenfolge erstellen. Die Speicherverwendung durch den <xref:System.String> Objekt muss weiterhin zugeordnet werden, obwohl der Arbeitsspeicher schließlich Garbage Collection aufgenommen wird.  
  
 .NET Framework, Version 2.0 führt die <xref:System.Runtime.CompilerServices.CompilationRelaxations?displayProperty=nameWithType> Enumerationsmember. Die <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Element kennzeichnet eine Assembly nicht erfordern, Internalisierung von Zeichenfolgenliteralen erfordert. Sie können anwenden <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> auf eine Assembly mit der <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> Attribut. Auch bei Verwendung der [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) um eine Assembly im Vorfeld zur Laufzeit zu kompilieren, werden Zeichenfolgen nicht allen Modulen Internpool.  
  
   
  
## Examples  
 Das folgende Beispiel verwendet drei Zeichenfolgen, die Wert zu bestimmen, ob eine neu erstellte Zeichenfolge identisch ist, und eine im Internpool vorhanden Zeichenfolge gleich sind.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft einen Verweis auf einen angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Ein Verweis auf <paramref name="str" />, wenn sich dieser im Internpool der Common Language Runtime befindet; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime verwaltet automatisch eine Tabelle, die Internpool, die eine einzelne Instanz jedes eindeutigen Zeichenfolgenliterals Konstante deklariert, die in einem Programm als auch eine eindeutige Instanz enthält <xref:System.String> programmgesteuert durch Aufrufen von hinzufügen die <xref:System.String.Intern%2A> Methode.  
  
 Der Internpool erhält Zeichenfolgenspeicher. Wenn Sie eine literale Zeichenfolgenkonstante mehrere Variablen zuweisen, jede Variable wird festgelegt, auf die gleiche Konstante im Internpool anstelle von Verweisen auf mehrere unterschiedliche Instanzen verweisen <xref:System.String> , die identische Werte haben.  
  
 Diese Methode sucht `str` im Internpool. Wenn `str` wurde bereits Internpool, ein Verweis auf diese Instanz wird zurückgegeben, andernfalls `null` zurückgegeben wird.  
  
 Vergleichen Sie diese Methode, um die <xref:System.String.Intern%2A> Methode.  
  
 Diese Methode gibt keinen booleschen Wert zurück. Wenn Sie die Methode aufrufen, da einen booleschen Wert, der angibt, ob eine bestimmte Zeichenfolge intern gespeichert werden soll, können Sie den folgenden Code.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Beginnend mit .NET Framework, Version 2.0, können Sie die Verwendung von Internpool bei Verwendung von überschreiben die [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) , eine Assembly zum Cache für systemeigene Images auf einem lokalen Computer zu installieren. Weitere Informationen finden Sie unter Leistungsaspekte im Abschnitt "Hinweise", um die <xref:System.String.Intern%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, dass Literalzeichenfolgen automatisch vom Compiler intern gespeichert werden.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese Zeichenfolge in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns>
          <see langword="true" />, wenn diese Zeichenfolge in der Normalisierungsform C vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden. .NET Framework unterstützt derzeit die Normalisierung Forms C, D, KC und KD.  
  
 Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge erfolgreich in verschiedenen Normalisierungsformen normalisiert wird.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage">
          <para>Die <see cref="Overload:System.String.IsNormalized" /> -Methode zurückkehrt <see langword="false" /> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt an, ob diese Zeichenfolge in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns>
          <see langword="true" />, wenn diese Zeichenfolge in der vom <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden. .NET Framework unterstützt derzeit die Normalisierung Forms C, D, KC und KD.  
  
 Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IsNormalized%2A> und <xref:System.String.Normalize%2A> Methoden.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage">
          <para>Die <see cref="Overload:System.String.IsNormalized" /> -Methode zurückkehrt <see langword="false" /> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob die angegebene Zeichenfolge <see langword="null" /> oder eine <see cref="F:System.String.Empty" />-Zeichenfolge ist.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A>ist eine bequeme Methode, die Ihnen ermöglicht, die gleichzeitig zu testen, ob eine <xref:System.String> ist `null` oder ihr Wert <xref:System.String.Empty>. Dies entspricht dem folgenden Code:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Können Sie die <xref:System.String.IsNullOrWhiteSpace%2A> Methode zum Testen, ob eine Zeichenfolge `null`, ihr Wert ist <xref:System.String.Empty?displayProperty=nameWithType>, oder es besteht nur aus Leerstellen bestehen.  
  
## <a name="what-is-a-null-string"></a>Was ist eine null-Zeichenfolge?  
 Eine Zeichenfolge ist `null` , wenn sie keinen Wert (in C++ und Visual Basic) zugewiesen wurden oder wenn der Wert explizit zugewiesen wurde `null`. Obwohl die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Funktion kann sauber eine null-Zeichenfolge, wie im folgenden Beispiel gezeigt, der versucht, eine aufzurufen, wenn Membern löst eine <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Was ist eine leere Zeichenfolge?  
 Eine Zeichenfolge ist leer, wenn er explizit eine leere Zeichenfolge zugewiesen ist ("") oder <xref:System.String.Empty?displayProperty=nameWithType>. Eine leere Zeichenfolge ist ein <xref:System.String.Length%2A> 0.  Das folgende Beispiel erstellt eine leere Zeichenfolge und zeigt an, dessen Wert und ihre Länge.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Zeichenfolgen untersucht und bestimmt, ob jede Zeichenfolge ist, eine leere Zeichenfolge ist oder ist `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob eine angegebene Zeichenfolge <see langword="null" /> ist, leer ist oder nur aus Leerzeichen besteht.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist oder wenn <paramref name="value" /> ausschließlich aus Leerzeichen besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A>ist eine Hilfsmethode, die ähnlich dem folgenden Code wird mit dem Unterschied, dass es sich um eine bessere Leistung bietet:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.IsNullOrWhiteSpace%2A> Methode interpretiert alle Zeichen, die einen Wert zurückgibt `true` wann erfolgt eine Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode als ein Leerzeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von Zeichenfolgen, und übergibt dann jedes Element des Arrays, das die <xref:System.String.IsNullOrWhiteSpace%2A> Methode.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet. <c>Trennzeichen</c> dient in der zurückgegebenen Zeichenfolge nur, wenn <c>Werte</c> verfügt über mehr als ein Element.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Zeichenfolgen enthält.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" /> und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn alle Member des `values` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>ist eine bequeme Methode, mit der jedes Element in verketten kann eine `IEnumerable(Of String)` Auflistung ohne zunächst die Elemente in einem Array von Zeichenfolgen konvertiert. Dies ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ). Das folgende Beispiel übergibt eine `List(Of String)` Objekt, das die klein-oder Großbuchstaben und Buchstaben des Alphabets an einen Lambda-Ausdruck, die Buchstaben, die einem bestimmten Buchstaben enthält auswählt (d. h. im Beispiel "M") größer oder gleich sind. Die `IEnumerable(Of String)` zurückgegebene Auflistung der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> an die Methode übergeben wird die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode, um das Ergebnis als einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis, das eine <xref:System.Collections.Generic.List%601> Objekt des Typs <xref:System.String>, übergibt sie dann an die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <c>Trennzeichen</c> dient in der zurückgegebenen Zeichenfolge nur, wenn <c>Werte</c> verfügt über mehr als ein Element.</param>
        <param name="values">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Elemente eines Objektarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null` oder, wenn ein beliebiges Element von `values` anders als das erste Element ist `null`, eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>) wird stattdessen verwendet. Finden Sie Hinweise für Aufruferabschnitt aus, wenn das erste Element des `values` ist `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>ist eine bequeme Methode, mit der jedes Element in einem Objektarray verketten, ohne Sie explizit seine Elemente in Zeichenfolgen konvertiert werden können. Die Zeichenfolgendarstellung für jedes Objekt im Array wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Er weist das Ergebnis ein Array von Ganzzahlen, übergibt sie dann an die <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> Methode.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Wenn das erste Element des <paramref name="values" /> ist <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> Methode verketten keine Elemente im <paramref name="values" /> , sondern stattdessen zurückgibt <see cref="F:System.String.Empty" />. Eine Reihe von problemumgehungen für dieses Problem sind verfügbar. Die einfachste Möglichkeit besteht darin, einen Wert zuzuweisen <see cref="F:System.String.Empty" /> auf das erste Element des Arrays, wie im folgenden Beispiel dargestellt.  
  
 [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)]
 [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <c>Trennzeichen</c> dient in der zurückgegebenen Zeichenfolge nur, wenn <c>Wert</c> verfügt über mehr als ein Element.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet alle Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="value" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. wenn `separator` ist "," und die Elemente der `value` sind "Apple", "Orange", "Pflaume" und "Birne", `Join(separator, value)` "Apple, Orange, Pflaume, Birne" zurückgegeben.  
  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn ein Element in `value` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Join%2A> Methode.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <c>Trennzeichen</c> dient in der zurückgegebenen Zeichenfolge nur, wenn <c>Wert</c> verfügt über mehr als ein Element.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <param name="startIndex">Das erste Element im <c>Wert</c> verwenden.</param>
        <param name="count">Die Anzahl der Elemente des <c>Wert</c> verwenden.</param>
        <summary>Verkettet die angegebenen Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Zeichenfolgen in <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.  
  
 - oder -   
  
 <see cref="F:System.String.Empty" />, wenn <paramref name="count" /> 0 (null) ist, <paramref name="value" /> keine Elemente enthält oder <paramref name="separator" /> und alle Elemente von <paramref name="value" /> <see cref="F:System.String.Empty" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. wenn `separator` ist "," und die Elemente der `value` sind "Apple", "Orange", "Pflaume" und "Birne", `Join(separator, value, 1, 2)` gibt "Orange, Pflaume".  
  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn ein Element in `value` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Elemente aus einem Array mit Namen von Früchten verkettet.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="startIndex" /> plus <paramref name="count" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente der <c>Werte</c>.</typeparam>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet. <c>Trennzeichen</c> dient in der zurückgegebenen Zeichenfolge nur, wenn <c>Werte</c> verfügt über mehr als ein Element.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Objekte enthält.</param>
        <summary>Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn alle Member des `values` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>ist eine bequeme Methode, mit dem Sie verketten, jedes Mitglied einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung ohne sie in Zeichenfolgen konvertieren. Die Zeichenfolgendarstellung für jedes Objekt in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
 Diese Methode ist insbesondere nützlich sein, die Language-Integrated Query (LINQ)-Abfrageausdrücke. Der folgende Code definiert z. B. eine sehr einfache `Animal` Klasse enthält den Namen des Animal und die Reihenfolge, zu dem er gehört. Zudem definiert der Code eine <xref:System.Collections.Generic.List%601> -Objekt, das eine Anzahl von enthält `Animal` Objekte. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Erweiterungsmethode aufgerufen, um das Extrahieren der `Animal` -Objekte, deren `Order` Eigenschaft "Rodent" entspricht. Das Ergebnis wird zum Übergeben der <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis, das eine <xref:System.Collections.Generic.List%601> Objekt vom Typ Integer, übergibt sie dann an die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Diese Methode beginnt die Suche an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `ExtractFilename` Methode, verwendet die <xref:System.String.LastIndexOf%28System.Char%29> Methode, um das letzte Verzeichnistrennzeichen in einer Zeichenfolge gesucht und Dateinamen der Zeichenfolge zu extrahieren. Wenn die Datei vorhanden ist, gibt die Methode den Dateinamen ohne Pfad zurück.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt `value` gefunden wird oder die Position des erste Zeichens überprüft wurde.  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%28System.String%29> immer Methodenrückgabe <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, der die letzte Indexposition in der aktuellen Instanz darstellt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%28System.String%29> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher sind in jedem Fall, da der bedingte Bindestrich ein ignorierbares Zeichen ist das Ergebnis das gleiche wie bei der bedingten Bindestrich in nicht enthalten war `value`. Bei der Suche nach nur einen bedingten Bindestrich erfolgt die Methodenrückgabe 6 und 5. Diese Werte entsprechen den Index des letzten Zeichens in die zwei Zeichenfolgen.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Im folgende Beispiel entfernt die Start- und Endtags HTML-Zeichenfolge, wenn die Tags beginnen und am Ende der Zeichenfolge. Wenn das Ende einer Zeichenfolge mit einer schließenden Klammer Zeichen (">"), im Beispiel wird die <xref:System.String.LastIndexOf%2A> Methode, um den Start des Endtags zu suchen.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um den letzten Index einer Teilzeichenfolge innerhalb einer Zeichenfolgeninstanz mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> -1. dieser Methode beginnt die Suche an den `startIndex` Zeichenposition dieser Instanz und wird rückwärts bis zum Anfang der aktuellen Instanz erst dann fortgesetzt `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgende Beispiel sucht den Index, der alle Vorkommen eines Zeichens in einer Zeichenfolge, aus dem Ende der Zeichenfolge am Anfang der Zeichenfolge arbeiten.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang.  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> immer Methodenrückgabe `startIndex`, also die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> Methode wird verwendet, um eine Teilzeichenfolge gefunden werden, enthält einen bedingten Bindestrich (U + 00AD) und vorausgeht oder der endgültige "m" in einer Zeichenfolge enthält. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da in der Suchzeichenfolge in der bedingten Bindestrich ignoriert wird, einen Aufruf der Methode während aufrufen, um eine Substrin suchen Suchen, der den bedingten Bindestrich und "m" besteht, Teilzeichenfolge gibt die Position des "m" in der Zeichenfolge zurück. g, der den bedingten Bindestrich und "n" besteht, gibt die Position der "n" zurück. Wenn die Suchzeichenfolge nur für den bedingten Bindestrich enthält, gibt die Methode den Index des "m", die den Wert darstellt `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Im folgende Beispiel sucht den Index, der alle Vorkommen einer Zeichenfolge in der Zielzeichenfolge, am Ende der Zielzeichenfolge am Anfang der Zielzeichenfolge arbeiten.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um den Index einer Teilzeichenfolge suchen, der eine bestimmten Zeichenposition vorausgeht, mithilfe der Vergleichsregeln der aktuellen Kultur, rufen die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
 Die Suche beginnt an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt `value` gefunden wird oder die Position des erste Zeichens überprüft wurde.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="options" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> immer Methodenrückgabe <see cref="P:System.String.Length" /> – 1, der die letzte Indexposition in der aktuellen Instanz darstellt.  
  
 Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da der bedingte Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn der bedingte Bindestrich wurden nicht in der Suchzeichenfolge in enthalten. Eine ordinale Suche erfolgreich sucht den bedingten Bindestrich in eine Zeichenfolge und gibt an, dass er nicht vorhanden ist aus der zweiten Zeichenfolge.  
  
 [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)]
 [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens des angegebenen Unicode-Zeichens in einer Teilzeichenfolge dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Diese Methode beginnt die Suche an den `startIndex` Zeichen Position und wird rückwärts bis zum Anfang dieser Instanz erst dann fortgesetzt `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgende Beispiel sucht den Index, der alle Vorkommen eines Zeichens in einer Teilzeichenfolge, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" />  -  <paramref name="count" /> + 1 ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%2A> immer Methodenrückgabe `startIndex`, also die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%2A> Methode wird verwendet, um die Position des einen bedingten Bindestrich (U + 00AD) in den beiden Zeichen suchen, die die endgültige "m" von zwei Zeichenfolgen vorausgehen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Im folgende Beispiel sucht den Index, der alle Vorkommen einer Zeichenfolge in Teilzeichenfolgen, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist ein negativer Wert.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" />  -  <paramref name="count" />+ 1 gibt eine Position an, die nicht in dieser Instanz ist.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um diesen Vorgang auszuführen, mithilfe der Vergleichsregeln der aktuellen Kultur, rufen die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen Position und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> immer Methodenrückgabe <paramref name="startIndex" />, also die Zeichenposition, an dem die Suche beginnt.  
  
 Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m", beginnend mit dem letzten "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
 [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)]
 [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen Position und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche der `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist ein negativer Wert.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> + 1 - <paramref name="count" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
 - oder -   
  
 Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage">
          <para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> immer Methodenrückgabe <paramref name="startIndex" />, also die Zeichenposition, an dem die Suche beginnt.  
  
 Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in allen jedoch der ersten Zeichenposition vor dem letzten "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt. Wenn sie einen Ordinalvergleich ausführt, sucht es die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt, wenn ein kulturabhängiger Vergleich ausgeführt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
 [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)]
 [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an dieser Instanz der letzten Zeichenposition und verläuft rückwärts zum Anfang, bis entweder ein Zeichen in `anyOf` gefunden wird oder die Position des erste Zeichens überprüft wurde. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "is" innerhalb einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an den `startIndex` Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts `anyOf` gefunden wird oder die Position des erste Zeichens überprüft wurde. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche geht von <c>StartIndex</c> bis zum Anfang dieser Instanz.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an den `startIndex` Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts `anyOf` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Wird bei der Suche Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "Aid" in einer Teilzeichenfolge einer anderen Zeichenfolge.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
 - oder -   
  
 Die aktuelle Instanz ist nicht gleich <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> minus <paramref name="count" /> + 1 ist weniger als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Zeichen im aktuellen <see cref="T:System.String" />-Objekt ab.</summary>
        <value>Die Anzahl der Zeichen in der aktuellen Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Length%2A> Eigenschaft gibt die Anzahl der <xref:System.Char> Objekte in dieser Instanz, die nicht die Anzahl von Unicode-Zeichen. Der Grund hierfür ist, dass ein Unicode-Zeichen kann, von mehreren dargestellt werden <xref:System.Char>. Verwenden der <xref:System.Globalization.StringInfo?displayProperty=nameWithType> -Klasse verwendet jedes Unicode-Zeichen anstelle von einzelnen <xref:System.Char>.  
  
 In einigen Sprachen, z. B. C und C++ gibt ein Null-Zeichen das Ende einer Zeichenfolge an. In .NET Framework kann ein Null-Zeichen in einer Zeichenfolge eingebettet sein. Wenn eine Zeichenfolge ein oder mehrere Null-Zeichen enthält, werden sie in die Länge der Zeichenfolge enthalten. Beispielsweise ist in der folgenden Zeichenfolge, die Teilzeichenfolgen "Abc" und "Def" durch ein Null-Zeichen getrennt sind. Die <xref:System.String.Length%2A> Eigenschaft gibt 7 gibt an, dass sie die sechs Buchstaben als auch für das Null-Zeichen enthalten.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Length%2A> Eigenschaft.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns>Eine neue normalisierte Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Normalisierungsform C vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen. Beispielsweise kann eine der folgenden Codepunkte den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden. .NET Framework unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, werden mithilfe von ordinalen Vergleich verglichen.  
  
 Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:  
  
1.  Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Benutzer Eingabegerät verglichen werden soll.  
  
2.  Rufen Sie die <xref:System.String.Normalize> Methode zum Normalisieren der Zeichenfolgen in der Normalisierungsform c vorliegt.  
  
3.  Rufen Sie zum Vergleichen von zwei Zeichenfolgen eine Methode, z. B. ordinal Zeichenfolgenvergleich, unterstützt, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, und geben Sie den Wert <xref:System.StringComparison?displayProperty=nameWithType> oder <xref:System.StringComparison?displayProperty=nameWithType> als die <xref:System.StringComparison> Argument. Um ein Array von normalisierte Zeichenfolgen zu sortieren, übergeben Sie eine `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine entsprechende Überladung der <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf den im vorherigen Schritt angegebenen Reihenfolge.  
  
 Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel eine Zeichenfolge in alle vier Normalisierungsformen normalisiert, bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform normalisiert die Codepunkte der normalisierte Zeichenfolge.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage">
          <para>Die <see cref="Overload:System.String.IsNormalized" /> -Methode zurückkehrt <see langword="false" /> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns>Eine neue Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der im <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden. .NET Framework unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, können sie mithilfe von ordinalen Vergleich verglichen werden.  
  
 Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:  
  
1.  Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Benutzer Eingabegerät verglichen werden soll.  
  
2.  Rufen Sie die <xref:System.String.Normalize%28System.Text.NormalizationForm%29> Methode, um die Zeichenfolgen in einer angegebenen Normalisierungsform zu normalisieren.  
  
3.  Rufen Sie zum Vergleichen von zwei Zeichenfolgen eine Methode, z. B. ordinal Zeichenfolgenvergleich, unterstützt, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, und geben Sie den Wert <xref:System.StringComparison?displayProperty=nameWithType> oder <xref:System.StringComparison?displayProperty=nameWithType> als die <xref:System.StringComparison> Argument. Um ein Array von normalisierte Zeichenfolgen zu sortieren, übergeben Sie eine `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine entsprechende Überladung der <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf den im vorherigen Schritt angegebenen Reihenfolge.  
  
 Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel eine Zeichenfolge in alle vier Normalisierungsformen normalisiert, bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform normalisiert die Codepunkte der normalisierte Zeichenfolge.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage">
          <para>Die <see cref="Overload:System.String.IsNormalized" /> -Methode zurückkehrt <see langword="false" /> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <see cref="Overload:System.String.Normalize" /> Methode Auslösen einer <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Equality%2A> Methode definiert, den Vorgang des Gleichheitsoperators für die <xref:System.String> Klasse. Sie können Code wie im Beispielabschnitt. Der Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> -Methode, die einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.  
  
> [!NOTE]
>  Visual Basic-Compiler löst nicht den Gleichheitsoperator als Aufruf an die <xref:System.String.op_Equality%2A> Methode. Stattdessen der Gleichheitsoperator dient als Wrapper für einen Aufruf der <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht den Gleichheitsoperator.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen verschiedene Werte haben.</summary>
        <returns>
          <see langword="true" />, wenn der Wert von <paramref name="a" /> vom Wert von <paramref name="b" /> verschieden ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für die <xref:System.String> Klasse.   Sie können Code wie im Abschnitt "Beispiele".  
  
 Die <xref:System.String.op_Inequality%2A> Operator wiederum ruft die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> -Methode, die einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.  
  
> [!NOTE]
>  Visual Basic-Compiler löst nicht den Ungleichheitsoperator als Aufruf an die <xref:System.String.op_Inequality%2A> Methode. Stattdessen Ungleichheitsoperators dient als Wrapper für einen Aufruf der <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Ungleichheitsoperator.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicode-Leerzeichen ist definiert als hexadezimale 0 x 0020.  
  
 Die <xref:System.String.PadLeft%28System.Int32%29> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadLeft%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die mit einem führenden Leerzeichen aufgefüllt wird, damit die Gesamtlänge zu erreichen ist `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadLeft%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die mit vorangestellten Schrägstrich aufgefüllt wird `paddingChar` Zeichen, damit die Gesamtlänge zu erreichen ist `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicode-Leerzeichen ist definiert als hexadezimale 0 x 0020.  
  
 Die <xref:System.String.PadRight%28System.Int32%29> -Methode füllt das Ende der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadRight%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die mit nachfolgenden Leerzeichen aufgefüllt wird, damit die Gesamtlänge zu erreichen ist `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> -Methode füllt das Ende der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadRight%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die mit nachfolgenden Leerzeichen aufgefüllt ist `paddingChar` Zeichen, damit die Gesamtlänge zu erreichen ist `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Zeichen in der aktuellen Instanz, beginnend an einer angegebenen Position und sich über die letzte Position fortsetzend, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Zeichenfolge ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], Zeichenfolgen sind nullbasiert. Der Wert, der die `startIndex` -Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge in der alle Zeichen ab Position `startIndex` bis zum Ende der ursprünglichen Zeichenfolge entfernt wurden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Remove%2A> Methode. Die nächsten vorletztes Groß-/Kleinschreibung entfernt den gesamten Text aus dem angegebenen Index bis zum Ende der Zeichenfolge ab. Im letzte Fall werden drei Zeichen beginnend am angegebenen Index entfernt.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ist kleiner als Null.  
  
 - oder -   
  
 <paramref name="startIndex" />Gibt eine Position, die nicht in dieser Zeichenfolge ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <param name="count">Die Anzahl der zu löschenden Zeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine bestimmte Anzahl von Zeichen in er aktuellen Instanz, beginnend an einer angegebenen Position, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], Zeichenfolgen sind nullbasiert. Der Wert, der die `startIndex` -Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die in der die Anzahl von Zeichen, durch angegeben die `count` Parameter wurden entfernt. Die Zeichen an der angegebenen Position entfernt `startIndex`.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie aus dem vollständigen Namen des zweiten Vornamens entfernen können.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="startIndex" />plus <paramref name="count" /> geben eine Position außerhalb dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Unicode-Zeichen.</param>
        <param name="newChar">Das Unicode-Zeichen ersetzt alle Vorkommen von <c>OldChar</c>.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen eines angegebenen Unicode-Zeichens in dieser Instanz durch ein anderes angegebenes Unicode-Zeichen ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die dieser Instanz entspricht, außer dass alle Instanzen von <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt werden. Wenn <paramref name="oldChar" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche nach `oldChar`.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle Vorkommen von `oldChar` ersetzt durch `newChar`.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können Verketten von aufeinander folgenden Aufrufen der <xref:System.String.Replace%2A> Methode zum Ausführen von mehreren Ersetzungen für die ursprüngliche Zeichenfolge. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Liste von durch Trennzeichen getrennte Werte durch Kommas, die Leerzeichen zwischen einer Reihe von Zahlen zu ersetzen.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge ersetzt alle Vorkommen von <c>OldValue</c>.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden. Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `newValue` ist `null`, alle Vorkommen von `oldValue` werden entfernt.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle Vorkommen von `oldValue` ersetzt durch `newValue`.  
  
 Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche nach `oldValue`.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können Verketten von aufeinander folgenden Aufrufen der <xref:System.String.Replace%2A> Methode zum Ausführen von mehreren Ersetzungen für die ursprüngliche Zeichenfolge. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie können die <xref:System.String.Replace%2A> Methode zum Rechtschreibfehler zu beheben.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> ist die leere Zeichenfolge ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray zurück, das die Teilzeichenfolgen dieser Instanz enthält, die durch Elemente eines angegebenen Zeichenfolgen- oder Unicode-Zeichenarrays getrennt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A>wird verwendet, um eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen zu unterteilen. Sie können entweder ein Zeichenarray 0 (null), einer oder mehrerer Trennzeichen angeben (die <xref:System.String.Split%28System.Char%5B%5D%29> Methode), oder Sie können ein Array von Zeichen verwenden, um 0 (null), einer oder mehrerer begrenzenden Zeichenfolgen angeben. Überladungen der der <xref:System.String.Split%2A> Methode ermöglichen es Ihnen, begrenzen die Anzahl von Teilzeichenfolgen, die von der Methode zurückgegeben (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> Methode), um zu bestimmen, ob leere Zeichenfolgen in der zurückgegebenen Teilzeichenfolgen enthalten sind (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> und <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> Methoden, oder Beide Methoden (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> und <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> Methoden).  
  
> [!IMPORTANT]
>  Detaillierte Informationen auf der <xref:System.String.Split%2A> -Methode, wie sowie Beispiele, in denen aufrufen jede Überladung, finden in der Dokumentation für die einzelnen Überladungen <xref:System.String.Split%2A>.  
  
 Die <xref:System.String.Split%2A> Methode ist nicht immer die beste Möglichkeit, eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen unterteilt. Wenn nicht alle Teilzeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahiert werden sollen oder eine Zeichenfolge, die basierend auf einem Muster, anstatt einen Satz von Trennzeichen analysiert werden sollen, sollten Sie die folgenden Alternativen.  
  
## <a name="regular-expressions"></a>Reguläre Ausdrücke  
 Wenn Zeichenfolgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck zum Extrahieren und ihre Elemente zu behandeln. Z. B. Zeichenfolgen handeln "*Anzahl* *Operand* *Anzahl*" können Sie eine [reguläre](~/docs/standard/base-types/regular-expressions.md) extrahieren und Verarbeiten der Elemente mit der Zeichenfolge. Im Folgenden ein Beispiel:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Muster für reguläre Ausdrücke `(\d+)\s+([-+*/])\s+(\d+)` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit mindestens ein Leerzeichen Zeichen.|  
|`([-+*/])`|Entspricht einem arithmetischen Operator Vorzeichen (+, -, *, oder /). Dies ist die zweite Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit mindestens ein Leerzeichen Zeichen.|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die dritte Erfassungsgruppe.|  
  
 Einen regulären Ausdruck können auch um Teilzeichenfolgen aus einer Zeichenfolge basierend auf einen festen Satz von Zeichen, anstatt ein Muster zu extrahieren. Dies ist ein gängiges Szenario, wenn eine dieser Bedingungen auftritt:  
  
-   Mindestens eines der Trennzeichen immer verarbeitet nicht als Trennzeichen in der <xref:System.String> Instanz.  
  
-   Die Reihenfolge und die Anzahl der Zeichen, Trennzeichen ist variabel oder unbekannt.  
  
 Z. B. die <xref:System.String.Split%2A> Methode kann nicht so teilen Sie die folgende Zeichenfolge verwendet werden, da die Anzahl der `\n` (in c#) oder `vbCrLf` (in Visual Basic) Zeichen ist variabel, und führen Sie sie nicht immer als Trennzeichen dienen.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Diese Zeichenfolge kann einfach, wie das folgende Beispiel zeigt ein regulärer Ausdruck unterteilt werden.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Muster für reguläre Ausdrücke `\[([^\[\]]+)\]` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\[`|Übereinstimmung mit einer öffnenden Klammer.|  
|`([^\[\]]+)`|Übereinstimmung mit beliebigem Zeichen, die kein öffnendes oder eine schließende Klammer ein- oder mehrmals ist ein. Dies ist die erste Erfassungsgruppe.|  
|`\]`|Übereinstimmung mit einer schließenden Klammer.|  
  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode entspricht weitgehend dem <xref:System.String.Split%2A?displayProperty=nameWithType>, außer dass es sich um eine Zeichenfolge, die basierend auf das Muster eines regulären Ausdrucks anstelle einer festen Zeichensatz unterteilt. Z. B. im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode zum Aufteilen einer Zeichenfolge, die durch verschiedene Kombinationen von Bindestrichen und andere Zeichen als Trennzeichen für Teilzeichenfolgen enthält.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Muster für reguläre Ausdrücke `\s-\s?[+*]?\s?-\s` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\s-`|Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.|  
|`[+*]?`|Übereinstimmung mit keinem oder einem Vorkommen entweder das + oder * Zeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.|  
|`-\s`|Übereinstimmung mit einem Bindestrich gefolgt von einem Leerzeichen.|  
  
## <a name="search-methods-and-the-substring-method"></a>Suchen von Methoden und der Substring-Methode  
 Wenn Sie nicht alle der Teilzeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, arbeiten mit einer der Methoden zum Zeichenfolgenvergleich, die den Index zurückgibt, an dem der Vergleich beginnt. Rufen Sie dann die <xref:System.String.Substring%2A> Methode, um die Teilzeichenfolge extrahiert, die Sie möchten. Die Methoden zum Zeichenfolgenvergleich gehören:  
  
-   <xref:System.String.IndexOf%2A>, die den nullbasierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.  
  
-   <xref:System.String.IndexOfAny%2A>, die den nullbasierten Index in der aktuellen Zeichenfolgeninstanz des ersten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.  
  
-   <xref:System.String.LastIndexOf%2A>, die den nullbasierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.  
  
-   <xref:System.String.LastIndexOfAny%2A>, womit einen nullbasierten Index in der aktuellen Zeichenfolgeninstanz des letzten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgegeben.  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> Methode, um die Punkte in einer Zeichenfolge zu ermitteln. Es verwendet dann die <xref:System.String.Substring%2A> Methode, um vollständige Sätze zurückzugeben.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge von einem bekannten Satz von Zeichen getrennt sind, können Sie die <xref:System.String.Split%28System.Char%5B%5D%29> Methode in Teilzeichenfolgen abzugrenzen. Andere Möglichkeiten, um Teilzeichenfolgen aus einer Zeichenfolge zu extrahieren, finden Sie unter der [Alternativen zu String.Split](#Alternatives) Abschnitt.  
  
## <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten. Beispielsweise enthält das Array Trennzeichen das Zeichen "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn keine Zeichen in dieser Instanz enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn zwei Trennzeichen angrenzen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Element im zurückgegebenen Array <xref:System.String.Empty>. Hier einige Beispiele:  
  
|Zeichenfolgenwert|Trennzeichen|Zurückgegebene array|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|neue Char [] {',', ' '} (c#)<br /><br /> Char() = {"," c "" C}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|neue Char [] {"."} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banane"|neue Char [] {"."} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"Banane"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|neue Char [] {} (c#)<br /><br /> Char() = "{}" (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>Das Separator-array  
 Jedes Element des Trennzeichens definiert ein separaten Trennzeichen, das ein einzelnes Zeichen besteht. Wenn die `separator` Argument ist `null` oder keine Zeichen enthält, die Methode behandelt Leerzeichen als Trennzeichen. Leerzeichen werden durch die Unicode-standard definiert. Diese zurückgeben `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Auflösen der Überladung String.Split(Char[]) und compiler  
 Obwohl die einzelnen Parameter für diese Überladung der <xref:System.String.Split%2A?displayProperty=nameWithType> ist ein Array von Zeichen, wie im folgenden Beispiel gezeigt mit einem einzelnen Zeichen aufrufen.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Da die `separator` Parameter ergänzt wird, mit der <xref:System.ParamArrayAttribute> -Attribut, Compiler ein einzelnes Zeichen als ein Array von Einzelelement-Zeichen interpretiert werden. Dies gilt nicht für andere <xref:System.String.Split%2A?displayProperty=nameWithType> Überladungen, die eine `separator` -Parameter müssen Sie explizit übergeben diese Überladungen ein Array von Zeichen als die `separator` Argument.  
  
## <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere Zeichen getrennt sind die `separator` array und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternativen zu String.Split  
 Die <xref:System.String.Split%2A> Methode ist nicht immer die beste Möglichkeit, eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen unterteilt. Wenn nicht alle Teilzeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahiert werden sollen oder eine Zeichenfolge, die basierend auf einem Muster, anstatt einen Satz von Trennzeichen analysiert werden sollen, sollten Sie die folgenden Alternativen.  
  
### <a name="regular-expressions"></a>Reguläre Ausdrücke  
 Wenn Zeichenfolgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck zum Extrahieren und ihre Elemente zu behandeln. Z. B. Zeichenfolgen handeln "*Anzahl* *Operand* *Anzahl*" können Sie eine [reguläre](~/docs/standard/base-types/regular-expressions.md) extrahieren und Verarbeiten der Elemente mit der Zeichenfolge. Im Folgenden ein Beispiel:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Muster für reguläre Ausdrücke `(\d+)\s+([-+*/])\s+(\d+)` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit mindestens ein Leerzeichen Zeichen.|  
|`([-+*/])`|Entspricht einem arithmetischen Operator Vorzeichen (+, -, *, oder /). Dies ist die zweite Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit mindestens ein Leerzeichen Zeichen.|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die dritte Erfassungsgruppe.|  
  
 Einen regulären Ausdruck können auch um Teilzeichenfolgen aus einer Zeichenfolge basierend auf einen festen Satz von Zeichen, anstatt ein Muster zu extrahieren. Dies ist ein gängiges Szenario, wenn eine dieser Bedingungen auftritt:  
  
-   Mindestens eines der Trennzeichen immer verarbeitet nicht als Trennzeichen in der <xref:System.String> Instanz.  
  
-   Die Reihenfolge und die Anzahl der Zeichen, Trennzeichen ist variabel oder unbekannt.  
  
 Z. B. die <xref:System.String.Split%2A> Methode kann nicht so teilen Sie die folgende Zeichenfolge verwendet werden, da die Anzahl der `\n` (in c#) oder `vbCrLf` (in Visual Basic) Zeichen ist variabel, und führen Sie sie nicht immer als Trennzeichen dienen.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Diese Zeichenfolge kann einfach, wie das folgende Beispiel zeigt ein regulärer Ausdruck unterteilt werden.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Muster für reguläre Ausdrücke `\[([^\[\]]+)\]` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\[`|Übereinstimmung mit einer öffnenden Klammer.|  
|`([^\[\]]+)`|Übereinstimmung mit beliebigem Zeichen, die kein öffnendes oder eine schließende Klammer ein- oder mehrmals ist ein. Dies ist die erste Erfassungsgruppe.|  
|`\]`|Übereinstimmung mit einer schließenden Klammer.|  
  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode entspricht weitgehend dem <xref:System.String.Split%2A?displayProperty=nameWithType>, außer dass es sich um eine Zeichenfolge, die basierend auf das Muster eines regulären Ausdrucks anstelle einer festen Zeichensatz unterteilt. Z. B. im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode zum Aufteilen einer Zeichenfolge, die durch verschiedene Kombinationen von Bindestrichen und andere Zeichen als Trennzeichen für Teilzeichenfolgen enthält.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Muster für reguläre Ausdrücke `\s-\s?[+*]?\s?-\s` wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\s-`|Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.|  
|`[+*]?`|Übereinstimmung mit keinem oder einem Vorkommen entweder das + oder * Zeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.|  
|`-\s`|Übereinstimmung mit einem Bindestrich gefolgt von einem Leerzeichen.|  
  
### <a name="search-methods-and-the-substring-method"></a>Suchen von Methoden und der Substring-Methode  
 Wenn Sie nicht alle der Teilzeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, arbeiten mit einer der Methoden zum Zeichenfolgenvergleich, die den Index zurückgibt, an dem der Vergleich beginnt. Rufen Sie dann die <xref:System.String.Substring%2A> Methode, um die Teilzeichenfolge extrahiert, die Sie möchten. Die Methoden zum Zeichenfolgenvergleich gehören:  
  
-   <xref:System.String.IndexOf%2A>, die den nullbasierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.  
  
-   <xref:System.String.IndexOfAny%2A>, die den nullbasierten Index in der aktuellen Zeichenfolgeninstanz des ersten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.  
  
-   <xref:System.String.LastIndexOf%2A>, die den nullbasierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.  
  
-   <xref:System.String.LastIndexOfAny%2A>, womit einen nullbasierten Index in der aktuellen Zeichenfolgeninstanz des letzten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgegeben.  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> Methode, um die Punkte in einer Zeichenfolge zu ermitteln. Es verwendet dann die <xref:System.String.Substring%2A> Methode, um vollständige Sätze zurückzugeben.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode. Sie haben auch die Möglichkeit der Verwendung der <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Um eine Zeichenfolge an einem Trennzeichen teilen möchten, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Um eine Zeichenfolge an einem Trennzeichen teilen möchten, verwenden die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einzelne Wörter aus einem Text-Block zum Behandeln von Leerzeichen und Satzzeichen, als Trennzeichen zu extrahieren. Das Zeichenarray übergeben, um die `separator` Parameter von der <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> Methode besteht aus einem Leerzeichen und einem Tabstoppzeichen, zusammen mit einigen häufig verwendeten Interpunktionszeichen.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie geben außerdem die maximale Anzahl der zurückzugebenden Teilzeichenfolgen an.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten.  
  
 Wenn keine Zeichen in dieser Instanz enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn `count` NULL ist, wird ein leeres Array zurückgegeben.  
  
 Wenn die `separator` Parameter ist `null` oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn zwei Trennzeichen angrenzen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` 1 Teilzeichenfolgen sind in der ersten zurückgegebenen `count` minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
 Die folgende Tabelle enthält Beispiele.  
  
|Zeichenfolgenwert|Trennzeichen|Anzahl|Zurückgegebene array|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|neue Char [] {',', ' '} (c#)<br /><br /> Char() = {"," c "" C} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|neue Char [] {"."} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banane"|neue Char [] {"."} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|2|{"Banane"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|neue Char [] {} (c#)<br /><br /> Char() = "{}" (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|neue Char [] null (c#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb" & VbLf & "Smarba" (Visual Basic)|neue Char [] null (c#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie `count` wirkt sich auf die Anzahl der Zeichenfolgen zurückgegebenes <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist ein negativer Wert.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen (die Zeichen in der `separator` Array) sind nicht in den Elementen im zurückgegebenen Array enthalten. Beispielsweise, wenn die `separator` Array enthält das Zeichen "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn keine Zeichen in dieser Instanz enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn die `options` Parameter ist <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist NULL, wird die Methode ein leeres Array zurück.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, die ein einzelnes Zeichen besteht. Wenn die `options` Argument ist <xref:System.StringSplitOptions.None>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String?displayProperty=nameWithType>. Z. B. wenn `separator` enthält zwei Elemente, die "-" und "_", der Wert der Zeichenfolgeninstanz "- _aa -\_", und der Wert der `options` Argument ist <xref:System.StringSplitOptions.None>, die Methode gibt ein Zeichenfolgenarray mit den folgenden fünf Elementen zurück:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, das darstellt, dass der leeren Zeichenfolge, die vor der "-"-Zeichen am Index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, das darstellt, dass der leeren Zeichenfolge zwischen dem "-"-Zeichen am Index 0 und das Zeichen "_" am Index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge, die das Zeichen "_" Index 4 folgt darstellt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, der darstellt, dass der leeren Zeichenfolge, die folgt der "-"-Zeichen am Index 5.  
  
## <a name="the-separator-array"></a>Das Separator-array  
 Wenn die `separator` Parameter ist `null` oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die `separator` Parameter im Aufruf der Überladung dieser Methode ist `null`, Compiler überladungsauflösung ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere Zeichen getrennt sind die `separator` Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge von einem bekannten Satz von Zeichenfolgen getrennt ist, können Sie die <xref:System.String.Split%2A> Methode in Teilzeichenfolgen abzugrenzen.  
  
## <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen-Zeichenfolgen werden nicht in den Elementen im zurückgegebenen Array enthalten. Beispielsweise, wenn die `separator` Array enthält die Zeichenfolge "--" und der Wert der aktuellen Zeichenfolgeninstanz "aa - bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn keine der Zeichenfolgen in dieser Instanz enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn die `options` Parameter ist <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist NULL, wird die Methode ein leeres Array zurück.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, die aus einem oder mehreren Zeichen besteht. Wenn die `options` Argument ist <xref:System.StringSplitOptions.None>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String?displayProperty=nameWithType>. Z. B. wenn `separator` enthält zwei Elemente, die "-" und "_", um der Wert der Zeichenfolgeninstanz ist "- _aa -\_", und der Wert von der `options` Argument ist <xref:System.StringSplitOptions.None>, die Methode gibt ein Sting-Array mit den folgenden fünf Elementen zurück:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, das darstellt, dass der leeren Zeichenfolge, die vor der "-" Teilzeichenfolge am Index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, das darstellt, dass der leeren Zeichenfolge zwischen dem "-" Teilzeichenfolge am Index 0 und die Teilzeichenfolge "_" am Index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge, die die Teilzeichenfolge "_" Index 4 folgt darstellt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, der darstellt, dass der leeren Zeichenfolge, die folgt der "-" Teilzeichenfolge am Index 5.  
  
## <a name="the-separator-array"></a>Das Separator-array  
 Wenn keines der Elemente im `separator` besteht aus mehreren Zeichen, gilt die gesamte Teilzeichenfolge ein Trennzeichen. Angenommen, sofern der Elemente im `separator` ist "10", bei dem Versuch, teilen die Zeichenfolge "This10is10a10string." Gibt die folgenden vier Elementen Array: {"This", "is", "a", "String". }.  
  
 Wenn die `separator` Parameter ist `null` oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die `separator` Parameter im Aufruf der Überladung dieser Methode ist `null`, Compiler überladungsauflösung ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in begrenzt werden die `separator` Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
 Die <xref:System.String.Split%2A> Methode ignoriert alle Elemente von `separator` , dessen Wert `null` oder eine leere Zeichenfolge ("").  
  
 Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im `separator` haben Zeichen gemeinsam, die <xref:System.String.Split%2A> Vorgang vom Anfang bis zum Ende des Werts der Instanz wird fortgesetzt, und entspricht dem ersten Element in `separator` , die gleich ein Trennzeichen in der -Instanz. Die Reihenfolge, in der Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im `separator`.  
  
 Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef". Wenn das erste Element im `separator` "Ef" und das zweite Element "bcde", ist das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "f". Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im `separator` vor dem Auftreten der Teilzeichenfolge "f".  
  
 Jedoch, wenn das erste Element des `separator` "bcd" und das zweite Element wurde "bc", ist das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "Ef". Dies liegt daran "bcd" das erste Trennzeichen in `separator` , ein Trennzeichen in der Instanz entspricht. Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", das Ergebnis wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "Def".  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen den Arrays zurückgegeben, indem einer Zeichenfolge <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> Methode mit seiner `options` Parameter gleich <xref:System.StringSplitOptions?displayProperty=nameWithType> und <xref:System.StringSplitOptions?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 Das folgende Beispiel definiert ein Array von Trennzeichen, die Interpunktion und Leerzeichen enthalten. Übergibt dieses Array zusammen mit einem Wert von <xref:System.StringSplitOptions?displayProperty=nameWithType> auf die <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> -Methode gibt ein Array, aus denen die einzelne Wörter aus der Zeichenfolge besteht.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Beachten Sie, die die Methode aufgerufen wird, mit der `options` Argument festgelegt wird, um <xref:System.StringSplitOptions?displayProperty=nameWithType>. Dadurch wird verhindert, dass das zurückgegebene Array einschließlich <xref:System.String.Empty?displayProperty=nameWithType> Werten, leeren Teilzeichenfolge Übereinstimmungen zwischen Satzzeichen und Leerzeichen darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten.  
  
 Wenn keine Zeichen in dieser Instanz enthält `separator`, oder die `count` Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn die `separator` Parameter ist `null` oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode. Jedoch, wenn die `separator` Parameter im Aufruf der Überladung dieser Methode ist `null`, Compiler überladungsauflösung ein Fehler auftritt. Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ der Null angeben. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Wenn die `count` -Parameter ist 0 (null), oder die `options` Parameter ist <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn die `options` Parameter ist <xref:System.StringSplitOptions.None>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` 1 Teilzeichenfolgen sind in der ersten zurückgegebenen `count` minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen-Zeichenfolgen werden nicht in den Elementen im zurückgegebenen Array enthalten.  
  
 Wenn keine der Zeichenfolgen in dieser Instanz enthält `separator`, oder die `count` Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn die `separator` Parameter ist `null` oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode. Jedoch, wenn die `separator` Parameter im Aufruf der Überladung dieser Methode ist `null`, Compiler überladungsauflösung ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Wenn die `count` -Parameter ist 0 (null), oder die `options` Parameter ist <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, die aus einem oder mehreren Zeichen besteht. Wenn die `options` Parameter ist <xref:System.StringSplitOptions.None>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` 1 Teilzeichenfolgen sind in der ersten zurückgegebenen `count` minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
## <a name="the-separator-array"></a>Das Separator-array  
 Wenn keines der Elemente im `separator` besteht aus mehreren Zeichen, gilt die gesamte Teilzeichenfolge ein Trennzeichen. Angenommen, sofern der Elemente im `separator` ist "10", bei dem Versuch, teilen die Zeichenfolge "This10is10a10string." Gibt dieses Array mit vier Elementen: {"This", "is", "a", "String". }.  
  
## <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in begrenzt werden die `separator` Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet. Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
 Die <xref:System.String.Split%2A> Methode ignoriert alle Elemente von `separator` , dessen Wert `null` oder eine leere Zeichenfolge ("").  
  
 Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im `separator` haben Zeichen gemeinsam, die <xref:System.String.Split%2A> Methode geht von Anfang bis zum Ende des Werts der Instanz, und entspricht dem ersten Element in `separator` , die gleich ein Trennzeichen in der -Instanz. Die Reihenfolge, in der Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im `separator`.  
  
 Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef". Wenn das erste Element im `separator` "Ef" und das zweite Element "bcde", ist das Ergebnis des Split-Vorgangs wäre "a" und "f". Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im `separator` vor dem Auftreten der Teilzeichenfolge "f".  
  
 Jedoch, wenn das erste Element des `separator` "bcd" und das zweite Element wurde "bc", ist das Ergebnis des Split-Vorgangs wäre "a" und "Ef". Dies liegt daran "bcd" das erste Trennzeichen in `separator` , ein Trennzeichen in der Instanz entspricht. Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", wäre das Ergebnis "a" und "Def".  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen. Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> also <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode bewirkt Kürzen Sie die Zeichenfolge ein. In der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teilzeichenfolge am Anfang dieser Instanz, die die gleiche Länge wie `value`, und gibt einen Wert zurück, ob sie gleich sind. Gleich, `value` muss eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>), muss ein Verweis auf die gleiche Instanz oder der Anfang dieser Instanz müssen übereinstimmen.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `StripStartTags` Methode, verwendet die <xref:System.String.StartsWith%28System.String%29> -Methode zum Entfernen von HTML-Starttags vom Anfang einer Zeichenfolge. Beachten Sie, dass die `StripStartTags` Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-Tags mit Beginn am Anfang der Zeile entfernt werden. Im Beispiel werden keine HTML-Tags, eingebettet in einer Zeichenfolge entfernt.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der bestimmt, wie diese Zeichenfolge und <c>Wert</c> verglichen werden.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn diese Instanz mit <paramref name="value" /> beginnt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.StartsWith%2A> -Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge und gibt einen Wert, der angibt, ob sie gleich sind. Als gleich ansehen `value` ein Verweis auf die gleiche Zeichenfolge ist, eine leere Zeichenfolge (""), oder mit den Anfang dieser Zeichenfolge übereinstimmt. Der Typ des Vergleichs von ausgeführten der <xref:System.String.StartsWith%2A> Methode hängt vom Wert von der `comparisonType` Parameter. Der Vergleich können die Konventionen der aktuellen Kultur (<xref:System.StringComparison?displayProperty=nameWithType> und <xref:System.StringComparison?displayProperty=nameWithType>) oder der invarianten Kultur (<xref:System.StringComparison?displayProperty=nameWithType> und <xref:System.StringComparison?displayProperty=nameWithType>), oder es kann besteht aus einem Zeichen für Zeichen Vergleich Codepunkte (<xref:System.StringComparison?displayProperty=nameWithType> oder <xref:System.StringComparison?displayProperty=nameWithType>). Der Vergleich kann auch Groß-/Kleinschreibung beachtet werden (<xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, oder <xref:System.StringComparison?displayProperty=nameWithType>), oder sie können die Groß-/Kleinschreibung ignorieren (<xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach der Zeichenfolge "the" am Anfang eine längere Zeichenfolge, die beginnt mit dem Wort "The". Wie die Ausgabe des Beispiels zeigt, die einen Aufruf der <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> -Methode, die eine kulturunabhängige jedoch die Groß-/Kleinschreibung Vergleich ein Fehler auftritt, mit die Zeichenfolge übereinstimmen, während ein Aufrufs an, die eine Kultur und Fall insensitive Vergleich der Zeichenfolge übereinstimmt.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt. Ein zweidimensionales Array initialisiert. Das erste Element der zweiten Dimension enthält eine Zeichenfolge, und das zweite Element enthält die Zeichenfolge, die am Anfang der ersten Zeichenfolge suchen. Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird. Beachten Sie, dass bei die Zeichenfolgeninstanz eine Ligatur enthält, kulturabhängigen vergleichen mit aufeinander folgenden Zeichen erfolgreich entsprechen.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmt, wie diese Zeichenfolge und <c>Wert</c> verglichen werden. Wenn <c>Kultur</c> ist <see langword="null" />, die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge, die gleiche Länge wie `value`, und gibt einen Wert, der angibt, ob sie gleich sind. Gleich, `value` muss eine leere Zeichenfolge (<xref:System.String?displayProperty=nameWithType>), muss ein Verweis auf die gleiche Instanz oder der Anfang dieser Instanz müssen übereinstimmen.  
  
 Diese Methode führt einen Vergleich mit der angegebenen Groß-/Kleinschreibung und Kultur entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Anfang einer anderen Zeichenfolge auftritt. Die <xref:System.String.StartsWith%2A> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die untergeordnete Zeichenfolge beginnt in einer angegebenen Zeichenposition und wird an das Ende der Zeichenfolge fortgesetzt.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.String.Substring%2A> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und endet am Ende der Zeichenfolge. Die Anfangsposition ist eine nullbasiert. Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein. Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und endet vor bis zum Ende der Zeichenfolge zu extrahieren, rufen Sie die <xref:System.String.Substring%2A> Methode.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge, die bei beginnt die `startIndex` Position in der aktuellen Zeichenfolge.  
  
 Um eine Teilzeichenfolge extrahiert, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, z. B. <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> zum Abrufen des Werts `startIndex`. Das zweite Beispiel veranschaulicht dies. extrahiert einen Schlüssel-Wert, der eine Zeichenposition nach dem Zeichen "=" beginnt.  
  
 Wenn `startIndex` ist gleich 0 (null), die Methode gibt die ursprüngliche Zeichenfolge unverändert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Teilzeichenfolge aus einer Zeichenfolge abrufen.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> Methode zum Trennen von Schlüssel/Wert-Paaren, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> Methode wird verwendet, um die Position des Zeichens ist gleich in der Zeichenfolge abzurufen... Der Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode extrahiert der Schlüsselname angegeben., der vom ersten Zeichen in der Zeichenfolge beginnt und für die Anzahl der Zeichen, die vom Aufruf zurückgegebene erweitert die <xref:System.String.IndexOf%2A> Methode. Der Aufruf der <xref:System.String.Substring%28System.Int32%29> Methode extrahiert dann den Wert, der dem Schlüssel zugeordnet. Er beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Anzahl der Zeichen in der Teilzeichenfolge.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die Teilzeichenfolge beginnt an einer angegebenen Zeichenposition und hat eine angegebene Länge.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge mit der Länge <paramref name="length" /> ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz und <paramref name="length" /> 0 (null) ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und endet vor dem Ende der Zeichenfolge. Die Anfangsposition ist eine nullbasiert. Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein. Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und bis zum Ende der Zeichenfolge zu extrahieren, rufen Sie die <xref:System.String.Substring%28System.Int32%29> Methode.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt es eine neue Zeichenfolge mit `length` Zeichen ab der der `startIndex` Position in der aktuellen Zeichenfolge.  
  
 Die `length` Parameter stellt die Gesamtzahl der Zeichen, die aus der aktuellen Zeichenfolgeninstanz zu extrahieren. Dies schließt das erste Zeichen am Index gefunden `startIndex`.  Das heißt, die <xref:System.String.Substring%2A> Methode versucht, das Extrahieren von Zeichen aus dem Index `startIndex` Index `startIndex`  +  `length` - 1.  
  
 Um eine Teilzeichenfolge extrahiert, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, z. B. <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> zum Abrufen des Werts `startIndex`.  
  
 Wenn die Teilzeichenfolge vom erstreckt `startIndex` auf eine angegebene Zeichenfolge können Sie z. B. eine Methode aufrufen <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> den Index der Endzeichen oder Zeichenfolge abgerufen.  Sie können dann wie folgt diesen Wert an eine Indexposition in der Zeichenfolge konvertieren:  
  
-   Wenn Sie ein einzelnes Zeichen gesucht haben, das das Ende der Teilzeichenfolge, markieren der `length` entspricht `endIndex`  -  `startIndex` + 1, in dem `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> Methode. Das folgende Beispiel extrahiert einen kontinuierlichen Speicherplatzblock "b"-Zeichen aus einer Zeichenfolge.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Wenn Sie mehrere Zeichen gesucht haben, die das Ende der Teilzeichenfolge, markieren das `length` entspricht `endIndex`  +  `endMatchLength`  -  `startIndex`, wobei `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> -Methode. und `endMatchLength` ist die Länge der Zeichenfolge ist, die das Ende der Teilzeichenfolge markiert. Das folgende Beispiel extrahiert einen Textblock an, die eine XML-Datei enthält `<definition>` Element.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Wenn das Zeichen oder die Zeichenfolge am Ende der Teilzeichenfolge, nicht enthalten ist die `length` entspricht `endIndex`  -  `startIndex`, wobei `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> Methode.  
  
 Wenn `startIndex` ist gleich 0 (null) und ist gleich der Länge der aktuellen Zeichenfolge, die Methode gibt die ursprüngliche Zeichenfolge unverändert zurück.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen einfache Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode, die zwei Zeichen aus einer Zeichenfolge, beginnend an der Zeichenposition der sechsten extrahiert (d. h. am index 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode in den folgenden drei Fällen Teilzeichenfolgen innerhalb einer Zeichenfolge isoliert. In beiden Fällen werden die Teilzeichenfolgen in Vergleichen verwendet, und im dritten Fall wird eine Ausnahme ausgelöst, weil ungültige Parameter angegeben werden.  
  
-   Extrahiert das einzelne Zeichen und der dritten Position in der Zeichenfolge (am Index 2), und vergleicht ihn mit einem "c". Dieser Vergleich gibt `true`.  
  
-   0 (null) Zeichen ab der vierten Position in der Zeichenfolge (am Index 3) extrahiert und übergibt es an die <xref:System.String.IsNullOrEmpty%2A> Methode. Dies gibt "true", da der Aufruf der <xref:System.String.Substring%2A> -Methode zurückkehrt <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Es versucht, ein Zeichen ab der vierten Position in der Zeichenfolge zu extrahieren. Da es kein Zeichen an dieser Position ist, löst der Methodenaufruf eine <xref:System.ArgumentOutOfRangeException> Ausnahme.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> Methode zum Trennen von Schlüssel/Wert-Paaren, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> Methode wird verwendet, um die Position des Zeichens ist gleich in der Zeichenfolge abzurufen... Der Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode extrahiert der Schlüsselname angegeben., der vom ersten Zeichen in der Zeichenfolge beginnt und für die Anzahl der Zeichen, die vom Aufruf zurückgegebene erweitert die <xref:System.String.IndexOf%2A> Methode. Der Aufruf der <xref:System.String.Substring%28System.Int32%29> Methode extrahiert dann den Wert, der dem Schlüssel zugeordnet. Er beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> gibt eine Position außerhalb dieser Instanz an.  
  
 - oder -   
  
 <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein stark typisierter Enumerator, der verwendet werden kann, um das Durchlaufen des aktuellen <see cref="T:System.String" /> Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Kann verwendet werden nur, wenn die <xref:System.String> Instanz umgewandelt wird ein <xref:System.Collections.Generic.IEnumerable%601> -Schnittstellenobjekt. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein Enumerator, mit dem die Elemente in der aktuellen Zeichenfolge durchlaufen werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.TrueString" /> ist. <see langword="false" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.FalseString" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert der aktuellen Zeichenfolge ist kein <see cref="F:System.Boolean.TrueString" /> oder <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl größer als <see cref="F:System.Byte.MaxValue" /> oder kleiner als <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Das Zeichen am Index 0 im aktuellen <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl kleiner als <see cref="F:System.Decimal.MinValue" /> oder als <see cref="F:System.Decimal.MaxValue" /> größer.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl größer als <see cref="F:System.Int16.MaxValue" /> oder kleiner als <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl größer als <see cref="F:System.SByte.MaxValue" /> oder kleiner als <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zurückgegebenen Objekts.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ChangeType%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht in den vom angegebenen Typ konvertiert werden die <paramref name="type" /> Parameter.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> -Objekts ist eine Zahl größer als <see cref="F:System.UInt16.MaxValue" /> oder kleiner als <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" /> Objekt ist eine Zahl größer <see cref="F:System.UInt32.MaxValue" /> oder kleiner als<see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die einzelnen Zeichen dieser Instanz darstellen. Wenn diese Instanz eine leere Zeichenfolge ist, ist das zurückgegebene Array leer und hat die Länge 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert jedes Zeichen (d. h. jede <xref:System.Char> Objekt) in einer Zeichenfolge in ein Zeichenarray. Das erste Zeichen kopiert ist am Index 0 (null), der das Zeichenarray zurückgegebenen. das letzte Zeichen am Index ist <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Rufen Sie zum Erstellen einer Zeichenfolge von Zeichen in ein Array von Zeichen der <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor.  
  
 Um ein Byte-Array zu erstellen, das die codierten Zeichen in einer Zeichenfolge enthält, instanziieren Sie den entsprechenden <xref:System.Text.Encoding> Objekt, und rufen die <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> Methode. Einige der standard in .NET Framework verfügbaren Codierungen umfassen Folgendes:  
  
|Codierung|Objekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToCharArray%2A> Methode, um die Zeichen in einer Zeichenfolge in ein Zeichenarray zu extrahieren. Sie zeigt dann die ursprüngliche Zeichenfolge und die Elemente im Array.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 Das folgende Beispiel definiert eine Zeichenfolge, die mit den Zeichen, das als Trennzeichen in einer durch Trennzeichen getrennten Zeichenfolge dienen. Er ruft dann die <xref:System.String.ToCharArray%2A> Methode, um ein Array von Zeichen zu erstellen, die übergeben werden kann die <xref:System.String.Split%28System.Char%5B%5D%29> Methode, um die durch Trennzeichen getrennte Zeichenfolge in seine einzelnen Teilzeichenfolgen zu trennen.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Länge einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Kopiert die Zeichen einer angegebenen Teilzeichenfolge dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die <paramref name="length" />-Zeichen dieser Instanz ab Zeichenposition <paramref name="startIndex" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert die Zeichen in einem Teil einer Zeichenfolge in ein Zeichenarray. Um eine Zeichenfolge aus einem Bereich von Zeichen in ein Zeichenarray zu erstellen, rufen die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor.  
  
 Die `startIndex` Parameter ist nullbasiert. Der Index des ersten Zeichens in der Zeichenfolgeninstanz ist 0 (null).  
  
 Wenn `length` NULL ist, ist das zurückgegebene Array leer und hat die Länge 0. Wenn diese Instanz `null` oder eine leere Zeichenfolge (""), das zurückgegebene Array leer und hat die Länge 0.  
  
 Um ein Byte-Array zu erstellen, das die codierten Zeichen in einem Teil einer Zeichenfolge enthält, instanziieren Sie den entsprechenden <xref:System.Text.Encoding> Objekt, und rufen die <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> Methode. Einige der standard in .NET Framework verfügbaren Codierungen umfassen Folgendes:  
  
|Codierung|Objekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Teilzeichenfolge innerhalb einer Zeichenfolge in ein Array von Zeichen, konvertiert und dann listet auf und zeigt die Elemente des Arrays.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="startIndex" />plus <paramref name="length" /> ist größer als die Länge dieser Instanz.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge aus Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode berücksichtigt die Regeln der Groß-und Kleinschreibung der aktuellen Kultur.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Die Schreibweise-Vorgang, der aus den Aufrufen resultiert die <xref:System.String.ToLower> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur. Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden. Hierdurch wird das gleiche Ergebnis in jede Kultur (im Gegensatz zu den <xref:System.String.ToLower> Methode) und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgende Beispiel werden mehrere gemischte Groß-/Kleinschreibung Zeichenfolgen in Kleinbuchstaben konvertiert.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden Zeichenfolge Groß-/Kleinschreibung Methoden aufrufen, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Um ein Zeichen in Kleinbuchstaben mit die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur zu konvertieren, rufen die <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln der Groß-und Kleinschreibung der Kultur angegeben werden, indem die `culture` Parameter zu bestimmen, wie die Groß-/Kleinschreibung der Zeichenfolge geändert wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie übergeben die <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> Methode eine <xref:System.Globalization.CultureInfo> Objekt außer <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln. Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Dies führt zum gleichen Ergebnis in jede Kultur und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgende Beispiel zwei Zeichenfolgen in Großbuchstaben in Kleinbuchstaben unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei konvertiert, und vergleicht dann die Kleinbuchstaben Zeichenfolgen. Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass für jedes Vorkommen des Unicode-LATIN CAPITAL LETTER I in eine Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist. Verknüpft ist mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn Ihre Anwendung hängt von der Groß-/Kleinschreibung einer Zeichenfolge in einer vorhersagbaren Weise, die von der aktuellen Kultur verwenden nicht betroffen ist ändern die <xref:System.String.ToLowerInvariant%2A> Methode. Die <xref:System.String.ToLowerInvariant%2A> Methode entspricht `ToLower(CultureInfo.InvariantCulture)`. Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von Zeichenfolgen, die ein einzelnes Wort in mehrere Sprachen enthält. Die <xref:System.String.ToLowerInvariant%2A> Methode wird verwendet, um die Elemente eines Arrays parallel mit der Groß-/Kleinschreibung Version jedes Worts aufzufüllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array um sicherzustellen, dass die Elemente in der gleichen Reihenfolge unabhängig von der Sprache angezeigt Kleinbuchstaben Array zu sortieren.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da diese Methode einfach die aktuelle Zeichenfolge unverändert zurückgibt, ist es nicht erforderlich, es direkt aufzurufen. In der Regel wird es implizit in eine zur kombinierten Formatierung Vorgang, wie im Beispiel gezeigt aufgerufen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.ToString%2A> Methode. Beachten Sie, die im Beispiel nicht explizit aufrufen, wird die <xref:System.String.ToString%2A> Methode. Stattdessen die Methode wird aufgerufen, implizit von der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Funktion.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</param>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider`ist reserviert und derzeit nicht bei diesem Vorgang beteiligt.  
  
 Da diese Methode einfach die aktuelle Zeichenfolge unverändert zurückgibt, ist es nicht erforderlich, es direkt aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Regeln der Groß-und Kleinschreibung der aktuellen Kultur, um jedes Zeichen in der aktuellen Instanz in dessen Entsprechung in Großbuchstaben zu konvertieren. Wenn ein Zeichen nicht über eine Entsprechung in Großbuchstaben verfügt, ist es unverändert in der zurückgegebenen Zeichenfolge enthalten.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
 Die <xref:System.String.ToUpper%2A> Methode wird häufig verwendet, um eine Zeichenfolge in Großbuchstaben zu konvertieren, damit es in einem Vergleich Groß-/Kleinschreibung verwendet werden kann. Eine bessere Methode zum Ausführen von Groß-und Kleinschreibung unterschieden wird, aufzurufenden verfügt über eine Methode zum Zeichenfolgenvergleich einer <xref:System.StringComparison> , dessen Wert Sie zum Festlegen des Parameters <xref:System.StringComparison?displayProperty=nameWithType> für einen Vergleich kulturabhängig, Groß-/Kleinschreibung.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Die Schreibweise-Vorgang, der aus den Aufrufen resultiert die <xref:System.String.ToUpper> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur. Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Hierdurch wird das gleiche Ergebnis in jede Kultur (im Gegensatz zu den <xref:System.String.ToUpper> Methode) und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToUpper%2A> Methode, um eine Reihe von einem Zeichen von Zeichenfolgen zu konvertieren, die jedes Zeichen in die lateinischen Latein-1, Ergänzung und Latin Extended-A-Zeichensätze enthalten. Es zeigt dann jede Zeichenfolge, deren Großbuchstaben von seinem Kleinbuchstaben unterscheidet.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Wie in beschrieben [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), sollten Sie vermeiden Zeichenfolge Groß-/Kleinschreibung Methoden aufrufen, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen. Rufen Sie zum Konvertieren einer Zeichenfolge in Großbuchstaben unter Verwendung der Groß-/ Kleinschreibungskonventionen der aktuellen Kultur der <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln der Groß-und Kleinschreibung der Kultur angegeben werden, indem die `culture` Parameter zu bestimmen, wie die Groß-/Kleinschreibung einer Zeichenfolge geändert wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie übergeben die <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> Methode eine <xref:System.Globalization.CultureInfo> Objekt außer <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln. Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Dies führt zum gleichen Ergebnis in jede Kultur und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge von Kleinbuchstaben in Großbuchstaben unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei zwei Zeichenfolgen und vergleicht dann die Zeichenfolgen in Großbuchstaben. Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass für jedes Vorkommen des Unicode-LATIN CAPITAL LETTER I in eine Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist. Verknüpft ist mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn Ihre Anwendung hängt von der Groß-/Kleinschreibung einer Zeichenfolge in einer vorhersagbaren Weise, die von der aktuellen Kultur verwenden nicht betroffen ist ändern die <xref:System.String.ToUpperInvariant%2A> Methode. Die <xref:System.String.ToUpperInvariant%2A> Methode entspricht `ToUpper(CultureInfo.InvariantCulture)`. Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von Zeichenfolgen, die ein einzelnes Wort in mehrere Sprachen enthält. Die <xref:System.String.ToUpperInvariant%2A> Methode wird verwendet, um die Elemente eines Arrays parallel mit der Groß-/Kleinschreibung Version jedes Worts aufzufüllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array in Großbuchstaben um sicherzustellen, dass die Elemente in der gleichen Reihenfolge unabhängig von der Sprache angezeigt Array zu sortieren.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle führenden und nachgestellten Leerraumzeichen aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang und Ende der aktuellen Zeichenfolge. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> -Methode aus der aktuellen Zeichenfolge alle führende und nachfolgende Leerzeichen entfernt. Jede führende und nachfolgende Entfernungsvorgang beendet, wenn ein nicht-Leerzeichen gefunden wird. Wenn die aktuelle Zeichenfolge "Abc Xyz" ist beispielsweise die <xref:System.String.Trim%2A> Methodenrückgabe "Abc Xyz". Verwenden Sie zum Entfernen von Leerzeichen zwischen Wörtern in einer Zeichenfolge einen [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle führenden und nachfolgenden Leerzeichen in der aktuellen Instanz gefunden entfernt werden zurückgegeben.  
  
 Wenn die aktuelle Zeichenfolge entspricht <xref:System.String.Empty> oder alle Zeichen in der aktuellen Instanz bestehen aus Leerstellen bestehen, der Methodenrückgabe <xref:System.String.Empty>.  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.Trim> -Methode entfernt alle führenden und nachgestellten Zeichen, die einen Rückgabewert von erzeugen `true` Wenn sie übergeben die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Trim?displayProperty=nameWithType> Methode, um zusätzliche Leerzeichen in Zeichenfolgen, die vom Benutzer eingegeben werden, bevor Sie verketten zu entfernen.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen behalten eine interne Liste von Leerzeichen, die diese Methode abschneidet. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], schneidet die Methode alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang und Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> -Methode entfernt aus der aktuellen Zeichenfolge alle führende und nachgestellte Zeichen in der `trimChars` Parameter. Jede führende und nachfolgende trim-Vorgang wird beendet, wenn ein Zeichen, der nicht `trimChars` festgestellt wird. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.Trim%2A> Methodenrückgabe "abc456xyz".  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt Sie eine neue Zeichenfolge zurück, in dem alle führenden und nachfolgenden `trimChars` Zeichen, die in der aktuellen Instanz gefunden werden entfernt.  
  
 Ist gleich die aktuelle Zeichenfolge <xref:System.String.Empty> oder alle Zeichen in der aktuellen Instanz bestehen, der Zeichen in der `trimChars` array, der Methodenrückgabe <xref:System.String.Empty>.  
  
 Wenn `trimChars` ist `null` oder ein leeres Array, das diese Methode entfernt keine führenden oder nachgestellten Zeichen, die in der Methode zurückgeben `true` Wenn sie übergeben die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> Methode, um Speicherplatz, Sternchen (*) und Apostroph (') Zeichen aus einer Zeichenfolge zu entfernen.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimEnd%2A> Methode entfernt aus der aktuellen Zeichenfolge alle Zeichen, die in der `trimChars` Parameter. Der Vorgang wird beendet, wenn das erste Zeichen, die nicht `trimChars` auftritt, wird am Ende der Zeichenfolge. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.TrimEnd%2A> Methodenrückgabe "123abc456xyz zurück".  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimEnd%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle nachfolgenden Zeichen gefunden `trimChars` aus der aktuellen Zeichenfolge entfernt werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie können die <xref:System.String.TrimEnd%28System.Char%5B%5D%29> Methode, um Leerzeichen oder Satzzeichen vom Ende einer Zeichenfolge abzuschneiden.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimStart%2A> Methode entfernt aus der aktuellen Zeichenfolge alle Zeichen, die in der `trimChars` Parameter. Der Entfernungsvorgang beendet, wenn ein Zeichen, der nicht `trimChars` festgestellt wird. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.TrimStart%2A> Methodenrückgabe "abc456xyz789".  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimStart%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle führenden Leerzeichen in der aktuellen Instanz gefunden entfernt werden zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.TrimStart%2A> Methode, um Leerraum und kommentierungszeichen von Quellcodezeilen zu kürzen. Die `StripComments` Methode bindet einen Aufruf von <xref:System.String.TrimStart%2A> und übergibt ein Array von Zeichen, die ein Leerzeichen und die Kommentarzeichen, also ein Apostroph (') in Visual Basic und ein Schrägstrich (/) in c# enthält. Die <xref:System.String.TrimStart%2A> Methode auch aufgerufen, um führende Leerzeichen zu entfernen, wenn zu bewerten, ob eine Zeichenfolge ein Kommentar ist.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 Im folgenden Beispiel wird ein Aufruf der `StripComments`-Methode veranschaulicht.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
