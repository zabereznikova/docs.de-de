<Type Name="Math" FullName="System.Math">
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Konstanten und statische Methoden für trigonometrische, logarithmische und andere gebräuchliche mathematische Funktionen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/math.cs#a4407e67b9a5afad). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
   
  
## Examples  
 Im folgende Beispiel werden verschiedene mathematische und trigonometrische Funktionen aus der <xref:System.Math> Klasse, um die inneren Winkel, der ein Trapez zu berechnen.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer oder gleich <see cref="F:System.Decimal.MinValue" />, aber kleiner oder gleich <see cref="F:System.Decimal.MaxValue" /> ist.</param>
        <summary>Gibt den Absolutbetrag einer <see cref="T:System.Decimal" />-Zahl zurück.</summary>
        <returns>Eine Dezimalzahl x im Bereich dieser ≤ 0 X ≤<see cref="F:System.Decimal.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Decimal> ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von 1,2 und -1,2 1.2.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Decimal%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Decimal> Werte.  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer oder gleich <see cref="F:System.Double.MinValue" />, aber kleiner oder gleich <see cref="F:System.Double.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
        <returns>Eine Gleitkommazahl x mit doppelter Genauigkeit, ≤ 0 X ≤<see cref="F:System.Double.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Double> ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von sowohl-1.2e03 und-1.2e03 1.2e03.  
  
 Wenn `value` gleich <xref:System.Double.NegativeInfinity> oder <xref:System.Double.PositiveInfinity>, ist der Rückgabewert <xref:System.Double.PositiveInfinity>. Wenn `value` gleich <xref:System.Double.NaN>, ist der Rückgabewert <xref:System.Double.NaN>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Double%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Double> Werte.  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer als <see cref="F:System.Int16.MinValue" />, aber kleiner oder gleich <see cref="F:System.Int16.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer 16-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Eine 16-Bit-Ganzzahl x mit Vorzeichen, ≤ 0 X ≤<see cref="F:System.Int16.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Int16> ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von-123 und 123 123.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Int16%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Int16> Werte.  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist gleich <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer als <see cref="F:System.Int32.MinValue" />, aber kleiner oder gleich <see cref="F:System.Int32.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Eine 32-Bit-Ganzzahl x mit Vorzeichen, ≤ 0 X ≤<see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Int32> ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von-123 und 123 123.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Int32%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Int32> Werte.  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist gleich <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer als <see cref="F:System.Int64.MinValue" />, aber kleiner oder gleich <see cref="F:System.Int64.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Eine 64-Bit-Ganzzahl x mit Vorzeichen, ≤ 0 X ≤<see cref="F:System.Int64.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Int64> ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von-123 und 123 123.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Int64%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Int64> Werte.  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist gleich <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer als <see cref="F:System.SByte.MinValue" />, aber kleiner oder gleich <see cref="F:System.SByte.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer 8-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Eine 8-Bit-Ganzzahl x mit Vorzeichen, ≤ 0 X ≤<see cref="F:System.SByte.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert eines Bytewerts mit Vorzeichen ist der numerische Wert ohne Vorzeichen. Beispielsweise ist der Absolute Wert von 12 und-12 12.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.SByte%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.SByte> Werte.  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist gleich <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, die größer oder gleich <see cref="F:System.Single.MinValue" />, aber kleiner oder gleich <see cref="F:System.Single.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Eine Gleitkommazahl x mit einfacher Genauigkeit, ≤ 0 X ≤<see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer <xref:System.Single> ist der numerische Wert ohne Vorzeichen. Z. B. den absoluten Wert von 1.2e-03 und-1.2e03 ist-1.2e03.  
  
 Wenn `value` gleich <xref:System.Single.NegativeInfinity> oder <xref:System.Single.PositiveInfinity>, ist der Rückgabewert <xref:System.Single.PositiveInfinity>. Wenn `value` gleich <xref:System.Single.NaN>, ist der Rückgabewert <xref:System.Single.NaN>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Abs%28System.Single%29> Methode zum Abrufen der Absolute Wert einer Reihe von <xref:System.Single> Werte.  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Zahl, die einen Kosinus darstellt, in dem <c>d</c> muss größer als oder gleich-1, aber kleiner oder gleich 1.</param>
        <summary>Gibt einen Winkel zurück, dessen Kosinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel, gilt θ, gemessen im Bogenmaß, sodass 0 ≤θ≤π  
  
 - oder -   
  
 <see cref="F:System.Double.NaN" />Wenn <paramref name="d" /> &lt; -1 oder <paramref name="d" /> &gt; 1 oder <paramref name="d" /> gleich <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.Math.PI?displayProperty=nameWithType> zum Konvertieren von Bogenmaß in Grad.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Acos%2A> Methode, um die Berechnung der inneren Winkel von einer bestimmten Trapez zu unterstützen.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Zahl, die einen Sinus darstellt, in dem <c>d</c> muss größer als oder gleich-1, aber kleiner oder gleich 1.</param>
        <summary>Gibt einen Winkel zurück, dessen Sinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel, gilt θ, gemessen im Bogenmaß, - π/2 ≤θ≤π/2  
  
 - oder -   
  
 <see cref="F:System.Double.NaN" />Wenn <paramref name="d" /> &lt; -1 oder <paramref name="d" /> &gt; 1 oder <paramref name="d" /> gleich <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver Rückgabewert stellt einen gegen den Uhrzeigersinn Winkel von der x-Achse dar; ein negativer Wert stellt einen Winkel im Uhrzeigersinn.  
  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.Math.PI?displayProperty=nameWithType> zum Konvertieren von Bogenmaß in Grad.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Asin%2A> , die in die Berechnung der inneren Winkel von einer bestimmten Trapez helfen.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Zahl, die einen Tangens darstellt.</param>
        <summary>Gibt einen Winkel zurück, dessen Tangens die angegebene Zahl ist.</summary>
        <returns>Ein Winkel, gilt θ, gemessen im Bogenmaß, - π/2 ≤θ≤π/2.  
  
 - oder -   
  
 <see cref="F:System.Double.NaN" />Wenn <paramref name="d" /> gleich <see cref="F:System.Double.NaN" />, - π/2 auf doppelte Genauigkeit (gerundet 1,5707963267949) gerundet, wenn <paramref name="d" /> gleich <see cref="F:System.Double.NegativeInfinity" />, oder π/2 auf doppelte Genauigkeit (1,5707963267949) gerundet, wenn <paramref name="d" /> gleich <see cref="F:System.Double.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver Rückgabewert stellt einen gegen den Uhrzeigersinn Winkel von der x-Achse dar; ein negativer Wert stellt einen Winkel im Uhrzeigersinn.  
  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.Math.PI?displayProperty=nameWithType> zum Konvertieren von Bogenmaß in Grad.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie berechnet den Arkustangens eines Werts und auf der Konsole anzeigt.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">Die y-Koordinate eines Punkts.</param>
        <param name="x">Die x-Koordinate eines Punkts.</param>
        <summary>Gibt einen Winkel zurück, dessen Tangens der Quotient zweier angegebener Zahlen ist.</summary>
        <returns>Ein Winkel, gilt θ, gemessen im Bogenmaß, - π≤θ≤π, und tan(θ) = <paramref name="y" />  /  <paramref name="x" />, wobei (<paramref name="x" />, <paramref name="y" />) ein Punkt in der kartesischen Ebene ist. Beachten Sie dabei:  
  
-   Für (<paramref name="x" />, <paramref name="y" />) im Quadranten 1, 0 &lt; θ &lt; π/2.  
  
-   Für (<paramref name="x" />, <paramref name="y" />) in Quadrant "," 2 "," π/2 &lt; θ≤π.  
  
-   Für (<paramref name="x" />, <paramref name="y" />) im Quadranten 3, - π &lt; θ &lt; - π/2.  
  
-   Für (<paramref name="x" />, <paramref name="y" />) in Quadrant "," 4 "," - π/2 &lt; θ &lt; 0.  
  
 Für Punkte an den Begrenzungen der Quadranten wird der folgende Rückgabewert zurückgegeben:  
  
-   Wenn y gleich 0 und x nicht negativ ist, gilt θ = 0.  
  
-   Wenn y gleich 0 und x negativ ist, gilt θ = π.  
  
-   Wenn y positiv und x gleich 0 ist, gilt θ = π/2.  
  
-   Wenn y negativ ist und x gleich 0 ist, gilt θ = -π/2.  
  
-   Wenn y gleich 0 ist und x gleich 0 ist, gilt θ = 0.  
  
 Wenn <paramref name="x" /> oder <paramref name="y" /> gleich <see cref="F:System.Double.NaN" /> ist oder wenn <paramref name="x" /> und <paramref name="y" /> entweder gleich <see cref="F:System.Double.PositiveInfinity" /> oder gleich <see cref="F:System.Double.NegativeInfinity" /> sind, gibt die Methode <see cref="F:System.Double.NaN" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der Winkel in der kartesischen Ebene zwischen der x-Achse und einen Vektor vom Ursprung (0,0) starten und beenden, an dem Punkt, (X, y).  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie berechnet den Arkustangens des einen Winkel und einen Vektor. Der resultierende Wert wird in der Konsole angezeigt.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">Die erste zu multiplizierende Zahl.</param>
        <param name="b">Die zweite zu multiplizierende Zahl.</param>
        <summary>Berechnet das vollständige Produkt aus zwei 32-Bit-Zahlen.</summary>
        <returns>Die Zahl, die das Produkt der angegebenen Zahlen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Math.BigMul%2A> Methode, um das Produkt von zwei ganzzahligen Werten zu berechnen.  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die kleinste Ganzzahl zurück, die größer oder gleich der angegebenen Zahl ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung plus unendlich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine Dezimalzahl.</param>
        <summary>Gibt den kleinsten ganzzahligen Wert zurück, der größer oder gleich der angegebenen Dezimalzahl ist.</summary>
        <returns>Der kleinste ganzzahlige Wert, der größer oder gleich <paramref name="d" /> ist. Beachten Sie, dass diese Methode einen <see cref="T:System.Decimal" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung plus unendlich. Das heißt, wenn `d` positiv ist, wird das Vorhandensein von jeder Nachkommawert Ursachen `d` auf die nächsthöhere ganze Zahl gerundet werden. Wenn `d` ist negativ, Rundung bewirkt, dass alle Nachkommawert von `d` verworfen werden. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Math.Floor%28System.Decimal%29> -Methode, die runden in Richtung minus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> Methode und Unterschiede aufgezeigt, mit der <xref:System.Math.Floor%28System.Decimal%29> Methode.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt den kleinsten ganzzahligen Wert zurück, der größer oder gleich der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist.</summary>
        <returns>Der kleinste ganzzahlige Wert, der größer oder gleich <paramref name="a" /> ist. Wenn <paramref name="a" /> gleich <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben. Beachten Sie, dass diese Methode einen <see cref="T:System.Double" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung plus unendlich. Das heißt, wenn `a` positiv ist, wird das Vorhandensein von jeder Nachkommawert Ursachen `a` auf die nächsthöhere ganze Zahl gerundet werden. Wenn `a` ist negativ, Rundung bewirkt, dass alle Nachkommawert von `a` verworfen werden. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Math.Floor%28System.Double%29> -Methode, die runden in Richtung minus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> Methode und Unterschiede aufgezeigt, mit der <xref:System.Math.Floor%28System.Double%29> Methode.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Kosinus des angegebenen Winkels zurück.</summary>
        <returns>Der Kosinus von <paramref name="d" />. Wenn <paramref name="d" /> gleich <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird <see cref="F:System.Double.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `d`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
 Zulässige Werte von `d` reichen von ungefähr-9223372036854775295 bis ungefähr 9223372036854775295. Für Werte außerhalb dieses Bereichs die <xref:System.Math.Cos%2A> -Methode zurückkehrt `d` unverändert, anstatt eine Ausnahme auszulösen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Cos%2A> bestimmte trigonometrischen Identitäten für ausgewählte Winkel ausgewertet.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbelkosinus des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbelkosinus von <paramref name="value" />. Wenn <paramref name="value" /> gleich <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird <see cref="F:System.Double.PositiveInfinity" /> zurückgegeben. Wenn <paramref name="value" /> gleich <see cref="F:System.Double.NaN" /> ist, wird <see cref="F:System.Double.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `value`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Cosh%2A> bestimmte hyperbolischen Identitäten für ausgewählte Werte ausgewertet.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">Der Dividend.</param>
        <param name="b">Der Divisor.</param>
        <param name="result">Der Rest.</param>
        <summary>Berechnet den Quotienten zweier 32-Bit-Ganzzahlen mit Vorzeichen und gibt außerdem den Rest als Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der angegebenen Zahlen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rest wird berechnet, indem mithilfe der Modulo-Operation.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> Methode.  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">Der Dividend.</param>
        <param name="b">Der Divisor.</param>
        <param name="result">Der Rest.</param>
        <summary>Berechnet den Quotienten zweier 64-Bit-Ganzzahlen mit Vorzeichen und gibt außerdem den Rest als Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der angegebenen Zahlen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rest wird berechnet, indem mithilfe der Modulo-Operation.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> Methode.  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>Stellt die Basis des natürlichen Logarithmus durch die Konstante <see langword="e" /> dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist 2.7182818284590452354.  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht <xref:System.Math.E> mit dem Wert aus einer Reihe von Power berechnet.  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Zahl, die einen Exponenten angibt.</param>
        <summary>Gibt den Wert von <see langword="e" /> hoch angegebenem Exponenten zurück.</summary>
        <returns>Die Zahl <see langword="e" /> hoch <paramref name="d" />. Wenn <paramref name="d" /> gleich <see cref="F:System.Double.NaN" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben. Wenn <paramref name="d" /> gleich <see cref="F:System.Double.NegativeInfinity" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`ist eine mathematische Konstante, deren Wert ca. 2,71828 entspricht.  
  
 Verwenden der <xref:System.Math.Pow%2A> Methode, um Potenzen von anderen Basen zu berechnen.  
  
 <xref:System.Math.Exp%2A>ist das Gegenteil der <xref:System.Math.Log%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Exp%2A> bestimmte exponentiellen und logarithmischen Identitäten für ausgewählte Werte ausgewertet.  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die größte Ganzzahl zurück, die kleiner oder gleich der angegebenen Zahl ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung minus unendlich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine Dezimalzahl.</param>
        <summary>Gibt die größte Ganzzahl zurück, die kleiner oder gleich der angegebenen Dezimalzahl ist.</summary>
        <returns>Die größte Ganzzahl, die kleiner oder gleich <paramref name="d" /> ist.  Beachten Sie, dass die Methode einen Ganzzahlwert vom Typ <see cref="T:System.Math" /> zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung minus unendlich. Das heißt, wenn `d` positiv ist, alle Nachkommawert wird abgeschnitten. Wenn `d` ist negativ ist, das Vorhandensein von jeder Nachkommawert bewirkt, dass es auf die nächste ganze Zahl gerundet. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Math.Ceiling%2A> -Methode, die Rundung in Richtung plus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> Methode und Unterschiede aufgezeigt, mit der <xref:System.Math.Ceiling%28System.Decimal%29> Methode.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt die größte Ganzzahl zurück, die kleiner oder gleich der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist.</summary>
        <returns>Die größte Ganzzahl, die kleiner oder gleich <paramref name="d" /> ist. Wenn <paramref name="d" /> gleich <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung minus unendlich. Das heißt, wenn `d` positiv ist, alle Nachkommawert wird abgeschnitten. Wenn `d` ist negativ ist, das Vorhandensein von jeder Nachkommawert bewirkt, dass es auf die nächste ganze Zahl gerundet. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Math.Ceiling%2A> -Methode, die Rundung in Richtung plus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> Methode und Unterschiede aufgezeigt, mit der <xref:System.Math.Ceiling%28System.Double%29> Methode.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Ein Dividend.</param>
        <param name="y">Ein Divisor.</param>
        <summary>Gibt den Rest der Division zweier angegebener Zahlen zurück.</summary>
        <returns>Eine Zahl, die gleich <paramref name="x" /> -(<paramref name="y" /> Q), wobei Q der Quotient ist <paramref name="x" />  /  <paramref name="y" /> auf die nächste Ganzzahl gerundet (Wenn <paramref name="x" />  /  <paramref name="y" /> liegt in der Mitte zwischen zwei ganzen Zahlen, die gerade ganze Zahl zurückgegeben).  
  
 Wenn <paramref name="x" /> - (<paramref name="y" />Q) gleich 0 ist, wird bei positivem <paramref name="x" /> +0 und bei negativem <paramref name="x" /> -0 zurückgegeben.  
  
 Wenn <paramref name="y" /> = 0 ist, wird <see cref="F:System.Double.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang entspricht, mit dem Rest-Vorgang in Abschnitt 5.1 ANSI/IEEE Std 754-1985 definiert; IEEE-Standard für binäre Gleitkommaarithmetik; Institute of Electrical and Electronics Engineers, Inc.; 1985.  
  
 Die <xref:System.Math.IEEERemainder%2A> Methode ist nicht identisch mit der Modulo-Operator. Obwohl beide den Rest nach der Division zurückgeben, unterscheiden sich die Formeln, die sie verwenden. Die Formel für die <xref:System.Math.IEEERemainder%2A> Methode ist:  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 Im Gegensatz dazu wird die Formel für den Moduloperator:  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 Im folgende Beispiel werden die Unterschiede zwischen des Rest zurückgegebenes die <xref:System.Math.IEEERemainder%2A> Methode mit den übrigen zurückgegebenes Modulo-Divisionsoperator.  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="d" />Parameter  
  
 </term><description>Rückgabewert  
  
 </description></listheader><item><term>Positive  
  
 </term><description>Der natürliche Logarithmus des <paramref name="d" />; d. h. ln <paramref name="d" />, oder der Protokolldatei e <paramref name="d" /> </description> </item> <item> <term> 0 (null)  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term>Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term>Gleich <see cref="F:System.Double.NaN" /> </term> <description> <see cref="F:System.Double.NaN" /> </description> </item> <item> <term> gleich<see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `d` wird als Zahl zur Basis 10 angegeben.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Log%2A> Methode.  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <param name="newBase">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle. (Plus unendlich steht für <see cref="F:System.Double.PositiveInfinity" />, minus unendlich für <see cref="F:System.Double.NegativeInfinity" /> und NaN für <see cref="F:System.Double.NaN" />.)  
  
 <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description>Rückgabewert  
  
 </description></listheader><item><term><paramref name="a" />&gt; 0  
  
 </term><description>(0 &lt; <paramref name="newBase" /> &lt; 1) – oder – (<paramref name="newBase" /> &gt; 1)  
  
 </description><description>lognewBase(a)  
  
 </description></item><item><term><paramref name="a" />&lt; 0  
  
 </term><description>(beliebiger Wert)  
  
 </description><description>"NaN"  
  
 </description></item><item><term>(beliebiger Wert)  
  
 </term><description><paramref name="newBase" />&lt; 0  
  
 </description><description>"NaN"  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description>"NaN"  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" />= Plus unendlich  
  
 </description><description>"NaN"  
  
 </description></item><item><term><paramref name="a" />= "NaN"  
  
 </term><description>(beliebiger Wert)  
  
 </description><description>"NaN"  
  
 </description></item><item><term>(beliebiger Wert)  
  
 </term><description><paramref name="newBase" />= "NaN"  
  
 </description><description>"NaN"  
  
 </description></item><item><term>(beliebiger Wert)  
  
 </term><description><paramref name="newBase" /> = 1  
  
 </description><description>"NaN"  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description>Plus unendlich  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description>-Infinity  
  
 </description></item><item><term><paramref name="a" />= Plus unendlich  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description>-Infinity  
  
 </description></item><item><term><paramref name="a" />= Plus unendlich  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description>Plus unendlich  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description> 0  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" />= Plus unendlich  
  
 </description><description> 0  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Log%2A> bestimmte logarithmische Identitäten für ausgewählte Werte ausgewertet.  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="d" />Parameter  
  
 </term><description>Rückgabewert  
  
 </description></listheader><item><term>Positive  
  
 </term><description>Der Logarithmus zur Basis 10 von <paramref name="d" />; ist, melden Sie sich 10<paramref name="d" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term>Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term>Gleich <see cref="F:System.Double.NaN" /> </term> <description> <see cref="F:System.Double.NaN" /> </description> </item> <item> <term> gleich<see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `d` wird als Zahl zur Basis 10 angegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Log10%2A> Methode, um den Logarithmus zur Basis 10 für ausgewählte Werte zurückzugeben.  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 8-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 8-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die größere von zwei 8-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Dezimalzahlen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Dezimalzahlen.</param>
        <summary>Gibt die größere von zwei Dezimalzahlen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Gleitkommazahlen mit doppelter Genauigkeit.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit doppelter Genauigkeit.</param>
        <summary>Gibt die größere von zwei Gleitkommazahlen mit doppelter Genauigkeit zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />. Wenn entweder <paramref name="val1" /> oder <paramref name="val2" /> oder sowohl <paramref name="val1" /> als auch <paramref name="val2" /> gleich <see cref="F:System.Double.NaN" /> ist, wird <see cref="F:System.Double.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 16-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 16-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die größere von zwei 16-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 32-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 32-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die größere von zwei 32-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 64-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 64-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die größere von zwei 64-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die größere von zwei 8-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt die größere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />. Wenn entweder <paramref name="val1" /> oder <paramref name="val2" /> oder sowohl <paramref name="val1" /> als auch <paramref name="val2" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 16-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 16-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die größere von zwei 16-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 32-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 32-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die größere von zwei 32-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 64-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 64-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die größere von zwei 64-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der größere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Max%2A> Methode zum Zurückgeben und Anzeigen der größeren von zwei Variablen.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 8-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 8-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 8-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Dezimalzahlen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Dezimalzahlen.</param>
        <summary>Gibt die kleinere von zwei Dezimalzahlen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Gleitkommazahlen mit doppelter Genauigkeit.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit doppelter Genauigkeit.</param>
        <summary>Gibt die kleinere von zwei Gleitkommazahlen mit doppelter Genauigkeit zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />. Wenn entweder <paramref name="val1" /> oder <paramref name="val2" /> oder sowohl <paramref name="val1" /> als auch <paramref name="val2" /> gleich <see cref="F:System.Double.NaN" /> ist, wird <see cref="F:System.Double.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 16-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 16-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 16-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 32-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 32-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 32-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 64-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 64-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 64-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 8-Bit-Ganzzahlen mit Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt die kleinere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />. Wenn entweder <paramref name="val1" /> oder <paramref name="val2" /> oder sowohl <paramref name="val1" /> als auch <paramref name="val2" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 16-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 16-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 16-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 32-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 32-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 32-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">Die erste von zwei zu vergleichenden 64-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <param name="val2">Die zweite von zwei zu vergleichenden 64-Bit-Ganzzahlen ohne Vorzeichen.</param>
        <summary>Gibt die kleinere von zwei 64-Bit-Ganzzahlen ohne Vorzeichen zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="val1" /> und <paramref name="val2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Min%2A> Methode zum Zurückgeben und die kleinere von zwei Variablen anzeigen.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>Stellt das Verhältnis vom Umfang eines Kreises zu dessen Durchmesser, angegeben durch die Konstante π dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist 3,14159265358979323846.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.PI> , die in die Berechnung der inneren Winkel von einer bestimmten Trapez helfen.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Eine Gleitkommazahl mit doppelter Genauigkeit, die potenziert werden soll.</param>
        <param name="y">Eine Gleitkommazahl mit doppelter Genauigkeit, die einen Exponenten darstellt.</param>
        <summary>Potenziert eine angegebene Zahl mit dem angegebenen Exponenten.</summary>
        <returns>Die Zahl <paramref name="x" /> hoch <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt den Rückgabewert, wenn für verschiedene Werte oder Wertebereiche angegeben werden die `x` und `y` Parameter. Weitere Informationen finden Sie unter <xref:System.Double?displayProperty=nameWithType>, <xref:System.Double?displayProperty=nameWithType> und <xref:System.Double?displayProperty=nameWithType>.  
  
|Parameter|Rückgabewert|  
|----------------|------------------|  
|`x`oder `y`  =  `NaN`.|`NaN`|  
|`x`= Jeder Wert außer `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` ist eine positive ungerade ganze Zahl.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` ist positiv, aber keine ungerade ganze Zahl.|`PositiveInfinity`|  
|`x`< 0, aber nicht `NegativeInfinity`; `y` ist keine Ganzzahl, `NegativeInfinity`, oder `PositiveInfinity`.|`NaN`|  
|`x`=-1; `y`  =  `NegativeInfinity` oder `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x`<-1 oder `x` > 1. `y` = `NegativeInfinity`.|0|  
|`x`<-1 oder `x` > 1. `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x`= 1; `y` beliebiger Wert außer `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Pow%2A> Methode, um den Wert zu berechnen, die aus der durch das Auslösen 2 mit einem Exponenten zwischen 0 und 32.  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rundet einen Wert auf die nächste Ganzzahl oder auf die angegebene Anzahl von Bruchstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Abschnitt  
  
 [Überladene Methodensyntax](#Syntax)   
 [Parameter](#Params)   
 [Rückgabewert](#Returns)   
 [Ausnahmen](#Exceptions)   
 [Welche Methode werden aufgerufen?](#Tasks)   
 [Werte für Mittelpunkt und Rundung Konventionen](#Midpoint)   
 [Rundung und Genauigkeit](#Precision)   
 [Rundung und mit einfacher Genauigkeit Gleitkommazahlen-Punktwerte](#Single)   
 Beispiele:   
 [Math.Round(Decimal)](#Round1_Example)  
 [Math.Round(Double)](#Round2_Example)  
 [Math.Round ("Decimal", "Int32")](#Round3_Example)  
 [Math.Round (Decimal, MidpointRounding)](#Round4_Example)  
 [Math.Round (Double, Int32)](#Round5_Example)  
 [Math.Round (Double, MidpointRounding)](#Round6_Example)  
 [Math.Round (Int32, Decimal MidpointRounding)](#Round7_Example)  
 [Math.Round (Double, Int32, MidpointRounding)](#Round8_Example)  
[Versionsinformationen](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a>Überladene Methodensyntax  
 Weitere Anleitungen zum Auswählen einer Überladung finden Sie unter [welche Methode aufrufen?](#Tasks)  
  
 `Decimal Math.Round(Decimal` `d` `)`  
 Rundet einen Dezimalwert auf die nächste ganze Zahl und Mittelpunkt-Werte auf die nächste gerade Zahl gerundet ([Beispiel](#Round1_Example)).  
  
 `Double Math.Round(Double` `a` `)`  
 Rundet einen Gleitkommawert mit doppelter Genauigkeit-Wert auf die nächste Ganzzahl und Mittelpunkt-Werte auf die nächste gerade Zahl gerundet ([Beispiel](#Round2_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`  
 Rundet einen Dezimalwert auf eine angegebene Anzahl von Dezimalstellen und Mittelpunkt-Werte auf die nächste gerade Zahl gerundet ([Beispiel](#Round3_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `)`  
 Rundet einen Gleitkommawert mit doppelter Genauigkeit den Wert auf eine angegebene Anzahl von Dezimalstellen und Mittelpunkt-Werte auf die nächste gerade Zahl gerundet ([Beispiel](#Round4_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`  
 Rundet einen Dezimalwert auf die nächste ganze Zahl, und verwendet die angegebene Rundung Konvention für Werte für Mittelpunkt ([Beispiel](#Round5_Example)).  
  
 `Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`  
 Rundet einen Gleitkommawert mit doppelter Genauigkeit-Wert auf die nächste ganze Zahl, und verwendet die angegebene Rundung Konvention für Werte für Mittelpunkt ([Beispiel](#Round6_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`  
 Rundet einen Dezimalwert auf eine angegebene Anzahl von Dezimalstellen und verwendet die angegebene Rundung Konvention für Werte für Mittelpunkt ([Beispiel](#Round7_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`  
 Rundet einen Gleitkommawert mit doppelter Genauigkeit den Wert auf eine angegebene Anzahl von Dezimalstellen und verwendet die angegebene Rundung Konvention für Werte für Mittelpunkt ([Beispiel](#Round8_Example)).  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parameter  
 Dies ist eine vollständige Liste der Parameter für die <xref:System.Math.Round%2A> Methode. Die Parameter, die durch jede Überladung verwendet wird finden Sie in der obigen Syntax für Überladung.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|Eine Zahl gerundet werden soll.|  
|`a`<br /><br /> - oder - <br /><br /> `value`|<xref:System.Double>|Eine zu rundende Gleitkommazahl mit doppelter Genauigkeit.|  
|`decimals`<br /><br /> - oder - <br /><br /> `digits`|<xref:System.Int32>|Die Anzahl von Dezimalstellen im Rückgabewert. Für <xref:System.Decimal> , es kann Werte zwischen 0 und 28. Für <xref:System.Double> , es kann Werte von 0 bis 15. Beachten Sie, dass 15 die maximale Anzahl von ganzheitlichen Zahlen sowie Nachkommastellen Ziffern von unterstützt die <xref:System.Double> Typ.<br /><br /> Standardwert: 0, d. h. in eine ganze Zahl gerundet.|  
|`mode`|<xref:System.MidpointRounding>|Ein Flag, der angibt, die Aufrufkonvention an für die Rundung Mittelpunkt Werte verwendet. Finden Sie unter [Werte für Mittelpunkt und Rundung Konventionen](#Midpoint).<br /><br /> Standardwert:<xref:System.MidpointRounding?displayProperty=nameWithType>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a>Rückgabewert  
 Typ: <xref:System.Decimal> oder <xref:System.Double>, je nach dem Typ des Werts gerundet werden soll.   
Ein numerischer Wert des gleichen Typs als `d`, `a`, oder `value`, aber gerundet, um eine ganze Zahl oder auf die angegebene Anzahl von Dezimalstellen. Finden Sie unter [Werte für Mittelpunkt und Rundung Konventionen](#Midpoint) Informationen zu runden von Zahlen mit Werten Mittelpunkt.  
  
> [!WARNING]
>  Der runden Algorithmus führt einen Gleichheitstest, Werte für Mittelpunkt zu runden. Aufgrund von Problemen mit der binären Darstellung und die Genauigkeit in die Gleitkommaformat kann von der Methode zurückgegebene Wert nicht erwartet werden. Weitere Informationen finden Sie unter [Rundung und Genauigkeit](#Precision).  
  
 Wenn eine Überladung mit einem <xref:System.Double> Parameter aufgerufen wird, und <xref:System.Double.NaN?displayProperty=nameWithType>, gibt die Methode <xref:System.Double.NaN?displayProperty=nameWithType>. Wenn beim Aufruf <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, der Methodenrückgabe <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zugeordnet.  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Ausnahmen  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|Das Ergebnis liegt außerhalb des Bereichs von der <xref:System.Decimal> Typ.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|`decimals`ist kleiner als 0 oder größer als 28.<br /><br /> - oder - <br /><br /> `digits`ist kleiner als 0 oder größer als 15.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|`mode`ist kein gültiger Wert von <xref:System.MidpointRounding>.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode werden aufgerufen?  
  
|Beschreibung|Call|  
|--------|----------|  
|Eine ganze Zahl gerundet wird, mit der runden auf die nächste Konvention.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> - oder - <br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|Rundet eine Zahl auf eine ganze Zahl mit einem angegebenen Runden von Konvention.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> - oder - <br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|Eine Zahl und eine angegebene Anzahl von Dezimalstellen gerundet wird, mit der runden auf die nächste Konvention.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> - oder - <br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|Rundet eine Zahl auf eine angegebene Anzahl von Dezimalstellen mithilfe eines angegebenen Runden von Konvention.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> - oder - <br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|Rundet einen <xref:System.Single> Wert auf eine angegebene Anzahl von Dezimalstellen mithilfe eines angegebenen Konvention Rundung und Minimieren des Verlust an Genauigkeit.|Konvertieren der <xref:System.Single> zu einem <xref:System.Decimal> , und rufen Sie <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.|  
|Rundet eine Zahl und eine angegebene Anzahl von Dezimalstellen und minimiert gleichzeitig die Problemen mit der Genauigkeit im Mittelpunkt Werte gerundet.|Rufen Sie eine Rundungsmethode, die einen "größer als oder ungefähr gleich"-Vergleich implementiert. Finden Sie unter [Rundung und Genauigkeit](#Precision).|  
|Round ein Dezimalstellenwert in eine ganze Zahl ist, die größer als der Dezimalstellenwert. Runden Sie z. B. 3.1 und 4 ein.|<xref:System.Math.Ceiling%2A>|  
|Round ein Dezimalstellenwert in eine ganze Zahl ist, die kleiner als der Dezimalstellenwert. Runden Sie z. B. 3.9 bis 3.|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a>Werte für Mittelpunkt und Rundung Konventionen  
 Rundung umfasst einen numerischen Wert mit einer angegebenen Genauigkeit in den nächsten Wert mit geringerer Genauigkeit zu konvertieren. Können z. B. die <xref:System.Math.Round%28System.Double%29> Methode 3.4 bis 3.0 Wert gerundet wird, und die <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> Methode 3.579 zu 3,58 Wert gerundet wird.  
  
 In der Mitte liegenden Werten ist der Wert nach der am wenigsten signifikante Ziffer in das Ergebnis genau halbem Weg zwischen zwei Zahlen. Beispielsweise ist 3.47500 Mitte liegenden Werten wird jedoch werden auf zwei Dezimalstellen gerundet und 7.500 ist Mitte liegenden Werten aus, wenn es auf eine ganze Zahl gerundet. In diesen Fällen kann nicht einfach der nächste Wert ohne eine Rundung Konvention identifiziert werden.  
  
 Die <xref:System.Math.Round%2A> Methode zwei Rundung Konventionen für die Behandlung Mittelpunkt Werte unterstützt:  
  
 **Aufgerundet**  
 Mittelpunkt Werte werden auf die nächste Zahl von NULL Weg gerundet. 3,75 abgerundet, 3.8, 3,85 runden, 3.9,-3.75 in-3.8, gerundet und-3.85 auf-3.9 gerundet. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding?displayProperty=nameWithType> Enumerationsmember.  
  
 Aufgerundet ist die am häufigsten bekannten Form der Rundung.  
  
 **Auf den nächsten Wert runden oder unverzerrte Rundung**  
 Mittelpunkt Werte werden auf die nächste gerade Zahl gerundet. Beispielsweise 3,75 und 3,85 gerundet wird, um 3.8 und-3.75 und-3.85 gerundet wird, um-3.8. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding?displayProperty=nameWithType> Enumerationsmember.  
  
 Auf den nächsten Wert gerundet wird der Standardform des Rundung in finanzielle und statistische Vorgängen verwendet. Es entspricht dem Standard IEEE 754, Abschnitt 4. Bei Verwendung in mehreren Rundungsoperationen verringert sich die Rundungsfehler, die vom Mittelpunkt der Werte in einer Richtung runden verursacht wird. In einigen Fällen kann diese Rundungsfehler erheblich sein.  
  
 Das folgende Beispiel veranschaulicht die Verschiebung, die vom Mittelpunkt der Werte in einer Richtung runden auftreten können. Im Beispiel berechnet den Mittelwert "true", eines Arrays von <xref:System.Decimal> schätzt, und klicken Sie dann den Mittelwert berechnet, wenn die Werte im Array mit den beiden Konventionen gerundet werden. In diesem Beispiel sind "true" Mittelwert "und" Mittelwert, der entsteht, wenn auf den nächsten Wert runden identisch. Unterscheidet jedoch der Mittelwert, der entsteht, wenn von NULL Weg gerundet indem.05 (oder 3,6 %) "true" bedeutet.  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 Wird standardmäßig die <xref:System.Math.Round%2A> Methode verwendet die Rundung auf die nächste Konvention. Die folgende Tabelle enthält die Überladungen der <xref:System.Math.Round%2A> -Methode und die Rundung Konvention, dass jede verwendet.  
  
|überladen|Konvention Rundung|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|Bestimmt, indem `mode` Parameter.|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|Bestimmt, indem `mode` Parameter|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|Bestimmt, indem `mode` Parameter|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|Bestimmt, indem `mode` Parameter|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a>Rundung und Genauigkeit  
 Um festzustellen, ob es sich bei einer Rundung auf einen Wert für den Mittelpunkt, umfasst die <xref:System.Math.Round%2A> -Methode multipliziert den ursprünglichen Wert von 10 gerundet werden<sup>n</sup>, wobei * n *die gewünschte Anzahl von Dezimalstellen im Rückgabewert, und klicken Sie dann bestimmt, ob der verbleibenden Bruchteil des Werts größer als oder gleich.5 ist. Dies ist eine leichte Abwandlung einen Test auf Gleichheit und wie erwähnt im Abschnitt "Testen für Gleichheit" die <xref:System.Double> Referenzthema, Gleichheit mit Gleitkommazahlen-Punktwerte sind problematisch, aufgrund der Gleitkommaformat Probleme bei der binären Darstellung und Genauigkeit. Dies bedeutet, dass jeder Bruchteil eine Zahl, die etwas weniger als.5 (aufgrund von einem Genauigkeitsverlust) wird nicht nach oben gerundet wird.  
  
 Das Problem wird anhand des folgenden Beispiels veranschaulicht. Wiederholte.1 auf 11.0 hinzugefügt, und rundet das Ergebnis auf die nächste ganze Zahl. Unabhängig von der runden Konvention 11.5 12 gerundet. Es wird jedoch wie die Ausgabe des Beispiels zeigt, nicht. Im Beispiel wird der "R" [standardmäßige Zahlenformatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) zum Anzeigen der Gleitkommawert Zeitwerts vollständige Genauigkeit und zeigt, dass der zu rundende Wert mit einfacher Genauigkeit bei wiederholten Ergänzungen verloren hat, und ihr Wert ist tatsächlich 11.499999999999998. Da.499999999999998 kleiner als.5 ist, wird der Wert nicht auf die nächsthöhere ganze Zahl gerundet. Wie das Beispiel auch zeigt, dieses Problem nicht ausgeführt, wenn es den konstanten Wert 11.5, weisen Sie einfach eine <xref:System.Double> Variable.  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 Probleme bei der Genauigkeit im Mittelpunkt Werte gerundet werden höchstwahrscheinlich unter folgenden Umständen auftreten:  
  
-   Wenn ein Dezimalstellenwert genau der Gleitkommatyp Binärformat ausgedrückt werden kann.  
  
-   Wenn der zu rundende Wert aus einen oder mehrere Operationen mit Gleitkommazahlen berechnet wird.  
  
-   Wenn der Wert gerundet wird ist eine <xref:System.Single> anstelle eines <xref:System.Double> oder <xref:System.Decimal>. Weitere Informationen finden Sie im nächsten Abschnitt [Rundung und Gleitkommawerten mit einfacher Genauigkeit](#Single).  
  
 In Fällen, in denen der Mangel an Genauigkeit bei Operationen Rundung problematisch ist, können Sie Folgendes tun:  
  
-   Rundung eine Überladung aufruft, der Rundet eine <xref:System.Double> -Wert, die Sie ändern die <xref:System.Double> auf eine <xref:System.Decimal> Wert ein, und rufen Sie eine Überladung, die Rundet eine <xref:System.Decimal> stattdessen Wert. Obwohl die <xref:System.Decimal> Datentyp verfügt außerdem über Probleme bei der Darstellung und Genauigkeitsverlust, diese Probleme sind weitaus weniger häufig.  
  
-   Definieren Sie einen benutzerdefinierten Rundung Algorithmus, der führt einen Test "nahezu gleich", um festzustellen, ob der zu rundende Wert nahe Mitte liegenden Werten akzeptabler Geschwindigkeit ist. Das folgende Beispiel definiert eine `RoundApproximate` Methode, die überprüft, ob ein Dezimalstellenwert ausreichend nahe Mitte liegenden Werten Mittelpunkt Rundung sein wird. Wie die Ausgabe des Beispiels zeigt, behebt er das Runden Problem, das im vorherigen Beispiel gezeigt.  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a>Rundung und mit einfacher Genauigkeit Gleitkommazahlen-Punktwerte  
 Die <xref:System.Math.Round%2A> Methode enthält, die Argumente des Typs akzeptieren Überladungen <xref:System.Decimal> und <xref:System.Double>. Es gibt keine Methoden, die Werte des Typs runden <xref:System.Single>. Wenn Sie übergeben ein <xref:System.Single> Wert auf eine der Überladungen der der <xref:System.Math.Round%2A> -Methode, es wird (in c#) umgewandelt oder konvertiert (in Visual Basic) eine <xref:System.Double>, und die entsprechende <xref:System.Math.Round%2A> -Überladung mit eine <xref:System.Double> Parameter aufgerufen wird. Obwohl dies eine erweiternde Konvertierung ist, umfasst es häufig einem Genauigkeitsverlust, wie im folgenden Beispiel veranschaulicht. Wenn eine <xref:System.Single> Wert des 16.325 wird zum Übergeben der <xref:System.Math.Round%2A> Methode und auf zwei Dezimalstellen, die mit der runden auf die nächste Konvention gerundet wird, ist das Ergebnis 16.32 16.33 und nicht das erwartete Ergebnis.  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 Diese unerwartete Ergebnis ist aufgrund eines Verlusts Genauigkeit bei der Konvertierung von der <xref:System.Single> -Wert in einen <xref:System.Double>. Da die resultierende <xref:System.Double> Wert 16.325000762939453 ist kein Mittelpunkt Wert ist größer als 16.325, es wird immer nach oben gerundet.  
  
 In vielen Fällen wie im Beispiel veranschaulicht, der Verlust an Genauigkeit kann werden minimiert oder beseitigt, indem Umwandlung oder Konvertierung der <xref:System.Single> -Wert in einen <xref:System.Decimal>. Beachten Sie, dass, da dies eine einschränkende Konvertierung ist, mithilfe der Cast-Operator oder eine Konvertierungsmethode aufgerufen muss.  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a>Math.Round(Decimal)-Beispiel  
 Das folgende Beispiel veranschaulicht die <xref:System.Math.Round%28System.Decimal%29> Methode. Beachten Sie, dass die <xref:System.Decimal> Wert 4.5 rundet 4 statt 5, da diese Überladung die verwendet <xref:System.MidpointRounding.ToEven> Konvention.  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a>Math.Round(Double)-Beispiel  
 Das folgende Beispiel zeigt, auf die nächste Ganzzahl gerundet.  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a>Math.Round (Decimal, Int32)-Beispiel  
 Im folgenden Beispiel wird die Dezimalwerte mit zwei Dezimalstellen auf Werte, die eine einzelne Dezimalstelle verfügen.  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a>Math.Round (Double, Int32) Beispiel  
 Im folgenden Beispiel wird die double-Werte mit zwei Dezimalstellen an Double-Werte, die eine einzelne Dezimalstelle verfügen.  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a>Math.Round (Decimal, MidpointRounding)-Beispiel  
 Das folgende Beispiel zeigt die Rückgabewerte der <xref:System.Math.Round%28System.Decimal%29> -Methode, die <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> Methode mit eine `mode` Argument des <xref:System.MidpointRounding.ToEven>, und die <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> Methode mit einer `mode` Argument des <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a>Math.Round (Double MidpointRounding) Beispiel  
 Das folgende Beispiel zeigt die Rückgabewerte der <xref:System.Math.Round%28System.Double%29> -Methode, die <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> Methode mit eine `mode` Argument des <xref:System.MidpointRounding.ToEven>, und die <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> Methode mit einer `mode` Argument des <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a>Math.Round (Int32, Decimal MidpointRounding)-Beispiel  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Round%2A> Methode mit dem <xref:System.MidpointRounding> Enumeration.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a>Math.Round (Int32 und Double MidpointRounding)-Beispiel  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> Methode mit dem <xref:System.MidpointRounding> Enumeration.  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a>Versionsinformationen  
 .NET Framework  
 Überladungen ohne eine <xref:System.MidpointRounding> Parameter werden unterstützt: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
Überladungen mit einem <xref:System.MidpointRounding> Parameter werden unterstützt: 4.5, 4, 3.5, 3.0 und 2.0  
  
 .NET Framework Client Profile  
 Alle Überladungen werden unterstützt: 4, 3.5 SP1  
  
 Portable Klassenbibliothek  
 Alle Überladungen werden unterstützt.  
  
 .NET für Windows Store-Apps  
 Alle Überladungen werden unterstützt: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <summary>Rundet einen Dezimalwert auf den nächsten ganzzahligen Wert.</summary>
        <returns>Die zum Parameter <paramref name="d" /> nächste Ganzzahl. Wenn der Nachkommawert von <paramref name="d" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, wird die gerade Zahl zurückgegeben. Beachten Sie, dass diese Methode einen <see cref="T:System.Decimal" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs von einem <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Eine zu rundende Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Rundet einen Gleitkommawert mit doppelter Genauigkeit auf den nächsten ganzzahligen Wert.</summary>
        <returns>Die zu <paramref name="a" /> nächste Ganzzahl. Wenn der Nachkommawert von <paramref name="a" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, wird die gerade Zahl zurückgegeben. Beachten Sie, dass diese Methode einen <see cref="T:System.Double" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Aufgrund der Verlust an Genauigkeit, die aus, die als Gleitkommazahlen Dezimalwerte darstellt oder arithmetische Vorgänge für Gleitkommawerte, in einigen Fällen kann die <see cref="M:System.Math.Round(System.Double)" /> Methode möglicherweise nicht angezeigt, Mittelpunkt Werte gerundet wird, die nächste gerade ganze Zahl. Im folgenden Beispiel, da der Gleitkommawert.1 keine endliche binäre Darstellung hat der erste Aufruf der <see cref="M:System.Math.Round(System.Double)" /> mit einem Wert von 11.5 Methodenrückgabe 11 statt 12.  
  
 [!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)]
 [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="decimals">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <summary>Rundet einen Dezimalwert auf die angegebene Anzahl von Bruchziffern.</summary>
        <returns>Die Zahl, die <paramref name="d" /> am nächsten liegt und deren Anzahl von Nachkommastellen gleich <paramref name="decimals" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" />ist kleiner als 0 oder größer als 28.</exception>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs von einem <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="mode">Angabe, wie runden <c>d</c> Wenn es genau zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Dezimalwert auf die nächste Ganzzahl. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die zu <paramref name="d" /> nächste Ganzzahl. Wenn <paramref name="d" /> genau in der Mitte zwischen zwei Zahlen liegt, von denen eine gerade und die andere ungerade ist, bestimmt der <paramref name="mode" />-Parameter, welche der beiden Zahlen zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" />ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs von einem <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine zu rundende Gleitkommazahl mit doppelter Genauigkeit.</param>
        <param name="digits">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <summary>Rundet einen Gleitkommawert mit doppelter Genauigkeit auf eine angegebene Anzahl von Bruchziffern.</summary>
        <returns>Die Zahl, die <paramref name="value" /> am nächsten liegt und deren Anzahl von Nachkommastellen gleich <paramref name="digits" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" />ist kleiner als 0 oder größer als 15.</exception>
        <block subset="none" type="usage">
          <para>Aufgrund der Verlust an Genauigkeit, die aus, die als Gleitkommazahlen Dezimalwerte darstellt oder arithmetische Vorgänge für Gleitkommawerte, in einigen Fällen kann die <see cref="M:System.Math.Round(System.Double,System.Int32)" /> Methode möglicherweise nicht angezeigt, Mittelpunkt Werte gerundet wird, die nächsten geraden Wert in der <paramref name="digits" /> decimal Position. Dies wird im folgenden Beispiel veranschaulicht, in denen 2.135 2.13 statt 2.14 gerundet wird. Dies geschieht, weil die Methode intern multipliziert <paramref name="value" /> von 10<sup>Ziffern</sup>, und die Multiplikation wird in diesem Fall aus einem Genauigkeitsverlust angehört.  
  
 [!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)]
 [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Eine zu rundende Gleitkommazahl mit doppelter Genauigkeit.</param>
        <param name="mode">Angabe, wie runden <c>Wert</c> Wenn es genau zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Gleitkommawert mit doppelter Genauigkeit auf die nächste Ganzzahl. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die zu <paramref name="value" /> nächste Ganzzahl. Wenn <paramref name="value" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, bestimmt <paramref name="mode" />, welche der beiden Zahlen zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" />ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Aufgrund der Verlust an Genauigkeit, die aus, die als Gleitkommazahlen Dezimalwerte darstellt oder arithmetische Vorgänge für Gleitkommawerte, in einigen Fällen kann die <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> Methode möglicherweise nicht angezeigt, Mittelpunkt Werte gerundet wird, die nächste gerade ganze Zahl. Im folgenden Beispiel, da der Gleitkommawert.1 keine endliche binäre Darstellung hat der erste Aufruf der <see cref="M:System.Math.Round(System.Double)" /> mit einem Wert von 11.5 Methodenrückgabe 11 statt 12.  
  
 [!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)]
 [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="decimals">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <param name="mode">Angabe, wie runden <c>d</c> Wenn es genau zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Dezimalwert auf die angegebene Anzahl von Bruchziffern. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die Zahl, die <paramref name="d" /> am nächsten liegt und deren Anzahl von Nachkommastellen gleich <paramref name="decimals" /> ist. Wenn <paramref name="d" /> weniger Dezimalstellen als <paramref name="decimals" /> hat, wird <paramref name="d" /> unverändert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" />ist kleiner als 0 oder größer als 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" />ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs von einem <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Eine zu rundende Gleitkommazahl mit doppelter Genauigkeit.</param>
        <param name="digits">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <param name="mode">Angabe, wie runden <c>Wert</c> Wenn es genau zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Gleitkommawert mit doppelter Genauigkeit auf eine angegebene Anzahl von Bruchziffern. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die Zahl, die <paramref name="value" /> am nächsten liegt und deren Anzahl von Dezimalstellen gleich <paramref name="digits" /> ist. Wenn <paramref name="value" /> weniger Dezimalstellen als <paramref name="digits" /> hat, wird <paramref name="value" /> unverändert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungsinformationen zu diesen und anderen Überladungen der `Round` -Methode finden Sie unter der <xref:System.Math.Round%2A> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" />ist kleiner als 0 oder größer als 15.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" />ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Aufgrund der Verlust an Genauigkeit, die aus, die als Gleitkommazahlen Dezimalwerte darstellt oder arithmetische Vorgänge für Gleitkommawerte, in einigen Fällen kann die <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> Methode möglicherweise Mittelpunkt Werte entsprechend den Angaben gerundet wird, nicht angezeigt durch die <paramref name="mode" /> Parameter. Dies wird im folgenden Beispiel veranschaulicht, in denen 2.135 2.13 statt 2.14 gerundet wird. Dies geschieht, weil die Methode intern multipliziert <paramref name="value" /> von 10<sup>Ziffern</sup>, und die Multiplikation wird in diesem Fall aus einem Genauigkeitsverlust angehört.  
  
 [!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)]
 [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Dezimalzahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer Dezimalzahl angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Decimal%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Decimal> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer Gleitkommazahl mit doppelter Genauigkeit angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Double%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Double> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> ist gleich <see cref="F:System.Double.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer ganzen 16-Bit-Zahl mit Vorzeichen angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Int16%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Int16> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer ganzen 32-Bit-Zahl mit Vorzeichen angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Int32%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Int32> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer ganzen 64-Bit-Zahl mit Vorzeichen angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Int64%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Int64> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer ganzen 8-Bit-Zahl mit Vorzeichen angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.SByte%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.SByte> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer Gleitkommazahl mit einfacher Genauigkeit angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="value" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Bedeutung  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> ist kleiner als Null.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Sign%28System.Single%29> Methode, um zu bestimmen, der die Vorzeichen einer <xref:System.Single> Wert und der Konsole anzeigt.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> ist gleich <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Sinus des angegebenen Winkels zurück.</summary>
        <returns>Der Sinus von <paramref name="a" />. Wenn <paramref name="a" /> gleich <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird <see cref="F:System.Double.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `a`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
 Zulässige Werte von `a` reichen von ungefähr-9223372036854775295 bis ungefähr 9223372036854775295. Für Werte außerhalb dieses Bereichs die <xref:System.Math.Sin%2A> -Methode zurückkehrt `a` unverändert, anstatt eine Ausnahme auszulösen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Sin%2A> bestimmte trigonometrischen Identitäten für ausgewählte Winkel ausgewertet.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbelsinus des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbelsinus von <paramref name="value" />. Wenn <paramref name="value" /> gleich <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NaN" /> ist, gibt diese Methode einen <see cref="T:System.Double" /> mit dem Wert <paramref name="value" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `value`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Sinh%2A> bestimmte hyperbolischen Identitäten für ausgewählte Werte ausgewertet.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Die Zahl, deren Quadratwurzel bestimmt werden soll.</param>
        <summary>Gibt die Quadratwurzel einer angegebenen Zahl zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="d" />Parameter  
  
 </term><description>Rückgabewert  
  
 </description></listheader><item><term>0 (null) oder ein positiver  
  
 </term><description>Die positive Quadratwurzel <paramref name="d" />.  
  
 </description></item><item><term>Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term>Ist gleich <see cref="F:System.Double.NaN" /> </term> <description> <see cref="F:System.Double.NaN" /> </description> </item> <item> <term> ist gleich<see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Die Quadratwurzel des Bereichs eines Quadrats repräsentiert die Länge einer beliebigen Seite des Quadrats. Das folgende Beispiel zeigt den Bereich von einigen Städten in den Vereinigten Staaten und erhalten einen Eindruck von jeden Ort Größe aus, wenn er durch ein Quadrat dargestellt wurden.  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Tangens des angegebenen Winkels zurück.</summary>
        <returns>Der Tangens von <paramref name="a" />. Wenn <paramref name="a" /> gleich <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" /> ist, wird <see cref="F:System.Double.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `a`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie berechnet den Tangens eines Winkels und in der Konsole anzeigt.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbeltangens des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbeltangens von <paramref name="value" />. Wenn <paramref name="value" /> gleich <see cref="F:System.Double.NegativeInfinity" /> ist, gibt diese Methode -1 zurück. Wenn "value" gleich <see cref="F:System.Double.PositiveInfinity" /> ist, gibt diese Methode 1 zurück. Wenn <paramref name="value" /> gleich <see cref="F:System.Double.NaN" /> ist, gibt diese Methode <see cref="F:System.Double.NaN" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `value`, im Bogenmaß angegeben werden muss. Multiplizieren von <xref:System.Math.PI?displayProperty=nameWithType>/180, Grad in Bogenmaß konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Math.Tanh%2A> bestimmte hyperbolischen Tangenten Identitäten für ausgewählte Werte ausgewertet.  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet den ganzzahligen Teil einer Zahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zahl wird auf die nächste Ganzzahl in Richtung 0 (null) gerundet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine abzuschneidende Zahl.</param>
        <summary>Berechnet den ganzzahligen Teil einer angegebenen Dezimalzahl.</summary>
        <returns>Der ganzzahlige Teil von <paramref name="d" />, d. h, die Zahl, die nach dem Verwerfen der Dezimalstellen übrig bleibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A>Rundet `d` auf die nächste Ganzzahl in Richtung 0 (null).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Truncate%28System.Decimal%29> Methode, um eine Positive und Negative truncate <xref:System.Decimal> Wert.  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine abzuschneidende Zahl.</param>
        <summary>Berechnet den den ganzzahligen Teil einer angegebenen Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Der ganzzahlige Teil von <paramref name="d" />, d. h. die Zahl, die übrig bleibt, wenn alle Dezimalstellen verworfen wurden, oder einer der Werte in der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="d" /></term><description>Rückgabewert  
  
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A>Rundet `d` auf die nächste Ganzzahl in Richtung 0 (null).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Math.Truncate%28System.Double%29> Methode, um eine Positive und Negative truncate <xref:System.Double> Wert.  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
