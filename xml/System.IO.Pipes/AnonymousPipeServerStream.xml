<Type Name="AnonymousPipeServerStream" FullName="System.IO.Pipes.AnonymousPipeServerStream">
  <TypeSignature Language="C#" Value="public sealed class AnonymousPipeServerStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AnonymousPipeServerStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.AnonymousPipeServerStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Macht einen Stream um eine anonyme Pipe, welche unterstützt synchrone und asynchrone Lese- und Schreibvorgänge verfügbar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes tragen zur sicheren prozessübergreifenden Kommunikation zwischen untergeordneten und übergeordneten Prozesse. Die <xref:System.IO.Pipes.AnonymousPipeServerStream> -Klasse ermöglicht es einen übergeordneten Prozess zum Senden oder Empfangen von Informationen aus einem untergeordneten Prozess.  
  
 Anonyme Pipes sind unbenannte, unidirektionale Pipes, die Daten in der Regel zwischen übergeordneten und untergeordneten Prozessen übertragen. Anonyme Pipes sind immer lokal. Sie können über ein Netzwerk verwendet werden. Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> Modi zu lesen.  
  
 Die Clientseite einer anonymen Pipe muss erstellt werden, ein Pipehandle bereitgestellt von der Serverseite durch Aufrufen der <xref:System.IO.Pipes.AnonymousPipeServerStream.GetClientHandleAsString%2A> Methode. Die Zeichenfolge wird dann als Parameter übergeben, für die Erstellung den Clientprozess. Vom Clientprozess, wird es dann zum Übergeben der <xref:System.IO.Pipes.AnonymousPipeClientStream> Konstruktor als die `pipeHandleAsString` Parameter.  
  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt freigeben muss, Handle für den Client mithilfe der <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> Methode, damit Sie benachrichtigt werden, wenn der Client beendet wird.  
  
> [!NOTE]
>  Für [!INCLUDE[winxppro](~/includes/winxppro-md.md)] und [!INCLUDE[win2kserver](~/includes/win2kserver-md.md)], maximal 10 Pipes kann gleichzeitig über das Netzwerk verbinden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge mithilfe von anonymen Pipes von einem übergeordneten Prozess an einen untergeordneten Prozess gesendet werden kann. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream>-Objekt in einem übergeordneten Prozess mit dem <xref:System.IO.Pipes.PipeDirection>-Wert <xref:System.IO.Pipes.PipeDirection.Out> erstellt. Erstellt auch eine <xref:System.IO.Pipes.AnonymousPipeClientStream> Objekt in einem untergeordneten Prozess mit einem <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.In>. Der übergeordnete Prozess sendet daraufhin eine vom Benutzer bereitgestellte Zeichenfolge an den untergeordneten Prozess. Die Zeichenfolge wird in der Konsole angezeigt.  
  
 In diesem Beispiel wird für den Serverprozess, der verwendet die <xref:System.IO.Pipes.AnonymousPipeServerStream> Klasse. Das gesamte Codebeispiel, einschließlich des Codes für die Pipeclient und Server, finden Sie unter [wie: Verwenden von anonymen Pipes zur lokalen prozessübergreifenden Kommunikation](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für <xref:System.IO.Pipes.AnonymousPipeServerStream> Konstruktoren ohne eine <xref:System.IO.Pipes.PipeDirection> Parameter, die die standardrichtung ist <xref:System.IO.Pipes.PipeDirection.Out>. Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardpuffergröße keine pipesicherheit hat und ein <xref:System.IO.HandleInheritability> Wert <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
 Anonyme Pipes kann in eine Richtung, sodass nur <c>Richtung</c> kann nicht festgelegt werden, um <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> -Klasse mit der angegebenen piperichtung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardpuffergröße keine pipesicherheit hat und ein <xref:System.IO.HandleInheritability> Wert <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
 Anonyme Pipes kann in eine Richtung, sodass nur <c>Richtung</c> kann nicht festgelegt werden, um <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann. Muss festgelegt werden, entweder <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Klasse mit dem angegebenen Pipe-Richtung und Vererbbarkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardpuffergröße und keine pipesicherheit verfügt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht eine Methode, um eine Zeichenfolge an einen untergeordneten Prozess mithilfe von anonymen Pipes von einem übergeordneten Prozess gesendet. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekts wird in einem übergeordneten Prozess mit einer <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" />nicht festgelegt ist entweder <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" />.</exception>
        <exception cref="T:System.NotSupportedException">
          Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, Microsoft.Win32.SafeHandles.SafePipeHandle serverSafePipeHandle, Microsoft.Win32.SafeHandles.SafePipeHandle clientSafePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, class Microsoft.Win32.SafeHandles.SafePipeHandle serverSafePipeHandle, class Microsoft.Win32.SafeHandles.SafePipeHandle clientSafePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,Microsoft.Win32.SafeHandles.SafePipeHandle,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="serverSafePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
        <Parameter Name="clientSafePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
 Anonyme Pipes kann in eine Richtung, sodass nur <c>Richtung</c> kann nicht festgelegt werden, um <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
        <param name="serverSafePipeHandle">Ein sicheres Handle für die Pipe, die von diesem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt gekapselt wird.</param>
        <param name="clientSafePipeHandle">Ein sicheres Handle für die <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> Objekt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> -Klasse aus den angegebenen Pipehandles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="serverSafePipeHandle" />oder <paramref name="clientSafePipeHandle" /> ist ein ungültiges Handle.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverSafePipeHandle" /> oder <paramref name="clientSafePipeHandle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler, z. B. ein Datenträgerfehler aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
 Anonyme Pipes kann in eine Richtung, sodass nur <c>Richtung</c> kann nicht festgelegt werden, um <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann. Muss festgelegt werden, entweder <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" />.</param>
        <param name="bufferSize">Die Größe des Puffers. Dieser Wert muss größer als oder gleich 0 sein.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Klasse mit der angegebenen piperichtung, Vererbbarkeitsmodus und Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt ohne pipesicherheit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" />nicht festgelegt ist entweder <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" />.  
  
 - oder -   
  
 <paramref name="bufferSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.NotSupportedException">
          Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability, int bufferSize, System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability, int32 bufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability,System.Int32,System.IO.Pipes.PipeSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
 Anonyme Pipes kann in eine Richtung, sodass nur <c>Richtung</c> kann nicht festgelegt werden, um <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann.</param>
        <param name="bufferSize">Die Größe des Puffers. Dieser Wert muss größer als oder gleich 0 sein.</param>
        <param name="pipeSecurity">Ein Objekt, das die Zugriffssteuerung und die Überwachungssicherheit für die Pipe bestimmt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> -Klasse mit der angegebenen piperichtung, Vererbbarkeitsmodus Puffergröße und pipesicherheit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt, da anonyme Pipes definiert werden, um unidirektional sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" />nicht festgelegt ist entweder <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" />.  
  
 - oder -   
  
 <paramref name="bufferSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.NotSupportedException">
          Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ClientSafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle ClientSafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle ClientSafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.ClientSafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das sichere Handle für die <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> -Objekt, das aktuell verbunden ist die <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Objekt.</summary>
        <value>Ein Handle für die <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> -Objekt, das aktuell verbunden ist die <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> Methode sollte aufgerufen werden, nachdem ein Clienthandle an einen Clientprozess übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeLocalCopyOfClientHandle">
      <MemberSignature Language="C#" Value="public void DisposeLocalCopyOfClientHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisposeLocalCopyOfClientHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die lokale Kopie der <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> Handle des Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> Methode sollte aufgerufen werden, nachdem das Clienthandle an den Client übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekts wird in einem übergeordneten Prozess mit einer <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~AnonymousPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nicht verwaltete Ressourcen frei und führt andere Bereinigungsvorgänge vor der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Instanz durch die Garbagecollection wieder zugänglich gemacht.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClientHandleAsString">
      <MemberSignature Language="C#" Value="public string GetClientHandleAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetClientHandleAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.GetClientHandleAsString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die verbundene <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> Objekthandle als Zeichenfolge.</summary>
        <returns>Eine Zeichenfolge, die verbundene darstellt <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> Handle des Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> Methode sollte aufgerufen werden, nachdem ein Clienthandle an einen Clientprozess übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekts wird in einem übergeordneten Prozess mit einer <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public override System.IO.Pipes.PipeTransmissionMode ReadMode { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Lesemodus für das <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Objekt. Für anonyme Pipes Übertragungsmodus muss <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />.</summary>
        <value>Der Lesemodus für das <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> im Lesemodus befindet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel wird die <xref:System.NotSupportedException> abgefangen, wenn die <xref:System.IO.Pipes.AnonymousPipeServerStream.ReadMode%2A> -Eigenschaftensatz auf <xref:System.IO.Pipes.PipeTransmissionMode.Message>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Übertragungsmodus ist ungültig. Für anonyme Pipes nur <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" /> wird unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Die Eigenschaft wird festgelegt, um <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />, der nicht für anonyme Pipes unterstützt.</exception>
        <exception cref="T:System.IO.IOException">Die Verbindung wurde unterbrochen, oder ein anderer e/a-Fehler auftritt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Pipe ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public override System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pipeübertragungsmodus, der von der aktuellen Pipe unterstützt wird.</summary>
        <value>Die <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> , die von der aktuellen Pipe unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> im Lesemodus befindet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt in einem übergeordneten Prozess erstellt wird und die <xref:System.IO.Pipes.AnonymousPipeServerStream.TransmissionMode%2A> Eigenschaft wird auf der Konsole angezeigt.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
