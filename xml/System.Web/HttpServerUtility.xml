<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Hilfsmethoden für die Verarbeitung von Webanforderungen zur Verfügung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden und Eigenschaften der <xref:System.Web.HttpServerUtility> Klasse verfügbar gemacht werden, durch die systeminterne Funktion <xref:System.Web.HttpContext.Server%2A> von ASP.NET bereitgestellte Objekt.  
  
   
  
## Examples  
 Ist ein Visual Studio Web Site-Projekt mit Quellcode zu diesem Thema steht verfügbar: [herunterladen](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode und die <xref:System.Web.HttpServerUtility.UrlEncode%2A> Methode der <xref:System.Web.HttpServerUtility> Klasse. Die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode wird sichergestellt, dass alle Benutzer bereitgestellte Zeichenfolge Eingabe werden als statischer Text in Browsern statt ausführbare Skript- oder HTML-Elementen gerendert werden. Die <xref:System.Web.HttpServerUtility.UrlEncode%2A> Methode codiert URLs so, dass sie ordnungsgemäß in HTTP-Datenstrom übertragen werden.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die vorhergehende Ausnahme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel löscht die letzte Ausnahme, die ausgelöst wurde.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Die Klasse oder der Typ des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Programmbezeichner (ProgID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt ein Objekt mithilfe der ProgID des Objekts.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" /> , das das zu erstellende Objekt darstellt.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Objekttyp identifiziert wird.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Der Klassenbezeichner des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch die Klassen-ID (Class Identifier, CLSID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> Methode, um eine Serverinstanz eines COM-Objekts zu erstellen.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode setzt die Ausführung der ursprünglichen Seite, nachdem die Ausführung der neuen Seite abgeschlossen ist. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos übergibt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für die neue wird nicht erneut ausgeführt die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erfordert, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Access Control.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A>führt eine clientseitige Umleitung, in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Internet Information Services (IIS) und ASP.NET Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die ASPX‑Seite "Updateinfo.aspx" im aktuellen Verzeichnis. Nachdem der Seite "Updateinfo.aspx" angezeigt wird, werden Ausführung des Programms zur Startseite zurück.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
 \- oder –  
  
 Fehler beim Ausführen von angegebenen Handlers <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="preserveForm">
          <see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung und gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" /> und <see cref="P:System.Web.HttpRequest.Form" /> Sammlungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die ASPX-Seite auszuführende `Updateinfo.aspx` in die aktuelle Anforderung und Beibehalten der <xref:System.Web.HttpRequest.QueryString%2A> und <xref:System.Web.HttpRequest.Form%2A> Sammlungen. Ausführung des Programms zurückgegeben, für die erste Seite nach `Updateinfo.aspx` wird angezeigt.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
 \- oder –  
  
 Fehler beim Ausführen von angegebenen Handlers <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> zum Aufzeichnen der Ausgabe.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe vom ausgeführten Handler.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode wird die Ausführung der ursprünglichen Anforderung fortgesetzt, nachdem die Ausführung des angegebenen virtuellen Pfads abgeschlossen ist. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos übergibt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für die neue wird nicht erneut ausgeführt die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erfordert, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Access Control.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A>führt eine clientseitige Umleitung, in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Internet Information Services (IIS) und ASP.NET Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel führt die `Login.aspx` Seite auf dem Server im aktuellen Verzeichnis und die Ausgabe der Seite über empfängt die <xref:System.IO.StringWriter> Objekt `writer`. Schreibt den HTML-Stream erhaltene `writer` in den HTTP-Ausgabestream.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
 \- oder –  
  
 Fehler beim Ausführen von angegebenen Handlers <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> zum Aufzeichnen der Ausgabe.</param>
        <param name="preserveForm">
          <see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe auf der Seite und einen booleschen Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" /> und <see cref="P:System.Web.HttpRequest.Form" /> Sammlungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode wird die Ausführung der ursprünglichen Anforderung fortgesetzt, nachdem die Ausführung des angegebenen virtuellen Pfads abgeschlossen ist. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos übergibt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für die neue wird nicht erneut ausgeführt die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erfordert, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Access Control.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A>führt eine clientseitige Umleitung, in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Internet Information Services (IIS) und ASP.NET Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel führt die `Login.aspx` Seite auf dem Server im aktuellen Verzeichnis und die Ausgabe der Seite über empfängt die <xref:System.IO.StringWriter> Objekt `writer`. Schreibt den HTML-Stream erhaltene `writer` in den HTTP-Ausgabestream. Der Inhalt der <xref:System.Web.HttpRequest.Form%2A> und <xref:System.Web.HttpRequest.QueryString%2A> Sammlungen werden beibehalten.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die aktuelle <see cref="T:System.Web.HttpContext" /> ist ein null-Verweis (<see langword="Nothing" /> in Visual Basic).  
  
 \- oder –  
  
 <paramref name="path" /> endet mit einem Punkt (.).  
  
 \- oder –  
  
 Fehler beim Ausführen von angegebenen Handlers <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der implementiert die <see cref="T:System.Web.IHttpHandler" /> an die aktuelle Anforderung übertragen.</param>
        <param name="writer">Die <see cref="T:System.IO.TextWriter" /> zum Aufzeichnen der Ausgabe.</param>
        <param name="preserveForm">
          <see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe vom ausgeführten Handler und einem booleschen Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" /> und <see cref="P:System.Web.HttpRequest.Form" /> Sammlungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler zum Verarbeiten von bestimmter, vordefinierter Typen von HTTP-Anforderungen in einer beliebigen Sprache, die mit der Common Language Specification (CLS) kompatibel ist, schreiben. Ausführbarer Code, der in den HTTP-Handler Klassen anstelle von herkömmlichen ASP (auch bekannt als klassisches ASP)-Seiten oder ASP.NET-Seiten definiert ist, antwortet auf diese bestimmten Anforderungen. HTTP-Handler zu ermöglichen, für die Interaktion mit der Low-Level-Anforderung und Antwort-Dienste von einem Webserver, auf dem Internetinformationsdienste (Internet Information Services, IIS) ausgeführt wird, und sie bieten ähnliche Funktionen ISAPI-Erweiterungen, doch ein einfacheres Programmiermodell.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, können Sie die Ressource anzeigen, die durch übermittelt wird die <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Zwar die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt durch angegebene Handler ist die <xref:System.Web.HttpServerUtility.Execute%2A> Methode und wird nicht erneut ausgeführt, Authentifizierung und Autorisierung Logik für die neue Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung für den Zugriff auf die Ressource haben Clients erforderlich ist, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> führt eine clientseitige Umleitung, in dem der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie für die IIS und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Fehler beim Ausführen von angegebenen Handlers <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="handler" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vorhergehende Ausnahme zurück.</summary>
        <returns>Die zuletzt ausgelöste Ausnahme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Beschreibung des letzten Fehlers die Anwendung, um den HTTP-Ausgabestream. Wenn keine Fehler aufgetreten sind, wird "No Errors" ausgegeben.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung wird sichergestellt, dass Text ordnungsgemäß im Browser angezeigt wird, und nicht vom Browser als HTML interpretiert. Angenommen, eine Textzeichenfolge eine kleiner-als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in den Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß anzeigt. <xref:System.Web.HttpServerUtility.HtmlDecode%2A>decodiert Text, der an den Server übertragen wurde.  
  
 Diese Methode ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern verwendet diese Methode <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite, Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> -Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer Code-Behind-Datei befindet, `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die <xref:System.Net.WebUtility> -Klasse zum Codieren oder Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel enthält die Funktion `LoadDecodedFile`, die die Daten aus einer Datei decodiert und kopiert ihn in einer Zeichenfolge.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Die <see cref="T:System.IO.TextWriter" /> Ausgabestream, der die decodierte Zeichenfolge enthalten.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und sendet die Ausgabe an eine <see cref="T:System.IO.TextWriter" /> Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung wird sichergestellt, dass Text ordnungsgemäß im Browser angezeigt wird, und nicht vom Browser als HTML interpretiert. Angenommen, eine Textzeichenfolge eine kleiner-als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in den Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß anzeigt.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A>decodiert Text, der an den Server übertragen wurde.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A>ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.HtmlDecode%2A> verwendet <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgende Beispiel decodiert eine Zeichenfolge, die für die Übertragung HTML-codiert über HTTP wurde. Wird die angegebene Zeichenfolge mit dem Namen decodiert `EncodedString` enthält den Text "Dies ist eine &lt;Testzeichenfolge&gt;.", und kopiert ihn in die Zeichenfolge mit dem Namen `DecodedString` als "Dies ist eine \<Testzeichenfolge >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <summary>Codiert eine Zeichenfolge in HTML und gibt diese codiert zurück.</summary>
        <returns>Der HTML-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung wird sichergestellt, dass Text ordnungsgemäß im Browser angezeigt wird, und nicht vom Browser als HTML interpretiert. Angenommen, eine Textzeichenfolge eine kleiner-als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in den Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß anzeigt.  
  
 Diese Methode ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern verwendet diese Methode <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite, Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> -Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer Code-Behind-Datei befindet, `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die <xref:System.Net.WebUtility> -Klasse zum Codieren oder Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie für die HTML-Codierung einen Wert, der potenziell unsicheren Code codes. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. Der Wert zum Codieren ist hartcodiert in diesem Beispiel wird nur für das Beispiel zu vereinfachen, und zeigen dem Typ des Werts, dass Sie möglicherweise die HTML-codiert. In der Regel würden Sie HTML-codiert einen Wert, den Sie vom Benutzer oder die Anforderung erhalten haben. `Result`bezieht sich auf eine `Literal` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Im nächste Beispiel wird ähnlich wie im vorherigen Beispiel, außer es wird gezeigt, wie für die HTML-Codierung einem Wert innerhalb einer Klasse, die ist nicht in der CodeBehind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Zeichenfolge.</param>
        <param name="output">Die <see cref="T:System.IO.TextWriter" /> Ausgabestream, der die codierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge in HTML und sendet die Ausgabe an eine <see cref="T:System.IO.TextWriter" /> Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung wird sichergestellt, dass Text ordnungsgemäß im Browser nicht interpretiert vom Browser als HTML angezeigt wird. Angenommen, eine Textzeichenfolge eine kleiner-als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Die HTML-Codierung der beiden Zeichen ist `&lt;` und `&gt;`, die bewirkt, dass des Browsers das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß anzeigt.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.HtmlEncode%2A> verwendet <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird codiert eine Zeichenfolge für die Übertragung von HTTP. Es wird die Zeichenfolge mit dem Namen `TestString`, enthält den Text "Dies ist eine \<Testzeichenfolge >.", und kopiert ihn in die Zeichenfolge mit dem Namen `EncodedString` als "Dies ist eine &lt;Testzeichenfolge&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computernamen des Servers ab.</summary>
        <value>Der Name des lokalen Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel speichert den Namen des Servers Computer als einer Zeichenfolgenvariablen.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Computername wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle Pfad zur Webanwendung.</param>
        <summary>Gibt den physischen Dateipfad zurück, der dem angegebenen virtuellen Pfad entspricht.</summary>
        <returns>Der physische Dateipfad, auf dem Webserver, der entspricht <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `path` ist `null`die <xref:System.Web.HttpServerUtility.MapPath%2A> -Methode gibt den vollständigen physischen Pfad des Verzeichnisses, das die aktuelle Anforderung für den Pfad enthält. Der relative Pfad muss nicht an eine vorhandene Datei oder Ordner für diese Methode einen Wert zurückgeben. Sie können keine jedoch einen Pfad außerhalb der Web-Anwendung angeben.  
  
> [!IMPORTANT]
>  Die <xref:System.Web.HttpServerUtility.MapPath%2A> Methode enthält möglicherweise vertrauliche Informationen über die hostumgebung. Der Rückgabewert sollte nicht für Benutzer angezeigt werden.  
  
 Eine Anwendung, die sich auf befindet `C:\ExampleSites\TestMapPath` würden die folgenden Ergebnisse zurück:  
  
|Aus anfordern|`path`|Zurückgegebener Wert|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/ DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/ NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|".. / RootLevelPage.aspx "|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die physische Datei einen relativen virtuellen Pfad abgerufen wird. Der Code befindet sich im Code-Behind-Datei für eine Webseite und nutzt die standardmäßige `Server` Objekt.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Im nächste Beispiel wird ähnlich wie im vorherigen Beispiel, außer es wird gezeigt, wie einen physischen Pfad von innerhalb einer Klasse abgerufen, die nicht in der CodeBehind-Datei ist.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert der Anforderung (in Sekunden) ab und legt diesen fest.</summary>
        <value>Die Timeoutwert-Einstellung für Anforderungen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Eigenschaft kann in der Datei "Web.config" festgelegt werden, durch Festlegen der `executionTimeout` -Attribut des Elements. Festlegen des Timeouts programmgesteuert mit der <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> -Eigenschaft Vorrang vor der Einstellung "Web.config".  
  
> [!NOTE]
>  Wenn Sie festlegen, die `debug` Attribut des Elements, das `true` in der Datei "Web.config" der Wert des <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> werden ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Timeout der Anforderung auf 60 Sekunden.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Timeoutzeitraum ist <see langword="null" /> oder konnte nicht festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Beendet für die aktuelle Anforderung die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seite zu übertragen, sollte eine andere ASPX-Seite. Beispielsweise ist eine Übertragung zu einer ASP- oder ASMX-Seite ungültig. Die <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode behält die <xref:System.Web.HttpRequest.QueryString%2A> und <xref:System.Web.HttpRequest.Form%2A> Sammlungen.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A>Aufrufe <xref:System.Web.HttpResponse.End%2A>, wodurch eine <xref:System.Threading.ThreadAbortException> Ausnahme nach Abschluss.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode und die Authentifizierung und Autorisierung Logik für die neue wird nicht erneut ausgeführt die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erfordert, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Access Control.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> Methode führt eine clientseitige Umleitung, in dem der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Internet Information Services (IIS) und ASP.NET Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm">
          <see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite. Gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" /> und <see cref="P:System.Web.HttpRequest.Form" /> Sammlungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seite zu übertragen, sollte eine andere ASPX-Seite. Beispielsweise ist eine Übertragung zu einer ASP- oder ASMX-Seite ungültig.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A>Aufrufe <xref:System.Web.HttpResponse.End%2A>, wodurch eine <xref:System.Threading.ThreadAbortException> Ausnahme nach Abschluss.  
  
 Wenn Sie festlegen, die `preserveForm` Parameter `true`, der Seite "Ziel" wird in der Lage, den Ansichtszustand von der vorherigen Seite zugreifen, die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft.  
  
 Aus Sicherheitsgründen sollten Sie halten die `enableViewStateMac` -Attributsatz zur `true`. ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode und die Authentifizierung und Autorisierung Logik für die neue wird nicht erneut ausgeführt die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erfordert, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Access Control.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> Methode führt eine clientseitige Umleitung, in dem der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Internet Information Services (IIS) und ASP.NET Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel führt eine neue Seite im selben Verzeichnis wie die aktuelle Seite.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der implementiert die <see cref="T:System.Web.IHttpHandler" /> an die aktuelle Anforderung übertragen.</param>
        <param name="preserveForm">
          <see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Anforderung mithilfe eines benutzerdefinierten HTTP-Handlers, der implementiert die <see cref="T:System.Web.IHttpHandler" /> -Schnittstelle und gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" /> und <see cref="P:System.Web.HttpRequest.Form" /> Sammlungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler zum Verarbeiten von bestimmter, vordefinierter Typen von HTTP-Anforderungen in einer beliebigen Sprache, die mit der Common Language Specification (CLS) kompatibel ist, schreiben. Ausführbarer Code, der in den HTTP-Handler Klassen anstelle von herkömmlichen ASP (auch bekannt als klassisches ASP)-Seiten oder ASP.NET-Seiten definiert ist, antwortet auf diese bestimmten Anforderungen. HTTP-Handler zu ermöglichen, für die Interaktion mit der Low-Level-Anforderung und Antwort-Dienste von einem Webserver, auf dem Internetinformationsdienste (Internet Information Services, IIS) ausgeführt wird, und sie bieten ähnliche Funktionen ISAPI-Erweiterungen, doch ein einfacheres Programmiermodell.  
  
 Wenn Sie festlegen, die `preserveForm` Parameter `true`, der Seite "Ziel" wird in der Lage, den Ansichtszustand von der vorherigen Seite zugreifen, die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft.  
  
 Aus Sicherheitsgründen sollten Sie halten die `enableViewStateMac` -Attributsatz zur `true`. ASP.NET überprüft nicht, dass der aktuelle Benutzer, zum Anzeigen der Ressource autorisiert ist durch übermittelt die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode und wird nicht erneut ausgeführt, Authentifizierung und Autorisierung Logik für die neue die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung entsprechende Autorisierung zum Zugriff auf der Ressourcenanbieters haben Clients erforderlich ist, sollte die Anwendung erzwingen die erneute Autorisierung oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> Methode führt eine clientseitige Umleitung, in dem der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System gelangt ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie für die IIS und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Integration einer benutzerdefinierten Autorisierungs-Methode, verwendet der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode, bevor Sie die Anwendung ruft der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>wurde in .NET Framework, Version 3.5 eingeführt. Zusammenfassende Informationen zu .NET Framework finden Sie unter [-Versionen und-Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode aufruft der <xref:System.Web.HttpServerUtility.TransferRequest%2A> -Überladung mit der `preserveForm` Parameter, um festzulegen `false`, die `method` Parameter festgelegt wird, um `null`, die `headers` Parameter festgelegt wird, um `null`, und die `preserveUser` Parametersatz auf `true`. Weitere Informationen finden Sie unter dem Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm">
          <see langword="true" />Beibehalten der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung ist; <see langword="false" /> zum Deaktivieren der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung.</param>
        <summary>Führt die angegebene URL asynchron aus und behält die Parameter der Abfragezeichenfolge bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ruft die <xref:System.Web.HttpServerUtility.TransferRequest%2A> -Überladung mit der `preserveForm` Parametersatz auf den Wert übergeben, die `method` Parameter festgelegt wird, um `null`, die `headers` Parameter, um festzulegen `null`, und die `preserveUser` Parametersatz um `true`. Weitere Informationen finden Sie unter dem Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm">
          <see langword="true" />Beibehalten der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung ist; <see langword="false" /> zum Deaktivieren der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung.</param>
        <param name="method">Die HTTP-Methode, die für die Ausführung der neuen Anforderung verwendet werden soll.</param>
        <param name="headers">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Anforderungsheadern für die neue Anforderung.</param>
        <summary>Führt die angegebene URL mit der angegebenen HTTP-Methode und den angegebenen HTTP-Headern asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, bei der Ausführung mit den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] die anforderungsverarbeitung von einem Ressourcentyp in einen anderen übertragen werden, während der Ausführung der zielanforderung mit den richtigen Anforderungskontext ermöglicht. Beispielsweise können Sie die <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode, um eine Anforderung für eine ASPX-Seite auf eine Anforderung für eine XML-Seite zu übertragen.  
  
 Die <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode führt eine asynchrone untergeordneten Ausführung die angegebene URL mit den folgenden Bedingungen:  
  
-   Wenn die `path` Parameter gibt an, eine Abfragezeichenfolge, sondern wird als neue Abfragezeichenfolge verwendet werden. Wenn keine Abfragezeichenfolge enthalten ist, wird die Abfragezeichenfolge der Anforderung erneut verwendet werden.  
  
-   Wenn die `method` Parameter angegeben wird, verwendet wird. Ist er `null`, die HTTP-Methode der ursprünglichen Anforderung verwendet werden.  
  
-   Wenn die `preserveForm` Parameter ist `true`, die aktuelle Entitätstext der Anforderung wird an die zielanforderung verfügbar sein. Dies ermöglicht es-formularbereitstellungen und hochgeladen werden, damit Sie übertragen werden.  
  
-   Wenn die Identität des Benutzers auf die ursprüngliche Anforderung zurzeit festgelegt ist, wird die Identität der neuen Anforderung übertragen werden. Dies ermöglicht authentifizierte Anforderungen an das Ergebnis der Authentifizierung für die neue Anforderung erneut zu verwenden. Wenn Sie nicht, dass den Benutzer wünschen, die übertragen werden, legen Sie den Benutzer auf `null` auf die ursprüngliche Anforderung, bevor übertragen wird.  
  
-   Wenn die `headers` Parameter angegeben wird, wird die neue Anforderung mit den angegebenen Headern ausgeführt. Dies kann verwendet werden, um die Anforderungsheader und Cookies für die neue Anforderung zu ändern, oder fügen einen speziellen Header, der angibt, in dem die ursprüngliche Anforderung empfangen wurde.  
  
     Diese Methode ruft die <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> methodenüberladung mit der `preserveUser` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert [!INCLUDE[iisver](~/includes/iisver-md.md)] im integrierten Modus ausgeführt wird.</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad.</param>
        <param name="preserveForm">
          <see langword="true" />Beibehalten der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung ist; <see langword="false" /> zum Deaktivieren der <see cref="P:System.Web.HttpRequest.Form" /> Auflistung.</param>
        <param name="method">Die HTTP-Methode für die neue Anforderung.</param>
        <param name="headers">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" /> Objekt, das Anforderungsheader für die neue Anforderung enthält.</param>
        <param name="preserveUser">
          <see langword="true" />um die Identität des Benutzers beibehalten. andernfalls <see langword="false" />. Rufen Sie diese Überladung mit diesem Parameter legen Sie auf die andere methodenüberladungen dieser Methode <see langword="true" />.</param>
        <summary>Nimmt eine asynchrone Ausführung der angegebenen URL mit der angegebenen HTTP-Methode, den angegebenen HTTP-Headern und dem angegebenen HTTP-Pfad vor und behält die Formularwerte und Benutzeridentität optional bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter dem Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende Textzeichenfolge.</param>
        <summary>Decodiert eine URL-Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text in URL-Zeichenfolgen ordnungsgemäß übertragen werden. Zeichen, z. B. eine Frage zu markieren (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) zu markieren und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden könnte. Daher müssen diese Zeichen codiert werden, `<a>` tags oder in der Abfrage von Zeichenfolgen, in denen die Zeichenfolgen vom Browser in eine Anforderungszeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern verwendet diese Methode <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite, Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> -Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer Code-Behind-Datei befindet, `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die <xref:System.Net.WebUtility> -Klasse zum Codieren oder Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie URL-decodiert einen Wert, der aus der Abfragezeichenfolge abgerufen wurden. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. `ReturnPage`bezieht sich auf eine `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Im nächste Beispiel wird ähnlich wie im vorherigen Beispiel, außer es wird gezeigt, wie URL-decodiert einen Wert innerhalb einer Klasse, die ist nicht in der CodeBehind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Die <see cref="T:System.IO.TextWriter" /> Ausgabestream, der die decodierte Zeichenfolge enthalten.</param>
        <summary>Decodiert eine HTML-Zeichenfolge, die in einer URL empfangen und sendet die Ausgabe an eine <see cref="T:System.IO.TextWriter" /> Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text in URL-Zeichenfolgen ordnungsgemäß übertragen werden. Zeichen, z. B. eine Frage zu markieren (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) zu markieren und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden könnte. Daher müssen diese Zeichen codiert werden, `<a>` tags oder in der Abfrage von Zeichenfolgen, in denen die Zeichenfolgen vom Browser in eine Anforderungszeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A>ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlDecode%2A> verwendet <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichenfolge, die mit dem Namen decodiert `EncodedString` (empfangen in einer URL) in der Zeichenfolge mit dem Namen `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Zeichenfolge für eine zuverlässige HTTP-Übertragung vom Webserver an einen Client über die URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A>ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlEncode%2A> verwendet <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Codiert eine Zeichenfolge als URL und gibt die codierte Zeichenfolge zurück.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text in URL-Zeichenfolgen ordnungsgemäß übertragen werden. Zeichen, z. B. eine Frage zu markieren (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) zu markieren und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden könnte. Daher müssen diese Zeichen codiert werden, `<a>` tags oder in der Abfrage von Zeichenfolgen, in denen die Zeichenfolgen vom Browser in eine Anforderungszeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern verwendet diese Methode <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite, Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> -Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer Code-Behind-Datei befindet, `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die <xref:System.Net.WebUtility> -Klasse zum Codieren oder Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie für die URL-Codierung einen Wert, der als ein Wert der Abfragezeichenfolge als Hyperlink verwendet wird. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. Der Wert zum Codieren ist in diesem Beispiel wird nur für das Beispiel zu vereinfachen und zeigen dem Typ des Werts, dass Sie möglicherweise die URL-Codierung codiert. In der Regel würden Sie URL-Codierung einen Wert, den Sie vom Benutzer oder die Anforderung erhalten haben. `NextPage`bezieht sich auf eine `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Im nächste Beispiel wird ähnlich wie im vorherigen Beispiel, außer es wird gezeigt, wie URL zu codierende einem Wert innerhalb einer Klasse, die sich nicht in der Code-Behind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <param name="output">Die <see cref="T:System.IO.TextWriter" /> Ausgabestream, der die codierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge als URL und sendet die Ausgabe an eine <see cref="T:System.IO.TextWriter" /> Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text in URL-Zeichenfolgen ordnungsgemäß übertragen werden. Zeichen, z. B. eine Frage zu markieren (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) zu markieren und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden könnte. Daher müssen diese Zeichen codiert werden, `<a>` tags oder in der Abfrage von Zeichenfolgen, in denen die Zeichenfolgen vom Browser in eine Anforderungszeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A>ist eine einfache Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit von einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlEncode%2A> verwendet <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird codiert eine Zeichenfolge für die Übertragung von HTTP. Es wird die Zeichenfolge mit dem Namen `TestString`, enthält den Text "Dies ist eine \<Testzeichenfolge >.", und kopiert ihn in die Zeichenfolge mit dem Namen `EncodedString` als "This + ist + a + % 3cTest + String % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Nicht verwenden. Nur für die Browserkompatibilität vorgesehen. Verwenden Sie <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Das zu decodierende URL-Zeichenfolgentoken.</param>
        <summary>Decodiert ein URL-Zeichenfolgentoken in sein entsprechendes Bytearray mit Base-64-Ziffern.</summary>
        <returns>Das Bytearray, das das decodierte URL-Zeichenfolgentoken enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode konvertiert ein URL-Zeichenfolgentoken, das Binärdaten als base-64-Ziffern codiert, in seine entsprechende Bytearraydarstellung. Verwenden der <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> -Methode zum Decodieren von Token in der URL übertragen und codiert, indem die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 Die <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode gibt ein leeres Bytearray zurück, wenn die `input` Parameter hat eine Länge von weniger als 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">Das zu codierende Bytearray.</param>
        <summary>Codiert ein Bytearray in seine äquivalente Zeichenfolgendarstellung mit Base-64-Ziffern, die für die Übertragung in der URL geeignet ist.</summary>
        <returns>Die Zeichenfolge, enthält der codierten token If-Byte-Arrays *Länge* größer als 1 ist, andernfalls eine leere Zeichenfolge ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Methode konvertiert ein Bytearray in eine entsprechende Zeichenfolgendarstellung mit base-64-Ziffern codiert wurde. Das Zeichenfolgentoken, das sich ergebende kann in der URL übertragen werden.  
  
 Die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> gibt eine leere Zeichenfolge zurück, wenn die `input` Parameter hat eine Länge von weniger als 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
