<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert und erstellt zur Laufzeit neue Instanzen von Klassen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder>die Stammklasse dient zum Steuern der Erstellung von dynamischen Klassen in der Laufzeit verwendet. Er bietet einen Satz von Routinen, die zum Definieren von Klassen, Methoden und Felder hinzufügen und erstellen Sie die Klasse innerhalb eines Moduls verwendet werden. Ein neues <xref:System.Reflection.Emit.TypeBuilder> können aus einem dynamischen Modul erstellt werden, durch Aufrufen der <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> Methode, die zurückgibt ein <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 Reflektionsausgabe bietet die folgenden Optionen zum Definieren der Typen:  
  
-   Definieren Sie eine Klasse oder Schnittstelle mit dem angegebenen Namen.  
  
-   Definieren Sie eine Klasse oder Schnittstelle mit dem angegebenen Namen und Attributen.  
  
-   Definieren Sie eine Klasse mit dem angegebenen Namen, die Attribute und die Basisklasse.  
  
-   Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und die Gruppe von Schnittstellen, die die Klasse implementiert.  
  
-   Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und Komprimierungsgröße.  
  
-   Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und die Klassengröße als Ganzes.  
  
-   Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse, Komprimierungsgröße und die Klassengröße als Ganzes.  
  
 So erstellen ein Arraytyp, Zeigertyp oder Byref-Typ für einen unvollständigen Typ, der durch dargestellt wird eine <xref:System.Reflection.Emit.TypeBuilder> -Objekts die <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> -Methode, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> -Methode, oder <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> Methode bzw..  
  
 Bevor ein Typ verwendet wird, die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> -Methode muss aufgerufen werden. **CreateType** schließt die Erstellung des Typs. Nach dem Aufruf von **CreateType**, der Aufrufer kann den Typ instanziieren, indem Sie mit der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode, und rufen Sie Member des Typs mit der <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Methode. Es ist ein Fehler zum Aufrufen von Methoden, die die Implementierung eines Typs nach dem Ändern **CreateType** aufgerufen wurde. Beispielsweise löst die common Language Runtime eine Ausnahme aus, wenn der Aufrufer versucht, eine neue Elemente hinzufügen.  
  
 Ein Klasseninitialisierer wird erstellt, indem Sie mit der <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> Methode. **DefineTypeInitializer** gibt eine <xref:System.Reflection.Emit.ConstructorBuilder> Objekt.  
  
 Geschachtelte Typen werden durch einen Aufruf der definiert die <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> Methoden.  
  
## <a name="attributes"></a>Attribute  
 Die <xref:System.Reflection.Emit.TypeBuilder> -Klasse verwendet die <xref:System.Reflection.TypeAttributes> Enumeration genauer die Merkmale des zu erstellenden Typs anzugeben:  
  
-   Schnittstellen werden angegeben, mit der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> und <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Attribute.  
  
-   Konkrete Klassen (Klassen, die nicht erweitert werden) werden angegeben, mit der <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> Attribut.  
  
-   Mehrere Attribute bestimmen typsichtbarkeit. Siehe dazu die Beschreibung der <xref:System.Reflection.TypeAttributes> Enumeration.  
  
-   Wenn <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> angegeben ist, wird das Ladeprogramm Layout der Felder in der Reihenfolge, die sie aus den Metadaten gelesen werden. Das Klassenladeprogramm der hält der angegebene Komprimierungsgröße, ignoriert jedoch die angegebenen Feldoffsets. Die Metadaten behält die Reihenfolge, in der die Felddefinitionen ausgegeben werden. Sogar über eine Zusammenführung wird die Metadaten die Felddefinitionen nicht neu anordnen. Das Ladeprogramm berücksichtigt nur, wenn das angegebene Feld Offsets <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> angegeben ist.  
  
## <a name="known-issues"></a>Bekannte Probleme  
  
-   Reflektionsausgabe überprüft nicht, ob eine nicht abstrakte Klasse, die eine Schnittstelle implementiert, alle in der Schnittstelle deklarierten Methoden implementiert hat. Jedoch, wenn die Klasse nicht alle in einer Schnittstelle deklarierten Methoden implementiert, wird die Common Language Runtime nicht die Klasse geladen.  
  
-   Obwohl <xref:System.Reflection.Emit.TypeBuilder> stammt aus <xref:System.Type>, einige der abstrakten Methoden definiert, der <xref:System.Type> Klasse sind nicht vollständig implementiert der <xref:System.Reflection.Emit.TypeBuilder> Klasse. Aufrufe dieser <xref:System.Reflection.Emit.TypeBuilder> Methoden lösen eine <xref:System.NotSupportedException> Ausnahme. Die gewünschte Funktionalität erhalten Sie durch Abrufen des erstellten Typs mithilfe der <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und Reflektieren des abgerufenen Typs.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie einen dynamischen Typ mit einem Feld, Konstruktor Eigenschaft und Methode erstellt wird. Im zweite Beispiel erstellt eine Methode dynamisch aus den Benutzereingaben.  
  
 **Beispiel einer**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine dynamische Assembly mit einem Modul definiert. Das Modul in der Beispielassembly enthält einen Typ `MyDynamicType`, verfügt über ein privates Feld, eine Eigenschaft, die ermittelt und definiert das private Feld, Konstruktoren, die das private Feld zu initialisieren und eine Methode, die eine vom Benutzer angegebene Zahl von privaten Feld multipliziert. Wert und gibt das Ergebnis zurück.  
  
 Die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Feld wird angegeben, wenn die Assembly erstellt wird. Der Assemblycode wird sofort verwendet werden soll, und die Assembly wird auch gespeichert, damit es mit geprüft werden auf den Datenträger [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) oder in einem anderen Programm verwendet.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen dynamischen Typ zu erstellen, indem Sie mithilfe von `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Die auszuführende Sicherheitsaktion (z. B. Demand, Assert usw.).</param>
        <param name="pset">Der Berechtigungssatz, für den die Aktion gilt.</param>
        <summary>Fügt diesem Typ deklarative Sicherheit hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity`kann mehrmals aufgerufen werden mit jedem Aufruf eine Sicherheitsaktion (z. B. Demand, Assert oder DENY-Anweisung) und einen Satz von Berechtigungen, die für die Aktion gelten angeben.  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0, 1.1 und 2.0 sind die Attribute für deklarative Sicherheit auf einen Typ angewendet werden, mithilfe dieser Methode in das alte Format der XML-Metadaten gespeichert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `AddDeclarativeSecurity` Methode, um eine sicherheitsforderung für hinzuzufügen <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> Flag zu einem dynamischen Typ mit dem Namen `MyDynamicClass`, in einer Assembly mit dem Namen EmittedExample.dll. Das Beispiel führt die Konsolenausgabe; Nachdem Sie es ausführen, können Sie [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) EmittedExample.dll untersuchen. In `MyDynamicClass`öffnen die `.class public auto ansi` Anweisung, um die deklarative Berechtigung finden Sie unter.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="action" /> ist ungültig (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, und <see langword="RequestRefuse" /> sind ungültig).</exception>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde mithilfe von <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Der Berechtigungssatz <paramref name="pset" /> enthält eine Aktion, die zuvor von hinzugefügten <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Die Schnittstelle, die dieser Typ implementiert.</param>
        <summary>Fügt eine Schnittstelle hinzu, die dieser Typ implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Implementierung einer Schnittstelle in einer dynamisch erstellten Typ mit `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</summary>
        <value>Schreibgeschützt. Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den vollständigen Name des Typs zurück, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</summary>
        <value>Schreibgeschützt. Der vollständige Name des Typs, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format der zurückgegebenen Zeichenfolge ist die Verkettung von den vollständigen Namen des Typs (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) und den Anzeigenamen der Assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), getrennt durch ein Komma und ein Leerzeichen.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> eine Beschreibung des Formats des Anzeigenamens einer Assembly.  
  
## <a name="version-information"></a>Versionsinformationen  
 In der .NET Framework-Versionen 1.0 und 1.1 enthalten der Wert dieser Eigenschaft nicht die Kultur oder den öffentlichen Schlüssel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basistyp dieses Typs ab.</summary>
        <value>Schreibgeschützt. Ruft den Basistyp dieses Typs ab.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Type" />-Objekt für die Klasse. Nachdem die Felder und Methoden für die Klasse definiert sind, wird <see langword="CreateType" /> aufgerufen, um das <see langword="Type" />-Objekt der Klasse zu laden.</summary>
        <returns>Gibt das neue <see cref="T:System.Type" />-Objekt für diese Klasse zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Typ ein geschachtelter Typ ist der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode muss für den einschließenden Typ aufgerufen werden, bevor sie auf den geschachtelten Typ aufgerufen wird.  
  
 Wenn der aktuelle Typ ein unvollständiger Typ abgeleitet oder unvollständige Schnittstellen implementiert, rufen Sie die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den übergeordneten Typ und die Schnittstellentypen vor dem Aufrufen dieser für den aktuellen Typ.  
  
 Wenn der einschließende Typ ein Feld enthält, die ein Werttyp, der als ein geschachtelter Typ (z. B. ein Feld, das eine Enumeration, die als ein geschachtelter Typ definiert ist) definiert ist Aufrufen der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode des einschließenden Typs generiert einen <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> Ereignis. Dies ist, da das Ladeprogramm die Größe des einschließenden Typs nicht, bis zum Abschluss des geschachtelten Typs bestimmen kann. Der Aufrufer sollte definieren Sie einen Ereignishandler für das <xref:System.AppDomain.TypeResolve> Ereignis zum Abschließen der Definition des geschachtelten Typs durch den Aufruf <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> auf die <xref:System.Reflection.Emit.TypeBuilder> Objekt, das den geschachtelten Typ darstellt. Das Codebeispiel in diesem Thema zeigt, wie ein solcher Ereignishandler zu definieren.  
  
 Ein Typ wird nur einmal erstellt, unabhängig davon, wie oft die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode aufgerufen wird. Alle Aufruf zurück, die die gleiche <xref:System.Type> Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie definiert einen Ereignishandler für die <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> -Ereignis für den Aufruf der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> Methode für einen geschachtelten Typ bei einer <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für den einschließenden Typ aufgerufen.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der einschließende Typ wurde nicht erstellt.  
  
 - oder -   
  
 Dieser Typ ist nicht abstrakt und enthält eine abstrakte Methode.  
  
 - oder -   
  
 Dieser Typ ist weder eine abstrakte Klasse noch eine Schnittstelle und hat eine Methode ohne Methodenkörper.</exception>
        <exception cref="T:System.NotSupportedException">Der Typ enthält ungültigen MSIL-Code (Microsoft Intermediate Language).  
  
 - oder -   
  
 Das Verzweigungsziel ist mit einem Offset von 1 Byte angegeben, die Entfernung des Ziels von der Verzweigung ist jedoch größer als 127 Bytes.</exception>
        <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden. Er enthält beispielsweise eine <see langword="static" />-Methode, die die Aufrufkonvention <see cref="F:System.Reflection.CallingConventions.HasThis" /> hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Reflection.TypeInfo" />-Objekt ab, das diesen Typ darstellt.</summary>
        <returns>Ein Objekt, das diesen Typ darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode ab, die den aktuellen generischen Typparameter deklariert hat.</summary>
        <value>Eine <see cref="T:System.Reflection.MethodBase" /> zur Darstellung der Methode, die den aktuellen Typ deklariert hat, wenn der aktuelle Typ ein generischer Typparameter ist, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt und keine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Typ zurück, der diesen Typ deklariert hat.</summary>
        <value>Schreibgeschützt. Der Typ, der diesen Typ deklariert hat.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Die Attribute des Konstruktors.</param>
        <param name="callingConvention">Die Aufrufkonvention des Konstruktors.</param>
        <param name="parameterTypes">Die Parametertypen des Konstruktors.</param>
        <summary>Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen und der Signatur hinzu.</summary>
        <returns>Der definierte Konstruktor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie keinen Konstruktor für den dynamischen Typ definieren, ein Standardkonstruktor wird automatisch bereitgestellt, und er ruft den Standardkonstruktor der Basisklasse.  
  
 Wenn Sie einen Konstruktor für den dynamischen Typ definieren, wird ein Standardkonstruktor nicht bereitgestellt. Sie haben die folgenden Optionen für die Bereitstellung eines Standardkonstruktors zusätzlich zu den Konstruktor aus, den Sie definiert:  
  
-   Wenn Sie einen Standardkonstruktor möchten, der einfach den Standardkonstruktor der Basisklasse aufruft, können Sie die <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> Methode zum Erstellen einer (und optional Beschränken des Zugriffs auf diese). Stellen Sie eine Implementierung für diesen Standardkonstruktor nicht. Wenn Sie dies tun, wird eine Ausnahme ausgelöst, wenn Sie versuchen, den Konstruktor zu verwenden. Es werden keine Ausnahmen ausgelöst, wenn die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode aufgerufen wird.  
  
-   Wenn Sie möchten einen Standardkonstruktor, der nicht mehr als einfach den Standardkonstruktor der Basisklasse aufrufen, oder einen anderen Konstruktor aufruft, etwas anderes die Basisklasse oder, die vollständig ist, müssen Sie die <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> Methode, erstellen und eine eigene Implementierung bereitzustellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineConstructor` bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festgelegt und Zurückgeben eines entsprechenden <xref:System.Reflection.Emit.ConstructorBuilder> für MSIL Auffüllung.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Die Attribute des Konstruktors.</param>
        <param name="callingConvention">Die Aufrufkonvention des Konstruktors.</param>
        <param name="parameterTypes">Die Parametertypen des Konstruktors.</param>
        <param name="requiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="optionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <summary>Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen, der angegebenen Signatur und den angegebenen benutzerdefinierten Modifizierern hinzu.</summary>
        <returns>Der definierte Konstruktor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.  
  
> [!NOTE]
>  Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Größe von <paramref name="requiredCustomModifiers" /> oder <paramref name="optionalCustomModifiers" /> entspricht nicht die Größe von <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Ein <see langword="MethodAttributes" />-Objekt, das die auf den Konstruktor anzuwendenden Attribute darstellt.</param>
        <summary>Definiert den Standardkonstruktor. Der hier definierte Konstruktor ruft einfach den Standardkonstruktor des übergeordneten Elements auf.</summary>
        <returns>Gibt den Konstruktor zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da der Standardkonstruktor automatisch definiert wird, ist es notwendig, diese Methode nur in den folgenden Situationen:  
  
-   Sie haben einen anderen Konstruktor definiert, und möchten auch einen Standardkonstruktor, der einfach den Basisklassenkonstruktor aufruft.  
  
-   Anders als die Attribute des Standardkonstruktors auf einen anderen Wert festlegen möchten <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, und <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineConstructor` bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festgelegt und Zurückgeben eines entsprechenden <xref:System.Reflection.Emit.ConstructorBuilder> für MSIL Auffüllung.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der übergeordnete Typ (Basistyp) weist keinen Standardkonstruktor auf.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Ereignisses. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute des Ereignisses.</param>
        <param name="eventtype">Der Typ des Ereignisses.</param>
        <summary>Fügt dem Typ ein neues Ereignis hinzu, das den angegebenen Namen, die angegebenen Attribute und den angegebenen Ereignistyp hat.</summary>
        <returns>Das definierte Ereignis.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="eventtype" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Der Name des Felds. <c>Feldname</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="type">Der Typ des Felds.</param>
        <param name="attributes">Die Attribute des Felds.</param>
        <summary>Fügt ein neues Feld mit dem angegebenen Namen, den angegebenen Attribute und dem angegebenen Feldtyp zum Typ hinzu.</summary>
        <returns>Das definierte Feld.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="fieldName" /> ist 0 (null).  
  
 - oder -   
  
 <paramref name="type" /> ist „System.Void“.  
  
 - oder -   
  
 Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Der Name des Felds. <c>Feldname</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="type">Der Typ des Felds.</param>
        <param name="requiredCustomModifiers">Gibt ein Array von Typen zurück, das die erforderlichen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Gibt ein Array von Typen zurück, das die optionalen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Die Attribute des Felds.</param>
        <summary>Fügt ein neues Feld mit dem angegebenen Namen, den Attributen, dem Feldtyp und den benutzerdefinierten Modifizierern zum Typ hinzu.</summary>
        <returns>Das definierte Feld.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="fieldName" /> ist 0 (null).  
  
 - oder -   
  
 <paramref name="type" /> ist „System.Void“.  
  
 - oder -   
  
 Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Ein Array von Namen für die generischen Typparameter.</param>
        <summary>Definiert die generischen Typparameter für den aktuellen Typ, gibt dabei deren Zahl und deren Namen an und gibt ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten zurück, das dazu verwendet werden kann, deren Einschränkungen festzulegen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten, das dazu verwendet werden kann, die Einschränkungen der generischen Typparameter für den aktuellen Typ zu definieren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode wird der aktuelle Typ einen generischen Typ. Wenn die Methode erneut auf den gleichen Typ aufgerufen wird eine <xref:System.InvalidOperationException> ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein generischer Typ mit zwei Typparametern erstellt und speichert sie in der Assembly GenericEmitExample1.dll gespeichert werden. Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) So zeigen Sie die generierten Typen an. Eine ausführlichere Erläuterung der Schritte sind für einen dynamischen generischen Typ definieren, finden Sie unter [wie: Definieren eines generischen Typs mit Reflektionsausgabe](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurden bereits generische Typparameter für diesen Typ definiert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="names" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> ist ein leeres Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="data">Das Daten-BLOB.</param>
        <param name="attributes">Die Attribute für das Feld.</param>
        <summary>Definiert das initialisierte Datenfeld im ".sdata"-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</summary>
        <returns>Ein Feld zum Verweisen auf die Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Feld, das Sie mit dieser Methode erstellen, werden `static`, selbst wenn Sie nicht einschließen, `FieldAttributes.Static` in der `attributes` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Die Größe der Daten ist kleiner oder gleich 0 (null) bzw. größer oder gleich 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="data" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde bereits zuvor aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen und den Methodenattributen hinzu.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, wenn Sie nicht die Signatur der Methode zum Zeitpunkt kennen Sie die Methode definieren. Beispielsweise könnte die Parametertypen und den Rückgabetyp einer generischen Methode durch generische Typparameter der Methode, die angegeben werden definiert werden muss, nachdem der Typ die Methode hinzugefügt wurden. Die Parameter und Rückgabetyp der Methode festgelegt werden können später mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> Methode.  
  
 Diese methodenüberladung definiert eine Methode mit <xref:System.Reflection.CallingConventions?displayProperty=nameWithType>. Wenn Sie eine Methode ohne eine Signatur, mit einer anderen Aufrufkonvention definieren verwenden die <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine generische Methode mit dem Namen `DemoMethod` , dessen Parametertyp und den Rückgabetyp von ihren generischen Typparametern angegeben werden. Die Methode definiert ist ohne eine Signatur, die herkömmliche Aufrufkonventionen verwenden. Die <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Methode wird verwendet, damit `DemoMethod` einer generischen Methode und die neu definierte Typparameter werden für die Signatur verwendet und Rückgabetyp.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> Methode.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Aufrufkonvention hinzu.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, wenn Sie nicht die Signatur der Methode zum Zeitpunkt kennen Sie die Methode definieren. Beispielsweise könnte die Parametertypen und den Rückgabetyp einer generischen Methode durch generische Typparameter der Methode, die angegeben werden definiert werden muss, nachdem der Typ die Methode hinzugefügt wurden. Die Parameter und Rückgabetyp der Methode festgelegt werden können später mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Methodensignatur hinzu.</summary>
        <returns>Die definierte Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineMethod` bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festlegen und zum Zurückgeben eines entsprechenden <xref:System.Reflection.Emit.MethodBuilder> für MSIL Auffüllung.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention und der Methodensignatur hinzu.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineMethod` bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festlegen und zum Zurückgeben eines entsprechenden <xref:System.Reflection.Emit.MethodBuilder> für MSIL Auffüllung.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention, der Methodensignatur und den benutzerdefinierten Modifizierern hinzu.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />-Objekt, das die neu hinzugefügte Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie benutzerdefinierte Modifizierer angeben müssen. Wenn Sie benutzerdefinierten Modifizierer, nachdem die Methode erstellt wurde, wie angeben müssen, z. B. mit einer generischen Methode, deren Parametertypen, indem die generischen Typparameter angegeben werden, Sie können die <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> oder <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> -methodenüberladungen, um zu definieren die Methode und anschließend mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> -Methode definieren Sie den Parameter und zurückgeben Typen mit benutzerdefinierten Modifizierer hat.  
  
> [!NOTE]
>  Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).  
  
 - oder -   
  
 Die Größe von <paramref name="parameterTypeRequiredCustomModifiers" /> oder <paramref name="parameterTypeOptionalCustomModifiers" /> entspricht nicht der Größe von <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">Der zu verwendende Methodentext. Dies sollte ein <see langword="MethodBuilder" />-Objekt sein.</param>
        <param name="methodInfoDeclaration">Die Methode, deren Deklaration verwendet werden soll.</param>
        <summary>Gibt einen bestimmten Methodentext an, der eine bestimmte Methodendeklaration, möglicherweise mit einem anderen Namen, implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nicht zum Ausgeben von methodenüberschreibungen oder schnittstellenimplementierungen. Um eine Methode einer Basisklasse zu überschreiben oder eine Methode einer Schnittstelle zu implementieren, geben Sie eine Methode mit demselben Namen und derselben Signatur einfach als die Methode, die außer Kraft gesetzt werden, oder implementieren fest, wie im Codebeispiel wird veranschaulicht.  
  
 Die <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> Methode wird verwendet, wenn ein Methodentext und eine Methodendeklaration unterschiedliche Namen aufweisen. Beispielsweise kann eine Klasse eine Methode der Basisklasse überschreiben und auch bieten eine separate Implementierung für einen Schnittstellenmember mit dem gleichen Namen wie im Codebeispiel wird veranschaulicht.  
  
 `DefineMethodOverride`definiert eine `methodimpl`, die besteht aus einem Paar von Metadatentoken. Ein Token zeigt auf eine Implementierung und der andere token verweist auf eine Deklaration, die der Text implementiert. Der Text für den Typ der Methode "Impl" definiert ist, auf definiert sein, und der Text muss virtuell sein (`Overridable` in Visual Basic). Die Deklaration kann an eine Methode, die für eine Schnittstelle implementiert wird, indem Sie den Typ, einer Methode in einer abgeleiteten Klasse oder eine im Typ definierte Methode definierten vorgenommen werden. Wenn die Deklaration nur für eine Schnittstelle ist, ist der Slot für die Schnittstelle geändert. Wenn die Deklaration einer Methode in einem Basistyp erfolgt, Slot des für die Methode überschrieben wird, und auch alle Duplikate für die überschriebene Methode ersetzt werden. Die überschriebene Methode darf nicht die tatsächlichen Methode sein, die deklariert wird. Wenn die Methode für den gleichen Typ ist, der Slot ersetzt, und alle Duplikate für die ersetzten Methoden überschrieben werden.  
  
> [!NOTE]
>  Weitere Informationen zur Methode Impls finden Sie unter `MethodImpl` in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
> [!IMPORTANT]
>  Nach der <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> -Methode aufgerufen wird, werden einige Funktionen von `methodInfoBody` kann nicht geändert werden. Sie können z. B. ein Attribut auf einen generischen Typparameter anwenden `methodInfoBody` mithilfe der <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> Methode. Wenn Sie verwenden, müssen die <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> -Methode dazu nach allen Eigenschaften des `methodInfoBody` definiert wurden.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält eine Schnittstelle `I` mit einer Methode `M()`, eine Basisklasse `A` , implementiert die Schnittstelle und eine abgeleitete Klasse `C` überschreibt die basisklassenimplementierung der `M()` sowie Stellt eine separate explizite Implementierung der `I.M()`.  
  
 Die `main()` Methode des Codebeispiels wird veranschaulicht, wie zum Ausgeben von der abgeleiteten Klasse `C`. Die Außerkraftsetzung der `A.M()` erfolgt einfach durch Ausgeben einer Methode `M()` mit derselben Signatur. Allerdings auf einer separaten Implementierung der `I.M()`, müssen Sie einen Methodentext definieren und verwenden Sie dann die <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> Methode, um diese Methodentext mit zuzuordnen eine <xref:System.Reflection.MethodInfo> darstellt `I.M()`. Der Name des Methodentextes spielt keine Rolle.  
  
 Das Codebeispiel erstellt eine Instanz der ausgegebenen-Klasse. Er erhält eine <xref:System.Reflection.MethodInfo> -Objekt für `I.M()`, und verwendet es die ausgegebene aufrufen ist die explizite schnittstellenimplementierung. Er dann erhält ein <xref:System.Reflection.MethodInfo> -Objekt für `A.M()`, und verwendet, um das Aufrufen dieser Methode die ausgegebene Klasse überschrieben.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> gehört nicht zu dieser Klasse.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> oder <paramref name="methodInfoDeclaration" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Der deklarierende Typ des <paramref name="methodInfoBody" /> ist nicht der von diesem <see cref="T:System.Reflection.Emit.TypeBuilder" /> dargestellte Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <summary>Definiert einen geschachtelten Typ anhand des Namens.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <summary>Definiert einen geschachtelten Typ, wozu dessen Name und Attribute angegeben sind.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
 - oder -   
  
 Dieser Typ ist versiegelt.  
  
 - oder -   
  
 Dieser Typ ist ein Array.  
  
 - oder -   
  
 Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
        <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen und erweitertem Typ.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
 - oder -   
  
 Dieser Typ ist versiegelt.  
  
 - oder -   
  
 Dieser Typ ist ein Array.  
  
 - oder -   
  
 Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
        <param name="typeSize">Die Gesamtgröße des Typs.</param>
        <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Gesamtgröße des Typs und erweitertem Typ.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
 - oder -   
  
 Dieser Typ ist versiegelt.  
  
 - oder -   
  
 Dieser Typ ist ein Array.  
  
 - oder -   
  
 Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
        <param name="packSize">Die Komprimierungsgröße des Typs.</param>
        <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, erweitertem Typ und Komprimierungsgröße.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
 - oder -   
  
 Dieser Typ ist versiegelt.  
  
 - oder -   
  
 Dieser Typ ist ein Array.  
  
 - oder -   
  
 Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
        <param name="interfaces">Die vom geschachtelte Typ implementierten Schnittstellen.</param>
        <summary>Definiert einen geschachtelten Typ mit seinem Namen, den Attributen, dem erweiterten Typ und den implementierten Schnittstellen.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode für den einschließenden Typ aufgerufen wurde.  
  
 Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, oder <xref:System.Type.GetNestedTypes%2A>.  
  
 Siehe die Beschreibung der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.  
  
 Ein doppelter Name ist nicht notwendigerweise erstellt, wenn `name` identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist. Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
 - oder -   
  
 Dieser Typ ist versiegelt.  
  
 - oder -   
  
 Dieser Typ ist ein Array.  
  
 - oder -   
  
 Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
 - oder -   
  
 Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element des <paramref name="interfaces" />-Arrays ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Der Kurzname des Typs. <c>Namen</c> darf keine eingebetteten null-Werte enthalten.</param>
        <param name="attr">Die Attribute des Typs.</param>
        <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
        <param name="packSize">Die Komprimierungsgröße des Typs.</param>
        <param name="typeSize">Die Gesamtgröße des Typs.</param>
        <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Größe und erweitertem Typ.</summary>
        <returns>Der definierte geschachtelte Typ.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der <see langword="PInvoke" />-Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
        <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
        <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
        <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige DLL-Importattribute (siehe die Beschreibung der <xref:System.Runtime.InteropServices.DllImportAttribute>) kann nicht als Argumente für diese Methode angegeben werden. Z. B. import die DLL-Attribut <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> muss hinzugefügt werden, nachdem die `PInvoke` Methode erstellt wird, wenn die Methode einen Wert zurückgibt. Im Beispiel veranschaulicht dies.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> Methode zum Erstellen einer `PInvoke` -Methode und zum Hinzufügen der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <xref:System.Reflection.Emit.MethodBuilder>, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> und <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>Methoden.  
  
> [!IMPORTANT]
>  Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> Flag.  
  
 Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs `MyType`, enthält die `PInvoke` Methode. Die `PInvoke` Methode darstellt, die Win32 `GetTickCount` Funktion.  
  
 Wenn das Beispiel ausgeführt wird, führt die `PInvoke` Methode. Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert. Können Sie die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Untersuchen der `MyType` Klasse und die `static` (`Shared` in Visual Basic) `PInvoke` Methode, die es enthält. Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren `MyType.GetTickCount` Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
 - oder -   
  
 Der übergeordnete Typ ist eine Schnittstelle.  
  
 - oder -   
  
 Die Methode ist abstrakt.  
  
 - oder -   
  
 Die Methode wurde bereits definiert.  
  
 - oder -   
  
 Die Länge von <paramref name="name" /> oder <paramref name="dllName" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der <see langword="PInvoke" />-Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
        <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
        <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
        <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
        <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige DLL-Importattribute (siehe die Beschreibung der <xref:System.Runtime.InteropServices.DllImportAttribute>) kann nicht als Argumente für diese Methode angegeben werden. Z. B. import die DLL-Attribut <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> muss hinzugefügt werden, nachdem die `PInvoke` Methode erstellt wird, wenn die Methode einen Wert zurückgibt. Im Beispiel veranschaulicht dies.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> Methode zum Erstellen einer `PInvoke` -Methode und zum Hinzufügen der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <xref:System.Reflection.Emit.MethodBuilder>, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> und <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> Methoden.  
  
> [!IMPORTANT]
>  Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> Flag.  
  
 Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs `MyType`, enthält die `PInvoke` Methode. Die `PInvoke` Methode darstellt, die Win32 `GetTickCount` Funktion.  
  
 Wenn das Beispiel ausgeführt wird, führt die `PInvoke` Methode. Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert. Können Sie die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Untersuchen der `MyType` Klasse und die `static` (`Shared` in Visual Basic) `PInvoke` Methode, die es enthält. Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren `MyType.GetTickCount` Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
 - oder -   
  
 Der übergeordnete Typ ist eine Schnittstelle.  
  
 - oder -   
  
 Die Methode ist abstrakt.  
  
 - oder -   
  
 Die Methode wurde bereits definiert.  
  
 - oder -   
  
 Die Länge von <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der <see langword="PInvoke" />-Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
        <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode.</param>
        <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
        <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
        <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode, die <see langword="PInvoke" />-Flags, die benutzerdefinierten Modifizierer für die Parameter und den Rückgabetyp.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die definierte <see langword="PInvoke" />-Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige DLL-Importattribute (siehe die Beschreibung der <xref:System.Runtime.InteropServices.DllImportAttribute>) kann nicht als Argumente für diese Methode angegeben werden. Z. B. import die DLL-Attribut <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> muss hinzugefügt werden, nachdem die `PInvoke` Methode erstellt wird, wenn die Methode einen Wert zurückgibt. Im Beispiel veranschaulicht dies.  
  
> [!NOTE]
>  Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der [\], Typ\[\], Typ\[\], Typ\[\]\[\], Typ\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > Methode zum Erstellen einer `PInvoke` -Methode und zum Hinzufügen der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <xref:System.Reflection.Emit.MethodBuilder>, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> und <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> Methoden.  
  
 Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs `MyType`, enthält die `PInvoke` Methode. Die `PInvoke` Methode darstellt, die Win32 `GetTickCount` Funktion.  
  
> [!IMPORTANT]
>  Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> Flag.  
  
> [!NOTE]
>  Das Beispiel verwendet eine Überladung, die keine benutzerdefinierten Modifizierer angibt. Ändern Sie den Beispielcode, um stattdessen verwenden Sie diese methodenüberladung zum Angeben von benutzerdefinierten Modifizierer.  
  
 Wenn das Beispiel ausgeführt wird, führt die `PInvoke` Methode. Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert. Können Sie die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Untersuchen der `MyType` Klasse und die `static` (`Shared` in Visual Basic) `PInvoke` Methode, die es enthält. Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren `MyType.GetTickCount` Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
 - oder -   
  
 Der übergeordnete Typ ist eine Schnittstelle.  
  
 - oder -   
  
 Die Methode ist abstrakt.  
  
 - oder -   
  
 Die Methode wurde bereits definiert.  
  
 - oder -   
  
 Die Länge von <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist 0 (null).  
  
 - oder -   
  
 Die Größe von <paramref name="parameterTypeRequiredCustomModifiers" /> oder <paramref name="parameterTypeOptionalCustomModifiers" /> entspricht nicht die Größe von <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Den Namen der Eigenschaft. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Eigenschaft.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
        <summary>Fügt dem Typ eine neue Eigenschaft mit dem angegebenen Namen und der angegebenen Eigenschaftensignatur hinzu.</summary>
        <returns>Die definierte Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine dynamische Eigenschaft definieren sowie das Abrufen einer <xref:System.Reflection.Emit.PropertyBuilder> für Spezifikation. Beachten Sie, dass eine `PropertyBuilder` benötigen auch eine entsprechende <xref:System.Reflection.Emit.MethodBuilder>, wird die IL-Logik für die Eigenschaft gespeichert.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Den Namen der Eigenschaft. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Eigenschaft.</param>
        <param name="callingConvention">Die Aufrufkonvention der Eigenschaftsaccessoren.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
        <summary>Fügt dem Typ eine neue Eigenschaft mit den Angaben für den Namen und die Signatur der Eigenschaften hinzu.</summary>
        <returns>Die definierte Eigenschaft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Den Namen der Eigenschaft. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Eigenschaft.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an. </param>
        <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an. </param>
        <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
        <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <summary>Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</summary>
        <returns>Die definierte Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.  
  
> [!NOTE]
>  Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist gleich <see langword="null" />.  
  
 - oder -   
  
 Irgendeines der Elemente des <paramref name="parameterTypes" />-Arrays ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Den Namen der Eigenschaft. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Eigenschaft.</param>
        <param name="callingConvention">Die Aufrufkonvention der Eigenschaftsaccessoren.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an. </param>
        <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an. </param>
        <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
        <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
        <summary>Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Aufrufkonvention, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</summary>
        <returns>Die definierte Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.  
  
> [!NOTE]
>  Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation. Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 Diese methodenüberladung wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiert den Initialisierer für diesen Typ.</summary>
        <returns>Gibt einen Typinitialisierer zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der erstellte Initialisierer ist immer öffentlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Initialisierung Konstruktor mit `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="size">Die Größe des Datenfelds.</param>
        <param name="attributes">Die Attribute für das Feld.</param>
        <summary>Definiert das initialisierte Datenfeld im <see langword=".sdata" />-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</summary>
        <returns>Ein Feld zum Verweisen auf die Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Feld, das Sie mit dieser Methode erstellen, werden `static`, selbst wenn Sie nicht einschließen, `FieldAttributes.Static` in der `attributes` Parameter.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineUninitializedData` initialisierte Datenfeld in einem dynamischen Typ zu erstellen:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner gleich 0 oder größer gleich 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Pfad dieses Typs ab.</summary>
        <value>Schreibgeschützt. Ruft den vollständigen Pfad dieses Typs ab.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Format ist "einschließenderTypVollständigerName + geschachtelterTypname" für geschachtelte Typen und "Typname" für den nicht geschachtelten Typen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters angibt.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt und keine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position eines Typparameters in der Typparameterliste des generischen Typs ab, der den Parameter deklariert hat.</summary>
        <value>Die Position des Typparameters in der Typparameterliste des generischen Typs, der den Parameter deklariert hat, wenn das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt einen generischen Typparameter darstellt, andernfalls nicht definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt und keine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 Wenn die aktuelle <xref:System.Reflection.Emit.TypeBuilder> stellt keinen generischen Typparameter dar. der Wert dieser Eigenschaft ist nicht definiert. Verwenden der <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> -Eigenschaft können Sie bestimmen, ob die aktuelle <xref:System.Reflection.Emit.TypeBuilder> einen generischen Typparameter darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">Der konstruierte generische Typ, dessen Konstruktor zurückgegeben wird.</param>
        <param name="constructor">Ein Konstruktor für die generische Typdefinition von <c>Typ</c>, der angibt, welcher Konstruktor von <c>Typ</c> zurückgegeben.</param>
        <summary>Gibt den Konstruktor des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Konstruktor der generischen Typdefinition entspricht.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor von <paramref name="type" /> entsprechend <paramref name="constructor" /> darstellt und einen Konstruktor angibt, der zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Methode bietet eine Möglichkeit zum Abrufen einer <xref:System.Reflection.ConstructorInfo> Objekt, das einen Konstruktor, der einen konstruierten generischen Typ darstellt, dessen Definition eines generischen Typs wird durch, eine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 Nehmen wir beispielsweise an, Sie haben eine <xref:System.Reflection.Emit.TypeBuilder> -Objekt, das den Typ darstellt, `G<T>` in C#-Syntax (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) und ein <xref:System.Reflection.Emit.ConstructorBuilder> Objekt, das einen Konstruktor darstellt `G<T>`. Nehmen wir an, die `G<T>` verfügt über eine generische Methode mit Typparameter `U` , erstellt eine Instanz des konstruierten Typs `G<U>`. Der Code zum Erstellen einer Instanz des konstruierten Typs ausgeben zu können, müssen Sie eine <xref:System.Reflection.ConstructorInfo> Objekt, das den Konstruktor dieses darstellt konstruierter Typ – also erstellt, die eine Instanz des `G<U>`. Zu diesem Zweck rufen Sie zuerst die <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode für die <xref:System.Reflection.Emit.TypeBuilder> -Objekt angeben der <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt, das darstellt `U` als Typargument. Rufen Sie anschließend die <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> bei dem Rückgabewert der Methode der <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode als Parameter `type` und <xref:System.Reflection.Emit.ConstructorBuilder> -Objekt, das den Konstruktor darstellt `G<U>` als Parameter `constructor`. Der Rückgabewert ist der <xref:System.Reflection.ConstructorInfo> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt. Im Codebeispiel wird dieses Szenario veranschaulicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens `Sample` , die über einen Typparameter, der mit dem Namen verfügt `T`. Die Klasse verfügt über ein Feld mit dem Namen `Field`, des Typs `T`, und eine generische Methode mit dem Namen `GM` des eigenen Typparameters mit dem Namen `U`. Methode `GM` erstellt eine Instanz des `Sample`, Ersetzen des eigenen Typparameters `U` für den Typparameter von `Sample`, und speichert dessen Eingabeparameter in `Field`. Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) und vergleichen Sie sie mit der Code ausgegeben, die von Klasse `Example`.  
  
 Der Code in der Klasse `Example` veranschaulicht die Verwendung von der <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Methode, um generische Code ausgeben. Die `Main` -Methode der Klasse `Example` erstellt eine dynamische Assembly mit einer Klasse mit dem Namen `Sample` und verwendet die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen `T`. Einen Standardkonstruktor und ein Feld mit dem Namen `Field`, des Typs `T`, Klasse hinzugefügt werden `Sample`. Eine Methode `GM` hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Methode. Der Typparameter der `GM` lautet `U`. Nach dem Definieren des Typparameters die Signatur der `GM` hinzugefügt wird, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> Methode. Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind `null` außer `parameterTypes`; `parameterTypes` legt den Typ der einzige Parameter von der Methode, um `U`, generischen Typparameter der Methode. Der Text der Methode erstellt eine Instanz des konstruierten Typs `Sample<U>` (`Sample(Of U)` in Visual Basic), weist der Methodenparameter, damit `Field`, und gibt dann den Wert des `Field`. Die <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Methode dient zum Erstellen einer <xref:System.Reflection.ConstructorInfo> , die den Standardkonstruktor des konstruierten generischen Typs darstellt `Sample<U>` in der <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> -Anweisung, die die Instanz erstellt.  
  
 Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten `Main`. Im Text des `Main`, die statische `GM` Methode wird aufgerufen, für den konstruierten generischen Typ `Sample<int>` (`Sample(Of Integer)` in Visual Basic), mit dem Typ <xref:System.String> ersetzt `U`.  
  
 Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe. Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zum Vergleichen des ausgegebenen Codes durch den Code für die `Sample` -Klasse, die in das Codebeispiel selbst kompiliert wird.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> stellt keinen generischen Typ dar.  
  
 - oder -   
  
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="constructor" /> ist keine generische Typdefinition.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="constructor" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> Objekte, die für diese Klasse angegebenen definierten öffentlichen und nicht öffentlichen Konstruktoren darstellen.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> Objekte, die für diese Klasse definierten angegebenen Konstruktoren darstellen. Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
        <summary>Gibt alle für diesen Typ definierten benutzerdefinierten Attribute zurück.</summary>
        <returns>Gibt ein Objektarray zurück, das alle benutzerdefinierten Attribute dieses Typs darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe <see cref="M:System.Type.GetType" /> , und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für das zurückgegebene <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des zu suchenden Attributs. Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</param>
        <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
        <summary>Gibt alle benutzerdefinierten Attribute des aktuellen Typs zurück, die einem angegebenen Typ zugewiesen werden können.</summary>
        <returns>Ein Array benutzerdefinierter Attribute, die für den aktuellen Typ definiert sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe <see cref="M:System.Type.GetType" /> , und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für das zurückgegebene <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ muss ein vom zugrunde liegenden Laufzeitsystem bereitgestellter Typ sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" /> ausgelöst.</summary>
        <returns>Diese Methode wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Ereignisses, nach dem gesucht werden soll.</param>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" /> Werte, die die Suche einschränkt.</param>
        <summary>Gibt das Ereignis mit dem angegebenen Namen zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.EventInfo" /> -Objekt deklariert oder geerbt wurde von diesem Typ mit dem angegebenen Namen, die das Ereignis darstellt oder <see langword="null" /> , wenn keine Übereinstimmungen vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die öffentlichen Ereignisse zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" /> -Objekten deklariert oder geerbt wurden von diesem Typ öffentlichen Ereignisse darstellen. Wenn keine öffentlichen Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetType%2A> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" /> Werte, die die Suche einschränkt.</param>
        <summary>Gibt die öffentlichen und nicht öffentlichen Ereignisse zurück, die von diesem Typ deklariert werden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" /> -Objekten deklariert oder geerbt wurden von diesem Typ, der den angegebenen Bindungsflags übereinstimmen, die die Ereignisse darstellt. Wenn keine übereinstimmenden Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Felds.</param>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt das vom angegebenen Namen angegebene Feld zurück.</summary>
        <returns>Gibt die <see cref="T:System.Reflection.FieldInfo" /> -Objekt deklariert oder geerbt wurde von diesem Typ mit dem angegebenen Namen und öffentlichen oder nicht öffentlichen Modifizierer, die das Feld darstellt. Wenn dann keine Übereinstimmungen vorhanden sind <see langword="null" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">Der konstruierte generische Typ, dessen Feld zurückgegeben wird.</param>
        <param name="field">Ein Feld für die generische Typdefinition von <c>Typ</c>, der angibt, welches Feld der <c>Typ</c> zurückgegeben.</param>
        <summary>Gibt das Feld des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Feld der generischen Typdefinition entspricht.</summary>
        <returns>Ein <see cref="T:System.Reflection.FieldInfo" />-Objekt, das das Feld von <paramref name="type" /> darstellt, das <paramref name="field" /> entspricht, welches ein Feld angibt, das zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Methode bietet eine Möglichkeit zum Abrufen einer <xref:System.Reflection.FieldInfo> Objekt, das ein Feld eines konstruierten generischen Typs darstellt, dessen Definition eines generischen Typs wird durch, eine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 Nehmen wir beispielsweise an, Sie haben eine <xref:System.Reflection.Emit.TypeBuilder> -Objekt, das den Typ darstellt, `G<T>` in C#-Syntax (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) und ein <xref:System.Reflection.Emit.FieldBuilder> -Objekt, das ein Feld darstellt `public T F` in C#-Syntax (`Public F As T`in Visual Basic `public: T F` in C++), wird durch definiert `G<T>`. Nehmen wir an, die `G<T>` verfügt über eine generische Methode mit Typparameter `U` , erstellt eine Instanz des konstruierten Typs `G<U>` und Aufrufe Feld `F` für diese Instanz. Damit des Funktionsaufrufs zu öffnen, müssen Sie eine <xref:System.Reflection.FieldInfo> Objekt, das darstellt `F` auf den konstruierten Typ – anders gesagt, ist vom Typ `U` anstatt Typ `T`. Zu diesem Zweck rufen Sie zuerst die <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode für die <xref:System.Reflection.Emit.TypeBuilder> -Objekt angeben der <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt, das darstellt `U` als Typargument. Rufen Sie anschließend die <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> bei dem Rückgabewert der Methode der <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode als Parameter `type` und <xref:System.Reflection.Emit.FieldBuilder> Objekt, das darstellt `F` als Parameter `field`. Der Rückgabewert ist der <xref:System.Reflection.FieldInfo> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt. Im Codebeispiel wird dieses Szenario veranschaulicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens Beispiel, das einen Typparameter, der mit dem Namen `T`. Die Klasse verfügt über ein Feld mit dem Namen `Field`, des Typs `T`, und eine generische Methode mit dem Namen `GM` des eigenen Typparameters mit dem Namen `U`. Methode `GM` erstellt eine Instanz des `Sample`, Ersetzen des eigenen Typparameters `U` für den Typparameter von `Sample`, und speichert dessen Eingabeparameter in `Field`. Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) und vergleichen Sie sie mit der Code ausgegeben, die von Klasse `Example`.  
  
 Der Code in der Klasse `Example` veranschaulicht die Verwendung von der <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Methode, um generische Code ausgeben. Die `Main` -Methode der Klasse `Example` erstellt eine dynamische Assembly mit einer Klasse mit dem Namen `Sample`, und verwendet die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen `T`. Einen Standardkonstruktor und ein Feld mit dem Namen `Field`, des Typs `T`, Klasse hinzugefügt werden `Sample`. Eine Methode `GM` hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Methode. Der Typparameter der `GM` lautet `U`. Nach dem Definieren des Typparameters die Signatur der `GM` hinzugefügt wird, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> Methode. Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind `null` außer `parameterTypes`; `parameterTypes` legt den Typ der einzige Parameter von der Methode, um `U`, generischen Typparameter der Methode. Der Text der Methode erstellt eine Instanz des konstruierten Typs `Sample<U>` (`Sample(Of U)` in Visual Basic), weist der Methodenparameter, damit `Field`, und gibt dann den Wert des `Field`. Die <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Methode dient zum Erstellen einer <xref:System.Reflection.FieldInfo> , die das Feld des konstruierten generischen Typs darstellt `Sample<U>` in der <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> und <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> Anweisungen.  
  
 Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten `Main`. Im Text des `Main`, die statische `GM` Methode wird aufgerufen, für den konstruierten generischen Typ `Sample<int>` (`Sample(Of Integer)` in Visual Basic), mit dem Typ <xref:System.String> ersetzt `U`.  
  
 Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe. Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zum Vergleichen des ausgegebenen Codes durch den Code für die `Sample` -Klasse, die in das Codebeispiel selbst kompiliert wird.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> stellt keinen generischen Typ dar.  
  
 - oder -   
  
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="field" /> ist keine generische Typdefinition.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="field" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt die öffentlichen und nicht öffentlichen Felder zurück, die von diesem Typ deklariert werden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.FieldInfo" /> -Objekten deklariert oder geerbt wurden von diesem Typ die öffentlichen und nicht öffentlichen Felder darstellen. Wenn keine Felder vorhanden sind, wird ein leeres Array zurückgegeben, wie angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.  
  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" /> Objekten, die die Typargumente eines generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten. Die Elemente des Arrays stellen die Typargumente eines generischen Typs oder die Typparameter einer generischen Typdefinition dar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des zurückgegebenen Arrays sind in der Reihenfolge, in der sie in der Liste mit Typparametern für die generische Typdefinition angezeigt werden.  
  
 Ein <xref:System.Reflection.Emit.TypeBuilder> -Objekt eine generische Typdefinition darstellt, wenn die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> -Methode wurde verwendet, um generische Typparameter. Diese Methode ruft die <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekte, die die generischen Typparameter darstellen.  
  
 Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> Methode auf eine <xref:System.Reflection.Emit.TypeBuilder> Objekt, für das die <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> -Eigenschaft gibt `true`, die <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> Eigenschaft gibt die aktuelle Instanz zurück. Ein <xref:System.Reflection.Emit.TypeBuilder> , stellt einen generischen Typ ist immer eine generische Typdefinition.  
  
 Bei Verwendung der <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode zum Erstellen eines generischen Typs aus eine <xref:System.Reflection.Emit.TypeBuilder> -Objekt, das eine generische Typdefinition darstellt, mit der <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> Methode für den konstruierten Typ erhält wieder die <xref:System.Reflection.Emit.TypeBuilder> Objekt, das den generischen Typ darstellt Definition.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ ist nicht generisch. Das heißt, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> gibt <see langword="false" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Schnittstelle.</param>
        <param name="ignoreCase">Wenn <see langword="true" />, wird bei der Suche die Groß-/Kleinschreibung. Wenn <see langword="false" />, wird bei der Suche die Groß-/Kleinschreibung beachtet.</param>
        <summary>Gibt die von dieser Klasse (direkt oder indirekt) implementierte Schnittstelle mit dem vollqualifizierten Namen zurück, der dem angegebenen Namen der Schnittstelle entspricht.</summary>
        <returns>Gibt eine <see cref="T:System.Type" /> -Objekt, das die implementierte Schnittstelle darstellt. Gibt NULL zurück, wenn kein mit der Schnittstelle übereinstimmender Name gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Die <see cref="T:System.Type" /> der Schnittstelle, für die die Zuordnung abgerufen werden sollen.</param>
        <summary>Gibt eine Schnittstellenzuordnung für die angeforderte Schnittstelle zurück.</summary>
        <returns>Gibt die angeforderte Schnittstellenzuordnung zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array aller für diesen Typ und die zugehörigen Basistypen implementierten Schnittstellen zurück.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Type" /> Objekten, die die implementierten Schnittstellen darstellen. Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Members.</param>
        <param name="type">Der Typ des zurückzugebenden Members.</param>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" />, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt alle öffentlichen und nicht öffentlichen Member zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" /> Objekten, die die öffentlichen und nicht öffentlichen Member, die für diesen Typ definiert wird, wenn darstellen <paramref name="nonPublic" /> verwendet wird; andernfalls werden nur die öffentlichen Member zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" />, wie z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt alle Member für die öffentlichen und nicht öffentlichen Member zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" /> -Objekten deklariert oder geerbt wurden von diesem Typ, die die öffentlichen und nicht öffentlichen Member darstellt. Wenn keine übereinstimmenden Member vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">Der konstruierte generische Typ, dessen Methode zurückgegeben wird.</param>
        <param name="method">Eine Methode für die generische Typdefinition von <c>Typ</c>, der angibt, welche Methode der <c>Typ</c> zurückgegeben.</param>
        <summary>Gibt die Methode des angegebenen konstruierten generischen Typs zurück, der der angegebenen Methode der generischen Typdefinition entspricht.</summary>
        <returns>Ein <see cref="T:System.Reflection.MethodInfo" />-Objekt, das die Methode von <paramref name="type" /> entsprechend <paramref name="method" /> darstellt und eine Methode angibt, die zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Methode bietet eine Möglichkeit zum Abrufen einer <xref:System.Reflection.MethodInfo> Objekt, das eine Methode einen konstruierten generischen Typ darstellt, dessen Definition eines generischen Typs wird durch, eine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 Nehmen wir beispielsweise an, Sie haben eine <xref:System.Reflection.Emit.TypeBuilder> -Objekt, das den Typ darstellt `G<T>` in C#-Syntax (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) und ein <xref:System.Reflection.Emit.MethodBuilder> Objekt zur Darstellung einer Methode `T M()` in C#-Syntax (`Function M() As T`in Visual Basic `T M()` in C++), wird durch definiert `G<T>`. Nehmen wir an, die `G<T>` verfügt über eine generische Methode mit Typparameter `U` , erstellt eine Instanz des konstruierten Typs `G<U>` und Methodenaufrufe `M` für diese Instanz. Des Funktionsaufrufs zu öffnen, müssen Sie eine <xref:System.Reflection.MethodInfo> Objekt, das darstellt `M` auf den konstruierten Typ – also Typ zurückgibt `U` anstatt Typ `T`. Zu diesem Zweck rufen Sie zuerst die <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode für die <xref:System.Reflection.Emit.TypeBuilder> -Objekt angeben der <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt, das darstellt `U` als Typargument. Rufen Sie anschließend die <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> bei dem Rückgabewert der Methode der <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode als Parameter `type` und <xref:System.Reflection.Emit.MethodBuilder> Objekt, das darstellt `T M()` als Parameter `method`. Der Rückgabewert ist der <xref:System.Reflection.MethodInfo> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt. Im Codebeispiel wird eines ähnliches Szenarios.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens `Sample` , die über einen Typparameter, der mit dem Namen verfügt `T`. Die Klasse verfügt über ein Feld mit dem Namen `Field`, des Typs `T`, und eine generische Methode mit dem Namen `GM` des eigenen Typparameters mit dem Namen `U`. Methode `GM` erstellt eine Instanz des `Sample`, Ersetzen des eigenen Typparameters `U` für den Typparameter von `Sample`, und speichert dessen Eingabeparameter in `Field`. Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) und vergleichen Sie sie mit der Code ausgegeben, die von Klasse `Example`.  
  
 Der Code in der Klasse `Example` veranschaulicht die Verwendung von der <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Methode, um generische Code ausgeben. Die `Main` -Methode der Klasse `Example` erstellt eine dynamische Assembly mit einer Klasse mit dem Namen `Sample` und verwendet die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen `T`. Einen Standardkonstruktor und ein Feld mit dem Namen `Field`, des Typs `T`, Klasse hinzugefügt werden `Sample`. Eine Methode `GM` hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Methode. Der Typparameter der `GM` lautet `U`. Nach dem Definieren des Typparameters die Signatur der `GM` hinzugefügt wird, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> Methode. Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind `null` außer `parameterTypes`; `parameterTypes` legt den Typ der einzige Parameter von der Methode, um `U`, generischen Typparameter der Methode. Der Text der Methode erstellt eine Instanz des konstruierten Typs `Sample<U>` (`Sample(Of U)` in Visual Basic), weist der Methodenparameter, damit `Field`, und gibt dann den Wert des `Field`. Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten `Main`. Im Text des `Main`, die statische `GM` Methode wird aufgerufen, für den konstruierten generischen Typ `Sample<int>` (`Sample(Of Integer)` in Visual Basic), mit dem Typ <xref:System.String> ersetzt `U`. Die <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Methode dient zum Erstellen einer <xref:System.Reflection.MethodInfo> für die statische `GM` Methode des konstruierten generischen Typs `Sample<U>`, und die <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> Methode dient dann zum Erstellen einer <xref:System.Reflection.MethodInfo> können, die in einem Methodenaufruf ausgegeben.  
  
 Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe. Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zum Vergleichen des ausgegebenen Codes durch den Code für die `Sample` -Klasse, die in das Codebeispiel selbst kompiliert wird.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist eine generische Methode, aber keine generische Methodendefinition.  
  
 - oder -   
  
 <paramref name="type" /> stellt keinen generischen Typ dar.  
  
 - oder -   
  
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="method" /> ist keine generische Typdefinition.  
  
 - oder -   
  
 Der deklarierende Typ von <paramref name="method" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt alle öffentlichen und nicht öffentlichen Methoden zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.MethodInfo" /> Objekte, die die öffentlichen und nicht öffentlichen Methoden, die für diesen Typ definiert wird, wenn <paramref name="nonPublic" /> verwendet wird; andernfalls werden nur die öffentlichen Methoden zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Die <see cref="T:System.String" /> , die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
 - oder -   
  
 Null, um eine Suche nach öffentlichen Methoden mit Beachtung der Groß-/Kleinschreibung durchzuführen.</param>
        <summary>Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert werden.</summary>
        <returns>Ein <see cref="T:System.Type" /> Objekt, das den geschachtelten Typ, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls darstellt <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 Wenn dieser Typ abgeschlossen ist, z. B. wenn `CreateType` für diesen Typ aufgerufen wurde, aber es sind geschachtelte Typen, die nicht abgeschlossen ist, klicken Sie dann `GetNestedTypes` für die nur die geschachtelten Typen zurück `CreateType` aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" />, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert oder geerbt werden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" /> Objekte in der aktuellen geschachtelten alle Typen darstellen <see cref="T:System.Type" /> , die den angegebenen bindungseinschränkungen entsprechen.  
  
 Ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine Typen, in der aktuellen geschachtelt sind <see cref="T:System.Type" />, oder wenn keiner der geschachtelten Typen die bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 Wenn dieser Typ abgeschlossen ist, z. B. wenn `CreateType` für diesen Typ aufgerufen wurde, aber es sind geschachtelte Typen, die nicht abgeschlossen ist, klicken Sie dann `GetNestedTypes` für die nur die geschachtelten Typen zurück `CreateType` aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Dieses Aufrufattribut. Diese Angabe muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />und so weiter.</param>
        <summary>Gibt alle öffentlichen und nicht öffentlichen Eigenschaften zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
        <returns>Gibt ein Array von <see langword="PropertyInfo" /> Objekten, die die öffentlichen und nicht öffentlichen Eigenschaften, die für diesen Typ definiert wird, wenn darstellen <paramref name="nonPublic" /> verwendet wird; andernfalls werden nur die öffentlichen Eigenschaften zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird für unvollständige Typen nicht implementiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die GUID dieses Typs ab.</summary>
        <value>Schreibgeschützt. Ruft die GUID dieses Typs ab.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des aufzurufenden Members. Dies kann ein Konstruktor, eine Methode, eine Eigenschaft oder ein Feld sein. Es muss ein geeignetes Aufrufattribut angegeben werden. Beachten Sie, dass es möglich ist, den Standardmember einer Klasse aufzurufen, indem Sie eine leere Zeichenfolge als Name des Members übergeben.</param>
        <param name="invokeAttr">Das Attribut für den Aufruf. Diese Angabe muss ein Bitflag aus <see langword="BindingFlags" />.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn der Binder ist <see langword="null" />, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll. Wenn der Member statisch ist, wird dieser Parameter ignoriert.</param>
        <param name="args">Eine Argumentliste. Dies ist ein Array von Objekten, das die Anzahl, Reihenfolge und den Typ der Parameter des aufzurufenden Members enthält. Wenn keine Parameter vorhanden sind, muss dies gleich NULL sein.</param>
        <param name="modifiers">Ein Array derselben Länge wie <c>Args</c> mit Elementen, die die Attribute, die den Argumenten des aufzurufenden Members zugeordnet darstellen. Ein Parameter verfügt über Attribute, die ihm in den Metadaten zugeordnet werden. Sie werden von verschiedenen Interoperabilitätsdiensten verwendet. Weitere Informationen finden Sie in den Metadatenspezifikationen.</param>
        <param name="culture">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen. Wenn diese gleich null ist, wird die <see langword="CultureInfo" /> des aktuellen Threads verwendet wird. (Dies ist z. B. erforderlich, um eine Zeichenfolge, die 1000 darstellt, in einen Double-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
        <param name="namedParameters">Jeder Parameter in der <c>NamedParameters</c> Array Ruft den Wert in das entsprechende Element in der <c>Args</c> Array. Wenn die Länge des <c>Args</c> ist größer als die Länge des <c>NamedParameters</c>, die restlichen Argumentwerte in der Reihenfolge übergeben.</param>
        <summary>Ruft den angegebenen Member auf. Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</summary>
        <returns>Gibt den Rückgabewert des aufgerufenen Members zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode wird aufgerufen, wenn die Anzahl von Parametern in der Deklaration der Methode der Anzahl der Argumente in der angegebenen Argumentliste entspricht und der Typ jedes Arguments vom Binder in den Typ des Parameters konvertiert werden kann.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf den Typ der Bindung angeforderte (BindingFlags.InvokeMethod, BindingFlags.GetProperties und So weiter.) gefunden werden. Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert. Wenn die Methode ausgewählt wurde, wird sie aufgerufen werden. Eingabehilfen ist an diesem Punkt aktiviert. Die Suche kann steuern, welchen Satz von Methoden werden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet durchsucht. Die `IBinder.BindToMethod` Methode ist verantwortlich für die Auswahl der Methode, die aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
> [!NOTE]
>  Zugriffseinschränkungen für vollständig vertrauenswürdige Code ignoriert. D. h. private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden können, und Sie aufgerufen wird, mithilfe von Reflektion im Code vollständig vertrauenswürdig ist.  
  
 Diese Methode wird zurzeit nicht unterstützt. Sie können den Typ mithilfe abrufen <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Das zu überprüfende Objekt.</param>
        <summary>Ruft einen Wert ab, der angibt, ob ein angegebenes <see cref="T:System.Reflection.TypeInfo" />-Objekt diesem Objekt zugewiesen werden kann.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="typeInfo" /> diesem Objekt zugewiesen werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Das zu überprüfende Objekt.</param>
        <summary>Ruft einen Wert, der angibt, ob ein angegebener <see cref="T:System.Type" /> können zu diesem Objekt zugewiesen werden.</summary>
        <returns>
          <see langword="true" />Wenn die <paramref name="c" /> Parameter und der aktuelle Typ denselben Typ, darstellen, oder wenn der aktuelle Typ, in der Vererbungshierarchie des ist <paramref name="c" />, oder wenn der aktuelle Typ eine Schnittstelle ist, die <paramref name="c" /> unterstützt. <see langword="false" />Wenn keine dieser Bedingungen gültig sind, oder wenn <paramref name="c" /> ist <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob der aktuelle dynamische Typ erstellt wurde.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode aufgerufen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach der <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode aufgerufen wurde, den Typ von dargestellt die <xref:System.Reflection.Emit.TypeBuilder> -Objekts abgeschlossen ist. Ausnahmen werden ausgelöst, auf alle weiteren Versuche, Mitglieder hinzufügen oder ändern andere Eigenschaften des Typs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des zu suchenden Attributs. Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</param>
        <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
        <summary>Bestimmt, ob ein benutzerdefiniertes Attribut auf den aktuellen Typ angewendet wird.</summary>
        <returns>
          <see langword="true" />Wenn eine oder mehrere Instanzen des <paramref name="attributeType" />, oder ein Attribut abgeleitete <paramref name="attributeType" />, für diesen Typ definiert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für unvollständige generische Typparameter nicht unterstützt. Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe <see cref="M:System.Type.GetType" /> , und rufen Sie <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> für das zurückgegebene <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ist nicht definiert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typparameter ist.</summary>
        <value>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt einen generischen Typparameter darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <xref:System.Reflection.Emit.GenericTypeParameterBuilder> Objekt und keine <xref:System.Reflection.Emit.TypeBuilder> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</summary>
        <value>
          <see langword="true" />, wenn der durch das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt dargestellte Typ generisch ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Reflection.Emit.TypeBuilder> -Objekt eine generische Typdefinition darstellt, wenn die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> -Methode wurde verwendet, um generische Typparameter. Eine Instanz von der <xref:System.Reflection.Emit.TypeBuilder> Klasse, die generisch ist, ist immer eine generische Typdefinition.  
  
 Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Reflection.Emit.TypeBuilder> -Objekt eine generische Typdefinition darstellt, wenn die <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> -Methode wurde verwendet, um generische Typparameter. Eine Instanz von der <xref:System.Reflection.Emit.TypeBuilder> Klasse, die generisch ist, ist immer eine generische Typdefinition.  
  
 Ein <xref:System.Reflection.Emit.TypeBuilder> kann verwendet werden, um generische Typdefinitionen erstellt, aber keine generische Typen konstruiert. Um einen konstruierten generischen Typ zu erhalten, rufen die <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode auf eine <xref:System.Reflection.Emit.TypeBuilder> , die Definition eines generischen Typs darstellt.  
  
 Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value>
          <see langword="true" />Wenn der aktuelle Typ sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich ist. <see langword="false" /> wenn er sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt. In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicherheitskritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly. Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.  
  
 Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt. Sie können diese Standardeinstellung überschreiben, indem Sie mit der <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, oder <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> methodenüberladung und Sicherheitsattribute angeben. Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben. Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.  
  
> [!NOTE]
>  Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt. Keine Attribute werden auf die dynamische Assembly angewendet werden. Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.  
  
 Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht erstellt wurde, durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsgeschützt ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</summary>
        <value>
          <see langword="true" />Wenn der aktuelle Typ sicherheitsrelevant und sicher zugänglich ist. <see langword="false" /> , wenn er sicherheitstransparent oder sicherheitsrelevant ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt. In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicherheitskritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly. Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.  
  
 Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt. Sie können diese Standardeinstellung überschreiben, indem Sie mit der <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, oder <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> methodenüberladung und Sicherheitsattribute angeben. Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben. Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.  
  
> [!NOTE]
>  Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt. Keine Attribute werden auf die dynamische Assembly angewendet werden. Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.  
  
 Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht erstellt wurde, durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ transparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value>
          <see langword="true" />Wenn der Typ sicherheitstransparent ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt. In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicherheitskritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly. Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.  
  
 Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt. Sie können diese Standardeinstellung überschreiben, indem Sie mit der <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, oder <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> methodenüberladung und Sicherheitsattribute angeben. Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben. Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.  
  
> [!NOTE]
>  Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt. Keine Attribute werden auf die dynamische Assembly angewendet werden. Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.  
  
 Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht erstellt wurde, durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Ein <see cref="T:System.Type" /> also überprüft werden soll.</param>
        <summary>Bestimmt, ob dieser Typ von einem angegebenen Typ abgeleitet ist.</summary>
        <returns>Schreibgeschützt. Gibt <see langword="true" /> Wenn dieser Typ dem Typ entspricht <paramref name="c" />, oder ein Untertyp des Typs <paramref name="c" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen eindimensionalen Arraytyp, dessen Elementtyp dem aktuellen Typ entspricht, mit einer unteren Grenze von 0 (null) darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Methode bietet eine Möglichkeit, einen Arraytyp mit jedem beliebigen Elementtyp, einschließlich generischer Typen zu generieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen `Sample`, und eine abstrakte Methode, die mit dem Namen `TestMethod`. `TestMethod`akzeptiert eine `ref` Parameter (`ByRef` in Visual Basic) vom Typ `Sample`, ein Zeiger auf den Typ `Sample`, und ein Array vom Typ `Sample`. Es gibt ein zweidimensionales Array vom Typ `Sample`. Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Die Anzahl von Dimensionen für das Array.</param>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array des aktuellen Typs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Methode bietet eine Möglichkeit, einen Arraytyp mit jedem beliebigen Elementtyp, einschließlich generischer Typen zu generieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen `Sample`, und eine abstrakte Methode, die mit dem Namen `TestMethod`. `TestMethod`akzeptiert eine `ref` Parameter (`ByRef` in Visual Basic) vom Typ `Sample`, ein Zeiger auf den Typ `Sample`, und ein Array vom Typ `Sample`. Es gibt ein zweidimensionales Array vom Typ `Sample`. Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> ist keine gültige Arraydimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" /> in Visual Basic) den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" /> in Visual Basic) den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> Methode bietet eine Möglichkeit zum Generieren von `ref` Typen (`ByRef` in Visual Basic) für Parameter aufgeführt sind.  
  
> [!NOTE]
>  Mithilfe von Microsoft intermediate Language (MSIL)-Syntax, wenn die aktuelle <xref:System.Reflection.Emit.TypeBuilder> darstellt `MyType`, und klicken Sie dann der Typ, der von dieser Methode zurückgegebene wäre `MyType&`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen `Sample`, und eine abstrakte Methode, die mit dem Namen `TestMethod`. `TestMethod`akzeptiert eine `ref` Parameter (`ByRef` in Visual Basic) vom Typ `Sample`, ein Zeiger auf den Typ `Sample`, und ein Array vom Typ `Sample`. Es gibt ein zweidimensionales Array vom Typ `Sample`. Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Ein Array von Typen, die die Typparameter der aktuellen generischen Typdefinition ersetzen sollen.</param>
        <summary>Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt den resultierenden konstruierten Typ zurück.</summary>
        <returns>Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn Sie den ausgegebene Code aus der Definition des aktuellen generischen Typs erstellter Typ erforderlich ist. Es ist nicht notwendig, rufen Sie die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> Methode vor dem Aufruf der <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> Methode auf eine <xref:System.Reflection.Emit.TypeBuilder> , die Definition eines generischen Typs darstellt. Wenn die aktuelle <xref:System.Reflection.Emit.TypeBuilder> stellt nicht die Definition eines generischen Typs dar. ein <xref:System.InvalidOperationException> ausgelöst wird.  
  
 Das Objekt, das durch diese Methode funktioniert als Platzhalter für einen konstruierten generischen Typ im ausgegebenen Code zurückgegeben. Dies ist eine Instanz einer Klasse abgeleitet <xref:System.Type> , dessen Funktionen beschränkt. Insbesondere:  
  
-   Um die Methoden, Felder und Konstruktoren, die für diese generische Typen konstruiert abzurufen, verwenden die <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, und <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> methodenüberladungen.  
  
-   Zwei Instanzen, die den gleichen konstruierten Typ darstellen vergleichen nicht als gleich. Im folgenden Code beispielsweise `t1.Equals(t2)` gibt `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keine Definition eines generischen Typs dar. Das heißt, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Type.Module" />-Eigenschaft eines beliebigen Elements von <paramref name="typeArguments" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see cref="P:System.Reflection.Module.Assembly" />-Eigenschaft des Moduls eines beliebigen Elements von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.  
  
> [!NOTE]
>  Mithilfe von Microsoft intermediate Language (MSIL)-Syntax, wenn die aktuelle <xref:System.Reflection.Emit.TypeBuilder> darstellt `MyType`, und klicken Sie dann der Typ, der von dieser Methode zurückgegebene wäre `MyType*`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen `Sample`, und eine abstrakte Methode, die mit dem Namen `TestMethod`. `TestMethod`akzeptiert eine `ref` Parameter (`ByRef` in Visual Basic) vom Typ `Sample`, ein Zeiger auf den Typ `Sample`, und ein Array vom Typ `Sample`. Es gibt ein zweidimensionales Array vom Typ `Sample`. Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das dynamische Modul ab, das diese Typdefinition enthält.</summary>
        <value>Schreibgeschützt. Ruft das dynamische Modul ab, das diese Typdefinition enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen dieses Typs ab.</summary>
        <value>Schreibgeschützt. Ruft den <see cref="T:System.String" />-Namen dieses Typs ab.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace ab, in dem dieser <see langword="TypeBuilder" /> definiert ist.</summary>
        <value>Schreibgeschützt. Ruft den Namespace ab, in dem dieser <see langword="TypeBuilder" /> definiert ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Komprimierungsgröße dieses Typs ab.</summary>
        <value>Schreibgeschützt. Ruft die Komprimierungsgröße dieses Typs ab.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Typ zurück, mit dem dieser Typ abgerufen wurde.</summary>
        <value>Schreibgeschützt. Der Typ, mit dem dieser Typ abgerufen wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
        <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
        <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
        <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Formatieren `binaryAttribute`, finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">Der neue Basistyp.</param>
        <summary>Legt den Basistyp des Typs fest, der sich derzeit in Bearbeitung befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `parent` ist `null`, <xref:System.Object> als Basistyp verwendet wird.  
  
 In der .NET Framework-Versionen 1.0 und 1.1, wird keine Ausnahme ausgelöst, wenn `parent` ein Schnittstellentyp ist jedoch ein <xref:System.TypeLoadException> wird ausgelöst, wenn die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> -Methode aufgerufen wird.  
  
 Die <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> Methode überprüft nicht für die meisten Ungültiger übergeordneter Typen. Angenommen, sie lehnt keinen übergeordneter Typ, der über keinen Standardkonstruktor verfügt, wenn der aktuelle Typ verfügt über einen Standardkonstruktor und nicht versiegelte Typen lehnt nicht lehnt die <xref:System.Delegate> Typ. In all diesen Fällen-Ausnahmen werden ausgelöst, durch die <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
 - oder -   
  
 <paramref name="parent" /> ist <see langword="null" />, und die aktuelle Instanz stellt eine Schnittstelle dar, deren Attribute <see cref="F:System.Reflection.TypeAttributes.Abstract" /> nicht einbeziehen.  
  
 - oder -   
  
 Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> ist eine Schnittstelle. Diese Ausnahmebedingung ist neu in .NET Framework, Version 2.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtgröße eines Typs ab.</summary>
        <value>Schreibgeschützt. Ruft die Gesamtgröße dieses Typs ab.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Namen des Typs ohne den Namespace zurück.</summary>
        <returns>Schreibgeschützt. Der Name des Typs ohne den Namespace.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird in dynamischen Modulen nicht unterstützt.</summary>
        <value>Schreibgeschützt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Typ mithilfe <xref:System.Type.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> und mithilfe der Reflektion für den abgerufenen Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wird in dynamischen Modulen nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das Typtoken dieses Typs zurück.</summary>
        <value>Schreibgeschützt. Gibt die <see langword="TypeToken" /> dieses Typs.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den zugrunde liegenden Systemtyp für diesen <see langword="TypeBuilder" />.</summary>
        <value>Schreibgeschützt. Gibt den zugrunde liegenden Systemtyp zurück.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Dieser Typ ist eine Enumeration, aber es ist kein zugrunde liegender Systemtyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Stellt dar, dass die Gesamtgröße für den Typ nicht angegeben ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
