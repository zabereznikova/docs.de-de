<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert, und ein Modul in eine dynamische Assembly darstellt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Abrufen einer Instanz des <xref:System.Reflection.Emit.ModuleBuilder>, verwenden Sie die <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `ModuleBuilder` um ein dynamisches Modul zu erstellen. Beachten Sie, dass der ModuleBuilder, durch den Aufruf erstellt wird <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> in <xref:System.Reflection.Emit.AssemblyBuilder>, anstatt über einen Konstruktor.  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dynamische Assembly, die diese Instanz definiert <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <value>Die dynamische Assembly, die das aktuelle dynamische Modul definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Assembly> Objekt, das zurückgegeben wird, ist die <xref:System.Reflection.Emit.AssemblyBuilder> , die diese Instanz definiert <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die globale Funktionsdefinitionen und globalen Daten für diese dynamisches Modul.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte aufgerufen werden, wenn der Benutzer die globalen Funktionen innerhalb dieses dynamische Modul definieren. Nach dem Aufrufen dieser Funktion werden keine weiteren neuen globalen Funktionen oder neuen globalen Daten zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von `CreateGlobalFunctions` zum Erstellen einer globalen statischen Methode aus einer <xref:System.Reflection.Emit.MethodBuilder> mit implementiert <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde bereits aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">Die URL für das Dokument.</param>
        <param name="language">Die GUID, die Sprache des Dokuments identifiziert. Dieser Wert kann <see cref="F:System.Guid.Empty" /> sein.</param>
        <param name="languageVendor">Die GUID, die den Compilerhersteller des Dokuments identifiziert. Dieser Wert kann <see cref="F:System.Guid.Empty" /> sein.</param>
        <param name="documentType">Die GUID, die den Dokumenttyp bezeichnet. Dieser Wert kann <see cref="F:System.Guid.Empty" /> sein.</param>
        <summary>Definiert ein Dokument für die Quelle an.</summary>
        <returns>Das definierte Dokument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Frühere Versionen von .NET Framework lösen <xref:System.ArgumentException> anstelle von <xref:System.ArgumentNullException> Wenn `url` ist `null`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineDocument` ein dynamisches Modul ein externes Symbol-Dokument (in diesem Fall eine unformatierte IL-Datei) an.  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> ist <see langword="null" />. Dies ist eine Änderung gegenüber früheren Versionen von .NET Framework.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode ist für ein dynamisches Modul aufgerufen, der kein Debugmodul ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Enumerationstyps. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="visibility">Die Typattribute für die Enumeration. Die Attribute sind definiert, die von Bits <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
        <param name="underlyingType">Der zugrunde liegende Typ der Enumeration. Dies muss ein integrierter Ganzzahltyp sein.</param>
        <summary>Definiert einen Enumerationstyp, der einen Werttyp mit einem einzelnen nicht-statisches Feld namens <paramref name="value__" /> des angegebenen Typs.</summary>
        <returns>Die definierte Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die definierte Enumeration ist eine abgeleitete Klasse von <xref:System.Enum>. Die `value__` Feld <xref:System.Reflection.FieldAttributes.Private> und <xref:System.Reflection.FieldAttributes.SpecialName> Attribute festgelegt.  
  
 Weitere Informationen zu den integrierten ganzzahligen Typen, die als zugrunde liegende Typen von Enumerationen angegeben werden können, finden Sie unter [Class Library Overview](~/docs/standard/class-library-overview.md).  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0 und 1.1, ist es erforderlich, Enumerationen, die mit definieren <xref:System.Reflection.Emit.TypeBuilder> da <xref:System.Reflection.Emit.EnumBuilder> ausgibt, deren Elemente vom Typ sind, Enumerationen <xref:System.Int32> anstelle des Enumerationstyps. In .NET Framework, Version 2.0 <xref:System.Reflection.Emit.EnumBuilder> ausgibt, Enumerationen, deren Elemente über den richtigen Typ.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von `DefineEnum` eine Enumerationsklasse in einem dynamischen Modul implementiert. Im Beispiel definiert eine Enumeration, die mit dem Namen `Elevation` , besitzt einen zugrunde liegenden Typ <xref:System.Int32>, und erstellt zwei Elemente: `Low`, mit dem Wert 0 (null) und `High`, mit dem Wert 1. Nachdem der Typ erstellt wurde, wird die Assembly gespeichert, mit dem Namen `TempAssembly.dll`. Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) untersuchen den Inhalt dieser Assembly.  
  
> [!NOTE]
>  Vor .NET Framework, Version 2.0 wird in diesem Codebeispiel wird eine ordnungsgemäße Enumeration kein erzeugt.  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Andere Attribute als Sichtbarkeitsattribute werden bereitgestellt.  
  
 - oder -   
  
 Eine Enumeration mit dem angegebenen Namen ist in der übergeordneten Assembly des Moduls vorhanden.  
  
 - oder -   
  
 Die Sichtbarkeitsattribute entsprechen nicht den Bereich der Enumeration. Z. B. <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> für angegeben <paramref name="visibility" />, aber die Enumeration ist keinen geschachtelten Typ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode. <c>Attribute</c> umfasst <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Definiert eine globale Methode mit dem angegebenen Namen, Attribute, Rückgabetyp und die Parametertypen.</summary>
        <returns>Die definierte globale Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die globale Methode, die diese Methode definiert wird, kann erst Sie rufen <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von `DefineGlobalMethod` zum Erstellen einer typunabhängig-Methode, die mit dem aktuellen gebunden <xref:System.Reflection.Emit.ModuleBuilder>. Nach dem Erstellen der globalen Methode <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> muss aufgerufen werden, um sie abzuschließen.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. D. h. <paramref name="attributes" /> enthält keine <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 - oder -   
  
 Die Länge des <paramref name="name" /> 0 (null)  
  
 - oder -   
  
 Ein Element in der <see cref="T:System.Type" /> Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attributes">Die Attribute der Methode. <c>Attribute</c> umfasst <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Definiert eine globale Methode mit dem angegebenen Namen, Attribute, Aufrufkonvention, Rückgabetyp und Parametertypen.</summary>
        <returns>Die definierte globale Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können keine globale Methode, die diese Methode definiert wird, bis Sie rufen <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `DefineGlobalMethod` zum Erstellen einer typunabhängig-Methode, die mit dem aktuellen gebunden <xref:System.Reflection.Emit.ModuleBuilder>. Nach dem Erstellen der globalen Methode <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> muss aufgerufen werden, um sie abzuschließen.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. D. h. <paramref name="attributes" /> enthält keine <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 - oder -   
  
 Ein Element in der <see cref="T:System.Type" /> Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Methode. <c>Namen</c> darf keine eingebetteten Null-Zeichen enthalten.</param>
        <param name="attributes">Die Attribute der Methode. <c>Attribute</c> umfasst <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="requiredReturnTypeCustomModifiers">Ein Array von Typen, die erforderlichen benutzerdefinierten Modifizierer für den Rückgabetyp darstellen, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" /> oder <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="optionalReturnTypeCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer für den Rückgabetyp, wie z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" /> oder <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="requiredParameterTypeCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter der globalen Methode dar. Wenn ein bestimmtes Argument keine erforderlichen benutzerdefinierten Modifizierer hat, geben <see langword="null" /> anstelle eines Arrays von Typen. Wenn die globale Methode keine Argumente besitzt oder keines der Argumente die erforderliche benutzerdefinierte Modifizierer hat, geben <see langword="null" /> anstelle eines Arrays von Arrays.</param>
        <param name="optionalParameterTypeCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar. Wenn ein bestimmtes Argument keine optionalen benutzerdefinierten Modifizierer hat, geben <see langword="null" /> anstelle eines Arrays von Typen. Wenn die globale Methode keine Argumente besitzt oder keines der Argumente optionale benutzerdefinierte Modifizierer hat, geben <see langword="null" /> anstelle eines Arrays von Arrays.</param>
        <summary>Definiert eine globale Methode mit dem angegebenen Namen, Attribute, Aufrufkonvention, Rückgabetyp, benutzerdefinierten Modifizierer für den Rückgabetyp, die Parametertypen und die benutzerdefinierten Modifizierer für die Parametertypen.</summary>
        <returns>Die definierte globale Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.  
  
 Sie können keine globale Methode, die diese Methode definiert wird, bis Sie rufen <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. D. h. <paramref name="attributes" /> enthält keine <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 - oder -   
  
 Ein Element in der <see cref="T:System.Type" /> Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> -Methode zuvor aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="data">Binary large Object (BLOB) der Daten.</param>
        <param name="attributes">Die Attribute für das Feld. Die Standardeinstellung ist <see langword="Static" />.</param>
        <summary>Definiert ein initialisierte Datenfeld im Abschnitt ".sdata" der portablen ausführbaren Datei (PE).</summary>
        <returns>Ein Feld zum Verweisen auf die Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static>automatisch `attributes`.  
  
 Die von dieser Methode definierten Daten werden erst erstellt, wenn die <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> -Methode aufgerufen wird.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> Methode, um eine initialisierte Datenfeld im Definieren der `.sdata` -Abschnitts der Datei (portable Executable)-Datei.  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 Die Größe des <paramref name="data" /> ist kleiner als oder gleich 0 (null) oder größer als oder gleich 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="data" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name für die Ressource.</param>
        <param name="stream">Ein Datenstrom, der die Bytes für die Ressource enthält.</param>
        <param name="attribute">Ein Enumerationswert, der angibt, ob die Ressource öffentlich oder privat ist.</param>
        <summary>Definiert ein binary large Object (BLOB), die eine Manifestressource in die dynamische Assembly eingebettet werden darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourcen, die im Assemblymanifest aufgezeichnet werden, werden die verwalteten Ressourcen oder Manifestressourcen-BLOBs können, und jedes dieser kann in der Assembly enthalten sein, indem Sie eine Verknüpfung oder durch das Einbetten von. Für dynamische Assemblys werden alle vier Szenarien unterstützt.  
  
-   Diese Methode ermöglicht Ihnen, eine Manifestressource BLOB mit einer dynamischen Assembly einzubetten.  
  
-   Zum Einbetten einer verwalteten Ressource in das Manifestmodul einer dynamischen Assembly oder in einer Satellitenmodul verwenden die <xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType> Methode zum Abrufen einer Ressourcenwriters und zum Verwenden der <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> Methode, um die Ressource hinzuzufügen.  
  
-   Um eine verwaltete Ressource in eine dynamische Assembly zu verknüpfen, verwenden die <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType> Methode zum Abrufen einer Ressourcenwriters und zum Verwenden der <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> Methode, um die verknüpfte Ressource hinzuzufügen.  
  
-   Um einer Manifestressource BLOB mit einer dynamischen Assembly zu verknüpfen, verwenden die <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType> Methode, um die verknüpfte Ressource hinzuzufügen.  
  
 Darüber hinaus kann eine einzelne Win32-Ressource an eine Assembly angefügt werden, mithilfe der <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> Methode oder die <xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> Methode. Diese Ressource wird im Assemblymanifest nicht angezeigt.  
  
   
  
## Examples  
 Im folgende Beispiel wird generiert und speichert eine dynamische Assembly mit dem Namen `EmittedManifestResourceAssembly.exe`, die ein eingebettetes enthält nicht verwaltete Ressource. Das Beispiel erstellt die Assembly, die aus einem Modul besteht, und öffnet einen arbeitsspeicherdatenstrom, die nicht verwaltete Ressource enthalten. Der Code ruft dann die <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> Methode, um die Ressource zu definieren.  
  
> [!NOTE]
>  Sie können eine beliebige Art von Datenstrom für die Ressource verwenden. Beispielsweise können Sie die nicht verwalteten Binärdaten aus einer Datei lesen.  
  
 Im Beispiel wird einen Typ definiert, in das dynamische Modul mit einer `Main` -Methode, und die MSIL für den Methodentext generiert. Nach dem Text für die `Main` Methode generiert wurde, und der Typ erstellt wurde, schreibt das Codebeispiel 5 Bytes in den Stream, der die Manifestressource zugeordnet. Wenn die Assembly gespeichert wird, wird die Ressource an sie angefügt.  
  
 Nach dem Ausführen des Beispiels können Sie die ausgegebene Assembly ausführen. Der Code in der ausgegebenen Assembly `Main` Methode liest die eingebettete Manifestressource und gibt die Bytewerte in die Konsole. Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) die Informationen im Assemblymanifest anzeigen.  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist eine Zeichenfolge mit der Länge 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die dynamische Assembly, die das aktuelle Modul enthält ist vorübergehend; d. h. kein Dateiname angegeben wurde beim <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der <see langword="PInvoke" />-Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
        <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
        <summary>Definiert eine <see langword="PInvoke" /> Methode mit dem angegebenen Namen, den Namen der DLL, in dem die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Typen der Parameter der Methode und die <see langword="PInvoke" />Flags.</summary>
        <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige DLL-Importattribute können nicht (siehe die Beschreibung des System.Runtime.InteropServices.DllImportAttribute) als Argumente für diese Methode angegeben werden. Solche Attribute sollte festgelegt werden, durch das ein benutzerdefiniertes Attribut für die Methode ausgeben. Z. B. import die DLL-Attribut `PreserveSig` wird durch das Ausgeben eines benutzerdefinierten Attributs festgelegt.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `DefinePInvokeMethod` Methode zum Erstellen einer <xref:System.Reflection.Emit.MethodBuilder> für externe nicht verwaltete Methode `MessageBoxA`, in der Win32-API. Das Beispiel zeigt ein Meldungsfeld mit **wiederholen** und **"Abbrechen"** Schaltflächen und der Rückgabewert aus dem Meldungsfeld angezeigt.  
  
> [!IMPORTANT]
>  Um einen Rückgabewert ungleich 0 (null) zu erhalten, müssen Sie hinzufügen <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> die Methodenimplementierungsflags nach der Erstellung der <xref:System.Reflection.Emit.MethodBuilder>, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> und <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> Methoden.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch oder wenn der enthaltende Typ eine Schnittstelle ist.  
  
 - oder -   
  
 Die Methode ist abstrakt.  
  
 - oder -   
  
 Die Methode wurde bereits definiert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit erstellt wurde<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der <see langword="PInvoke" />-Methode. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
        <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
        <param name="attributes">Die Attribute der Methode.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode.</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
        <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
        <summary>Definiert eine <see langword="PInvoke" /> Methode mit dem angegebenen Namen, den Namen der DLL, in dem die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Typen der Parameter der Methode und die <see langword="PInvoke" />Flags.</summary>
        <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige DLL-Importattribute (siehe die Beschreibung der <xref:System.Runtime.InteropServices.DllImportAttribute>) kann nicht als Argumente für diese Methode angegeben werden. Solche Attribute sollte festgelegt werden, durch das ein benutzerdefiniertes Attribut für die Methode ausgeben. Z. B. import die DLL-Attribut `PreserveSig` wird durch das Ausgeben eines benutzerdefinierten Attributs festgelegt.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `DefinePInvokeMethod` Methode zum Erstellen einer <xref:System.Reflection.Emit.MethodBuilder> für externe nicht verwaltete Methode `MessageBoxA`, in der Win32-API. Das Beispiel zeigt ein Meldungsfeld mit **wiederholen** und **"Abbrechen"** Schaltflächen und der Rückgabewert aus dem Meldungsfeld angezeigt.  
  
> [!IMPORTANT]
>  Um einen Rückgabewert ungleich 0 (null) zu erhalten, müssen Sie hinzufügen <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> die Methodenimplementierungsflags nach der Erstellung der <xref:System.Reflection.Emit.MethodBuilder>, mithilfe der <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> und <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> Methoden.  
  
 Dieses Beispiel verwendet eine andere Überladung von der <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A> -Methode, aber das Verfahren ist identisch.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch, oder wenn der enthaltende Typ eine Schnittstelle ist, oder wenn die Methode zurück, wenn abstrakt ist wird die Methode wurde zuvor definiert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit erstellt wurde<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Ressource. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="description">Die Beschreibung der Ressource.</param>
        <summary>Definiert die benannte verwaltete eingebettete Ressource in diesem Modul gespeichert werden.</summary>
        <returns>Eine Ressourcenwriters für die definierte Ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufrufer muss nicht aufrufen, die `ResourceWriter.Generate()` und `ResourceWriter.Close()` Methoden, da diese Methoden, indem aufgerufen werden `ModuleBuilder.Save` beim Schreiben von der dynamischen Assembly auf den Datenträger.  
  
 Verwenden Sie diese Methode, um eine verwaltete Ressource einbetten. Um ein Blob Manifestressource einzubetten, verwenden die <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> Methode. Eine Übersicht über das Einbetten von und Verknüpfen von verwalteten Ressourcen und Manifestressourcen-Blobs finden Sie unter der <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> Methode.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von `DefineResource` hinzuzufügende eine externe Ressource mit dem aktuellen <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Modul ist vorübergehend.  
  
 - oder -   
  
 Die enthaltende Assembly ist nicht dauerhaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Ressource. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="description">Die Beschreibung der Ressource.</param>
        <param name="attribute">Die Ressourcenattribute.</param>
        <summary>Definiert die benannte verwaltete eingebettete Ressource mit den angegebenen Attributen, die in diesem Modul gespeichert werden soll.</summary>
        <returns>Eine Ressourcenwriters für die definierte Ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufrufer muss nicht aufrufen, die `ResourceWriter.Generate()` und `ResourceWriter.Close()` Methoden, da diese Methoden, indem aufgerufen werden `ModuleBuilder.Save` beim Schreiben von der dynamischen Assembly auf den Datenträger.  
  
 Verwenden Sie diese Methode, um eine verwaltete Ressource einbetten. Um ein Blob Manifestressource einzubetten, verwenden die <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> Methode. Eine Übersicht über das Einbetten von und Verknüpfen von verwalteten Ressourcen und Manifestressourcen-Blobs finden Sie unter der <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> Methode.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von DefineResource zum Hinzufügen einer externen Ressource mit dem aktuellen <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Modul ist vorübergehend.  
  
 - oder -   
  
 Die enthaltende Assembly ist nicht dauerhaft.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs, einschließlich des Namespaces. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> für einen privaten Typ mit dem angegebenen Namen in diesem Modul aus.</summary>
        <returns>Einen privaten Typ mit dem angegebenen Namen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des definierten Typs.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> erhält, den vollständigen Typnamen und die Attribute des Typs.</summary>
        <returns>Ein <see langword="TypeBuilder" /> mit allen erforderlichen Attribute erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Das Attribut mit dem Typ zugeordnet werden soll.</param>
        <param name="parent">Der Typ, den der definierte Typ erweitert.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> angegebenen Typnamens, dessen Attribute und der Typ, der definierte Typ erweitert.</summary>
        <returns>Ein <see langword="TypeBuilder" /> mit allen erforderlichen Attribute erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des definierten Typs.</param>
        <param name="parent">Der Typ, den der definierte Typ erweitert.</param>
        <param name="typesize">Die Gesamtgröße des Typs.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> erhält, den Typnamen, die Attribute der Typ, der definierte Typ erweitert, und die Gesamtgröße des Typs.</summary>
        <returns>Ein <see langword="TypeBuilder" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Es ist nicht zulässig, zwei Typen mit demselben Namen in zwei verschiedenen Modulen einer Assembly aufweisen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des definierten Typs.</param>
        <param name="parent">Der Typ, den der definierte Typ erweitert.</param>
        <param name="packsize">Die Komprimierungsgröße des Typs.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> erhält, den Typnamen, die Attribute der Typ, der definierte Typ erweitert, und die Komprimierungsgröße des Typs.</summary>
        <returns>Ein <see langword="TypeBuilder" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute mit dem Typ zugeordnet werden soll.</param>
        <param name="parent">Der Typ, den der definierte Typ erweitert.</param>
        <param name="interfaces">Die Liste der Schnittstellen, die den Typ implementiert.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> erhält, den Typnamen, Attribute, der Typ, der definierte Typ erweitert, und die Schnittstellen, die die definierte Typ implementiert.</summary>
        <returns>Ein <see langword="TypeBuilder" /> mit allen erforderlichen Attribute erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Pfad des Typs. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="attr">Die Attribute des definierten Typs.</param>
        <param name="parent">Der Typ, den der definierte Typ erweitert.</param>
        <param name="packingSize">Die Komprimierungsgröße des Typs.</param>
        <param name="typesize">Die Gesamtgröße des Typs.</param>
        <summary>Erstellt eine <see langword="TypeBuilder" /> erhält den Namen, Attribute, der Typ, der definierte Typ erweitert, die Komprimierungsgröße des definierten Typs und die Gesamtgröße des definierten Typs.</summary>
        <returns>Ein <see langword="TypeBuilder" /> mit allen erforderlichen Attribute erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typnamen müssen innerhalb einer Assembly eindeutig sein. Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.Emit.TypeBuilder> in der aktuellen dynamisches Modul mit `CreateType`, builds und schließt den Typ und speichert die Assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">In der übergeordneten Assembly des Moduls ist ein Typ mit dem angegebenen Namen vorhanden.  
  
 - oder -   
  
 Attribute des geschachtelten Typs werden für einen Typ festgelegt, die nicht geschachtelt ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <c>Namen</c> darf keine eingebetteten NULL-Werte enthalten.</param>
        <param name="size">Die Größe des Datenfelds.</param>
        <param name="attributes">Die Attribute für das Feld.</param>
        <summary>Definiert ein nicht initialisierte Datenfeld im Abschnitt ".sdata" der portablen ausführbaren Datei (PE).</summary>
        <returns>Ein Feld zum Verweisen auf die Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static>automatisch `attributes`.  
  
 Die von dieser Methode definierten Daten werden erst erstellt, wenn die <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> -Methode aufgerufen wird.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner gleich 0 oder größer gleich 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">Ein nicht transparenter BLOB, das eine nicht verwaltete Ressource darstellt.</param>
        <summary>Definiert eine nicht verwaltete eingebettete Ressource erhält ein nicht transparenter binary large Object (BLOB) von Bytes an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Assembly kann nur eine nicht verwaltete Ressource zugeordnet werden. Dies bedeutet, dass der Aufruf `DefineVersionInfoResource` oder `DefineUnmanagedResource` nach entweder eine der Methoden aufgerufen wurde zuvor löst <xref:System.ArgumentException>. Mehrere nicht verwaltete Ressourcen müssen mit einem Tool wie dem Microsoft ResMerge-Hilfsprogramm (nicht im Lieferumfang der common Language Runtime) zusammengeführt werden sollen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Eine nicht verwaltete Ressource wurde bereits in der Assembly des Moduls definiert wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">Der Name der Datei nicht verwaltete Ressource.</param>
        <summary>Definiert eine nicht verwaltete Ressource, die den Namen der Win32-Ressourcendatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Assembly kann nur eine nicht verwaltete Ressource zugeordnet werden. Dies bedeutet, dass der Aufruf `DefineVersionInfoResource` oder `DefineUnmanagedResource` nach entweder eine der Methoden aufgerufen wurde zuvor löst <xref:System.ArgumentException>. Mehrere nicht verwaltete Ressourcen müssen mit einem Tool wie dem Microsoft ResMerge-Hilfsprogramm (nicht im Lieferumfang der common Language Runtime) zusammengeführt werden sollen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Eine nicht verwaltete Ressource wurde bereits in der Assembly des Moduls definiert wurde.  
  
 - oder -   
  
 <paramref name="resourceFileName" /> ist die leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> wurde nicht gefunden.  
  
 - oder -   
  
 <paramref name="resourceFileName" /> ist ein Verzeichnis.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich dem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> dem Typ und dem Wert dieser Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see langword="String" /> , die den vollqualifizierten Namen und Pfad zu diesem Modul darstellt.</summary>
        <value>Der vollqualifizierte Modulname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Abrufen der Namen ohne die Pfadangabe `Name`.  
  
> [!NOTE]
>  Die Groß-/Kleinschreibung einen Modulnamen ist plattformabhängig.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Greift auf die Informationen im Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">Eine Arrayklasse.</param>
        <param name="methodName">Der Name einer Methode auf die Array-Klasse.</param>
        <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Die benannte Methodenrückgabe auf ein Array-Klasse.</summary>
        <returns>Die benannte Methode für eine Arrayklasse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod`ist nützlich, wenn Sie ein Array eines Typs, dessen Definition wurde nicht abgeschlossen, haben und Sie definierte Methoden zugreifen möchten <xref:System.Array>. Sie können z. B. einen Typ definieren und definieren Sie eine Methode, die ein Array des Typs als Parameter verwendet werden soll. Um die Elemente des Arrays zugreifen zu können, müssen Sie Methoden von Aufrufen der <xref:System.Array> Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> zum Abrufen der <xref:System.Reflection.MethodInfo> für eine Methode, einen Arraywert zurückgibt.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" />ist kein Array.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> oder <paramref name="methodName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">Das Objekt für das Array.</param>
        <param name="methodName">Eine Zeichenfolge, die den Namen der Methode enthält.</param>
        <param name="callingConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="returnType">Der Rückgabetyp der Methode</param>
        <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
        <summary>Gibt das Token für die benannte Methode für eine Arrayklasse.</summary>
        <returns>Das Token für die benannte Methode für eine Arrayklasse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist vergleichbar mit <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>, mit dem Unterschied, dass das Token der Arraymethode, statt die Methode selbst zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> zum Abrufen der <xref:System.Reflection.Emit.MethodToken> für eine Methode, einen Arraywert zurückgibt.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" />ist kein Array.  
  
 - oder -   
  
 Die Länge von <paramref name="methodName" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> oder <paramref name="methodName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">Der Konstruktor für die ein Token abgerufen werden soll.</param>
        <summary>Gibt das Token zur Identifizierung des angegebenen Konstruktors innerhalb dieses Moduls zurück.</summary>
        <returns>Das Token zum Identifizieren des angegebenen Konstruktors innerhalb dieses Modul verwendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">Der Konstruktor für die ein Token abgerufen werden soll.</param>
        <param name="optionalParameterTypes">Eine Auflistung der Typen von optionalen Parametern an den Konstruktor übergibt.</param>
        <summary>Gibt das Token verwendet, um den Konstruktor zu identifizieren, der die angegebenen Attribute und die Parametertypen innerhalb dieses Modul verfügt.</summary>
        <returns>Das Token zum Identifizieren des angegebenen Konstruktors innerhalb dieses Modul verwendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt die benutzerdefinierten Attribute, die mit dem aktuellen angewendet wurden <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <returns>Ein Array, das die benutzerdefinierten Attribute enthält. Das Array ist leer, wenn keine Attribute vorhanden sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Basistyp, von dem Attribute abgeleitet werden.</param>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt die benutzerdefinierten Attribute, die mit dem aktuellen angewendet wurden <see cref="T:System.Reflection.Emit.ModuleBuilder" />, und die von einem angegebenen Attributtyp abgeleitet sind.</summary>
        <returns>Ein Array, das die benutzerdefinierten Attribute, die enthält, auf jeder Ebene, von der abgeleiteten <paramref name="attributeType" />; das Array ist leer, wenn keine solchen Attribute vorhanden sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ist ein <see cref="T:System.Type" /> Objekt von der Laufzeit bereitgestellt wird. Beispielsweise <paramref name="attributeType" /> ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Informationen zu den Attributen zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.ModuleBuilder" /> angewendet wurden. Diese sind als <see cref="T:System.Reflection.CustomAttributeData" />-Objekte ausgedrückt.</summary>
        <returns>Eine generische Liste von <see cref="T:System.Reflection.CustomAttributeData" /> Objekte, die Darstellung von Daten zu den Attributen, die für das aktuelle Modul angewendet wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den reflektionsbezogenen Kontext geladen wird. Methoden wie <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> und <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> kann nicht in solchen Fällen verwendet werden, da sie Instanzen der Attribute erstellen. Code in den ReflectionOnly Kontext kann nicht ausgeführt werden. Weitere Informationen und Beispielcode, finden Sie unter der <xref:System.Reflection.CustomAttributeData> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Feldname.</param>
        <param name="bindingAttr">Eine Kombination der <see langword="BindingFlags" /> -Bitflags zum Steuern der Suche.</param>
        <summary>Gibt ein auf Modulebene-Feld, in der Region ".sdata" der portable ausführbare Datei (PE) Datei, mit dem angegebenen Namen und Binden von Attributen definiert.</summary>
        <returns>Ein Feld mit dem angegebenen Namen und das Binden von Attributen oder <see langword="null" /> , wenn das Feld nicht vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie dynamische Assemblys ausgeben, werden Felder im ".sdata" Bereich der PE (portable Executable)-Datei definiert, mit der <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> oder <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> Methoden.  
  
> [!IMPORTANT]
>  Modulebene Felder können nicht abgerufen werden, erst nach der <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> Methode für das Modul aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Eine Kombination der <see langword="BindingFlags" /> -Bitflags zum Steuern der Suche.</param>
        <summary>Gibt alle Felder in der Region ".sdata" der PE (portable Executable)-Datei definiert, die den angegebenen Bindungsflags übereinstimmen.</summary>
        <returns>Ein Array von Feldern, die die angegebenen Flags entsprechen. das Array ist leer, wenn keine solche Felder vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie dynamische Assemblys ausgeben, werden Felder im ".sdata" Bereich der PE (portable Executable)-Datei definiert, mit der <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> oder <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> Methoden.  
  
> [!IMPORTANT]
>  Modulebene Felder können nicht abgerufen werden, erst nach der <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> Methode für das Modul aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">Das Feld für die ein Token abgerufen werden soll.</param>
        <summary>Gibt das Token zur Identifizierung des angegebenen Felds innerhalb dieses Moduls zurück.</summary>
        <returns>Das Token verwendet, um das angegebene Feld innerhalb dieses Modul zu identifizieren.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <param name="bindingAttr">Eine Kombination von <see langword="BindingFlags" /> -Bitflags zum Steuern der Suche.</param>
        <param name="binder">Ein Objekt, das <see langword="Binder" /> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</param>
        <param name="callConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="types">Die Parametertypen der Methode.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</param>
        <summary>Gibt die Modulebene-Methode, die den angegebenen Kriterien entspricht.</summary>
        <returns>Eine Methode, die auf Modulebene definiert ist und den angegebenen Kriterien entspricht; oder <see langword="null" /> ist eine solche Methode ist nicht vorhanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt die Implementierung für alle Überladungen der vererbten <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> Methode. Verwenden Sie die geerbte <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> Methode zum Abrufen von Methoden, die deklariert wurden auf Modulebene. Auf Modulebene Methoden im ausgegebenen Code definiert werden, mithilfe der <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> Methode.  
  
> [!IMPORTANT]
>  Auf Modulebene Methoden können nicht abgerufen werden, erst nach der <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> Methode für das Modul aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />ist <see langword="null" />, <paramref name="types" /> ist <see langword="null" />, oder ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Eine Kombination von <see langword="BindingFlags" /> -Bitflags zum Steuern der Suche.</param>
        <summary>Gibt alle Methoden, die auf Modulebene für den aktuellen definiert wurden <see cref="T:System.Reflection.Emit.ModuleBuilder" />, und mit den angegebenen Bindungsflags übereinstimmen.</summary>
        <returns>Ein Array, das alle auf Modulebene Methoden enthält, entsprechen <paramref name="bindingFlags" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Modulebene Methoden im ausgegebenen Code definiert werden, mithilfe der <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> Methode.  
  
> [!IMPORTANT]
>  Auf Modulebene Methoden können nicht abgerufen werden, erst nach der <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> Methode für das Modul aufgerufen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">Die Methode, die ein Token abgerufen werden soll.</param>
        <summary>Gibt das Token verwendet, um die angegebene Methode innerhalb dieses Modul zu identifizieren.</summary>
        <returns>Das Token verwendet, um die angegebene Methode innerhalb dieses Modul zu identifizieren.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der deklarierende Typ für die Methode ist nicht in diesem Modul aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">Die Methode, die ein Token abgerufen werden soll.</param>
        <param name="optionalParameterTypes">Eine Auflistung der Typen von optionalen Parameter der Methode.</param>
        <summary>Gibt das Token verwendet, um die Methode zu identifizieren, die die angegebenen Attribute und die Parametertypen innerhalb dieses Modul verfügt.</summary>
        <returns>Das Token verwendet, um die angegebene Methode innerhalb dieses Modul zu identifizieren.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der deklarierende Typ für die Methode ist nicht in diesem Modul aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">Wenn diese Methode zurückgegeben, eine Kombination der <see cref="T:System.Reflection.PortableExecutableKinds" /> Werte, der angibt, die Art des Codes im Modul.</param>
        <param name="machine">Wenn diese Methode gibt einen von der <see cref="T:System.Reflection.ImageFileMachine" /> Werte, der angibt, der vom Modul verwiesen Plattform.</param>
        <summary>Ruft ein Wertepaar, der angibt, der Art des Codes in einem Modul und die Plattform, auf die vom Modul ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Modulen ist `peKind` ist immer <xref:System.Reflection.PortableExecutableKinds?displayProperty=nameWithType> und `machine` ist immer 0 (null).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">Die Signatur.</param>
        <summary>Definiert ein Token für die Signatur, die definiert, wird durch das angegebene <see cref="T:System.Reflection.Emit.SignatureHelper" />.</summary>
        <returns>Ein Token für die definierte Signatur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode definiert ein Metadatentoken für die Signatur von beschriebenen `sigHelper`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigHelper" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">Signatur binary large Object (BLOB).</param>
        <param name="sigLength">Die Länge der Signatur-BLOB.</param>
        <summary>Definiert ein Token für die Signatur, die den angegebenen Zeichenlänge Array und Signatur aufweist.</summary>
        <returns>Ein Token für die angegebene Signatur.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigBytes" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> -Objekt, das Zertifikat in der Authenticode-Signatur der Assembly, die dieses Modul gehört enthalten entspricht. Wenn die Assembly nicht mit Authenticode signiert wurde <see langword="null" /> wird zurückgegeben.</summary>
        <returns>Ein Zertifikat oder <see langword="null" /> Wenn die Assembly, zu der dieses Modul gehört, nicht mit Authenticode signiert wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Zeichenfolge, die das Modul Konstante Pool hinzufügen.</param>
        <summary>Gibt das Token der angegebenen Zeichenfolge in das Modul Konstante Pool zurück.</summary>
        <returns>Das Token der Zeichenfolge in der Konstante Pool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `str` wurde bereits definiert ist, wird das vorhandene Token zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Symbolwriter dieses dynamische Modul zugeordnet.</summary>
        <returns>Den Symbolwriter dieses dynamische Modul zugeordnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des der <see cref="T:System.Type" /> abgerufen.</param>
        <summary>Ruft den im Modul definierten benannten Typ ab.</summary>
        <returns>Der angeforderte Typ, wenn der Typ in diesem Modul definiert ist; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren. Verwenden der <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> Methoden stattdessen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Länge der <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer verfügt nicht über <see cref="T:System.Security.Permissions.ReflectionPermission" /> auf nicht öffentliche Objekte außerhalb der aktuellen Assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">Ein Fehler beim Laden der <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des der <see cref="T:System.Type" /> abgerufen.</param>
        <param name="ignoreCase">Wenn <see langword="true" />, wird bei der Suche die Groß-/Kleinschreibung. Wenn <see langword="false" />, wird bei der Suche die Groß-/Kleinschreibung beachtet.</param>
        <summary>Ruft den benannten Typ im Modul definierten optional ignorieren die Groß-/Kleinschreibung des Typnamens.</summary>
        <returns>Der angeforderte Typ, wenn der Typ in diesem Modul definiert ist; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren. Verwenden der <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> Methoden stattdessen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Länge der <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer verfügt nicht über <see cref="T:System.Security.Permissions.ReflectionPermission" /> auf nicht öffentliche Objekte außerhalb der aktuellen Assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des der <see cref="T:System.Type" /> abgerufen.</param>
        <param name="throwOnError">
          <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="ignoreCase">Wenn <see langword="true" />, wird bei der Suche die Groß-/Kleinschreibung. Wenn <see langword="false" />, wird bei der Suche die Groß-/Kleinschreibung beachtet.</param>
        <summary>Ruft den benannten Typ im Modul definierten optional ignorieren die Groß-/Kleinschreibung des Typnamens. Optional löst eine Ausnahme aus, wenn der Typ nicht gefunden wird.</summary>
        <returns>Dem angegebenen Typ, wenn der Typ in diesem Modul deklariert ist andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `throwOnError` Parameter wirkt sich nur auf was geschieht, wenn der Typ nicht gefunden wird. Dies beeinflusst keine andere Ausnahmen, die möglicherweise ausgelöst werden. Insbesondere, wenn der Typ gefunden wird, kann nicht geladen werden kann <xref:System.TypeLoadException> kann ausgelöst werden, selbst wenn `throwOnError` ist `false`.  
  
 Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren. Verwenden der <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> Methoden stattdessen.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Länge der <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer verfügt nicht über <see cref="T:System.Security.Permissions.ReflectionPermission" /> auf nicht öffentliche Objekte außerhalb der aktuellen Assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />ist <see langword="true" /> und der angegebene Typ wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle in diesem Modul definierten Klassen zurück.</summary>
        <returns>Ein Array, das innerhalb des Moduls, das von dieser Instanz reflektiert wird definierten Typen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException`ist eine besondere Klasse Load-Ausnahme. Die `ReflectionTypeLoadException.Types` -Eigenschaft enthält das Array von Klassen, die im Modul definiert und geladen wurden. Dieses Array kann einige null-Werte enthalten. Die `ReflectionTypeLoadException.LoaderExceptions` Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Klassenladeprogramm ausgelöst wurden. Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.  
  
 Z. B. wenn eine der Klassen der Klasseninitialisierer löst eine Ausnahme während der es wird geladen, eine `TargetInvocationException` befindet sich in dem entsprechenden Element des der `LoaderExceptions` Array.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Klasse, einschließlich des Namespaces.</param>
        <summary>Gibt das Token verwendet, um den Typ mit dem angegebenen Namen zu identifizieren.</summary>
        <returns>Das Token verwendet, um den Typ mit dem angegebenen Namen in diesem Modul zu identifizieren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode eignet sich für Clients die <xref:System.Reflection.Emit.MethodRental> Klasse, die auf den Text einer Methode nicht direkt ändern möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist die leere Zeichenfolge ("").  
  
 - oder -   
  
 <paramref name="name" />Stellt eine <see langword="ByRef" /> Typ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die vom angegebenen Typ <paramref name="name" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.InvalidOperationException">Dies ist ein nicht-transiente-Modul, das ein flüchtiges Modul verweist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Die Typobjekt, das den Klassentyp darstellt.</param>
        <summary>Gibt das Token zur Identifizierung des angegebenen Typs in diesem Modul zurück.</summary>
        <returns>Das Token verwendet, um den angegebenen Typ innerhalb dieses Modul zu identifizieren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token werden in Microsoft intermediate Language (MSIL)-Anweisungen verwendet, um Objekte zu identifizieren. Token sind relativ zu dem Modul, in dem sie enthalten sind. Z. B. den Tokenwert für `String` ist es wahrscheinlich, dass von einem Modul zu unterscheiden. Wenn `GetTypeToken` wird aufgerufen, wird ein Verweis auf das Modul hinzugefügt. Der Verweis wird einem dauerhaften Bestandteil des Moduls. mehrere Aufrufe mit dem gleichen Argument haben keine weitere Auswirkung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist ein <see langword="ByRef" />-Typ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dies ist ein nicht-transiente-Modul, das ein flüchtiges Modul verweist.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des benutzerdefinierten Attributs zur Prüfung auf.</param>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt einen Wert, der angibt, ob der Typ des angegebenen Attributs für dieses Modul angewendet wurde.</summary>
        <returns>
          <see langword="true" />Wenn eine oder mehrere Instanzen des <paramref name="attributeType" /> wurden für dieses Modul angewendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ist ein <see cref="T:System.Type" /> Objekt von der Laufzeit bereitgestellt wird. Beispielsweise <paramref name="attributeType" /> ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob das Objekt eine Ressource ist.</summary>
        <returns>
          <see langword="true" />Wenn das Objekt eine Ressource ist. andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob dieses dynamische Modul flüchtig ist.</summary>
        <returns>
          <see langword="true" />Wenn dieses dynamische Modul flüchtig ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version des Metadatenstreams ab.</summary>
        <value>Eine 32-Bit-Ganzzahl, die Version des Metadatenstreams darstellt. Die zwei höherwertigen Bytes die Hauptversionsnummer und die zwei niederwertigen Bytes darstellen die Nebenversionsnummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Weitere Informationen zu den Metadatenheader finden Sie unter "Partition II: Metadata Definition and Semantics" in der Dokumentation für die Common Language Infrastructure (CLI). Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Token, das das aktuelle dynamische Modul in den Metadaten bezeichnet.</summary>
        <value>Ein Integer-Token, das das aktuelle Modul in den Metadaten bezeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Token mit dieser Eigenschaft können auf der nicht verwalteten Reflektions-API übergeben werden. Weitere Informationen finden Sie unter [nicht verwalteten Reflektions-API](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen universellen eindeutigen Bezeichner (Universally Unique Identifier, UUID) ab, der zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</summary>
        <value>Eine <see cref="T:System.Guid" />, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In nicht verwalteten Metadaten, die GUID zurückgegeben, indem Sie die <xref:System.Reflection.Module.ModuleVersionId%2A> Eigenschaft wird als bezeichnet den `mvid`, und im GUID-Heap gespeichert wird.  
  
> [!NOTE]
>  Weitere Informationen zu Metadaten kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Zeichenfolge, die angibt, ob dies ein in-Memory-Modul ist.</summary>
        <value>Text, der angibt, ob dies ein in-Memory-Modul ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name der ein dynamisches Modul konnte nicht ermittelt werden, bis das Modul gespeichert und vom Datenträger neu geladen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das ein Feld im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt das Feld identifiziert, die durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Reflection.FieldInfo" /> Objekt, das das Feld, das das angegebene Metadatentoken identifizierte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für ein Feld im Bereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />Gibt ein Feld, dessen übergeordnetes Objekt <see langword="TypeSpec" /> verfügt über eine Signatur mit Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ oder Member im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt den Typ oder Member, die durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definierten identifiziert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MemberInfo" /> Objekt, das den Typ oder Member, die durch das angegebene Metadatentoken identifiziert ist darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ oder Member im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> oder <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden für eine oder beide nicht angegeben der <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.  
  
 - oder -   
  
 <paramref name="metadataToken" />bezeichnet eine Eigenschaft oder ein Ereignis.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Methode oder ein Konstruktor im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt die Methode oder der Konstruktor, identifiziert durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MethodBase" /> Objekt, das die Methode, die durch das angegebene Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericMethodArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für eine Methode oder ein Konstruktor im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Signatur im Modul identifiziert.</param>
        <summary>Gibt den signaturblob, das durch ein Metadatentoken identifiziert zurück.</summary>
        <returns>Ein Array von Bytes, die der Signatur-Blob darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informationen zum Metadatentoken und Signaturen kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein gültiger <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, Signatur, den richtigen oder <see langword="FieldDef" /> token im Gültigkeitsbereich des aktuellen Moduls.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Zeichenfolge im String-Heap des Moduls identifiziert.</param>
        <summary>Gibt die Zeichenfolge, die durch das angegebene Metadatentoken identifiziert.</summary>
        <returns>Ein <see cref="T:System.String" /> , die einen Zeichenfolgenwert aus dem Metadaten String-Heap enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für eine Zeichenfolge im Gültigkeitsbereich des aktuellen Moduls.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt den Typ identifiziert durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Type" /> Objekt, das den Typ, der durch das angegebene Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge, die den Namen des dynamischen Moduls darstellt.</summary>
        <value>Der Name des dynamischen Moduls.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Eine Instanz einer Hilfsklasse, die angibt, das benutzerdefinierte Attribut angewendet werden soll.</param>
        <summary>Wendet ein benutzerdefiniertes Attribut für dieses Modul mithilfe eines benutzerdefinierten Attribut-Generators.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
        <param name="binaryAttribute">Ein Byte-BLOB, das Attribut darstellt.</param>
        <summary>Wendet ein benutzerdefiniertes Attribut für dieses Modul mithilfe ein angegebenes binary large Object (BLOB), das das Attribut darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Formatieren `binaryAttribute`, finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des benutzerdefinierten Attributs</param>
        <param name="data">Ein nicht transparenter BLOB (BLOB) von Bytes, die den Wert des benutzerdefinierten Attributs darstellt.</param>
        <summary>Diese Methode hat keine Funktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Funktion.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">Der Einstiegspunkt für den Benutzer.</param>
        <summary>Legt den Einstiegspunkt für den Benutzer fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Compiler möglicherweise einen Startstub vor dem Aufrufen der wichtigsten Benutzer generieren. Die Startstub wird der Einstiegspunkt sein. Während der Benutzer, die wichtigsten, damit der Debugger den Einstiegspunkt der Compiler nicht schrittweise wird benutzerdefinierter Einstiegspunkt kann.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Member nicht mehr benötigt <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> Flag. (Siehe [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryPoint" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode ist für ein dynamisches Modul aufgerufen, der kein Debugmodul ist.  
  
 - oder -   
  
 <paramref name="entryPoint" />ist nicht in dieser dynamischen Modul enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Reflection.Emit.ModuleBuilder>-Instanz in eine <xref:System.Runtime.InteropServices._ModuleBuilder>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Die Methode wird spät gebundenem Zugriff aufgerufen unter Verwendung des COM <c>IDispatch</c> Schnittstelle.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Reflection.Emit.ModuleBuilder>-Instanz in eine <xref:System.Runtime.InteropServices._ModuleBuilder>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Die Methode wird spät gebundenem Zugriff aufgerufen unter Verwendung des COM <c>IDispatch</c> Schnittstelle.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Der Speicherort, der die Anzahl der von dem Objekt bereitgestellten Schnittstellen mit Typinformationen empfängt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Reflection.Emit.ModuleBuilder>-Instanz in eine <xref:System.Runtime.InteropServices._ModuleBuilder>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Die Methode wird spät gebundenem Zugriff aufgerufen unter Verwendung des COM <c>IDispatch</c> Schnittstelle.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Die Element-ID.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Reflection.Emit.ModuleBuilder>-Instanz in eine <xref:System.Runtime.InteropServices._ModuleBuilder>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Die Methode wird spät gebundenem Zugriff aufgerufen unter Verwendung des COM <c>IDispatch</c> Schnittstelle.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
