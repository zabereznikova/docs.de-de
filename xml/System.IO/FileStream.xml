<Type Name="FileStream" FullName="System.IO.FileStream">
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen <see cref="T:System.IO.Stream" /> für eine Datei bereit, wobei synchrone und asynchrone Lese- und Schreibvorgänge unterstützt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Verwenden der <xref:System.IO.FileStream> Klasse aus lesen, schreiben zu öffnen und Schließen von Dateien in einem Dateisystem, und um andere dateibezogene Betriebssystemhandles, z. B. Pipes, Standardeingabe und Standardausgabe zu bearbeiten. Können Sie die <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, und <xref:System.IO.FileStream.Flush%2A> Methoden zum synchrone Vorgängen ausführen oder die <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A> Methoden zum asynchronen Ausführen DDL-Vorgänge. Verwenden Sie die asynchronen Methoden ressourcenintensiven Dateivorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]-App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. <xref:System.IO.FileStream>puffert Eingabe und Ausgabe für eine bessere Leistung.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
 Die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft erkennt, ob die Dateihandle asynchron geöffnet wurde. Bei der Erstellung einer Instanz von, geben Sie diesen Wert der <xref:System.IO.FileStream> -Klasse mit einem Konstruktor, verfügt ein `isAsync`, `useAsync`, oder `options` Parameter. Wenn die Eigenschaft den Wert `true`, der Datenstrom nutzt überlappender e/a, um die Dateivorgänge asynchron ausführen. Allerdings die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft hat keine werden `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft ist `false` und rufen Sie den asynchronen Lesevorgang und Schreibvorgänge, die UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
 Die <xref:System.IO.FileStream.Seek%2A> Methode unterstützt den zufälligen Zugriff auf Dateien. <xref:System.IO.FileStream.Seek%2A>ermöglicht den Lese-/Schreibposition an einer beliebigen Position innerhalb der Datei verschoben werden soll. Dies erfolgt mit Byte-Offset Verweis Point-Parameter. Das Byte-Offset ist relativ zu den Bezugspunkt, der den Anfang, die aktuelle Position oder das Ende der zugrunde liegenden Datei, sein kann, dargestellt durch die drei Elemente von der <xref:System.IO.SeekOrigin> Enumeration.  
  
> [!NOTE]
>  Datenträgerdateien unterstützen immer den wahlfreien Zugriff. Zum Zeitpunkt der Erstellung der <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert festgelegt ist, um `true` oder `false` abhängig von der zugrunde liegende Dateityp. Wenn der zugrunde liegenden Dateityp FILE_TYPE_DISK ist gemäß Definition in winbase.h der <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert ist `true`. Andernfalls die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert ist `false`.  
  
 Wenn ein Prozess mit Teil der Datei gesperrt beendet oder schließt eine Datei mit ausstehenden sperren, ist das Verhalten nicht definiert.  
  
 Verzeichnisvorgänge und andere Dateivorgänge finden Sie in der <xref:System.IO.File>, <xref:System.IO.Directory>, und <xref:System.IO.Path> Klassen. Die <xref:System.IO.File> Klasse ist eine Hilfsprogrammklasse, die in erster Linie für die Erstellung der statische Methoden <xref:System.IO.FileStream> Objekte auf der Grundlage von Dateipfaden. Die <xref:System.IO.MemoryStream> Klasse erstellt einen Datenstrom aus einem Bytearray und ähnelt der <xref:System.IO.FileStream> Klasse.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Erkennung von Stream Position Änderungen  
 Wenn ein <xref:System.IO.FileStream> Objekt hat keinen exklusiven auf das Handle, das einem anderen Thread konnte das Dateihandle gleichzeitig zugreifen und Ändern der Position des Betriebssystems Dateizeiger, das das Dateihandle zugeordnet ist. In diesem Fall wird die zwischengespeicherte Position in der <xref:System.IO.FileStream> -Objekt und die zwischengespeicherten Daten in den Puffer gefährdet werden. Die <xref:System.IO.FileStream> Objekt auf Methoden, die Zugriff auf den zwischengespeicherten Puffer, um sicherzustellen, dass das Betriebssystem Handle Position identisch mit die zwischengespeicherte Position verwendeten routinemäßig überprüft die <xref:System.IO.FileStream> Objekt.  
  
 Wenn unerwartete Änderungen in die Position des Handles, in einem Aufruf erkannt wird der <xref:System.IO.FileStream.Read%2A> -Methode, die .NET Framework verwirft den Inhalt des Puffers und der Stream erneut aus der Datei gelesen. Dies kann die Leistung zu erzielen, abhängig von der Größe der Datei und alle anderen Prozesse, die Auswirkungen auf die Position des Dateidatenstroms beeinträchtigen.  
  
 Wenn in einem Aufruf unerwartete Änderungen in die Position des Handles erkannt wird die <xref:System.IO.FileStream.Write%2A> -Methode, den Inhalt des Puffers werden verworfen und ein <xref:System.IO.IOException> Ausnahme wird ausgelöst.  
  
 Ein <xref:System.IO.FileStream> Objekt hat keinen exklusiven auf das Handle Wenn entweder die <xref:System.IO.FileStream.SafeFileHandle%2A> Eigenschaft zugegriffen wird, um das Handle verfügbar zu machen oder die <xref:System.IO.FileStream> Objekt erhält die <xref:System.IO.FileStream.SafeFileHandle%2A> Eigenschaft in seinem Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der <xref:System.IO.FileStream> Konstruktoren.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Im folgende Beispiel wird gezeigt, wie asynchron in eine Datei geschrieben wird. Dieser Code wird in einer WPF-app, die einen TextBlock mit dem Namen UserInput und eine Schaltfläche, um einen Click-Ereignishandler mit dem Namen Button_Click eingebunden wurde ausgeführt. Der Dateipfad muss geändert werden, in eine Datei als auf dem Computer beendet wird.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> wird aufgerufen, wird auch das Handle geschlossen und die Handleanzahl für die Datei wird wieder um eins erniedrigt.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" />ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> wird aufgerufen, wird auch das Handle geschlossen und die Handleanzahl für die Datei wird wieder um eins erniedrigt.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" />ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit dem angegebenen Pfad und dem angegebenen Erstellungsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis misslingen, die `FileStream` Objekt geschlossen wurde, aber lesen versucht wird erfolgreich ausgeführt werden).  
  
 Dieser Konstruktor können keine um schreibgeschützten Dateien zu öffnen; Stattdessen müssen Sie einen Konstruktor, der akzeptiert verwenden eine `FileAccess` Parameter mit dem Wert `FileAccess.Read`.  
  
 Die Größe des Puffers wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Für Konstruktoren ohne eine <xref:System.IO.FileAccess> Parameter, wenn die `mode` Parametersatz auf <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> ist der Standardzugriff. Andernfalls wird der Zugriff auf festgelegt <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Schreiben von Daten in eine Datei byteweise, und überprüfen, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine <see cref="T:System.IO.FileAccess" />-Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle. Klicken Sie alternativ lesen und Schreiben in das Handle vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="handle" /> Parameter ist ein ungültiges Handle.  
  
 - oder -   
  
 Die <paramref name="handle" /> Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="bufferSize" /> Parameter ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumerationen:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle">
          <see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und für den Besitz der <see langword="FileStream" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles werden wie angegeben. Wenn der Prozess das Handle, das einen Aufruf von besitzt die <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen und die Handleanzahl für die Datei wird verringert. Die `FileStream` Objekt erhält die Standardpuffergröße von 4096 Bytes.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles und zu vermeiden, Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" />ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" />ist <see langword="true" /> Wenn <c>Pfad</c> gibt eine Datenträgerdatei an.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus und die Lese-/Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis misslingen, die `FileStream` Objekt geschlossen wurde, aber lesen versucht wird erfolgreich ausgeführt werden). Die Größe des Puffers wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync">
          <see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der `isAsync` Parameter `true` um das Dateihandle asynchron zu öffnen. Wenn der Parameter ist `true`, der Datenstrom nutzt überlappender e/a, um die Dateivorgänge asynchron ausführen. Allerdings die Parameter enthält keinen sein `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die `isAsync` Parameter ist `false` und rufen Sie den asynchronen Lesevorgang und Schreibvorgänge, die UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle. Klicken Sie alternativ lesen und Schreiben in das Handle vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="handle" /> Parameter ist ein ungültiges Handle.  
  
 - oder -   
  
 Die <paramref name="handle" /> Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <paramref name="bufferSize" /> Parameter ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumerationen:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle">
          <see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles werden wie angegeben. Wenn diese `FileStream` besitzt das Handle, einen Aufruf der <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen. Insbesondere wird die Datei Handleanzahl verringert. Die `FileStream` Objekt erhält die angegebenen Puffergröße.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle. Klicken Sie alternativ lesen und Schreiben in das Handle vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" />ist <see langword="true" /> Wenn <c>Pfad</c> gibt eine Datenträgerdatei an.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis misslingen, die `FileStream` Objekt geschlossen wurde, aber lesen versucht wird erfolgreich ausgeführt werden). Die Größe des Puffers wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Das System ausgeführt wird, Windows 98 oder Windows 98 Zweite Ausgabe und <paramref name="share" /> festgelegt ist, um <see langword="FileShare.Delete" />.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle">
          <see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync">
          <see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles werden wie angegeben. Wenn diese `FileStream` besitzt das Handle, einen Aufruf der <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen. Insbesondere wird die Datei Handleanzahl verringert. Die `FileStream` Objekt erhält die angegebenen Puffergröße.  
  
 `FileStream`wird davon ausgegangen, dass sie die exklusive Kontrolle über das Handle besitzt. Lesen, schreiben oder beim Suchen einer `FileStream` enthalten auch ein Handle zu beschädigten Daten führen. Rufen Sie Daten aus Sicherheitsgründen <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie abschließend mit dem Handle. Klicken Sie alternativ lesen und Schreiben in das Handle vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read`ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" />ist kleiner als <see langword="FileAccess.Read" /> oder größer als <see langword="FileAccess.ReadWrite" /> oder <paramref name="bufferSize" /> kleiner oder gleich 0 ist.</exception>
        <exception cref="T:System.ArgumentException">Das Handle ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für das angegebene Dateihandle, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und das Dateihandle für schreibgeschützten Zugriff festgelegt ist.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" />ist <see langword="true" /> Wenn <c>Pfad</c> gibt eine Datenträgerdatei an.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung sowie die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="mode" />, <paramref name="access" />, oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Das System ausgeführt wird, Windows 98 oder Windows 98 Zweite Ausgabe und <paramref name="share" /> festgelegt ist, um <see langword="FileShare.Delete" />.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" />ist <see langword="true" /> Wenn <c>Pfad</c> gibt eine Datenträgerdatei an.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="useAsync">Gibt an, ob eine asynchrone E/A oder eine synchrone E/A verwendet wird. Beachten Sie jedoch, dass das zugrunde liegende Betriebssystem möglicherweise keine asynchrone E/A unterstützt, sodass das Handle je nach Plattform auch bei der Angabe von <see langword="true" /> möglicherweise synchron geöffnet wird. Bei asynchronem Öffnen liefern die <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode und die <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode bei umfangreichen Lese- oder Schreibvorgängen eine höhere Leistung, sind aber möglicherweise bei kleinen Lese- und Schreibvorgängen wesentlich langsamer. Wenn die Anwendung asynchrone e/a nutzen, legen die <c>UseAsync</c> Parameter <see langword="true" />. Wird die asynchrone E/A richtig eingesetzt, können Anwendungen um ein Zehnfaches beschleunigt werden. Wenn die Anwendung jedoch nicht an eine asynchrone E/A angepasst wurde, kann dies die Leistung auch um das Zehnfache verringern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Daten asynchron in eine Datei schreiben, und vergewissern Sie sich, dass die Daten richtig geschrieben wurde. Ein `State` Objekt wird erstellt, um Informationen aus den Hauptthread, übergeben die `EndReadCallback` und `EndWriteCallback` Methoden.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="mode" />, <paramref name="access" />, oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Das System ausgeführt wird, Windows 98 oder Windows 98 Zweite Ausgabe und <paramref name="share" /> festgelegt ist, um <see langword="FileShare.Delete" />.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" />ist <see langword="true" /> Wenn <c>Pfad</c> gibt eine Datenträgerdatei an.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Ein Wert, der zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Zugriffsmöglichkeiten anderer FileStreams auf die gleiche Datei, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge zu ermöglichen, die genutzt werden kann, für die Erstellung einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel schreibt Daten in eine Datei und liest dann die Daten mithilfe der <xref:System.IO.FileStream> Objekt.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="mode" />, <paramref name="access" />, oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.  
  
 - oder -   
  
 <see cref="F:System.IO.FileOptions.Encrypted" />ist für die angegebene <paramref name="options" />, aber dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="rights">Eine Konstante, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine Konstante, die zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Verwenden Sie diese <xref:System.IO.FileStream.%23ctor%2A> Konstruktor anzuwendenden Zugriff Rechte zum Zeitpunkt der Erstellung einer Datei. Um zugreifen oder diese Rechte in einer vorhandenen Datei ändern, sollten Sie mithilfe der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden.  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge zu ermöglichen, die genutzt werden kann, für die Erstellung einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="mode" />, <paramref name="access" />, oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.  
  
 - oder -   
  
 <see cref="F:System.IO.FileOptions.Encrypted" />ist für die angegebene <paramref name="options" />, aber dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Das angegebene <paramref name="path" />, und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="rights">Eine Konstante, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine Konstante, die zusätzliche Dateioptionen angibt.</param>
        <param name="fileSecurity">Eine Konstante, die die Zugriffssteuerung und die Überwachungssicherheit für die Datei bestimmt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße, zusätzliche Dateioptionen, die Zugriffssteuerung und die Überwachungssicherheit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Verwenden Sie diese <xref:System.IO.FileStream.%23ctor%2A> Konstruktor anzuwendenden Zugriff Rechte zum Zeitpunkt der Erstellung einer Datei. Um zugreifen oder diese Rechte in einer vorhandenen Datei ändern, sollten Sie mithilfe der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden.  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge zu ermöglichen, die genutzt werden kann, für die Erstellung einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
> [!NOTE]
>  `path`ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Es kann einen beliebigen Teil eines Systems, die Zugriff über Datenströme unterstützt. Je nach System kann diese Klasse z. B. ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A>ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien zu kapseln. Wenn `path` gibt an, ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für die resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel schreibt Daten in eine Datei und liest dann die Daten mithilfe der <xref:System.IO.FileStream> Objekt.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
 - oder -   
  
 <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in ein NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />verweist auf ein nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:", usw., in einer nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
 - oder -   
  
 <paramref name="mode" />, <paramref name="access" />, oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei nicht gefunden werden kann z. B. bei <paramref name="mode" /> ist <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" />, und die Datei <paramref name="path" /> ist nicht vorhanden. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Ein e/a-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegebene Datei von <paramref name="path" /> bereits vorhanden ist, ist aufgetreten.  
  
 - oder -   
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="access" /> angefordert darf nicht vom Betriebssystem für den angegebenen <paramref name="path" />, z. B. wenn <paramref name="access" /> ist <see langword="Write" /> oder <see langword="ReadWrite" /> und die Datei oder das Verzeichnis für schreibgeschützten Zugriff festgelegt ist.  
  
 - oder -   
  
 <see cref="F:System.IO.FileOptions.Encrypted" />ist für die angegebene <paramref name="options" />, aber dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Das angegebene <paramref name="path" />, und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer, in den Daten gelesen werden sollen.</param>
        <param name="offset">Der Byteoffset im <c>Array</c> an der Lesevorgang beginnen soll.</param>
        <param name="numBytes">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Lesevorgang abgeschlossen ist.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Beginnt einen asynchronen Lesevorgang. (Erwägen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> stattdessen.)</summary>
        <returns>Ein Objekt, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <xref:System.IO.FileStream.BeginRead%2A> und <xref:System.IO.FileStream.EndRead%2A> zum Implementieren asynchroner Vorgänge. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.  
  
 <xref:System.IO.FileStream.EndRead%2A>muss genau einmal für jeden Aufruf aufgerufen werden <xref:System.IO.FileStream.BeginRead%2A>. Wegen eines Fehlers beim ein Lesevorgang beendet vor dem Beginn einer anderen Lesevorgang kann unerwünschtes Verhalten wie z. B. Deadlocks verursachen.  
  
 <xref:System.IO.FileStream>bietet zwei unterschiedliche Verwendungsarten des: synchrone e/a und asynchrone e/a. Während beide verwendet werden können, lassen die zugrunde liegenden Ressourcen des Betriebssystems möglicherweise Zugriff nur in einem dieser Modi zu. Standardmäßig <xref:System.IO.FileStream> Öffnet das Betriebssystemhandle synchron. In Windows verlangsamt dies asynchrone Methoden. Wenn asynchrone Methoden verwendet werden, verwenden die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanRead%2A>.  
  
 Wenn ein Stream geschlossen ist, oder Sie ein ungültiges Argument übergeben, Ausnahmen werden ausgelöst, unmittelbar aus <xref:System.IO.FileStream.BeginRead%2A>. Fehler während einer asynchronen leseanforderung z. B. Fehler auf dem Datenträger während der e/a-Anforderung, für den Thread im Threadpool ausgeführt, und werden bei einem Aufruf sichtbar <xref:System.IO.FileStream.EndRead%2A>.  
  
 <xref:System.IO.Stream.EndRead%2A>muss aufgerufen werden, dabei <xref:System.IAsyncResult> um herauszufinden, wie viele Bytes gelesen wurden.  
  
 Mehrere gleichzeitige asynchrone Anforderungen das Rendern der Anforderung Abschluss unsicher.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Arraylänge minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Es wurde ein asynchroner Lesevorgang nach Erreichen des Dateiendes versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <c>Array</c> ab dem Bytes in den aktuellen Stream kopiert werden sollen.</param>
        <param name="numBytes">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang. (Erwägen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> stattdessen.)</summary>
        <returns>Ein Objekt, das auf den asynchronen Schreibvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <xref:System.IO.FileStream.BeginWrite%2A> und <xref:System.IO.FileStream.EndWrite%2A> zum Implementieren asynchroner Vorgänge. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.  
  
 <xref:System.IO.FileStream.EndWrite%2A>muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> aus <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A>blockiert, bis die e/a-Operation abgeschlossen ist.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.BeginWrite%2A>.  
  
 <xref:System.IO.FileStream>bietet zwei unterschiedliche Verwendungsarten des: synchrone e/a und asynchrone e/a. Während beide verwendet werden können, lassen die zugrunde liegenden Ressourcen des Betriebssystems möglicherweise Zugriff nur in einem dieser Modi zu. Standardmäßig <xref:System.IO.FileStream> Öffnet das Betriebssystemhandle synchron. In Windows verlangsamt dies asynchrone Methoden. Wenn asynchrone Methoden verwendet werden, verwenden die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 Wenn ein Stream geschlossen ist, oder Sie ein ungültiges Argument übergeben, Ausnahmen werden ausgelöst, unmittelbar aus <xref:System.IO.FileStream.BeginWrite%2A>. Fehler während einer asynchronen schreibanforderung, z. B. Fehler auf dem Datenträger während der e/a-Anforderung für den Thread im Threadpool ausgeführt, und werden bei einem Aufruf sichtbar <xref:System.IO.FileStream.EndWrite%2A>.  
  
 Mehrere gleichzeitige asynchrone Anforderungen das Rendern der Anforderung Abschluss unsicher.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />die Länge minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn der Stream Lesevorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn von eine Klasse abgeleitet <xref:System.IO.Stream> keine Lesevorgänge unterstützt, werden Aufrufe von der <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, und <xref:System.IO.FileStream.BeginRead%2A> Methoden lösen eine <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `CanRead` Eigenschaft. Die Ausgabe dieses Codes lautet "MyFile.txt nicht geschrieben werden kann." Zum Abrufen der Ausgabenachricht "MyFile.txt können sowohl in geschrieben und gelesen werden.", ändern die `FileAccess` Parameter `ReadWrite` in die `FileStream` Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn der Stream Suchvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder der <see langword="FileStream" /> von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe in der Konsole, erstellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn von eine Klasse abgeleitet <xref:System.IO.Stream> Suchvorgänge nicht unterstützt, werden Aufrufe von <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, und <xref:System.IO.FileStream.Seek%2A> Auslösen einer <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanSeek` Eigenschaft zu überprüfen, ob ein Stream Suchvorgänge unterstützt.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn von eine Klasse abgeleitet <xref:System.IO.Stream> unterstützt nicht das Schreiben von einem Aufruf von <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, oder <xref:System.IO.FileStream.WriteByte%2A> löst eine <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanWrite` Eigenschaft zu überprüfen, ob ein Stream Schreibvorgänge unterstützt.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Das folgenden Beispiel wird mithilfe der `CanWrite` Eigenschaft. Die Ausgabe dieses Codes lautet "MyFile.txt geschrieben werden kann." Zum Abrufen der Ausgabenachricht "MyFile.txt können sowohl in geschrieben und gelesen werden.", ändern die `FileAccess` Parameter `ReadWrite` in die `FileStream` Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.FileStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich <xref:System.ComponentModel.Component.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. <xref:System.ComponentModel.Component.Dispose%2A>Ruft die geschützte <xref:System.IO.FileStream.Dispose%2A> Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft <xref:System.IO.FileStream.Dispose%2A> mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.FileStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see cref="M:System.ComponentModel.Component.Dispose" />. Weitere Informationen zum Implementieren <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</param>
        <summary>Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist. (Erwägen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> stattdessen.)</summary>
        <returns>Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen. Streams geben nur am Ende des Streams 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <xref:System.IO.FileStream.BeginRead%2A> und <xref:System.IO.FileStream.EndRead%2A> zum Implementieren asynchroner Vorgänge. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.  
  
 <xref:System.IO.FileStream.EndRead%2A>muss aufgerufen werden, genau für jeden Aufruf von <xref:System.IO.FileStream.BeginRead%2A>. Wegen eines Fehlers beim ein Lesevorgang beendet vor dem Beginn einer anderen Lesevorgang kann unerwünschtes Verhalten wie z. B. Deadlocks verursachen.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A>kann aufgerufen werden, auf jedem <xref:System.IAsyncResult> aus <xref:System.IO.FileStream.BeginRead%2A>. Aufrufen von <xref:System.IO.FileStream.EndRead%2A> Aufschluss darüber, wie viele Bytes aus dem Stream gelesen wurden. <xref:System.IO.FileStream.EndRead%2A>blockiert, bis die e/a-Operation abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde. (Erwägen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> stattdessen.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <xref:System.IO.FileStream.BeginWrite%2A> und <xref:System.IO.FileStream.EndWrite%2A> zum Implementieren asynchroner Vorgänge. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A>muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> aus <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A>blockiert, bis die e/a-Operation abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Bereinigungsvorgänge sicher, wenn der Garbage Collector den <see langword="FileStream" /> verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft `Finalize` Wenn das aktuelle Objekt wird finalisiert werden. `Finalize`Schließt die `FileStream`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Beim Aufrufen der <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> -Methode, den Betriebssystem-e/a-Puffer wird ebenfalls geleert.  
  
 Ein Stream Encoder wird nicht geleert werden, es sei denn, Sie explizit aufrufen <xref:System.IO.FileStream.Flush%2A> oder das Objekt freizugeben. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> zu `true` ist, werden Daten aus dem Puffer geleert werden, in den Stream, aber die Encoder-Status wird nicht geleert werden. Dadurch wird den Encoder seinen Zustand (teilweise Zeichen) beibehalten, sodass er den nächsten Block von Zeichen richtig zu codieren. Dieses Szenario betrifft UTF8 und UTF7, in denen bestimmte Zeichen nur verschlüsselt werden können, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfängt.  
  
 Da ein Puffer zum Lesen oder Schreiben verwendet werden kann <xref:System.IO.FileStream.Flush> führt die folgenden zwei Funktionen:  
  
-   Alle zuvor in den Puffer geschriebenen Daten in die Datei kopiert und der Puffer mit Ausnahme von Datenbankzustands Encoder deaktiviert ist.  
  
-   Wenn <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> ist `true` und Daten wurde zuvor in den Puffer zum Lesen aus der Datei kopiert, die aktuelle Position in der Datei verringert, um die Anzahl der gelesenen Bytes im Puffer ist. Der Puffer wird dann gelöscht.  
  
 Verwenden der <xref:System.IO.FileStream.Flush%28System.Boolean%29> -methodenüberladung, wenn Sie sicherstellen möchten, dass alle Zwischendateipuffer Daten gepuffert bezieht sich auf den Datenträger.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" />, um alle Zwischendateipuffer zu leeren, andernfalls <see langword="false" />.</param>
        <summary>Löscht die Puffer für diesen Datenstrom, veranlasst die Ausgabe aller gepufferten Daten in die Datei und löscht zudem alle Zwischendateipuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie möchten, um sicherzustellen, dass alle Zwischendateipuffer Daten gepuffert wird geschrieben auf den Datenträger.  
  
 Beim Aufrufen der <xref:System.IO.FileStream.Flush%2A> -Methode, den Betriebssystem-e/a-Puffer wird ebenfalls geleert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das Token zum überwachen von Abbruchanforderungen .</param>
        <summary>Löscht alle Puffer für diesen Stream asynchron, veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die die asynchrone Leerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.IO.FileStream.FlushAsync%2A> -Methode, den Betriebssystem-e/a-Puffer wird ebenfalls geleert.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die Einträge in der Zugriffssteuerungsliste für die Datei kapselt, das vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungseinstellungen für die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.IO.FileStream> Klasse und <xref:System.IO.FileStream.GetAccessControl%2A> kann verwendet werden, das die Einträge in der Zugriffssteuerungsliste (ACL) einer vorhandenen Datei abgerufen werden, erwägen Sie <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> Methode, wie es ist einfacher zu verwenden.  
  
 Verwenden der <xref:System.IO.FileStream.GetAccessControl%2A> Methode, um die ACL-Einträge für eine Datei abzurufen.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 - oder -  
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dateihandle des Betriebssystems für die Datei ab, die durch das aktuelle <see langword="FileStream" />-Objekt gekapselt wird.</summary>
        <value>Das Dateihandle des Betriebssystems für die vom <see langword="FileStream" />-Objekt gekapselte Datei oder -1, wenn der <see langword="FileStream" /> geschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein Betriebssystem-Handle für die Verwendung mit dem Betriebssystem bereitgestellten Systemaufrufe (z. B. `ReadFile` unter Windows). Sie funktioniert nicht mit Funktionen der C-Bibliothek, die einen Dateideskriptor, z. B. erwarten `fread`.  
  
 Das Betriebssystemhandle möglicherweise geöffnet wurden synchron oder asynchron ausgeführt wird, je nachdem, welche `FileStream` Klassenkonstruktor aufgerufen wurde. Verwenden der <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft, um zu ermitteln, ob dieses Handle asynchron geöffnet wurde. In Win32 Dies bedeutet, dass das Handle geöffnet wurde, für überlappende e/a und andere Parameter für erfordert `ReadFile` und `WriteFile`.  
  
> [!CAUTION]
>  Datenverluste auftreten, wenn eine `FileStream` ist dessen Handle übergeben wird, ein Vorgang verschiebt das Handle der Dateizeiger, erstellt, und klicken Sie dann die `FileStream` erneut verwendet wird. Mehrere Threads können nicht problemlos gleichzeitig auf dieselbe Datei schreiben und `FileStream` Pufferung Code wird davon ausgegangen, dass es ausschließlich das Handle steuert. `FileStream`Dies unter Umständen Auslösen einer <xref:System.IO.IOException> Wenn `FileStream` erkennt, dass ein anderer Prozess den Dateizeiger verschoben wurde. Um dies zu vermeiden, Sie keine Daten schreiben in einen Teil der Datei, die `FileStream` möglicherweise gepuffert und Wiederherstellung den Dateizeiger am Speicherort, die er hatte, als Methoden auf zuletzt aufgerufenen `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="FileStream" /> asynchron oder synchron geöffnet wurde.</summary>
        <value>
          <see langword="true" />, wenn <see langword="FileStream" /> asynchron geöffnet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `IsAsync` Eigenschaft erkennt, ob die `FileStream` Handle asynchron geöffnet wurde, aktivieren den Code so die <xref:System.IO.FileStream.Handle%2A> Eigenschaft ordnungsgemäß. In Win32 `IsAsync` wird "true" bedeutet, dass das Handle geöffnet wurde, für überlappende e/a und erfordert daher verschiedene Parameter für `ReadFile` und `WriteFile`.  
  
 Bei der Erstellung einer Instanz von, geben Sie diesen Wert der <xref:System.IO.FileStream> -Klasse mit einem Konstruktor, verfügt ein `isAsync`, `useAsync`, oder `options` Parameter. Wenn die Eigenschaft den Wert `true`, der Datenstrom nutzt überlappender e/a, um die Dateivorgänge asynchron ausführen. Allerdings die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft hat keine werden `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft ist `false` und rufen Sie den asynchronen Lesevorgang und Schreibvorgänge, die UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des Streams in Bytes ab.</summary>
        <value>Ein Long-Wert, der die Länge des Streams in Bytes darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Length` und `Position` Eigenschaften für eine End-of-File-Bedingung überprüfen.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" />ist für diesen Stream <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, z. B. wurde die Datei geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu sperrenden Bereichs. Der Wert dieses Parameters muss größer oder gleich 0 sein.</param>
        <param name="length">Der zu sperrende Bereich.</param>
        <summary>Verhindert, dass andere Prozesse im <see cref="T:System.IO.FileStream" /> lesen oder schreiben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Sperren eines Bereichs eines Dateidatenstroms erhält die Threads mit der Sperren exklusiven Zugriff auf dieses Bereichs des Dateidatenstroms.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Teil einer Datei zu sperren, sodass ein anderer Prozess auf, dass ein Teil der Datei zugreifen kann, obwohl sie Lese-/Schreibzugriff auf die Datei hat. Führen Sie das Programm gleichzeitig in verschiedenen Befehlsfenstern und untersuchen Sie der verschiedenen Konsole Eingabeoptionen verwenden.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der Prozess kann nicht auf die Datei zugreifen, da sie teilweise von einem anderen Prozess gesperrt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des <see langword="FileStream" /> ab, der an den Konstruktor übergeben wurde.</summary>
        <value>Eine Zeichenfolge, die den Namen des <see langword="FileStream" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position dieses Streams ab oder legt diese fest.</summary>
        <value>Die aktuelle Position dieses Streams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Suchvorgänge, die an einem beliebigen Speicherort überschreitet die Länge des Streams wird unterstützt.  Wenn Sie die Länge der Datei suchen, wächst die Dateigröße.  In Microsoft Windows NT und neueren Betriebssystemen ist bis zum Ende der Datei hinzugefügten Daten auf 0 (null) festgelegt.  In Microsoft Windows 98 oder früher, werden bis zum Ende der Datei hinzugefügten Daten nicht auf 0 (null), festgelegt, d. h., die zuvor Daten gelöscht sichtbar, in den Stream ist. Festlegen der Position im Stream auf einen hohen Wert hinter dem Ende des Streams in Windows 98 oder früher kann dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Length` und `Position` Eigenschaften für eine End-of-File-Bedingung überprüfen.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vom Stream wird Suchen nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
 \- oder –  
  
 Die Position wurde auf einen sehr großen Wert festgelegt, der das Ende des Streams in Windows 98 oder früher überschreitet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, die Position auf einen negativen Wert festzulegen.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Es wurde versucht, über das Ende eines Streams hinaus zu suchen, der dies nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Enthält nach Rückkehr dieser Methode das angegebene Bytearray mit den Werten zwischen <c>Offset</c> und (<c>Offset</c> + <c>Anzahl</c> - 1<c>)</c> durch die aus der aktuellen Quelle gelesenen Bytes ersetzt.</param>
        <param name="offset">Der Byteoffset im <c>Array</c> an dem die gelesenen Bytes platziert werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <summary>Liest einen Byteblock aus dem Stream und schreibt die Daten in einen angegebenen Puffer.</summary>
        <returns>Die Gesamtanzahl der in den Puffer gelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Read%2A>.  
  
 Die `offset` -Parameter gibt den Offset des Bytes in `array` (Pufferindex) ab dem gelesen werden soll und die `count` Parameter gibt die maximale Anzahl von Bytes, die aus diesem Stream gelesen werden. Der zurückgegebene Wert ist die tatsächliche Anzahl der gelesenen Bytes oder 0 (null), wenn das Ende des Streams erreicht ist. Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der gelesenen Bytes erweiterte. Wenn eine Ausnahme auftritt, ist die aktuelle Position im Stream nicht geändert.  
  
 Die <xref:System.IO.FileStream.Read%2A> Methode gibt 0 (null) erst nach dem Ende des Streams erreicht. Andernfalls <xref:System.IO.FileStream.Read%2A> liest immer mindestens ein Byte aus dem Stream vor der Rückgabe. Wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf von sind <xref:System.IO.FileStream.Read%2A>, die Methode blockiert, bis mindestens 1 Byte Daten zurückgegeben werden kann. Eine Implementierung kann weniger Bytes als angefordert zurückgeben, selbst wenn das Ende des Streams nicht erreicht wurde.  
  
 Verwendung <xref:System.IO.BinaryReader> zum Lesen von primitiven Datentypen.  
  
 Unterbrochen Sie einen Thread, der einen Lesevorgang ausführt wird nicht. Obwohl die Anwendung scheinbar ordnungsgemäß erfolgreich ausgeführt wird, nachdem der Thread nicht blockiert ist, kann die Unterbrechung Leistung und Zuverlässigkeit der Anwendung verringern.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel liest den Inhalt aus einem <xref:System.IO.FileStream> und schreibt ihn in eine andere <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den die Daten geschrieben werden sollen.</param>
        <param name="offset">Der Byteoffset im <c>Puffer</c> ab dem Daten aus dem Stream geschrieben.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="cancellationToken">Das Token zum überwachen von Abbruchanforderungen .</param>
        <summary>Liest eine Folge von Bytes asynchron aus dem aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden. Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.ReadAsync%2A> Methode können Sie ressourcenintensive Dateivorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]-App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden verwendet, in Verbindung mit der `async` und `await` in Visual Basic und C#-Schlüsselwörter.  
  
 Verwenden der <xref:System.IO.FileStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie asynchron aus einer Datei gelesen werden.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein Byte aus der Datei und erhöht die Leseposition um ein Byte.</summary>
        <returns>Das Byte, das in <see cref="T:System.Int32" /> umgewandelt wurde, oder -1, wenn das Ende des Streams erreicht wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Schreiben von Daten in eine Datei byteweise, und überprüfen, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der aktuelle Stream wird geschlossen.</exception>
        <block subset="none" type="overrides">
          <para>Die standardmäßige Implementierung auf <see langword="Stream" /> erstellt ein neues Single-Byte-Array und ruft dann <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Während dies formal richtig ist, ist es ineffizient. Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizienter Version, die den Puffer direkt, liest die Zuordnung zusätzlichen Array bei jedem Aufruf zu vermeiden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />-Objekt ab, das das Dateihandle des Betriebssystems für die Datei darstellt, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</summary>
        <value>Ein Objekt, das das Dateihandle des Betriebssystems für die Datei darstellt, von der das aktuelle <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.SafeFileHandle%2A> Eigenschaft automatisch entleert den Stream und legt die aktuelle Streamposition auf 0 fest.  Dadurch kann die Datei verschoben werden soll oder die Position im Stream durch einen anderen Stream mit zurückgesetzt werden die <xref:System.IO.FileStream.SafeFileHandle%2A> von dieser Eigenschaft zurückgegeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes.  
  
 Sicherheitsaktion: Linkaufruf  
  
 Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Der Punkt relativ zu <c>Ursprung</c> aus dem gesucht werden soll.</param>
        <param name="origin">Gibt den Anfang, am Ende oder die aktuelle Position als Bezugspunkt für <c>Offset</c>, anhand eines Werts vom Typ <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Legt die aktuelle Position dieses Streams auf den angegebenen Wert fest.</summary>
        <returns>Die neue Position im Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Suchvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Sie können an einem beliebigen Speicherort überschreitet die Länge des Streams gesucht. Wenn Sie die Länge der Datei suchen, wächst die Dateigröße. In Windows NT und höheren Versionen werden am Ende der Datei hinzugefügte Daten auf NULL festgelegt. In Windows 98 oder früher werden am Ende der Datei hinzugefügte Daten nicht auf 0 (null), festgelegt, d. h., die zuvor Daten gelöscht sichtbar, in den Stream ist.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Schreiben von Daten in eine Datei byteweise, und überprüfen, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Das folgende Beispiel liest Text in umgekehrter Richtung vom Ende der Datei an den Anfang der Datei mit den verschiedenen <xref:System.IO.SeekOrigin> Werte mit der <xref:System.IO.FileStream.Seek%2A> Methode.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.NotSupportedException">Der Datenstrom unterstützt keine Suchvorgänge, z. B. wenn die <see langword="FileStream" /> aus einer Pipe- oder Konsolenausgabe Ausgabe erstellt wird.</exception>
        <exception cref="T:System.ArgumentException">Es wird versucht, vor Beginn des Streams eine Suche auszuführen.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Ein Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf die aktuelle Datei angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt beschriebene Einträge in Zugriffssteuerungslisten auf die Datei an, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.IO.FileStream> Klasse und <xref:System.IO.FileStream.SetAccessControl%2A> kann auf einer vorhandenen Datei verwendet werden, sollten Sie die <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> -Methode ist einfacher zu verwenden.  
  
 Die <xref:System.IO.FileStream.SetAccessControl%2A> Methode gilt Einträge Access Control List (ACL) für eine Datei, die nicht geerbte Zugriffssteuerungsliste darstellt.  
  
> [!CAUTION]
>  Die ACL angegeben, für die `fileSecurity` Parameter ersetzt die vorhandene Zugriffssteuerungsliste für die Datei. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden die <xref:System.IO.FileStream.GetAccessControl%2A> Methode zum Abrufen der vorhandenen ACL, ändern und verwenden Sie dann <xref:System.IO.FileStream.SetAccessControl%2A> , wieder in der Datei anzuwenden.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="fileSecurity" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei konnte nicht gefunden oder geändert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff zum Öffnen der Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die neue Länge des Streams.</param>
        <summary>Legt die Länge dieses Streams auf den angegebenen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.SetLength%2A>.  
  
 Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten. In diesem Szenario wird die aktuelle Position größer als die neue Länge wird die aktuelle Position das letzte Byte des Datenstroms verschoben. Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert und bleibt unverändert, die aktuelle Position. Wenn der Stream erweitert wird, sind den Inhalt des Streams zwischen der alten und die neue Länge nicht definiert.  
  
 Ein Stream muss Schreib- und Suchvorgänge für unterstützen `SetLength` arbeiten.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt und die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft, um zu bestimmen, ob Suchvorgänge unterstützt werden. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A> und <xref:System.IO.Stream.CanSeek%2A>.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, die <paramref name="value" /> Parameter kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu entsperrenden Bereichs.</param>
        <param name="length">Der zu entsperrende Bereich.</param>
        <summary>Ermöglicht anderen Prozessen den Zugriff auf die gesamte Datei oder einen Teil der Datei, die zuvor gesperrt war.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sperren Teil einer Datei, einem anderen Prozess kann nicht, dass ein Teil der Datei zugreifen, obwohl sie Lese-/Schreibzugriff auf die Datei hat, und klicken Sie dann den angegebenen Teil der Datei zu entsperren. Führen Sie das Programm gleichzeitig in verschiedenen Befehlsfenstern und untersuchen Sie der verschiedenen Konsole Eingabeoptionen verwenden.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <c>Array</c> aus dem Bytes in den Stream kopiert werden soll.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Schreibt einen Block von Bytes in den Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Write%2A>.  
  
 Die `offset` -Parameter gibt den Offset des Bytes in `array` (Pufferindex) ab dem kopiert wird, und die `count` -Parameter gibt die Anzahl der Bytes, die in den Stream geschrieben werden. Wenn der Schreibvorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes erweiterte. Wenn eine Ausnahme auftritt, ist die aktuelle Position im Stream nicht geändert.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
 Unterbrochen Sie einen Thread, der einen Schreibvorgang ausführt wird nicht. Obwohl die Anwendung scheinbar ordnungsgemäß erfolgreich ausgeführt wird, nachdem der Thread nicht blockiert ist, kann die Unterbrechung Leistung und Zuverlässigkeit der Anwendung verringern.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
 \- oder –  
  
 Ein anderer Thread hat möglicherweise eine unerwartete Änderung der Position des Dateihandles des Betriebssystems verursacht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Die aktuelle Streaminstanz unterstützt keine Schreibvorgänge.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, aus dem Daten geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <c>Puffer</c> aus dem Bytes in den Stream kopiert werden soll.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <param name="cancellationToken">Das Token zum überwachen von Abbruchanforderungen .</param>
        <summary>Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.WriteAsync%2A> Methode können Sie ressourcenintensive Dateivorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]-App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden verwendet, in Verbindung mit der `async` und `await` in Visual Basic und C#-Schlüsselwörter.  
  
 Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie asynchron in eine Datei geschrieben wird.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Ein Byte, das in den Stream geschrieben werden soll.</param>
        <summary>Schreibt ein Byte an die aktuelle Position im Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.WriteByte%2A>.  
  
 Verwendung `WriteByte` einen Byte, das Schreiben einer `FileStream` effizient. Wenn der Stream geschlossen oder schreibgeschützt ist, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Schreiben von Daten in eine Datei byteweise, und überprüfen, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <block subset="none" type="overrides">
          <para>Die standardmäßige Implementierung auf <see langword="Stream" /> erstellt ein neues Single-Byte-Array und ruft dann <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Während dies formal richtig ist, ist es ineffizient. Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizienter Version, die den Puffer direkt, liest die Zuordnung zusätzlichen Array bei jedem Aufruf zu vermeiden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
