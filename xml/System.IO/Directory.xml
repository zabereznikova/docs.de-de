<Type Name="Directory" FullName="System.IO.Directory">
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Macht statische Methoden zum Erstellen, Verschieben und Auflisten in Verzeichnissen und Unterverzeichnissen verfügbar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/io/directory.cs#b3ad5f0ba800bb28). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Verwenden der <xref:System.IO.Directory> Klasse für normale Vorgänge wie kopieren, verschieben, umbenennen, erstellen und Löschen von Verzeichnissen.  
  
-   Um ein Verzeichnis zu erstellen, verwenden Sie eines der <xref:System.IO.Directory.CreateDirectory%2A> Methoden.  
  
-   Um ein Verzeichnis zu löschen, verwenden Sie eines der <xref:System.IO.Directory.Delete%2A> Methoden.  
  
-   Verwenden Sie zum Abrufen, oder legen Sie das aktuelle Verzeichnis für eine app, die <xref:System.IO.Directory.GetCurrentDirectory%2A> oder <xref:System.IO.Directory.SetCurrentDirectory%2A> Methode.  
  
-   Zum Bearbeiten von <xref:System.DateTime> Informationen im Zusammenhang mit der Erstellung Zugriff und das Schreiben eines Verzeichnisses verwenden Methoden wie <xref:System.IO.Directory.SetLastAccessTime%2A> und <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Die statischen Methoden von der <xref:System.IO.Directory> Klasse sicherheitsüberprüfungen für alle Methoden durchzuführen. Wenn Sie ein Objekt mehrmals wiederverwenden möchten, sollten Sie mit der entsprechenden Instanzmethode der <xref:System.IO.DirectoryInfo> stattdessen, da die sicherheitsüberprüfung wird nicht immer erforderlich sein.  
  
 Falls Sie nur eine Verbindung mit dem Directory Aktion ausführen, ist es möglicherweise effizienter, eine statische <xref:System.IO.Directory> -Methode, anstatt eine entsprechende <xref:System.IO.DirectoryInfo> -Instanzmethode. Die meisten <xref:System.IO.Directory> Methoden erfordern, den Pfad zu dem Verzeichnis, das Sie bearbeiten.  
  
> [!NOTE]
>  Bei Membern, die eine Zeichenfolge akzeptiert `path` -Parameter, dass der Pfad muss wohlgeformt sein oder eine Ausnahme ausgelöst. Z. B. wenn ein Pfad vollqualifizierte ist aber mit einem Leerzeichen ("c:\temp") beginnt, ist nicht die Pfadzeichenfolge gekürzt, damit der Pfad als beschädigt betrachtet wird und eine Ausnahme ausgelöst wird. Darüber hinaus kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert sein. "C:\temp c:\windows" wird z. B. auch eine Ausnahme auslöst. Stellen Sie sicher, dass die Pfade wohlgeformt sind, wenn Sie Methoden verwenden, die eine Pfadzeichenfolge akzeptieren. Weitere Informationen finden Sie unter <xref:System.IO.Path>.  
  
 Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad in einer Datei oder ein Verzeichnis verweisen. Sie können einen vollständigen Pfad, ein relativer Pfad oder einen Pfad (UNC = Universal Naming Convention) für einen Server und Freigabe verwenden. Beispielsweise sind alle folgenden Pfade zulässig:  
  
-   "" c: "\\\MyDir" in C#- oder "c:\MyDir" in Visual Basic.  
  
-   "" MyDir "\\\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in C#- oder "\\\MyServer\MyShare" in Visual Basic.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff auf neue Verzeichnisse für alle Benutzer. Allerdings muss die app die richtige Sicherheit den Zugriff auf vorhandene Verzeichnisse sein.  
  
 Berechtigungen für ein Verzeichnis und alle Unterverzeichnisse, Ende die Pfadzeichenfolge mit dem Verzeichnistrennzeichen fordern. (Z. B. "C:\Temp\\" C:\Temp\ und alle Unterverzeichnisse Zugriff gewährt.) Bei Bedarf Berechtigungen nur für ein bestimmtes Verzeichnis End die Pfadzeichenfolge mit einem Punkt. (Z. B. "C:\Temp\\." gewährt den Zugriff nur auf C:\Temp\\und nicht auf seinen Unterverzeichnissen.)  
  
 Bei Membern, akzeptieren ein `searchPattern` Parameter, die zu suchende Zeichenfolge kann eine beliebige Kombination von literalen Zeichen und Platzhalterzeichen; \* und?. Dieser Parameter werden reguläre Ausdrücke nicht erkannt. Weitere Informationen finden Sie unter der <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> Methode oder eine beliebige andere Methode, verwendet der `searchPattern` Parameter.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory>und <xref:System.IO.DirectoryInfo> können nicht für die Verwendung in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps. Informationen zum Zugriff auf Dateien und Ordner im [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, finden Sie unter [den Zugriff auf Daten und Dateien (Windows Store-apps)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie alle Textdateien aus einem Verzeichnis abgerufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.EnumerateFiles%2A> Methode, um eine Auflistung von Textdateien in einem Verzeichnis abzurufen, und verwenden diese Sammlung in einer Abfrage, um alle Zeilen zu suchen, die "Beispiel" enthalten.  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und alle zugehörigen Dateien in ein neues Verzeichnis verschieben. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <summary>Erstellt alle Verzeichnisse und Unterverzeichnisse im angegebenen Pfad, es sei denn, sie sind bereits vorhanden.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Verzeichnisse im angegebenen `path` erstellt werden, es sei denn, sie sind bereits vorhanden, oder eines Teils der `path` ist ungültig. Wenn das Verzeichnis bereits vorhanden ist, diese Methode ein neues Verzeichnis nicht erstellt, aber es gibt eine <xref:System.IO.DirectoryInfo> -Objekt für das vorhandene Verzeichnis.  
  
 Die `path` Parameter gibt einen Verzeichnispfad aufweist, keinen Dateipfad.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Erstellen des Verzeichnisses.  
  
 Sie können ein Verzeichnis auf einem Remotecomputer, auf eine Freigabe erstellen, die Sie über Schreibzugriff auf. UNC-Pfade werden unterstützt. Sie können beispielsweise angeben, für die folgende `path`: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C# geschrieben.  
  
 Erstellen ein Verzeichnis mit nur das Doppelpunktzeichen (:)) wird nicht unterstützt und führt dazu, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt und löscht das angegebene Verzeichnis.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Erstellen Sie das Verzeichnis C:\Users\User1\Public\Html aus, wenn das aktuelle Verzeichnis C:\Users\User1 ist, verwenden Sie keines der folgenden Aufrufe, stellen Sie sicher, dass der umgekehrte Schrägstrich richtig interpretiert wird.  
  
 In Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 In C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 In C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  
  
 - oder -   
  
 Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 - oder -   
  
 <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />enthält einen Doppelpunkt (:)), die nicht Teil einer laufwerksbezeichnung ("" c: "\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien oder Verzeichnisse. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <param name="directorySecurity">Die Zugriffssteuerung, die auf das Verzeichnis angewendet werden soll.</param>
        <summary>Erstellt alle Verzeichnisse im angegebenen Pfad, sofern diese nicht bereits vorhanden sind, und übernimmt die angegebene Windows-Sicherheit.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um erstellen Sie ein Verzeichnis mit der Zugriffssteuerung, daher ist es nicht möglich, die das Verzeichnis zugegriffen werden kann, bevor Sicherheit angewendet wird.  
  
 Alle Verzeichnisse im angegebenen der `path` Parameter erstellt, es sei denn, sie sind bereits vorhanden, oder eines Teils der `path` ist ungültig. Die `path` Parameter gibt einen Verzeichnispfad aufweist, keinen Dateipfad. Wenn das Verzeichnis bereits vorhanden ist, diese Methode ein neues Verzeichnis nicht erstellt, aber es gibt eine <xref:System.IO.DirectoryInfo> -Objekt für das vorhandene Verzeichnis.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Erstellen des Verzeichnisses.  
  
 Sie können ein Verzeichnis auf einem Remotecomputer, auf eine Freigabe erstellen, die Sie über Schreibzugriff auf. UNC-Pfade werden unterstützt. Sie können beispielsweise angeben, für die folgende `path`: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C# geschrieben.  
  
 Erstellen ein Verzeichnis mit nur das Doppelpunktzeichen (:)) wird nicht unterstützt und bewirkt, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Verzeichnis mit Zugriffsregeln für zwei Benutzerkonten.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  
  
 - oder -   
  
 Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 - oder -   
  
 <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />enthält einen Doppelpunkt (:)), die nicht Teil einer laufwerksbezeichnung ("" c: "\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien und Verzeichnissen und für den Zugriff auf das Zielverzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> Sicherheitsaktion:<see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden leeren Verzeichnisses. Dieses Verzeichnis muss schreibbar und leer sein.</param>
        <summary>Löscht ein leeres Verzeichnis aus einem angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verhält sich genauso wie <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> mit `false` für den zweiten Parameter angegeben.  
  
 Die `path` Parameter kann ein relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Löschen des Verzeichnisses.  
  
 Diese Methode löst eine <xref:System.IO.IOException> in das Verzeichnis angegeben der `path` Parameter enthält, Dateien oder Unterverzeichnisse.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 In einigen Fällen, wenn Sie das angegebene Verzeichnis im Datei-Explorer geöffnet haben die <xref:System.IO.Directory.Delete%2A> Methode kann nicht in der Lage, zu löschen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie ein neues Verzeichnis und Unterverzeichnis erstellen und löschen Sie nur das Unterverzeichnis wird.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  
  
 - oder -   
  
 Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
 - oder -   
  
 Das durch <paramref name="path" /> angegebene Verzeichnis ist nicht leer.  
  
 - oder -   
  
 Das Verzeichnis ist schreibgeschützt oder enthält eine schreibgeschützte Datei.  
  
 - oder -   
  
 Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  
  
 - oder -   
  
 Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden Verzeichnisses.</param>
        <param name="recursive">
          <see langword="true" />Entfernen von Verzeichnissen, Unterverzeichnissen und Dateien in <c>Pfad</c>ist, andernfalls <see langword="false" />.</param>
        <summary>Löscht das angegebene Verzeichnis und, sofern angegeben, alle Unterverzeichnisse und Dateien im Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter kann ein relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Löschen des Verzeichnisses.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Wenn die `recursive` Parameter ist `true`, der Benutzer muss über Schreibberechtigungen für das aktuelle Verzeichnis als auch für alle Unterverzeichnisse verfügen.  
  
 Das Verhalten dieser Methode unterscheidet sich geringfügig, wenn Sie ein Verzeichnis löschen, die einen Analysepunkt, z. B. eine symbolische Verknüpfung oder einen Bereitstellungspunkt enthält. Wenn der Analysepunkt ein Verzeichnis ist, z. B. einen Bereitstellungspunkt aufgehoben wird, und der Bereitstellungspunkt wird gelöscht. Diese Methode wird der Analysepunkt nicht durchsucht. Der Analysepunkt wird gelöscht, ist der Analysepunkt einen symbolischen Link mit einer Datei, und nicht das Ziel der symbolischen Verknüpfung.  
  
 In einigen Fällen, wenn Sie das angegebene Verzeichnis im Datei-Explorer geöffnet haben die <xref:System.IO.Directory.Delete%2A> Methode kann nicht in der Lage, zu löschen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie ein neues Verzeichnis, die Unterverzeichnis und die Datei im Unterverzeichnis erstellen, und klicken Sie dann rekursiv die neuen Elemente löschen.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  
  
 - oder -   
  
 Das von <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt, oder <paramref name="recursive" /> ist <see langword="false" />, und <paramref name="path" /> ist kein leeres Verzeichnis.  
  
 - oder -   
  
 Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
 - oder -   
  
 Das Verzeichnis enthält eine schreibgeschützte Datei.  
  
 - oder -   
  
 Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  
  
 - oder -   
  
 Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, relative oder absolute Pfad die Informationen in den `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die zurückgegebenen Verzeichnisnamen vorangestellt der Wertanbieter das `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` -Parameter, die zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Verzeichnisse der obersten Ebene in einem angegebenen Pfad.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegebenen wird und der angegebene Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können angeben, relative oder absolute Pfad die Informationen in den `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die zurückgegebenen Verzeichnisnamen vorangestellt der Wertanbieter das `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` -Parameter, die zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet Verzeichnisse der obersten Ebene in einem angegebenen Pfad, die einem angegebenen Suchmuster entsprechen.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  
  
 Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|Genau ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können angeben, relative oder absolute Pfad die Informationen in den `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die zurückgegebenen Verzeichnisnamen vorangestellt der Wertanbieter das `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` -Parameter, die zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Verzeichnisse in einem angegebenen Pfad, die einem angegebenen Suchmuster entsprechen. Er verwendet die `searchOption` Parameter fest, dass alle Unterverzeichnisse in die Suche einbezogen werden sollen.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie auf alle Dateien in einem Verzeichnis abzurufen und auf ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Das folgende Beispiel listet die Dateien im angegebenen Verzeichnis auf jede Zeile der Datei liest und die Zeile angezeigt, wenn sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, das von <paramref name="path" /> angegebenen wird und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie auf alle Textdateien in einem Verzeichnis abzurufen und auf ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel wird die Dateien im angegebenen Verzeichnis aufgeführt werden, die eine Erweiterung ".txt" aufweisen, liest alle Zeilen der Datei und Zeile angezeigt, wenn sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  
  
 Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die Textdateien in einem Verzeichnis und seinen Unterverzeichnissen abgerufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, ist sie nicht mehr in den ursprünglichen Verzeichnissen vorhanden.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Das folgende Beispiel rekursiv alle Dateien aufgeführt werden, die eine Erweiterung ".txt" aufweisen, liest alle Zeilen der Datei und Zeile angezeigt, wenn sie die Zeichenfolge "Microsoft" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen im von <paramref name="path" /> angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateisystemeinträgen in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`...  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung von Dateisystemeinträgen in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  
  
 Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Bei jedem Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Bestimmt, ob der angegebene Pfad auf ein vorhandenes Verzeichnis auf einem Datenträger verweist.</summary>
        <returns>
          <see langword="true" />, wenn sich <paramref name="path" /> auf ein vorhandenes Verzeichnis bezieht; <see langword="false" />, wenn ein Verzeichnis nicht vorhanden ist, oder wenn beim Versuch festzustellen, ob ein angegebenes Verzeichnis vorhanden ist, ein Fehler auftritt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Überprüfen, ob das Verzeichnis vorhanden ist.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Wenn Sie nicht mindestens über eine nur-Lese Berechtigung in das Verzeichnis verfügen die <xref:System.IO.Directory.Exists%2A> Methode zurück `false`.  
  
 Die <xref:System.IO.Directory.Exists%2A> -Methode zurückkehrt `false` Wenn ein Fehler auftritt, bei dem Versuch, um festzustellen, ob die angegebene Datei vorhanden ist. Dies kann auftreten, in Situationen, in denen Auslösen von Ausnahmen, z. B. ein Dateiname ungültige Zeichen oder zu viele Zeichen, d. h. einen fehlerhaften oder fehlenden Datenträger übergeben oder wenn der Aufrufer nicht über die Berechtigung zum Lesen der Datei.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von Datei-bzw. Verzeichnisnamen in der Befehlszeile, bestimmt die Art des Namens ist und verarbeitet sie entsprechend.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Dateien. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die ACL-Einträge für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode, um das die Einträge in der Zugriffssteuerungsliste für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen, oder, die Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis verfügen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetAccessControl%2A> und <xref:System.IO.Directory.SetAccessControl%2A> Methoden zum Hinzufügen von ein Eintrag in der Liste (ACL) zu steuern und entfernen Sie einen ACL-Eintrag in einem Verzeichnis.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Die spezifische Ausnahme ist möglicherweise eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="path" /> Parameter angegeben, ein Verzeichnis, die schreibgeschützt ist.  
  
 - oder -   
  
 Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 - oder -  
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Sicherheitsaktion: Anforderung.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <param name="includeSections">Einer der <see cref="T:System.Security.AccessControl.AccessControlSections" />-Werte, der den Typ der zu empfangenden ACL-Informationen angibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die angegebenen Typen von Einträgen in einer Zugriffssteuerungsliste für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode, um das die Einträge in der Zugriffssteuerungsliste für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen, oder, die Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis verfügen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Die spezifische Ausnahme ist möglicherweise eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <paramref name="path" /> Parameter angegeben, ein Verzeichnis, die schreibgeschützt ist.  
  
 - oder -   
  
 Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 - oder -  
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Sicherheitsaktion: Anforderung.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft Datum und Zeit der Erstellung eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Diese Methode entspricht <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Erstellungszeit des angegebenen Verzeichnisses ab.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC).  
  
 Verwenden Sie diese Methode, um den Zeitpunkt der Erstellung eines Verzeichnisses basierend auf der koordinierten Weltzeit (UTC) zu erhalten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das aktuelle Arbeitsverzeichnis der Anwendung ab.</summary>
        <returns>Eine Zeichenfolge, die den Pfad des aktuellen Arbeitsverzeichnisses enthält und endet nicht mit einem umgekehrten Schrägstrich (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das aktuelle Verzeichnis unterscheidet sich von das ursprüngliche Verzeichnis, das Sie aus dem der Prozess gestartet wurde.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetCurrentDirectory`-Methode veranschaulicht.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows CE, das keine Funktionalität für das aktuelle Verzeichnis enthält.  
  
 Diese Methode ist in .NET Compact Framework verfügbar, wird aber derzeit nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse im angegebenen Pfad, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> durch ein Sternchen (\*) als das Suchmuster angegeben, daher wird auch alle Unterverzeichnisse. Wenn Unterverzeichnisse durchsucht werden müssen, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> -Methode, die Ihnen ermöglicht, geben Sie Suche der Unterverzeichnisse mit den `searchOption` Parameter.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die `path` Parameter kann relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die von dieser Methode zurückgegebenen Namen vorangestellt Verzeichnisinformationen in bereitgestellten `path`.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von Datei-bzw. Verzeichnisnamen in der Befehlszeile, bestimmt die Art des Namens ist und verarbeitet sie entsprechend.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in Übereinstimmungen <c>Pfad</c>. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, er unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen von Unterverzeichnissen (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die dem Suchmuster im angegebenen Verzeichnis entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Unterverzeichnisse direkt unter dem angegebenen Verzeichnis, die das angegebenen Suchmuster entsprechen. Wenn das angegebene Verzeichnis keine Unterverzeichnisse ist, oder es keine Unterverzeichnisse entsprechen den `searchPattern` Parameter dieser Methode ein leeres Array zurück. Es wird nur die oberste Verzeichnis durchsucht. Wenn auch die Unterverzeichnisse durchsucht werden sollen, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> Methode, und geben Sie <xref:System.IO.SearchOption.AllDirectories> in der `searchOption` Parameter.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Die `path` Parameter können Informationen der relative oder absolute Pfad angeben, und ist nicht in der Groß-/Kleinschreibung beachtet.  Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Verzeichnisse in einem Pfad, die mit dem angegebenen Buchstaben beginnen.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe von <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 - oder -   
  
 <paramref name="searchPattern" />Sie enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in Übereinstimmungen <c>Pfad</c>. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, er unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) zurück, die dem angegebenen Suchmuster im aktuellen Verzeichnis entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die den angegebenen Kriterien entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter können Informationen der relative oder absolute Pfad angeben, und ist nicht in der Groß-/Kleinschreibung beachtet. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Verzeichnisse, die mit dem angegebenen Buchstaben in einem Pfad zu beginnen. Das Verzeichnis der obersten Ebene wird durchsucht.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 - oder -   
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad einer Datei oder eines Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides zurück.</summary>
        <returns>Eine Zeichenfolge, die für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den voll gekennzeichneten Pfadnamen der `path`, wie vom <xref:System.IO.Path.GetFullPath%2A>, und gibt Informationen zum Stammverzeichnis. Der angegebene Pfad ist nicht erforderlich, vorhanden sein.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Festlegen von aktuellen Verzeichnis und den Verzeichnisstamm anzuzeigen.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien (einschließlich des Pfads) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) für die Dateien im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebenen Dateinamen angehängt werden auf die angegebene `path` Parameter.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> durch ein Sternchen (\*) als das Suchmuster angegeben.  
  
 Die `path` Parameter kann relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht sichergestellt; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetFiles%2A> Methode, um die Dateinamen von einem Benutzer angegebenen Speicherort zurück. Im Beispiel ist für alle Fehler abgefangen werden, die diese Methode gemeinsam konfiguriert.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  
  
 - oder -   
  
 Netzwerkfehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der zugehörigen Pfade), die dem angegebenen Suchmuster entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebenen Dateinamen angehängt werden auf die angegebene `path` Parameter und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert; verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
> [!NOTE]
>  Da diese Methode für den Dateinamen mit der 8.3-Namensformat und das Format des lange Datei eincheckt, ein Suchmuster "\*1\*".txt "" möglicherweise unerwartete Dateinamen zurück. Beispiel für die Verwendung von einem Suchmuster "\*1\*".txt "" "longfilename.txt" zurückgegeben, da das Äquivalent der 8.3-Namensformat "LONGFI ~ 1.txt" lautet.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die `path` Parameter kann relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Dateien, die mit dem angegebenen Buchstaben beginnen.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  
  
 - oder -   
  
 Netzwerkfehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe von <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 - oder -   
  
 <paramref name="searchPattern" />Sie enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen. Anhand eines Werts wird bestimmt, ob Unterverzeichnisse durchsucht werden sollen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der Pfade), die dem angegebenen Suchmuster und der Option entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angegebene Parameter werden die zurückgegebenen Dateinamen angehängt `path` und die Reihenfolge der zurückgegebenen Dateinamen ist nicht sichergestellt; verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei hingegen Suchmuster"Suchmuster"beide Dateien zurück.  
  
> [!NOTE]
>  Da diese Methode für den Dateinamen mit der 8.3-Namensformat und das Format des lange Datei eincheckt, ein Suchmuster "\*1\*".txt "" möglicherweise unerwartete Dateinamen zurück. Beispiel für die Verwendung von einem Suchmuster "\*1\*".txt "" "longfilename.txt" zurückgegeben, da das Äquivalent der 8.3-Namensformat "LONGFI ~ 1.txt" lautet.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen sein zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die Dateinamen enthalten den vollständigen Pfad an.  
  
 Die `path` Parameter kann relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" /> Methode.  
  
 - oder -   
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchpattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  
  
 - oder -   
  
 Es ist ein Netzwerkfehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien und Unterverzeichnisse in einem angegebenen Pfad zurück.</summary>
        <returns>Ein Array mit den Namen der Dateien und Unterverzeichnisse im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien oder Unterverzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht sichergestellt; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFileSystemEntries%2A> durch ein Sternchen (\*) als das Suchmuster angegeben.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A> Methode zu füllen ein Array von Zeichenfolgen mit den Namen aller Dateien und Unterverzeichnisse in einem benutzerdefinierten Speicherort und ausgegeben. jeder Zeichenfolgenwert im Array an die Konsole. Im Beispiel ist für alle Fehler abgefangen werden, die diese Methode gemeinsam konfiguriert.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <summary>Gibt ein Array von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht sichergestellt; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A> Methode zu füllen ein Array von Zeichenfolgen mit den Namen aller Dateien von einem benutzerdefinierten Filter in einem bestimmten Speicherort und die einzelnen Zeichenfolgen im Array an die Konsole ausgegeben. Im Beispiel ist für alle Fehler abgefangen werden, die diese Methode gemeinsam konfiguriert.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" /> Methode.  
  
 - oder -   
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in Übereinstimmungen <c>Pfad</c>.  Dieser Parameter darf eine Kombination aus gültigem Literalpfad und Platzhalterzeichen (* und?) Zeichen, aber sie unterstützt keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  
  
 Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt ein Array aller Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht sichergestellt; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern`kann eine Kombination von Literal-und Platzhalterzeichen, es unterstützt jedoch keine regulären Ausdrücke. Die folgenden Bezeichner für Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\*(Sternchen)|NULL oder mehr Zeichen an dieser Stelle.|  
|? (Fragezeichen)|0 (null) oder ein Zeichen an dieser Stelle.|  
  
 Zeichen als die Platzhalter sind Literalzeichen. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern`darf nicht mit enden zwei Punkte ("..") oder zwei Punkte ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, noch keine ungültigen Zeichen enthalten. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*".txt "", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, werden Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung von der-Methode zurückgegeben. Z. B. "\*xls" gibt "book.xls" und "book.xlsx" zurück.  
> -   In allen anderen Fällen erfolgt die Methodenrückgabe Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif".  
>   
>  Wenn Sie das Fragezeichen als Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, das Suchmuster "Datei?. TXT"gibt nur die erste Datei zurück, wohingegen Suchmuster" Datei\*".txt" "beide Dateien zurückgegeben.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund, wenn Sie arbeiten mit vielen Dateien und Verzeichnisse <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Sie können Informationen mit relativen Pfad angeben der `path` Parameter. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis, mit dem Sie zu ermittelnde interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />eine Zeichenfolge der Länge 0 (null) ist, enthält nur Leerzeichen oder enthält ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
 \- oder –  
  
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Diese Methode ist identisch mit <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" /> Methode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">Die <paramref name="path" /> Parameter weist ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">Die <paramref name="path" /> Parameter weist ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt des letzten Schreibzugriffs im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) auf die angegebenen Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen Sie die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Namen der logischen Laufwerke auf diesem Computer in der Form "&lt;Laufwerkbuchstaben&gt;:\\".</summary>
        <returns>Die logischen Laufwerke auf diesem Computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives gibt alle Laufwerke, auf die zugegriffen werden kann auf einen bestimmten Computer, einschließlich des Diskettenlaufwerks und optische Laufwerke zurück.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetLogicalDrives%2A> Methode ein Array von Zeichenfolgen die Namen der einzelnen Laufwerke auf dem aufrufenden Computer zuweisen. Jedes Element dieses Arrays Zeichenfolge wird dann auf der Konsole ausgegeben. Im Beispiel ist für alle Fehler abgefangen werden, die diese Methode gemeinsam konfiguriert.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, z. B. Aufrufen von systemeigenem Code mit PInvoke oder COM-Interop. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, dessen übergeordnetes Verzeichnis abgerufen werden soll.</param>
        <summary>Ruft das übergeordnete Verzeichnis des angegebenen Pfads ab, sowohl für absolute als auch für relative Pfade.</summary>
        <returns>	Das übergeordnete Verzeichnis oder <see langword="null" />, wenn <paramref name="path" />das Stammverzeichnis ist, einschließlich des Stammverzeichnisses eines UNC-Server- oder Freigabenamens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` -Parameter vor dem Abrufen des Verzeichnisses.  
  
 Die von dieser Methode zurückgegebene Zeichenfolge besteht aus allen Zeichen des Pfads bis zur, aber nicht einschließlich, der letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>. Angenommen, um die Übergabe des Pfads "C:\Directory\SubDirectory\test.txt" <xref:System.IO.Directory.GetParent%2A> "C:\Directory\SubDirectory" zurückgegeben. Übergeben "C:\Directory\SubDirectory" gibt "C:\Directory" zurück. Allerdings übergeben "C:\Directory\SubDirectory\\" gibt "C:\Directory\SubDirectory", da das letzte Verzeichnistrennzeichen nach "Unterverzeichnis" ist.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetParent%2A> Methode, um das übergeordnete Verzeichnis von einem Benutzer angegebenen Speicherort abrufen "Path". Der zurückgegebene Wert den <xref:System.IO.Directory.GetParent%2A> Methode ist, klicken Sie dann auf der Konsole ausgegeben. Im Beispiel ist für alle Fehler abgefangen werden, die diese Methode gemeinsam konfiguriert.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Durch angegebene Verzeichnis <paramref name="path" /> ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen aus Dateien oder Verzeichnisse. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Der Pfad der Datei oder des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destDirName">Der Pfad zum neuen Speicherort für <c>SourceDirName</c>. Wenn <c>SourceDirName</c> ist eine Datei, klicken Sie dann <c>DestDirName</c> muss auch ein Dateiname sein.</param>
        <summary>Verschiebt eine Datei oder ein Verzeichnis und dessen Inhalt an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt ein neues Verzeichnis mit dem Namen gemäß `destDirName` und verschiebt den Inhalt des `sourceDirName` in das neu erstellte Zielverzeichnis. Wenn Sie versuchen, ein Verzeichnis in ein Verzeichnis zu verschieben, die bereits vorhanden ist, ein <xref:System.IO.IOException> erfolgt. Beispielsweise wird eine Ausnahme ausgelöst, wenn Sie versuchen, c:\mydir nach c:\public zu verschieben und c:\public bereits vorhanden ist. Alternativ können Sie angeben "" c: "\\\public\\\mydir" als die `destDirName` -Parameter angeben, wenn "Mydir" nicht unter vorhanden ist "" c: "\\\public", oder geben Sie den Namen eines neuen Verzeichnisses z. B. "" c: "\\\newdir".  
  
 Die `sourceDirName` und `destDirName` -Argumenten relativer oder absoluter Pfad Angaben zur zulässig sind. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende der Path-Parameter vor dem Verschieben des Verzeichnis entfernt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und alle zugehörigen Dateien in ein neues Verzeichnis verschieben. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es wurde versucht, ein Verzeichnis auf ein anderes Volume zu verschieben.  
  
 - oder -   
  
 <paramref name="destDirName" /> ist bereits vorhanden.  
  
 - oder -   
  
 Die <paramref name="sourceDirName" /> und <paramref name="destDirName" /> Parameter verweisen auf dieselbe Datei oder dasselbe Verzeichnis.  
  
 - oder -   
  
 Das Verzeichnis oder eine darin enthaltene Datei wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" />oder <paramref name="destDirName" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirName" /> oder <paramref name="destDirName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die vom angegebenen Pfad <paramref name="sourceDirName" /> ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von <paramref name="sourceDirName" /> der und Schreiben in <paramref name="sourceDirName" /> und <paramref name="destDirName" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ein Verzeichnis, dem Einträge von Zugriffssteuerungslisten hinzugefügt oder aus diesem entfernt werden sollen.</param>
        <param name="directorySecurity">Ein <see cref="T:System.Security.AccessControl.DirectorySecurity" /> -Objekt, das einen ACL-Eintrag von beschriebene Verzeichnis angewendet wird beschrieben, die <c>Pfad</c> Parameter.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt beschriebene Einträge von Zugriffssteuerungslisten auf das angegebene Verzeichnis an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Directory.SetAccessControl%2A> Methode gilt Einträge Access Control List (ACL) für eine Datei, die nicht geerbte Zugriffssteuerungsliste darstellt.  
  
> [!CAUTION]
>  Die ACL angegeben, für die `directorySecurity` Parameter ersetzt die vorhandene Zugriffssteuerungsliste für das Verzeichnis. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden die <xref:System.IO.Directory.GetAccessControl%2A> Methode zum Abrufen der vorhandenen ACL, und ändern Sie sie.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen, oder, die Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis verfügen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.Directory.SetAccessControl%2A> Methode speichert nur <xref:System.Security.AccessControl.DirectorySecurity> Objekte, die nach der Erstellung des Objekts geändert wurden.  Wenn ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt wurde nicht verändert, wird nicht in einer Datei beibehalten werden.  Es ist daher nicht möglich, zum Abrufen einer <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus einer Datei, und wenden Sie das gleiche Objekt in eine andere Datei erneut an.  
  
 ACL-Informationen aus einer Datei in einen anderen zu kopieren:  
  
1.  Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode zum Abrufen der <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus der Quelldatei.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.DirectorySecurity> Objekt für die Zieldatei.  
  
3.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> Methode der Quelle <xref:System.Security.AccessControl.DirectorySecurity> Objekt, das die ACL-Informationen abzurufen.  
  
4.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Methode, um die Informationen zu kopieren, die in Schritt 3 in das Ziel abgerufenen <xref:System.Security.AccessControl.DirectorySecurity> Objekt.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt, das die Ziel-Datei mithilfe der <xref:System.IO.Directory.SetAccessControl%2A> Methode.  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetAccessControl%2A> und <xref:System.IO.Directory.SetAccessControl%2A> Methoden zum Hinzufügen von ein Eintrag in der Liste (ACL) zu steuern und entfernen Sie einen ACL-Eintrag in einem Verzeichnis.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directorySecurity" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> war ungültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff auf das Verzeichnis, das vom angegebenen <paramref name="path" />.  
  
 - oder -   
  
 Der aktuelle Prozess verfügt nicht über ausreichende Berechtigungen zum Festlegen des ACL-Eintrags.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Sicherheitsaktion: Anforderung.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einer Datei oder einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt für die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTimeUtc">Datum und Uhrzeit der Erstellung des Verzeichnisses oder der Datei. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) für die angegebene Datei oder das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, auf den das aktuelle Arbeitsverzeichnis festgelegt ist.</param>
        <summary>Legt das aktuelle Arbeitsverzeichnis der Anwendung auf das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung beendet wird, wird das Arbeitsverzeichnis wiederhergestellt, an ihrem ursprünglichen Speicherort (das Verzeichnis, in dem der Prozess gestartet wurde).  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden entfernt. am Ende der `path` Parameter vor dem Festlegen des Verzeichnisses.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Wenn Sie das Verzeichnis auf ein Laufwerk mit Wechselmedien, z. B. zu (für ein Diskettenlaufwerk "A:") oder "E:" für ein CD-ROM-Laufwerk festlegen, können Sie bestimmen, ob das Laufwerk bereit, mithilfe ist der <xref:System.IO.DriveInfo.IsReady%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Festlegen von aktuellen Verzeichnis und den Verzeichnisstamm anzuzeigen.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Zugreifen auf nicht verwalteten Code.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in Dateien oder Verzeichnisse. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTime">Ein Objekt mit dem Wert für Zugriffsdatum und-Zeitpunkt von festzulegende <c>Pfad</c>. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTimeUtc">Ein Objekt mit dem Wert für Zugriffsdatum und-Zeitpunkt von festzulegende <c>Pfad</c>. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt Datum und Zeit des letzten Schreibvorgangs in einem Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTimeUtc">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Schreibzugriffs auf ein Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" />Gibt einen Wert außerhalb des Bereichs von Datumsangaben oder Uhrzeiten, die für diesen Vorgang zulässig.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
