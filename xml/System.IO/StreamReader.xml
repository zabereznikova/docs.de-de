<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementiert einen <see cref="T:System.IO.TextReader" />, der Zeichen aus einem Bytestream in einer bestimmten Codierung liest.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/io/streamreader.cs#b5fe1efcec14de32). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 <xref:System.IO.StreamReader>für die Zeicheneingabe in einer bestimmten Codierung entworfen, wohingegen die <xref:System.IO.Stream> Klasse dient für Byte für ein- und Ausgabe. Verwendung <xref:System.IO.StreamReader> zum Lesen von Zeilen mit Informationen aus einer standard-Text-Datei.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
 <xref:System.IO.StreamReader>Der Standardwert ist UTF-8-Codierung, sofern nicht anders, anstatt die Standardwerte in die ANSI-Codepage für das aktuelle System angegeben. UTF-8-Unicode-Zeichen ordnungsgemäß behandelt und konsistente Ergebnisse lokalisierten Versionen des Betriebssystems enthält. Wenn Sie erhalten die aktuelle zeichencodierung mithilfe der <xref:System.IO.StreamReader.CurrentEncoding%2A> -Eigenschaft, der Wert ist nicht zuverlässig erst nach dem ersten <xref:System.IO.StreamReader.Read%2A> -Methode, da die automatische Erkennung Codierung nicht erst nach dem ersten Aufruf erfolgt eine <xref:System.IO.StreamReader.Read%2A> Methode.  
  
 Wird standardmäßig ein <xref:System.IO.StreamReader> ist nicht threadsicher. Finden Sie unter <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> für ein threadsicherer Wrapper.  
  
 Die <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> und <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> methodenüberladungen lesen und Schreiben Sie die Anzahl der Zeichen, die gemäß der `count` Parameter. Diese werden von <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> und <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, das Lesen und Schreiben Sie die Anzahl der Bytes, die gemäß der `count` Parameter. Verwenden der <xref:System.IO.BufferedStream> Methoden nur zum Lesen und Schreiben einer ganzzahligen Anzahl von Byte Array-Elemente.  
  
> [!NOTE]
>  Beim Lesen aus einem <xref:System.IO.Stream>, es ist jedoch effizienter, einen Puffer zu verwenden, die gleiche Größe wie die internen Puffer des Streams befindet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von <xref:System.IO.StreamReader> Text aus einer Datei zu lesen. In diesem Beispiel verwendete Konstruktor wird nicht unterstützt, für die Verwendung in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] Apps.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 Das folgende Beispiel instanziiert einen <xref:System.IO.StreamReader> -Objekt und ruft seine <xref:System.IO.StreamReader.ReadAsync%2A> Methode, um eine Datei asynchron zu lesen.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung auf <xref:System.Text.UTF8Encoding>, die <xref:System.IO.StreamReader.BaseStream%2A> Eigenschaft mit dem `stream` Parameter und die Größe des internen Puffers auf 1024 Bytes.  
  
 Die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />Lesevorgänge werden nicht unterstützt werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu lesende vollständige Dateipfad.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Dateinamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der vollständige Dateipfad angegeben ist, durch die `path` Parameter. Dieser Konstruktor initialisiert die Codierung auf <xref:System.Text.UTF8Encoding> und die Größe des Puffers auf 1024 Bytes.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; sie können einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt werden.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />enthält eine falsche oder ungültige Syntax für Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream mit der angegebenen Option zur Erkennung der Bytereihenfolgemarken.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung auf <xref:System.Text.UTF8Encoding>, die <xref:System.IO.StreamReader.BaseStream%2A> Eigenschaft mit dem `stream` Parameter und die Größe des internen Puffers auf 1024 Bytes.  
  
 Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />Lesevorgänge werden nicht unterstützt werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream und mit der angegebenen Zeichencodierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zeichencodierung wird festgelegt, indem die `encoding` Parameter und die Größe des Puffers auf 1024 Bytes festgelegt ist. Die <xref:System.IO.StreamReader> Objekt versucht, die Codierung durch einen Blick auf die ersten drei Bytes des Streams zu erkennen. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />Lesevorgänge werden nicht unterstützt werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der zu lesende vollständige Dateipfad.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Dateinamen mit der angegebenen Option zur Erkennung der Bytereihenfolgemarken.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung auf <xref:System.Text.UTF8Encoding>, die <xref:System.IO.StreamReader.BaseStream%2A> Eigenschaft mit dem `stream` Parameter und die Größe des internen Puffers auf 1024 Bytes.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; sie können einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt werden.  
  
 Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls die <xref:System.Text.UTF8Encoding> verwendet wird. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />enthält eine falsche oder ungültige Syntax für Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Der zu lesende vollständige Dateipfad.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Dateinamen und mit der angegebenen Zeichencodierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung gemäß der `encoding` Parameter und die Größe des internen Puffers auf 1024 Bytes. Die <xref:System.IO.StreamReader> Objekt versucht, die Codierung durch einen Blick auf die ersten drei Bytes des Streams zu erkennen. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; sie können einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt werden.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />enthält eine falsche oder ungültige Syntax für Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream mit der angegebenen Zeichencodierung und Option zur Erkennung der Bytereihenfolgemarken.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung gemäß der `encoding` Parameter, die <xref:System.IO.StreamReader.BaseStream%2A> Eigenschaft mit der `stream` Parameter und die Größe des internen Puffers auf 1024 Bytes.  
  
 Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />Lesevorgänge werden nicht unterstützt werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der zu lesende vollständige Dateipfad.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Dateinamen mit der angegebenen Zeichencodierung und Option zur Erkennung der Bytereihenfolgemarken.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung gemäß der `encoding` Parameter und die Größe des internen Puffers auf 1024 Bytes.  
  
 Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; sie können einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt werden.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />enthält eine falsche oder ungültige Syntax für Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <param name="bufferSize">Die Mindestgröße des Puffers.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream mit der angegebenen Zeichencodierung, Option zur Erkennung der Bytereihenfolgemarken und Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Puffergröße, Anzahl der 16-Bit-Zeichen wird festgelegt, durch die `bufferSize` Parameter. Wenn `bufferSize` ist kleiner als die zulässige Mindestgröße (128 Zeichen), wird die minimale zulässige Größe verwendet.  
  
 Mit diesem Konstruktor können Sie so ändern Sie die Codierung beim ersten Sie Auslesen der <xref:System.IO.StreamReader> Objekt. Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!NOTE]
>  Beim Lesen aus einem <xref:System.IO.Stream>, es ist jedoch effizienter, einen Puffer zu verwenden, die gleiche Größe wie die internen Puffer des Streams befindet.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist kleiner gleich 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Der zu lesende vollständige Dateipfad.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="detectEncodingFromByteOrderMarks">Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll.</param>
        <param name="bufferSize">Die Mindestgröße des Puffers als Zahl aus 16-Bit-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Dateinamen mit der angegebenen Zeichencodierung, Option zur Erkennung der Bytereihenfolgemarken und Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die Codierung gemäß der `encoding` Parameter.  
  
 Mit diesem Konstruktor können Sie so ändern Sie die Codierung beim ersten Sie Auslesen der <xref:System.IO.StreamReader> Objekt. Die `detectEncodingFromByteOrderMarks` -Parameter erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
 Die Puffergröße, Anzahl der 16-Bit-Zeichen wird festgelegt, durch die `bufferSize` Parameter. Wenn `bufferSize` ist kleiner als die zulässige Mindestgröße (128 Zeichen), wird die minimale zulässige Größe verwendet.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe (UNC = Universal Naming Convention) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; sie können einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt werden.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, der Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dies <xref:System.IO.StreamReader> Konstruktor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />enthält eine falsche oder ungültige Syntax für Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> ist kleiner gleich 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der zu lesende Stream.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" />, um am Anfang der Datei nach Bytereihenfolgemarken zu suchen, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Die Mindestgröße des Puffers.</param>
        <param name="leaveOpen">
          <see langword="true" />, um den Datenstrom geöffnet zu lassen, nach dem das <see cref="T:System.IO.StreamReader" />-Objekt freigegeben wurde; andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamReader" />-Klasse für den angegebenen Stream auf Grundlage der angegebenen Zeichencodierung, der Option zur Erkennung der Bytereihenfolgenmarken, der Puffergröße und lässt optional den Stream geöffnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es sei denn, Sie legen die `leaveOpen` Parameter `true`, die <xref:System.IO.StreamReader> -Objekt ruft <xref:System.IO.Stream.Dispose> zur angegebenen <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
 Die Puffergröße, Anzahl der 16-Bit-Zeichen wird festgelegt, durch die `bufferSize` Parameter. Wenn `bufferSize` ist kleiner als die zulässige Mindestgröße (128 Zeichen), wird die minimale zulässige Größe verwendet.  
  
 Dieser Konstruktor ermöglicht es Ihnen so ändern Sie die Codierung beim ersten Sie Auslesen der <xref:System.IO.StreamReader> Objekt. Wenn die `detectEncodingFromByteOrderMarks` Parameter ist `true`, des Konstruktors erkennt die Codierung durch einen Blick auf die ersten drei Bytes des Streams. Er erkennt automatisch die UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge beginnt markiert. Andernfalls ist die vom Benutzer bereitgestellte Codierung verwendet. Weitere Informationen finden Sie unter der <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>-Methode.  
  
> [!NOTE]
>  Beim Lesen aus einem <xref:System.IO.Stream>, es ist jedoch effizienter, einen Puffer zu verwenden, die gleiche Größe wie die internen Puffer des Streams befindet.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht ordnungsgemäß interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den zugrunde liegenden Stream zurück.</summary>
        <value>Der zugrunde liegende Stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden diese Eigenschaft auf den zugrunde liegenden Stream zuzugreifen. Die <xref:System.IO.StreamReader> -Klasse puffert die Eingabe aus dem zugrunde liegenden Stream beim Aufrufen eines der <xref:System.IO.StreamReader.Read%2A> Methoden. Wenn Sie die Position des zugrunde liegenden Stream bearbeiten, nachdem Daten in den Puffer gelesen wurden, kann die Position des zugrunde liegenden Datenstroms auf die Position des internen Puffers nicht überein. Um den internen Puffer zurückzusetzen, rufen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig. Die <xref:System.IO.StreamReader> Konstruktoren, haben die `detectEncodingFromByteOrderMarks` Parameter kann ändern, die Codierung beim ersten Sie Auslesen der <xref:System.IO.StreamReader> Objekt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das <see cref="T:System.IO.StreamReader" />-Objekt sowie den zugrunde liegenden Stream und gibt alle dem Reader zugeordneten Systemressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt die <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> Methode.  
  
 Diese Implementierung der <xref:System.IO.StreamReader.Close%2A> Aufrufe der <xref:System.IO.StreamReader.Dispose%2A> -Methode übergibt eine `true` Wert.  
  
 Das Leeren des Streams wird die zugrunde liegende Encoder nicht entleert, es sei denn, Sie explizit aufrufen <xref:System.IO.StreamReader.Close%2A>. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A> zu `true` ist, werden Daten aus dem Puffer geleert werden, in den Stream, aber die Encoder-Status wird nicht geleert werden. Dadurch wird den Encoder seinen Zustand (teilweise Zeichen) beibehalten, sodass er den nächsten Block von Zeichen richtig zu codieren. Dieses Szenario betrifft UTF8 und UTF7, in denen bestimmte Zeichen codiert werden kann, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfängt.  
  
 Nach einem Aufruf <xref:System.IO.StreamReader.Close%2A>, für die der Reader keine Vorgänge möglicherweise Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Zeichencodierung ab, die das aktuelle <see cref="T:System.IO.StreamReader" />-Objekt verwendet.</summary>
        <value>Die durch das aktuelle Leseprogramm verwendete aktuelle Zeichencodierung. Der Wert kann sich nach dem ersten Aufruf einer <see cref="Overload:System.IO.StreamReader.Read" />-Methode von <see cref="T:System.IO.StreamReader" /> ändern, da die automatische Erkennung der Codierung erst nach dem ersten Aufruf einer <see cref="Overload:System.IO.StreamReader.Read" />-Methode erfolgt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Codierung des angegebenen <xref:System.IO.StreamReader> Objekt.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den internen Puffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.StreamReader.DiscardBufferedData%2A> -Methode zum Zurücksetzen des internen Puffers für die <xref:System.IO.StreamReader> Objekt. Diese Methode aufrufen, müssen Sie nur, wenn die Position des internen Puffers und <xref:System.IO.StreamReader.BaseStream%2A> stimmen nicht überein. Diese Positionen können nicht übereinstimmende werden, wenn Sie Daten in den Puffer gelesen und anschließend eine neue Position in den zugrunde liegenden Stream. Diese Methode verlangsamt die Leistung und sollte verwendet werden, nur wenn unbedingt notwendig ist, z. B. wenn einen Teil des Inhalts der gelesen werden soll eine <xref:System.IO.StreamReader> Objekt mehr als einmal.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario, in dem die <xref:System.IO.StreamReader.DiscardBufferedData%2A> -Methode muss aufgerufen werden, um den internen Puffer und den zugrunde liegenden Stream zu synchronisieren. Die Datei im Beispiel wird verwendet, um die Position zu veranschaulichen und besteht aus dem Text `abcdefghijklmnopqrstuvwxyz`. Durch Aufrufen von <xref:System.IO.StreamReader.DiscardBufferedData%2A> , nachdem die Daten gelesen werden, das Beispiel funktioniert wie erwartet. Nachdem die ersten 15 Zeichen gelesen wurden, die Position auf der Offset-Wert von 2 zurückgesetzt wurde und alle verbleibenden Zeichen werden gelesen. Wenn Sie den Aufruf von entfernen <xref:System.IO.StreamReader.DiscardBufferedData%2A>, das Beispiel funktioniert nicht wie erwartet. Werden die ersten 15 Zeichen gelesen, jedoch nur die Position des zugrunde liegenden Stream wird zurückgesetzt. Der interne Puffer, der die <xref:System.IO.StreamReader> Objekt befindet sich noch in der 16. Zeichen. Aus diesem Grund <xref:System.IO.StreamReader.ReadToEnd%2A> gibt alle Zeichen im Puffer plus der Zeichen in den zugrunde liegenden Stream ab, die von der Position zurücksetzen.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Schließt den zugrunde liegenden Stream und gibt die vom <see cref="T:System.IO.StreamReader" /> verwendeten nicht verwalteten Ressourcen sowie optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich <xref:System.IDisposable.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. <xref:System.IDisposable.Dispose%2A>Ruft die geschützte <xref:System.IO.StreamReader.Dispose%2A> Methode mit dem `disposing` Parameter auf "true" festgelegt. <xref:System.Object.Finalize%2A>Ruft <xref:System.IO.StreamReader.Dispose%2A> mit `disposing` auf "false" festgelegt.  
  
 Wenn die `disposing` Parameter ist `true`, gibt diese Methode sämtliche Ressourcen frei, die sämtliche für verwaltete Objekte frei, die die <xref:System.IO.StreamReader> Objektverweise. Diese Methode ruft die <xref:System.IDisposable.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dispose kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />müssen Sie darauf achten, nicht auf Objekte verweisen, die einen früheren Aufruf von Dispose [Cref,...] verworfen wurde. Weitere Informationen zum Implementieren <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see cref="M:System.IDisposable.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich die aktuelle Streamposition am Ende des Streams befindet.</summary>
        <value>
          <see langword="true" />, wenn sich die aktuelle Streamposition am Ende des Streams befindet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende Stream wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see cref="T:System.IO.StreamReader" />-Objekt um einen leeren Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Lesen von Methoden werden aufgerufen, auf <xref:System.IO.StreamReader.Null>, wird immer NULL zurückgegeben. Wenn <xref:System.IO.StreamReader.ReadLine%2A> aufgerufen, <xref:System.IO.StreamReader.Null>, `null` wird zurückgegeben.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das nächste verfügbare Zeichen zurück, ohne es zu verarbeiten.</summary>
        <returns>Eine ganze Zahl, die das nächste zu lesende Zeichen darstellt, oder -1, wenn keine zu lesenden Zeichen vorhanden sind oder der Stream keine Suchvorgänge unterstützt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.StreamReader.Peek%2A> Methode gibt einen ganzzahligen Wert zurück, um zu bestimmen, ob das Ende der Datei oder ein anderer Fehler aufgetreten ist. Dadurch kann einen Benutzer zuerst zu überprüfen, wenn der zurückgegebene Wert-1 ist, bevor Sie diesen zum Umwandeln einer <xref:System.Char> Typ.  
  
 Diese Methode überschreibt <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 Die aktuelle Position der <xref:System.IO.StreamReader> Objekt wird nicht geändert, indem <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird Zeilen aus einer Datei gelesen, bis das Ende der Datei erreicht ist.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das nächste Zeichen aus dem Eingabestream und verschiebt die Zeichenposition um ein Zeichen nach vorn.</summary>
        <returns>Das nächste Zeichen im Eingabestream wird als <see cref="T:System.Int32" />-Objekt dargestellt, oder -1, wenn keine weiteren Zeichen verfügbar sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Diese Methode gibt eine ganze Zahl zurück, sodass-1 zurückgegeben werden kann, wenn das Ende des Streams erreicht wurde. Wenn Sie die Position des zugrunde liegenden Stream bearbeiten, nachdem Daten in den Puffer gelesen wurden, kann die Position des zugrunde liegenden Datenstroms auf die Position des internen Puffers nicht überein. Um den internen Puffer zurückzusetzen, rufen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht eine einfache Verwendung von der <xref:System.IO.StreamReader.Read%2A> Methode.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, lesen ein einzelnes Zeichen mithilfe der <xref:System.IO.StreamReader.Read> methodenüberladung, die ASCII-ganze Zahl, die als Dezimal- und hexadezimaldarstellung Ausgabe zu formatieren.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Enthält nach Rückkehr dieser Methode das angegebene Zeichenarray mit den Werten zwischen <c>Index</c> und (<c>Index + Zähler - 1</c>) durch die aus der aktuellen Quelle gelesenen Zeichen ersetzt.</param>
        <param name="index">Der Index des <c>Puffer</c> ab dem geschrieben werden soll.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Zeichen.</param>
        <summary>Liest vom aktuellen Stream ein angegebenes Maximum von Zeichen in einen Puffer ein und beginnt dabei am angegebenen Index.</summary>
        <returns>Die Anzahl der gelesenen Zeichen, bzw. 0 (null), wenn das Ende des Streams erreicht ist und keine Daten gelesen wurden. Die Anzahl ist gleich dem <paramref name="count" />-Parameter oder kleiner, abhängig davon, ob die Daten im Stream verfügbar sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Diese Methode gibt eine ganze Zahl zurück, sodass 0 zurückgegeben werden kann, wenn das Ende des Streams erreicht wurde.  
  
 Bei Verwendung der <xref:System.IO.StreamReader.Read%2A> -Methode, es ist jedoch effizienter, um einen Puffer verwenden, die die gleiche Größe wie die internen Puffer des Streams ist, der interne Puffer auf die gewünschte Blockgröße festgelegt ist, und immer kleiner als die Blockgröße lesen. Wenn die Größe des internen Puffers nicht angegeben wurde, wenn der Stream erstellt wurde, ist die Standardgröße 4 KB (4096 Bytes). Wenn Sie die Position des zugrunde liegenden Stream bearbeiten, nachdem Daten in den Puffer gelesen wurden, kann die Position des zugrunde liegenden Datenstroms auf die Position des internen Puffers nicht überein. Um den internen Puffer zurückzusetzen, rufen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig.  
  
 Diese Methode gibt entweder nach dem die Anzahl der Zeichen, die gemäß der `count` Parameter werden gelesen, oder das Ende der Datei erreicht ist. <xref:System.IO.TextReader.ReadBlock%2A>ist eine blockierende Version von <xref:System.IO.StreamReader.Read%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden fünf Zeichen gelesen, schrittweise, bis das Ende der Datei erreicht ist.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Pufferlänge minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, der Stream wird z. B. geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Enthält nach Rückkehr dieser Methode das angegebene Zeichenarray mit den Werten zwischen <c>Index</c> und (<c>Index</c> + <c>Anzahl</c> - 1) durch die Zeichen ersetzt aus der aktuellen Quelle gelesenen.</param>
        <param name="index">Die Position im <c>Puffer</c> ab dem geschrieben werden soll.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Zeichen. Wenn das Ende des Streams erreicht ist, bevor die angegebene Anzahl von Zeichen in den Puffer geschrieben wurde, erfolgt die aktuelle Methodenrückgabe.</param>
        <summary>Liest eine angegebene Höchstanzahl von Zeichen asynchron aus dem aktuellen Stream und schreibt die Daten in einen Puffer, wobei am angegebenen Index begonnen wird.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Zeichen, die in den Puffer gelesen werden. Der Ergebniswert kann kleiner als die Anzahl der angeforderten Zeichen sein, wenn die Anzahl der derzeit verfügbaren Zeichen kleiner ist als die angeforderte Anzahl, oder er kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abschluss der Aufgabe entweder nach dem die Anzahl der Zeichen, die gemäß der `count` Parameter werden gelesen oder das Ende des Streams erreicht ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie alle Zeichen in einer Datei gelesen werden, mithilfe der <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode. Er überprüft, ob jedes Zeichen ein Buchstabe, eine Ziffer oder ein Leerzeichen vor dem Hinzufügen der Zeichen mit einer Instanz von der <xref:System.Text.StringBuilder> Klasse.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="index" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Reader wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Enthält nach Rückkehr dieser Methode das angegebene Zeichenarray mit den Werten zwischen <c>Index</c> und (<c>Index + Zähler - 1</c>) durch die aus der aktuellen Quelle gelesenen Zeichen ersetzt.</param>
        <param name="index">Die Position im <c>Puffer</c> ab dem geschrieben werden soll.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Zeichen.</param>
        <summary>Liest eine angegebene Höchstanzahl von Zeichen aus dem aktuellen Stream und schreibt die Daten in einen Puffer, wobei am angegebenen Index begonnen wird.</summary>
        <returns>Die Anzahl der gelesenen Zeichen. Die Anzahl ist kleiner oder gleich <paramref name="count" />, je nachdem, ob alle Eingabezeichen gelesen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position des zugrunde liegenden Stream wird durch die Anzahl der Zeichen, die in der gelesenen erweiterte `buffer`.  
  
 Die Methode blockiert, bis entweder `count` Zeichen gelesen werden, oder das Ende des Streams erreicht haben. Dies ist eine blockierende Version <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Pufferlänge minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.IO.StreamReader" /> ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Enthält nach Rückkehr dieser Methode das angegebene Zeichenarray mit den Werten zwischen <c>Index</c> und (<c>Index</c> + <c>Anzahl</c> - 1) durch die Zeichen ersetzt aus der aktuellen Quelle gelesenen.</param>
        <param name="index">Die Position im <c>Puffer</c> ab dem geschrieben werden soll.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Zeichen. Wenn das Ende des Streams erreicht ist, bevor die angegebene Anzahl von Zeichen in den Puffer geschrieben wurde, erfolgt die Methodenrückgabe.</param>
        <summary>Liest eine angegebene Höchstanzahl von Zeichen asynchron aus dem aktuellen Stream und schreibt die Daten in einen Puffer, wobei am angegebenen Index begonnen wird.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Zeichen, die in den Puffer gelesen werden. Der Ergebniswert kann kleiner als die Anzahl der angeforderten Zeichen sein, wenn die Anzahl der derzeit verfügbaren Zeichen kleiner ist als die angeforderte Anzahl, oder er kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Aufgabe nicht abgeschlossen bis entweder die Anzahl der Zeichen, die gemäß der `count` Parameter werden gelesen, oder das Ende des Streams erreicht haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="index" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Reader wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest eine Zeile von Zeichen aus dem aktuellen Stream und gibt die Daten als Zeichenfolge zurück.</summary>
        <returns>Die nächste Zeile des Eingabestreams bzw. <see langword="null" />, wenn das Ende des Eingabestreams erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Zeile ist definiert, wie eine Folge von Zeichen, gefolgt von einer Zeile feed ("\n"), ein Wagenrücklauf ("\r") oder einem Wagenrücklauf, unmittelbar gefolgt von einer Zeile Zeilenvorschub ("\r\n"). Die Zeichenfolge, die zurückgegeben wird, enthält keine abschließende Carriage return, Wagenrücklauf oder Zeilenvorschub. Der zurückgegebene Wert ist `null` , wenn das Ende des Eingabestreams erreicht ist.  
  
 Diese Methode überschreibt <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Wenn die aktuelle Methode löst eine <xref:System.OutOfMemoryException>, die Position des Readers in der zugrunde liegenden <xref:System.IO.Stream> Objekt wird durch die Anzahl der Zeichen, die die Methode wurde lesen, aber die bereits in den internen gelesenen Zeichen erweitert <xref:System.IO.StreamReader.ReadLine%2A> Puffer werden verworfen. . Wenn Sie die Position des zugrunde liegenden Stream bearbeiten, nachdem Daten in den Puffer gelesen wurden, kann die Position des zugrunde liegenden Datenstroms auf die Position des internen Puffers nicht überein. Um den internen Puffer zurückzusetzen, rufen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird Zeilen aus einer Datei gelesen, bis das Ende der Datei erreicht ist.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher vorhanden, um einen Puffer für die zurückgegebene Zeichenfolge zuzuordnen.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest eine Zeile von Zeichen asynchron aus dem aktuellen Stream und gibt die Daten als Zeichenfolge zurück.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält die nächste Zeile aus dem Stream oder ist <see langword="null" />, wenn alle Zeichen gelesen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie mithilfe die erste Zeile einer Datei Lesen der <xref:System.IO.StreamReader.ReadLineAsync> Methode.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl der Zeichen in der nächsten Zeile ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Reader wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle Zeichen von der aktuellen Position bis zum Ende des Streams.</summary>
        <returns>Der Rest des Streams als Zeichenfolge, von der aktuellen Position bis zum Ende. Wenn die aktuelle Position am Ende des Streams ist, wird eine leere Zeichenfolge ("") zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>funktioniert am besten, wenn alle Eingaben aus der aktuellen Position bis zum Ende des Streams gelesen werden sollen. Verwenden Sie bei Bedarf mehr Kontrolle über wie viele Zeichen aus dem Stream gelesen werden die <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung, was in der Regel eine bessere Leistung zur Folge.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>wird davon ausgegangen, dass der Stream erkennt, wenn das Ende erreicht hat. Bei interaktiven Protokollen, die bei der sendet der Server Daten nur, wenn dafür Fragen wird die Verbindung nicht geschlossen <xref:System.IO.StreamReader.ReadToEnd%2A> möglicherweise unbegrenzte Zeit blockiert, da es eine End ist nicht erreichbar, und vermieden werden sollte.  
  
 Beachten Sie, dass bei Verwendung der <xref:System.IO.StreamReader.Read%2A> -Methode, es ist jedoch effizienter, einen Puffer zu verwenden, die gleiche Größe wie die internen Puffer des Streams befindet. Wenn die Größe des Puffers nicht angegeben wurde, wenn der Stream erstellt wurde, ist die Standardgröße 4 KB (4096 Bytes).  
  
 Wenn die aktuelle Methode löst eine <xref:System.OutOfMemoryException>, die Position des Readers in der zugrunde liegenden <xref:System.IO.Stream> Objekt wird durch die Anzahl der Zeichen, die die Methode wurde lesen, aber die bereits in den internen gelesenen Zeichen erweitert <xref:System.IO.StreamReader.ReadLine%2A> Puffer werden verworfen. . Wenn Sie die Position des zugrunde liegenden Stream bearbeiten, nachdem Daten in den Puffer gelesen wurden, kann die Position des zugrunde liegenden Datenstroms auf die Position des internen Puffers nicht überein. Um den internen Puffer zurückzusetzen, rufen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird liest ganz nach dem Ende einer Datei in einem Vorgang.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher vorhanden, um einen Puffer für die zurückgegebene Zeichenfolge zuzuordnen.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle Zeichen asynchron von der aktuellen Position bis zum Ende des Streams und gibt diese als einzelne Zeichenfolge zurück.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält eine Zeichenfolge mit den Zeichen von der aktuellen Position bis zum Ende des Streams.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie das Lesen des Inhalts einer Datei mithilfe der <xref:System.IO.StreamReader.ReadToEndAsync> Methode.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von Zeichen ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Reader wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
