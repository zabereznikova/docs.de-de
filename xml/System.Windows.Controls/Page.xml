<Type Name="Page" FullName="System.Windows.Controls.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt eine Inhalte, die zu der navigiert werden kann und die von Windows Internet Explorer gehostet werden kann <see cref="T:System.Windows.Navigation.NavigationWindow" />, und <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page>Kapselt einen Inhalt, der navigiert werden kann, enthält die folgenden wichtigsten Elemente:  
  
-   **Verwaltung der Objektlebensdauer**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Navigation**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Darstellung**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Hosten von Darstellung**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Eine Seite kann mit Markup, Markup und CodeBehind oder Code definiert werden. Eine Seite ist die bevorzugte Methode zum Paketinhalt für die Navigation, den folgenden Gründen:  
  
-   Es ist einfach zu definieren, wiederzuverwenden und zu verwalten.  
  
-   Zugriff auf und verwendet werden können die <xref:System.Windows.Navigation.NavigationService> , der dorthin navigiert ist.  
  
-   Sie können ändern, Titel, Breite, Höhe und die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] des Hostfensters (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Es verfügt über designerunterstützung im [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Eine Seite aufgenommen werden kann, aus <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, oder in einem Browser. Um gehostet werden, kann eine Seite sein:  
  
-   Direktes untergeordnetes Element von einem <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, oder <xref:System.Windows.Controls.Frame> Element im [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Instanziiert, und legen Sie als Wert für die `Content` Eigenschaft <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, und <xref:System.Windows.Controls.Frame>.  
  
-   Legen Sie als die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Quelle der `Source` Eigenschaft entweder <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
-   Legen Sie als die <xref:System.Windows.Application.StartupUri%2A> in eine eigenständige Anwendung.  
  
-   Legen Sie als die <xref:System.Windows.Application.StartupUri%2A> in einer [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 In der Regel weist eine Anwendung zwei oder mehr Seiten navigiert werden können, zwischen der Verwendung der folgenden Mechanismen:  
  
-   Deklarativ mithilfe <xref:System.Windows.Documents.Hyperlink>.  
  
-   Programmgesteuert durch die Verwendung <xref:System.Windows.Navigation.NavigationService>.  
  
-   Visuell mithilfe der Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] des Hosts, einschließlich [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, und <xref:System.Windows.Controls.Frame>.  
  
 Für die strukturierte Navigation mithilfe der Seitenfunktionen (<xref:System.Windows.Navigation.PageFunction%601>), finden Sie unter [Übersicht über die strukturierte Navigation](~/docs/framework/wpf/app-development/structured-navigation-overview.md) und [Navigation Topologien Overview](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat für das Steuerelement festgelegt werden.  Wenn eine Eigenschaft von einem Standardformat festgelegt ist, kann die Eigenschaft von seinem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt, welche desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Standard-WPF-Designs](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine standard-Seite ist nur mit Markup definiert:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 Das folgende Beispiel zeigt, wie eine Standardseite mit definiert wurde nur code:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 Das folgende Beispiel zeigt, wie eine standard-Seite ist mit einer Kombination von Markup und CodeBehind definiert.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Page" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Controls.Page> nicht wird beibehalten (finden Sie unter <xref:System.Windows.Controls.Page.KeepAlive%2A>), es muss einen Standardkonstruktor zur zulassen implementieren [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] erstellen eine neue Instanz der beim Sichern navigiert oder Navigationsverlauf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Die Größe zu verwenden, um die untergeordneten Elemente anzuordnen.</param>
        <summary>Ordnet den Inhalt (untergeordnete Elemente) der <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Size" /> , die die angeordnete Größe der Seite darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Hintergrund für einen <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die <see cref="T:System.Windows.Media.Brush" /> , <see cref="T:System.Windows.Controls.Page" /> verwendet, um seine Hintergrund gezeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Background" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Inhalt einer <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Ein Objekt, das den Inhalt des enthält eine <see cref="T:System.Windows.Controls.Page" />. Die Standardeinstellung ist <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Controls.Page> kann nur ein einzelnes untergeordnetes Element verfügen. Alle anderen Elemente auf einer <xref:System.Windows.Controls.Page> Nachfolger dieses Elements werden muss. In der Regel der Inhalt des eine <xref:System.Windows.Controls.Page> hostet Layoutelement – z. B. <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, und <xref:System.Windows.Controls.DockPanel>–, die den Inhalt des hostet die <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Content" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namen der angegebenen Schriftfamilie fest.</summary>
        <value>Ein <see cref="T:System.Windows.Media.FontFamily" /> , die die Schriftfamilie für den Inhalt einer <see cref="T:System.Windows.Controls.Page" />. Die Standardeinstellung ist <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.FontFamily" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.FontFamily%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Schriftgrad fest.</summary>
        <value>Der Schriftgrad für den Inhalt einer <see cref="T:System.Windows.Controls.Page" />. Die Standardeinstellung ist <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schriftgrad muss eine Positive Zahl sein und im Bereich der <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.FontSize" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.FontSize%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Vordergrund-für eine <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die <see cref="T:System.Windows.Media.Brush" /> , <see cref="T:System.Windows.Controls.Page" /> zum Zeichnen der Vordergrundfarbe verwendet. Die Standardeinstellung ist <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Foreground" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.Foreground%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die <see cref="T:System.Windows.Controls.Page" /> -Instanz im Navigationsverlauf beibehalten wird.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Windows.Controls.Page" /> Instanz wird im Navigationsverlauf beibehaltene, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Seite zuerst navigiert wird, eine neue Instanz der dem <xref:System.Windows.Controls.Page> Klasse erstellt wird. Wenn eine Seite aus (zurück oder vorwärts) navigiert wird, wird ein Eintrag für die Seite Navigationsverlauf hinzugefügt. Standardmäßig verweist der Eintrag nicht Page-Objekt. Stattdessen enthält der Eintrag ein Pack [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die Seite. Wenn der Eintrag für die Seite mit dem Pack Navigationsverlauf navigiert wird [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] wird verwendet, um eine neue Instanz der Seite zu erstellen. Dieses Verhalten ist die Standardeinstellung, vermeiden Sie übermäßige arbeitsspeichernutzung: Seiteninstanzen beibehalten Arbeitsspeicher, speziell jene mit einem nicht trivialen Menge an Inhalten schnell verarbeiten kann. Dieses Problem wird durch die Tatsache erweitert, dass es keine Beschränkung für die Anzahl von Einträgen, die in der Rückseite gespeichert werden können und forward Aufruflisten von Navigationsverlauf ist. Im Gegensatz dazu speichern Pack [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] für Seiten hat Sie praktisch keine Auswirkung auf den Arbeitsspeicherverbrauch.  
  
 Die wichtigste Nebeneffekt beim Erstellen neuer Instanzen einer Seite ist, dass die Seitenstatus nicht von einer Instanz von einer Seite beibehalten wird. In diesen Fällen [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] bietet verschiedene Techniken zum Erinnern an den Zustand.  
  
 Um eine Seite beizubehalten, legen Sie die <xref:System.Windows.Controls.Page.KeepAlive%2A> Eigenschaft `true` (die Standardeinstellung ist `false`).  
  
> [!NOTE]
>  Seiten, die instanziiert und navigiert zur Verwendung nur Code (z. B. durch Aufruf von <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), werden automatisch beibehalten.  
  
 Vermeiden Sie die Einstellung <xref:System.Windows.Controls.Page.KeepAlive%2A> auf `true` es sei denn, Sie möchten:  
  
-   Wenn eine Seite viel Inhalt aufweist, dauert es sehr lange zum Instanziieren. Wenn die Seite wird nicht beibehalten, und die Seite häufig navigiert wird, kann die Kosten der ständig Instanziierung der Seite eine negative Auswirkung auf die benutzerfreundlichkeit auswirken. Sie sollten jedoch hinsichtlich der Leistung basieren auf den Standardeinstellungen und die Leistung Ihrer Anwendung ein Profil erstellen; Wenn Seiten testen mit Ladezeiten erkannt werden, die unter dem Bereich für Ihre Anwendung erforderliche liegen, möglicherweise die Konfigurieren der Seiten, beibehalten zu werden, dass eine Möglichkeit zur Behebung des Problems.  
  
> [!NOTE]
>  Einträge für Seiten, die beibehalten werden, werden nicht im Navigationsverlauf des beibehalten einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] , wenn ein Benutzer vom navigiert und dann wieder auf die [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Nur Journaleinträge für Seiten, die nicht beibehalten werden, werden im Navigationsverlauf beibehalten.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
> [!NOTE]
>  Der Metadatentyp für diese Abhängigkeitseigenschaft ist <xref:System.Windows.PropertyMetadata>, nicht <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] beibehalten eine Instanz von der <xref:System.Windows.Controls.Page> -Klasse über mehrere Navigationen hinweg.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.KeepAlive" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.KeepAlive%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen Enumerator für die logischen untergeordneten Elemente von einem <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die <see cref="T:System.Collections.IEnumerator" /> für die logischen untergeordneten Elemente des eine <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Der verfügbare Bereich, den das Fenster mit seinen untergeordneten Elementen bereitstellen kann.</param>
        <summary>Misst die untergeordneten Elemente von der <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Size" /> d. h. die tatsächliche Größe des Fensters. Die Methode kann einen größeren Wert zurück, in dem Fall das übergeordnete Element möglicherweise Bildlaufleisten hinzufügen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Navigationsbereich-Dienst, den der Host der Seite verwendet, um die Navigation zum Verwalten von ab.</summary>
        <value>Die <see cref="T:System.Windows.Navigation.NavigationService" /> -Objekt, dass der Host der Seite zum Verwalten der Navigation, verwendet oder <see langword="null" /> , wenn der Host keine Navigation unterstützt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seiten aufgenommen werden können, indem mehrere Typen von Hosts, einschließlich <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, und ein Browser auf.  
  
 Seiten müssen oft für die Integration des Hosts Navigation im Seitennavigation unterstützen. Da eine Seite möglicherweise nicht ist zur Laufzeit werden die Hosts bekannt, kann nicht es jedoch direkt mit ihrem Host Navigation Mitgliedern dazu integrieren.  
  
 Sie können stattdessen versuchen, einen Navigationsdienst verwendet wird, einen Dienst, der im Webbrowserstil Navigation unterstützt und ist Teil von der <xref:System.Windows.Navigation.NavigationService> Klasse. Sie können nicht erstellt, eine eigene <xref:System.Windows.Navigation.NavigationService> Instanz, jedoch. Stattdessen Hosttypen wie <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, oder einen Browser erstellen ihre eigenen <xref:System.Windows.Navigation.NavigationService> -Instanz, die Sie zugreifen können die <xref:System.Windows.Controls.Page.NavigationService%2A> Eigenschaft.  
  
 Dem Navigationsdienst, die von zurückgegeben wird das <xref:System.Windows.Controls.Page.NavigationService%2A> Eigenschaft ist für die Instanz von der <xref:System.Windows.Navigation.NavigationService> -Klasse, die von der ersten Navigator in der visuellen Struktur verwaltet wird. Falls nicht vorhanden, `null` zurückgegeben wird, wird eine Seite Host unterstützt keine Navigation angibt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Window> Klasse unterstützt keine Navigation und stellt keine Navigationsdienst bereit.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie eine Seite kann überprüfen, ob ein Navigationsdienst verfügbar ist und, wenn dies der Fall ist, verwenden, um zurück zur vorherigen Seite navigieren.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Die alte Vorlage.</param>
        <param name="newTemplate">Die neue Vorlage.</param>
        <summary>Wird aufgerufen, wenn die Vorlage für eine <see cref="T:System.Windows.Controls.Page" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das vorherige übergeordnete Element. Legen Sie auf <see langword="null" /> Wenn die <see cref="T:System.Windows.DependencyObject" /> verfügte nicht über eine vorherige übergeordnete Element.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element der <see cref="T:System.Windows.Controls.Page" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das neue übergeordnete Element ist weder ein <see cref="T:System.Windows.Window" /> noch ein <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleitete Klassen, die Serialisierungsverhalten bestimmt die <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />Wenn der Inhalt serialisiert werden soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleitete Klassen, die Serialisierungsverhalten bestimmt die <see cref="P:System.Windows.Controls.Page.Title" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />Wenn der Inhalt serialisiert werden soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleitete Klassen, die Serialisierungsverhalten bestimmt die <see cref="P:System.Windows.Controls.Page.WindowHeight" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />Wenn der Inhalt serialisiert werden soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleitete Klassen, die Serialisierungsverhalten bestimmt die <see cref="P:System.Windows.Controls.Page.WindowTitle" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />Wenn der Inhalt serialisiert werden soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleitete Klassen, die Serialisierungsverhalten bestimmt die <see cref="P:System.Windows.Controls.Page.WindowWidth" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />Wenn der Inhalt serialisiert werden soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] von einem <see cref="T:System.Windows.Navigation.NavigationWindow" /> auf [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] sichtbar ist.</summary>
        <value>
          <see langword="true" />Wenn die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] eines Hosts <see cref="T:System.Windows.Navigation.NavigationWindow" /> sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow>Zeigt die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] werden standardmäßig im Webbrowserstil Rückwärtsrichtung Navigation aktivieren. Wenn eine Seite, als festgelegt ist die <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> automatisch geöffnet wird, eine <xref:System.Windows.Navigation.NavigationWindow> zum Hosten der Seite. Wenn die Seite nicht die Standardeinstellung verwenden möchte <xref:System.Windows.Navigation.NavigationWindow> Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], er kann festgelegt <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> auf `false`.  
  
> [!NOTE]
>  Da [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] kann nicht mit der Navigation integrieren [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] für [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], ermöglicht eine eigene Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], die angezeigt oder ausgeblendet, indem kann <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]lässt sich mit Integrieren der [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]so festlegen <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> auf Seiten im [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] hat keine Auswirkungen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Ausblenden der Navigationsleiste [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] von einem <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> Eigenschaft überprüft wird, auf eine <see cref="T:System.Windows.Controls.Page" /> -Instanz, die nicht von gehostet wird eine <see cref="T:System.Windows.Window" />, <see cref="T:System.Windows.Navigation.NavigationWindow" />, oder einen Browser.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das hinzuzufügende untergeordnete Objekt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.Page>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Der dem Objekt hinzuzufügende Text.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.Page>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Steuerelementvorlage für eine <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die <see cref="T:System.Windows.Controls.ControlTemplate" /> für eine <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eine Markuperweiterung, die Vorgehensweise der Dialogfeldvorlagen-Ressource verweisen, entweder identifiziert `StaticResource` oder `DynamicResource`. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der die angeforderte Vorlagenauswahl identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert. Weitere Informationen finden Sie unter [Inline-Stile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Template" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Titel der <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Der Titel des der <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Windows.Controls.Page.Title%2A> Eigenschaft wird nicht angezeigt, indem <xref:System.Windows.Controls.Page>, noch in der Titelleiste des Fensters, das gehostet wird angezeigt ein <xref:System.Windows.Controls.Page>. Legen Sie stattdessen <xref:System.Windows.Controls.Page.WindowTitle%2A> so ändern Sie den Titel eines Fensters Host.  
  
 <xref:System.Windows.Controls.Page.Title%2A>kann auch verwendet werden, um den Namen des Eintrags im Navigationsverlauf für ein Inhaltselement Navigation zu generieren. Die folgenden Teile der Daten werden verwendet, um automatisch der Name eines Eintrags in der Rangfolge Navigation erstellt:  
  
-   Der angefügte <xref:System.Windows.Navigation.JournalEntry.Name%2A> Attribut.  
  
-   Die <xref:System.Windows.Controls.Page.Title%2A>-Eigenschaft  
  
-   Die <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft und die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite  
  
-   Die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite.  
  
 Wenn Sie verknüpft haben eine <xref:System.Windows.Navigation.CustomContentState> Objekt mit einem Inhaltselement im Navigationsverlauf, können Sie den angezeigten Namen in den Eintrag im Navigationsverlauf angeben, durch Überschreiben <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Title" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.Title%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Höhe des Hosts <see cref="T:System.Windows.Window" /> oder <see cref="T:System.Windows.Navigation.NavigationWindow" /> von einem <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die Höhe eines Fensters, das direkt hostet eine <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A>wird nur angewendet, wenn eine <xref:System.Windows.Controls.Page> direkt von einem Fenster, einschließlich gehostet wird:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Wenn eine <xref:System.Windows.Controls.Page> gehostet wird, indem Sie eine <xref:System.Windows.Controls.Frame>wird durch das Festlegen <xref:System.Windows.Controls.Page.WindowHeight%2A> hat keine Auswirkungen, aber Sie erhalten weiterhin den Wert des <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 Ein <xref:System.Windows.Controls.Page> in einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] können nur <xref:System.Windows.Controls.Page.WindowHeight%2A> so ändern Sie die Höhe des [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; die Höhe kann nicht geändert werden, indem <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, oder <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 Die Mindesthöhe der [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster beträgt 150 Pixel. Für Seiten die in einem Browser gehostet werden, bedeutet dies, dass den Wert der <xref:System.Windows.Controls.Page.WindowHeight%2A> können nicht angewendet werden, wenn sie die Höhe des verursachen würde die [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster aus, um weniger als 150 Pixel betragen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Höhe eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Titel des Hosts <see cref="T:System.Windows.Window" /> oder <see cref="T:System.Windows.Navigation.NavigationWindow" /> von einem <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Der Titel eines Fensters, das direkt hostet die <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird der Titel eines Fensters, das eine Seite hostet einschließlich <xref:System.Windows.Navigation.NavigationWindow> und [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], ist der Name der Datei, die derzeit gehostet wird (mit einer XAML-Dateien, wenn die Seite lose ist [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], oder eine Erweiterung ".xbap", wenn die Seite Teil einer ist[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Eine Seite kann die Standardeinstellung ändern, indem Festlegen seiner <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft.  
  
 Sobald eine Seite der Titel eines Fensters auf diese Weise legt fest, das Window-Titel ändert sich nicht, bis eine andere Seite legt <xref:System.Windows.Controls.Page.WindowTitle%2A> mit einem anderen Wert.  
  
> [!NOTE]
>  Die <xref:System.Windows.Controls.Page> muss das oberste Element in einem Fenster für Inhalt <xref:System.Windows.Controls.Page.WindowTitle%2A> ; Wenn wirksam ein <xref:System.Windows.Controls.Page> gehostet wird, innerhalb einer <xref:System.Windows.Controls.Frame>, z. B. <xref:System.Windows.Controls.Page.WindowTitle%2A> ändert sich nicht auf den Titel des Hostfensters.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A>kann auch verwendet werden, um den Namen des Eintrags im Navigationsverlauf für ein Inhaltselement Navigation zu generieren. Die folgenden Teile der Daten werden verwendet, um automatisch der Name eines Eintrags in der Rangfolge Navigation erstellt:  
  
-   Der angefügte <xref:System.Windows.Navigation.JournalEntry.Name%2A> Attribut.  
  
-   Die <xref:System.Windows.Controls.Page.Title%2A>-Eigenschaft  
  
-   Die <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft und die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite  
  
-   Die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite.  
  
 Wenn Sie verknüpft haben eine <xref:System.Windows.Navigation.CustomContentState> Objekt mit der ein Inhaltselement im Navigationsverlauf, können Sie die Name-Wert eines Elements Verlauf angeben, durch Überschreiben <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie den Titel eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Breite des Hosts <see cref="T:System.Windows.Window" /> oder <see cref="T:System.Windows.Navigation.NavigationWindow" /> von einem <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Die Breite eines Fensters, das direkt hostet eine <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A>wird nur angewendet, wenn eine <xref:System.Windows.Controls.Page> direkt von einem Fenster, einschließlich gehostet wird:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Wenn eine <xref:System.Windows.Controls.Page> gehostet wird, indem Sie eine <xref:System.Windows.Controls.Frame>wird durch das Festlegen <xref:System.Windows.Controls.Page.WindowWidth%2A> hat keine Auswirkungen, aber Sie erhalten weiterhin den Wert des <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 Ein <xref:System.Windows.Controls.Page> in einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] können nur <xref:System.Windows.Controls.Page.WindowWidth%2A> so ändern Sie die Breite des [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; die Breite kann nicht geändert werden, indem <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, oder <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 Die minimale Breite der [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster beträgt 250 Pixel. Für Seiten die in einem Browser gehostet werden, bedeutet dies, dass den Wert der <xref:System.Windows.Controls.Page.WindowWidth%2A> können nicht angewendet werden, wenn sie die Gesamtbreite der verursachen würde die [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster aus, um weniger als 250 Pixel betragen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Breite eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
