<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Die abstrakte Basisklasse, von der alle Persistenzdienste abgeleitetet werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Wenn beim Ausführen des Workflows bestimmte Bedingungen eintreten, speichert das Workflowlaufzeitmodul Zustandsinformationen zur Workflowinstanz. Die Speicherung kann z.&#160;B. erfolgen, wenn eine atomarische Transaktion abgeschlossen wird, wenn die Workflowinstanz in den Leerlauf wechselt, wenn der Host <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> für die Workflowinstanz aufruft, oder wenn eine Workflowinstanz beendet wird. Wenn die Semantik des Workflowlaufzeitmodul eine Speicherung verlangt, ruft das Workflowlaufzeitmodul von einem Persistenzdienst bereitgestellte Methoden auf, um Zustandsinformationen zur Workflowinstanz zu speichern. Muss dementsprechend das Workflowlaufzeitmodul eine zuvor gespeicherte Workflowinstanz wiederherstellen, ruft es von einem Persistenzdienst bereitgestellte Methoden auf, um diese Zustandsinformationen zu laden. Das Workflowlaufzeitmodul verarbeitet jede Semantik, die sich darauf bezieht, wann eine Speicherung ausgeführt werden soll. Der Persistenzdienst übernimmt das tatsächliche Speichern und Laden der Workflowzustandsinformationen in einen Datenspeicher und aus einem Datenspeicher.  
  
 Sie können einen Persistenzdienst erstellen, indem Sie eine Klasse von der <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService>-Klasse ableiten.  Sie können den Persistenzdienst dem Workflow-Laufzeitmodul hinzufügen, indem Sie <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> aufrufen oder einen entsprechenden Eintrag in die Anwendungskonfigurationsdatei aufnehmen. <xref:System.Workflow.Runtime.WorkflowRuntime> sollte nur einen Persistenzdienst enthalten. Von Windows Workflow Foundation wird die <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>-Klasse bereitgestellt. Diesen vordefinierten Persistenzdienst können Sie sofort verwenden oder erweitern.  
  
 Das Workflowlaufzeitmodul verfügt über Semantik zum Sperren von Workflowzustandsinformationen. Diese Semantik kann in Umgebungen verwendet werden, in denen in verschiedenen Prozessen ausgeführte Persistenzdienste möglicherweise Zugriff auf einen einzigen Datenspeicher haben. Die <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService>-Klasse kann diese Funktionalität des Workflowlaufzeitmoduls unterstützen. Dazu wird für <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> ein Parameter bereitgestellt, der angibt, ob die Zustandsinformationen einer Workflowinstanz im Datenspeicher gesperrt werden sollen. Außerdem wird eine <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A>-Methode zum Entsperren von gesperrten Workflowzustandsinformationen bereitgestellt. Bei einem Persistenzdienst, von dem das Sperren implementiert wird, sollten durch einen Aufruf von <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> die Zustandsinformationen für eine Workflowinstanz gesperrt werden.  
  
 Der Persistenzdienst sollte <xref:System.Workflow.Runtime.Hosting.PersistenceException> auslösen, wenn die Zustandsinformationen nicht im Datenspeicher gespeichert oder aus dem Datenspeicher geladen werden können. Vom Workflow-Laufzeitmodul wird dieses Verhalten vorausgesetzt.  
  
 Ein Batchverarbeitungsmechanismus wird für Dienste bereitgestellt, die einen permanenten Speicher zum Speichern von Workflowzustandsinformationen verwenden. In diesen Fällen ist es wichtig, dass der vom Persistenzdienst verwendete permanente Speicher und der interne Zustand des Workflow-Laufzeitmoduls konsistent bleiben. Dem Dienst kann Funktionalität hinzugefügt werden, die mit der <xref:System.Workflow.Runtime.IPendingWork>-Schnittstelle definiert wird. Sie können dann auch die Batchverarbeitung für Workflowtransaktionen verwenden, die von <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> bereitgestellt wird, indem Sie Änderungen am Datenspeicher <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> als Arbeitsaufgabe hinzufügen. Der permanente Speicher sollte die <xref:System.Transactions.IEnlistmentNotification>-Schnittstelle implementieren, sodass Workflowinformationen bei einem Transaktionsrollback nicht fälschlicherweise dauerhaft gespeichert werden. Weitere Informationen finden Sie unter <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> oder <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird das Erstellen einer Instanz dieser `SqlWorkflowPersistenceService`-Klasse (abgeleitet von `WorkflowPersistenceService`) dargestellt. Dieses Beispiel stammt aus dem Nested Exception Handlers SDK-Beispiel in der Datei Program.cs.  Weitere Informationen finden Sie unter der [geschachtelte Ausnahme Handler Beispiel](http://msdn.microsoft.com/en-us/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Die <see cref="T:System.Workflow.ComponentModel.Activity" />, deren serialisiertes Format angefordert wird.</param>
        <summary>Ruft das serialisierte Standardformat von <see cref="T:System.Workflow.ComponentModel.Activity" /> ab.</summary>
        <returns>Das serialisierte Standardformat von <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Die Stammaktivität der Workflowinstanz.</param>
        <summary>Gibt an, ob die gegebene Aktivität blockiert wird.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Aktivität blockiert wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Die Stammaktivität der Workflowinstanz.</param>
        <summary>Ruft die Beendigungs- oder Unterbrechungsinformationen der angegebenen Aktivität ab.</summary>
        <returns><see cref="T:System.String" />, der die Beendigungs- oder Unterbrechungsinformationen enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Die Stammaktivität der Workflowinstanz.</param>
        <summary>Ruft den Status des Workflows ab.</summary>
        <returns>Ein <see cref="T:System.Workflow.Runtime.WorkflowStatus" />-Enumerationswert, der den Status des Workflows angibt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId"><see cref="T:System.Guid" /> des abgeschlossenen Bereichs.</param>
        <param name="outerActivity"><see cref="T:System.Workflow.ComponentModel.Activity" />, die die Aktivität darstellt, die den abgeschlossenen Bereich einschließt.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse, wird der angegebene abgeschlossene Bereich zurück in den Arbeitsspeicher geladen.</summary>
        <returns><see cref="T:System.Workflow.ComponentModel.Activity" />, die den abgeschlossenen Bereich darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Workflowlaufzeitmodul verwendet <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> zum Implementieren der Kompensierung. Sie müssen eine identische Kopie des abgeschlossenen Bereichs wiederherstellen. Dazu müssen Sie einen gültigen <xref:System.IO.Stream> aus Ihrer Darstellung des abgeschlossenen Bereichs im Datenspeicher wiederherstellen. Anschließend müssen Sie diesen <xref:System.IO.Stream> an eine der überladenen Methoden von <xref:System.Workflow.ComponentModel.Activity.Load%2A> übergeben, um eine Deserialisierung des Bereichs auszuführen.  
  
 Wenn der Persistenzdienst den abgeschlossenen Bereich nicht aus seinem Datenspeicher laden kann, sollte er <xref:System.Workflow.Runtime.Hosting.PersistenceException> in Verbindung mit einer entsprechenden Meldung auslösen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `LoadCompletedContextActivity`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId"><see cref="T:System.Guid" /> der Stammaktivität der Workflowinstanz.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse, wird der angegebene Zustand der Workflowinstanz wieder in den Arbeitsspeicher geladen.</summary>
        <returns>Eine <see cref="T:System.Workflow.ComponentModel.Activity" />, die die Stammaktivität der Workflowinstanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen eine identische Kopie der Aktivität wiederherstellen. Dazu müssen Sie einen gültigen <xref:System.IO.Stream> aus der Darstellung der Workflowinstanz im Datenspeicher wiederherstellen. Übergeben Sie dann diesen <xref:System.IO.Stream> an eine der überladenen <xref:System.Workflow.ComponentModel.Activity.Load%2A>-Methoden, um den Zustand der Workflowinstanz zu deserialisieren. Wenn der Persistenzdienst den Zustand der Workflowinstanz nicht aus seinem Datenspeicher laden kann, sollte er <xref:System.Workflow.Runtime.Hosting.PersistenceException> in Verbindung mit einer entsprechenden Meldung auslösen.  
  
 Das Workflowlaufzeitmodul implementiert eine Sperrsemantik, um den Zugriff auf einen im Datenspeicher gespeicherten Zustand der Workflowinstanz zu beschränken. Auf diesen Zustand können Persistenzdienste zugreifen, die in mehreren Prozessen ausgeführt werden. Eine Sperrsemantik soll verhindern, dass Persistenzdienste, die in zwei verschiedenen Prozessen ausgeführt werden, gleichzeitig dieselbe Workflowinstanz in den Arbeitsspeicher laden. Ob Sie sich für diese Funktionalität entscheiden, hängt vom Umgebungstyp ab, den der Persistenzdienst unterstützen soll. Wenn Sie sich für die Laufzeitsperrsemantik entscheiden und dieser Zustand der Workflowinstanzen wurde bereits von einem anderen Prozess gesperrt, dann sollten Sie <xref:System.Workflow.Runtime.WorkflowOwnershipException> auslösen. Sperren Sie andernfalls den Zugriff auf den Zustand der Workflowinstanz im Datenspeicher. Sie können den Zustand einer Workflowinstanz entsperren, wenn Sie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> oder <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> aufrufen und dabei den Unlock-Parameter auf `true` festgelegt haben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `LoadWorkflowInstanceState`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">Das serialisierte Format von <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">Die äußere <see cref="T:System.Workflow.ComponentModel.Activity" />, die die wiederherzustellende <see cref="T:System.Workflow.ComponentModel.Activity" /> enthält.</param>
        <summary>Stellt die <see cref="T:System.Workflow.ComponentModel.Activity" /> aus ihrem serialisierten Format wieder her.</summary>
        <returns>Die wiederhergestellte <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `RestoreFromDefaultSerializedForm`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity"><see cref="T:System.Workflow.ComponentModel.Activity" />, die den abgeschlossenen Bereich darstellt.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse, wird der angegebene abgeschlossene Bereich in einen Datenspeicher geladen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Workflowlaufzeitmodul speichert zum Implementieren der Kompensation den Zustand von Aktivitäten des abgeschlossenen Bereichs. Sie müssen zum Serialisieren von <xref:System.Workflow.ComponentModel.Activity.Save%2A> eine der überladenen `activity`-Methoden in einen <xref:System.IO.Stream> laden. Anschließend können Sie den <xref:System.IO.Stream> weiter verarbeiten, bevor Sie ihn in den Datenspeicher laden. Wenn jedoch das Workflowlaufzeitmodul <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> aufruft, müssen Sie eine identische Kopie der Aktivität wiederherstellen.  
  
 Der abgeschlossene Bereich muss der Workflowinstanz, die ihn einschließt, zugeordnet werden können, damit Sie den Bereich beim Abschließen oder Beenden der Workflowinstanz im Datenspeicher als nicht erforderlich markieren können. Speichern Sie deshalb auch die <xref:System.Guid> der Workflowinstanz, die dem abgeschlossenen Bereich zugeordnet ist. Sie erhalten die GUID über die <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>-Eigenschaft der <xref:System.Workflow.Runtime.WorkflowInstance>, die `activity` zugeordnet ist.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> übernimmt die <xref:System.Guid> des abgeschlossenen Bereichs als Parameter. Speichern Sie deshalb auch die <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> zugeordnete `activity`-Eigenschaft. Auf diese Eigenschaft kann durch das <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty>-Feld von `activity` verwiesen werden.  
  
 Verwenden Sie die Batchverarbeitung für Workflowtransaktionen, wenn Sie einen Persistenzdienst implementieren, der einen permanenten Speicher verwendet. Dadurch wird die Konsistenz mit dem internen Zustand des Workflowlaufzeitmoduls aufrechterhalten, indem der tatsächliche Schreibvorgang bis zu einem Commitpunkt des Workflows verzögert wird. Damit die Batchverarbeitung für Workflowtransaktionen verwendet wird, fügen Sie der <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>-Eigenschaft eine Arbeitsaufgabe hinzu, die die ausstehenden Änderungen an der Datenbank darstellt. Implementieren Sie außerdem die <xref:System.Workflow.Runtime.IPendingWork>-Schnittstelle in Ihrem Persistenzdienst.  
  
 Wenn Sie den abgeschlossenen Bereich nicht im Datenspeicher speichern können, lösen Sie <xref:System.Workflow.Runtime.Hosting.PersistenceException> in Verbindung mit einer entsprechenden Meldung aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `SaveCompletedContextActivity`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Die Stammaktivität der Workflowinstanz.</param>
        <param name="unlock">
          <see langword="true" />, wenn die Workflowinstanz nicht gesperrt werden soll; <see langword="false" />, wenn die Workflowinstanz gesperrt werden soll.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse, wird der Zustand der Workflowinstanz in einem Datenspeicher gespeichert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen eine der überladenen <xref:System.Workflow.ComponentModel.Activity.Save%2A>-Methoden aufrufen, um `rootActivity` in einen <xref:System.IO.Stream> zu serialisieren. Sie können dann den <xref:System.IO.Stream> weiter verarbeiten, bevor Sie ihn in den Datenspeicher schreiben. Wenn jedoch das Workflowlaufzeitmodul <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> aufruft, müssen Sie eine identische Kopie der Stammaktivität wiederherstellen. Wenn Sie den Zustand der Workflowinstanz nicht im Datenspeicher speichern können, lösen Sie <xref:System.Workflow.Runtime.Hosting.PersistenceException> in Verbindung mit einer entsprechenden Meldung aus.  
  
 Das Workflowlaufzeitmodul stellt eine Sperrsemantik bereit, um den Zugriff auf einen im Datenspeicher gespeicherten Zustand der Workflowinstanz zu beschränken. Auf diesen Zustand können Persistenzdienste zugreifen, die in mehreren Hosts ausgeführt werden und auf denselben Datenspeicher verweisen. Eine Sperrsemantik soll verhindern, dass Persistenzdienste, die in zwei verschiedenen Workflowlaufzeiten ausgeführt werden, gleichzeitig dieselbe Workflowinstanz in den Arbeitsspeicher laden. Ob Sie sich für diese Funktionalität entscheiden, hängt vom Umgebungstyp ab, den der Persistenzdienst unterstützen soll. Wenn Sie sich für die Laufzeitsperrsemantik entscheiden und ein Persistenzdienst versucht dann einen Zustand der Workflowinstanz zu speichern, der bereits von einem anderen Prozess gesperrt wurde, dann sollten Sie <xref:System.Workflow.Runtime.WorkflowOwnershipException> auslösen. Wenn `unlock``true` ist, dann heben Sie die Sperre des Zugriffs auf den Zustand der Workflowinstanz auf, nachdem Sie ihn gespeichert haben.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> übernimmt die <xref:System.Guid> der Workflowinstanz als Parameter. Speichern Sie deshalb diese <xref:System.Guid>. Sie können die Workflowinstanz mit dieser <xref:System.Guid> auch den gespeicherten Zuständen ihrer abgeschlossenen Bereiche zuordnen. Das ist erforderlich, damit Sie diese abgeschlossenen Bereiche beim Abschließen der Workflowinstanz als nicht erforderlich markieren können.  
  
 Das Workflowlaufzeitmodul ruft <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> auf. Dabei handelt es sich um eine Endzeit, zu der die Workflowinstanz abgeschlossen oder beendet wird. Wenn deshalb <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> gleich <xref:System.Workflow.Runtime.WorkflowStatus.Completed> oder <xref:System.Workflow.Runtime.WorkflowStatus.Terminated> ist, können Sie die Workflowinstanz und alle zugeordneten abgeschlossenen Bereiche sicher aus dem Datenspeicher löschen. Sie können stattdessen auch das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted>- oder das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated>-Ereignis abonnieren, um zu bestimmen, ob die Datensätze sicher gelöscht werden können, die der Workflowinstanz zugeordnet sind. Ob Sie die Datensätze tatsächlich aus dem Datenspeicher löschen, hängt von der Implementierung ab.  
  
 Verwenden Sie die Batchverarbeitung für Workflowtransaktionen, wenn Sie einen Persistenzdienst implementieren, der einen permanenten Speicher verwendet. Dadurch wird die Konsistenz mit dem internen Zustand des Workflowlaufzeitmoduls aufrechterhalten, indem der tatsächlichen Schreibvorgang bis zu einem Commitpunkt des Workflows verzögert wird. Damit die Batchverarbeitung für Workflowtransaktionen verwendet wird, fügen Sie der <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>-Eigenschaft eine Arbeitsaufgabe hinzu, die die ausstehenden Änderungen am permanenten Speicher darstellt. Implementieren Sie außerdem die <xref:System.Workflow.Runtime.IPendingWork>-Schnittstelle in Ihrem Persistenzdienst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `SaveWorkflowInstanceState`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity"><see cref="T:System.Workflow.ComponentModel.Activity" />, die den abgeschlossenen Bereich darstellt.</param>
        <summary>Bestimmt, ob ein Workflow im Leerlauf entladen werden soll.</summary>
        <returns>Wenn <see langword="true" />, entlädt das Workflowlaufzeitmodul den angegebenen Workflow, sobald er in den Leerlauf wechselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `UnloadOnIdle`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Die Stammaktivität der Workflowinstanz.</param>
        <summary>Entsperrt beim Überschreiben in einer abgeleiteten Klasse den Zustand der Workflowinstanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist abstrakt und enthält deshalb keine Standardimplementierung zum Sperren und Entsperren.  
  
 Wenn Sie beim Implementieren eines benutzerdefinierten Persistenzdienstes ein Sperrschema implementieren möchten, müssen Sie diese Methode überschreiben und basierend auf dem Wert des Unlock-Parameters einen Sperr-Entsperr-Mechanismus in der <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>-Methode bereitstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Implementierung der `UnlockWorkflowInstanceState`-Methode gezeigt. Dieses Beispiel stammt aus dem Beispiel zum benutzerdefinierten Persistenzdienst in der Datei FilePersistenceService.cs. Weitere Informationen finden Sie unter [benutzerdefinierte Persistenz-Beispiel](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
