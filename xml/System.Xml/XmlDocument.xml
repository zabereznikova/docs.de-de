<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ein XML-Dokument dar. Sie können diese Klasse zum Laden, Überprüfen, Bearbeiten, Hinzufügen und Positionieren von XML in einem Dokument verwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a>Die <xref:System.Xml.XmlDocument> Klasse ist eine speicherinterne Darstellung eines XML-Dokuments. Es implementiert die W3C [(XML-DOKUMENTOBJEKTMODELL)](~/docs/standard/data/xml/xml-document-object-model-dom.md) Level 1 Core und das DOM Level 2 Core.  
  
 *DOM* steht für *Dokumentobjektmodell*. Weitere Informationen dazu, finden Sie unter [(XML-DOKUMENTOBJEKTMODELL)](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Sie können XML in das DOM geladen, mit der <xref:System.Xml.XmlDocument> Klasse, und klicken Sie dann programmgesteuert lesen, ändern und Entfernen von XML in das Dokument.  
  
 Öffnen Sie gegebenenfalls die Abdeckung der <xref:System.Xml.XmlDocument> Klasse und finden Sie unter wie sie implementiert wird, finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Aufgaben  
  
-   [Laden von XML in das Dokumentobjektmodell](#Load)  
  
-   [Überprüfen sie anhand eines Schemas](#Validation)  
  
-   [Navigieren Sie in der Dokumentstruktur](#Navigate)  
  
-   [Suchen nach Knoten](#Find)  
  
-   [Bearbeiten von Knoten](#Edit)  
  
-   [Hinzufügen von Knoten](#Add)  
  
-   [Entfernen von Knoten](#Remove)  
  
-   [Position-Knoten](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Laden von XML in das Dokumentobjektmodell  
 Beginnen Sie mit einem XML-Dokument, wie diese. Es ist nur ein paar Bücher in einer Auflistung. Aber sie enthält grundlegende Dinge, die Sie in einem beliebigen XML-Dokument zu finden ist. ein Namespace, Elemente, die Daten darstellen und Attribute, die die Daten beschreiben.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Als Nächstes geladen Sie diese Daten in das DOM werden, damit Sie damit arbeiten können, im Arbeitsspeicher. Die am häufigsten verwendete Möglichkeit hierzu ist, finden Sie in eine Datei auf dem lokalen Computer oder in einem Netzwerk.  
  
 In diesem Beispiel werden XML-Daten aus einer Datei geladen. Wenn die Datei nicht vorhanden ist, gerade generiert einige XML-Code und lädt, gesucht.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Erfahren Sie mehr:** [Lesen eines XML-Dokuments in das DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Überprüfen sie anhand eines Schemas  
 Beginnen Sie mit einem XML-Schema wie diesen. Dieses Schema definiert die Datentypen in der XML-Code, und welche Attribute erforderlich sind.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Erstellen Sie ein <xref:System.Xml.XmlReader> -Objekt mithilfe des Schemas, und klicken Sie dann dieses Objekt in das DOM geladen Erstellen Sie einen Ereignishandler, der ausgeführt wird, wenn der Code versucht, auf die XML-Datei auf Weise ändern, die die Regeln des Schemas.  
  
 Diese Codeblöcke anzeigen Hilfsmethoden, die diese ausführen.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Erfahren Sie mehr:** [Validieren eines XML-Dokuments im DOKUMENTOBJEKTMODELL](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Navigieren Sie in der Dokumentstruktur  
 Sie können Eigenschaften zum Navigieren in einem XML-Dokument verwenden. Aber bevor Sie diese verwenden, schnell überprüfen wir einige Begriffe. Ihr Dokument besteht aus Knoten. Jeder Knoten besitzt als einzelnes *übergeordneten* Knoten direkt darüber liegenden. Der einzige Knoten, die keinen übergeordneten Knoten ist das Stammelement des Dokuments, als Knoten der obersten Ebene ist. Die meisten Knoten verfügen können *untergeordneten* Knoten, die Knoten direkt darunter sind. Knoten, die auf der gleichen Ebene befinden, sind *gleichgeordnete Elemente*.  
  
 Die folgenden Beispiele veranschaulichen den Stammknoten, springen Sie zu den ersten untergeordneten Knoten des Stammknotens, Zugriff auf alle untergeordneten Knoten, Abrufen zurück an den übergeordneten Knoten, und navigieren dann über nebengeordneten Knoten.  
  
 **Beginnen Sie mit dem Stammknoten**  
  
 In diesem Beispiel ruft den Stammknoten ab und verwendet dann diesen Knoten, um den Inhalt des Dokuments auf der Konsole ausgegeben.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Abrufen von untergeordneten Knoten**  
  
 In diesem Beispiel springt zu den ersten untergeordneten Knoten des Stammknotens, und klicken Sie dann die untergeordneten Knoten dieses Knotens durchläuft, falls vorhanden.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Zurück zum übergeordneten Knoten abrufen**  
  
 Verwenden Sie die <xref:System.Xml.XmlDocument.ParentNode%2A>-Eigenschaft.  
  
 **Anhand des letzten untergeordneten Knoten**  
  
 In diesem Beispiel schreibt den Preis des Buchs an die Konsole (die den letzten untergeordneten Knoten eines Knotens Buch ist).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Wechseln, über die gleichgeordneten Elemente**  
  
 In diesem Beispiel wird die Book um Buch vorwärts verschoben. Buchknoten sind gleichgeordnete Elemente untereinander.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Für gleichgeordnete Elemente rückwärts navigieren**  
  
 In diesem Beispiel wird aus Book um Buch rückwärts verschoben.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Suchen nach Knoten  
 Die am häufigsten verwendete Möglichkeit zum finden von einem oder mehreren Knoten der Daten ist die Verwendung eine XPath-Abfrage-Zeichenfolge, aber es gibt auch Methoden, die eine nicht erforderlich ist.  
  
 **Abrufen eines Knotens**  
  
 In diesem Beispiel sucht ein Buch mit der ISBN-Nummer.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 Die Zeichenfolge ab, die in diesem Beispiel wird eine XPath-Abfrage. Finden Sie weitere Beispiele finden sie hier: [XPath-Beispiele](https://msdn.microsoft.com/en-us/library/ms256086.aspx).  
  
 Sie können auch die <xref:System.Xml.XmlDocument.GetElementById%2A> Knoten abgerufen. Um diesen Ansatz verwenden, müssen Sie definieren in das Dokument Definition Typdeklarationen Ihrer XML-Datei-IDs.  
  
 Nachdem Sie einen Knoten erhalten haben, erhalten Sie den Wert von Attributen oder untergeordneten Knoten. In diesem Beispiel werden, die mit einem Buchknoten.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Abrufen einer Auflistung von Knoten**  
  
 In diesem Beispiel werden alle Bücher ausgewählt, wird der Nachname des Autors **Austen**, und klicken Sie dann den Preis für diese Büchern ändert.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Sie können auch eine Auflistung von Knoten abrufen, mit dem Namen des Knotens. In diesem Beispiel ruft z. B. eine Auflistung von der alle Buchtitel.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Erfahren Sie mehr:** [wählen Sie Knoten mithilfe von XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Bearbeiten von Knoten  
 In diesem Beispiel bearbeitet eine Book-Knoten und seine Attribute.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Erfahren Sie mehr:** [Ändern von Knoten, Inhalten und Werten in einem XML-Dokument](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Hinzufügen von Knoten  
 Um einen Knoten hinzuzufügen, verwenden Sie die <xref:System.Xml.XmlDocument.CreateElement%2A> Methode oder die <xref:System.Xml.XmlDocument.CreateNode%2A> Methode.  
  
 Verwenden Sie zum Hinzufügen eines Datenknoten z. B. ein Buch die <xref:System.Xml.XmlDocument.CreateElement%2A> Methode.  
  
 Für alle anderen Arten von Knoten, z. B. einen Kommentar, Leerraum oder CDATA-Knoten die <xref:System.Xml.XmlDocument.CreateNode%2A> Methode.  
  
 In diesem Beispiel wird einen Buchknoten erstellt, fügt der Attribute für diesen Knoten und fügt dann diesen Knoten, auf das Dokument.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Erfahren Sie mehr:** [Einfügen von Knoten in einem XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Entfernen von Knoten  
 Verwenden Sie zum Entfernen eines Knotens die <xref:System.Xml.XmlNode.RemoveChild%2A> Methode.  
  
 In diesem Beispiel entfernt ein Buch aus dem Dokument und Leerzeichen, das unmittelbar vor der Buchknoten angezeigt wird.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Erfahren Sie mehr:** [Entfernen von Knoten, Inhalten und Werten aus einem XML-Dokument](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Position-Knoten  
 Sie können auswählen, in dem einen Knoten im Dokument angezeigt werden soll die <xref:System.Xml.XmlNode.InsertBefore%2A> und <xref:System.Xml.XmlNode.InsertAfter%2A> Methoden.  
  
 Dieses Beispiel zeigt zwei Hilfsmethoden. Eine davon wird einen höheren Knoten in einer Liste verschoben. Die anderen Knoten Verschiebt einen unteren Knoten.  
  
 Diese Methoden können in einer Anwendung verwendet werden, die Benutzern ermöglicht, Bücher in einer Liste von Büchern nach oben oder unten verschieben. Wenn ein Benutzer ein Buch auswählt und einen Up drückt und gedrückt konnte Methoden wie diese mit der entsprechenden Buchknoten vor oder nach anderen Buchknoten Positionieren von Code aufgerufen werden.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Vollständiges Beispiel:** [Bearbeiten von XML-Speicher mithilfe der XmlDocument-Klasse und anderen verwandten Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDocument" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden ist ein Beispiel für die Validierung zur Buildzeit laden. Ein Dokument Type Definition (DTD) überprüfen <xref:System.Xml.XmlReader> wird zum Übergeben der <xref:System.Xml.XmlDocument.Load%2A> Methode und eine <xref:System.Xml.Schema.ValidationEventHandler> wird bereitgestellt, um Benutzer von Validierungsfehler zu benachrichtigen. In diesem Beispiel tritt ein Validierungsfehler gefunden wird, aber das Dokument wird noch geladen. Alternativ können Sie definieren, einen validierenden <xref:System.Xml.XmlReader> lösen eine Ausnahme aus, und Beenden des Ladevorgangs, wenn ein Validierungsfehler gefunden wird, indem Sie nicht angeben der <xref:System.Xml.Schema.ValidationEventHandler>. Weitere Informationen zum Überprüfen von XML-Daten finden Sie im Abschnitt Hinweise der <xref:System.Xml.XmlReader>-Referenzseite.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 In diesem Beispiel wird die Datei `bookDTD.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">Der zu verwendende <see langword="XmlImplementation" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlDocument" />-Klasse mit der angegebenen <see cref="T:System.Xml.XmlImplementation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Der zu verwendende <see langword="XmlNameTable" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlDocument" />-Klasse mit der angegebenen <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basis-URI des aktuellen Knotens ab.</summary>
        <value>Der Speicherort, von dem aus der Knoten geladen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Netzwerk-XML-Dokument besteht aus Segmenten der Daten unter Verwendung verschiedener W3C standard aggregiert und enthält daher Knoten, die aus verschiedenen Quellen stammen. Die `BaseURI` gibt Aufschluss darüber, woher diese Knoten stammen.  
  
 Für die Document-Knoten `BaseURI` gibt den Speicherort des XML-Dokuments zurück. Beispielsweise, wenn die `XmlDocument` mit dem Aufruf Doc geladen wurde. Load ("http://server/mydata.xml"), die `BaseURI` für das Dokument Knoten http://server/mydata.xml ist. Jedoch, wenn die <xref:System.Xml.XmlDocument.Load%2A> Methode wird vom Server an einen anderen URI umgeleitet `BaseURI` gibt den ursprünglichen URI übergeben wird, um die `Load` Methode.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM). Weitere Informationen zu `BaseURI` und mit anderen Knotentypen Verhalten, finden Sie unter <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" />, wenn die Teilstruktur unter dem angegebenen Knoten rekursiv geklont werden soll, <see langword="false" />, wenn nur der Knoten selbst geklont werden soll.</param>
        <summary>Erstellt ein Duplikat dieses Knotens.</summary>
        <returns>Der geklonte <see langword="XmlDocument" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient als einen Kopierkonstruktor für Knoten. Der geklonte Knoten weist kein übergeordnetes Element (<xref:System.Xml.XmlNode.ParentNode%2A> gibt `null`).  
  
 Wenn `deep` ist `true`, enthält der geklonte Knoten alle untergeordneten Knoten, andernfalls nur den `XmlDocument` Knoten geklont. Finden Sie unter der <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> Methode, um festzustellen, wie diese Methode für andere Knotentypen verhält.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Unterschied zwischen einem Tiefe und flache Klon.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der <see cref="P:System.Xml.XmlNode.NamespaceURI" /> bleibt leer, sofern das Präfix kein erkanntes integriertes Präfix, z. B. „xmlns“ ist. In diesem Fall hat der <see langword="NamespaceURI" /> den Wert http://www.w3.org/2000/xmlns/.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `XmlAttribute` hinzugefügt werden kann ein <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A> Methode.  
  
   
  
## Examples  
 Im folgenden wird ein Attribut erstellt und ein XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Der qualifizierte Name des Attributs. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder.</param>
        <param name="namespaceURI">Der namespaceURI des Attributs. Wenn der qualifizierte Name das Präfix xmlns enthält, muss dieser Parameter http://www.w3.org/2000/xmlns/ lauten.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen qualifizierten Namen und dem angegebenen <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `XmlAttribute` hinzugefügt werden kann ein <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des Attributs (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <param name="localName">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI des Attributs (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent. Wenn <c>Präfix</c> Xmlns ist, muss dieser Parameter andernfalls http://www.w3.org/2000/xmlns/; lauten wird eine Ausnahme ausgelöst.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `XmlAttribute` hinzugefügt werden kann ein <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A> Methode.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Der Inhalt des neuen <see langword="XmlCDataSection" />.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlCDataSection" />, der die angegebenen Daten enthält.</summary>
        <returns>Die neue <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind CDataSection-Knoten zulässig in Element-Knoten und EntityReference-Knoten, wenn der EntityReference-Knoten nicht über ein untergeordnetes Element eines Attributknotens ist .  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen CDATA-Knoten und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Der Inhalt des neuen <see langword="XmlComment" />.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlComment" />, der die angegebenen Daten enthält.</summary>
        <returns>Die neue <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind Kommentarknoten nur im Dokument "," Element "und" EntityReference-Knoten zulässig, wenn der EntityReference-Knoten nicht über ein untergeordnetes Element eines Attributs ist Knoten.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Kommentar erstellt und ein XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des Attributs (sofern vorhanden).</param>
        <param name="localName">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI des Attributs (sofern vorhanden).</param>
        <summary>Erstellt ein Standardattribut mit dem angegebenen Präfix, lokalen Namen und Namespace-URI.</summary>
        <returns>Die neue <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Die neue <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DocumentFragment-Knoten können nicht in ein Dokument eingefügt werden. Allerdings können Sie die untergeordneten Elemente des Knotens DocumentFragment in ein Dokument einfügen.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein XML-Dokument neue Knoten hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="publicId" Type="System.String" />
        <Parameter Name="systemId" Type="System.String" />
        <Parameter Name="internalSubset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Dokumenttyps.</param>
        <param name="publicId">Der öffentliche Bezeichner des Dokumenttyps oder <see langword="null" />. Sie können einen öffentlichen URI ebenso wie einen Systembezeichner angeben, um den Speicherort der externen DTD-Teilmenge zu identifizieren.</param>
        <param name="systemId">Der Systembezeichner des Dokumenttyps oder <see langword="null" />. Gibt die URL des Dateispeicherorts für die externe DTD-Teilmenge an.</param>
        <param name="internalSubset">Die interne DTD-Teilmenge für den Dokumenttyp oder <see langword="null" />.</param>
        <summary>Gibt ein neues <see cref="T:System.Xml.XmlDocumentType" />-Objekt zurück.</summary>
        <returns>Die neue <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Knoten wird analysiert haben <xref:System.Xml.XmlDocumentType.Entities%2A> und <xref:System.Xml.XmlDocumentType.Notations%2A> Sammlungen.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind DocumentType-Knoten nur in Document-Knoten zulässig. Jede <xref:System.Xml.XmlDocument> können nur einen DocumentType-Knoten verfügen. DocumentType-Knoten muss auch eingefügt werden, bevor Sie das Stammelement der `XmlDocument` (wenn das Dokument bereits über ein Stammelement verfügt, Sie können nicht hinzufügen einen DocumentType-Knoten).  
  
 Wenn die übergebenen Parametern nicht um eine gültige erstellen kombinieren `XmlDocumentType`, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen DocumentType-Knoten und ein XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Diese Methode hat eine vererbungsanforderung. Volle Vertrauenswürdigkeit ist erforderlich, um das Überschreiben der <see langword="CreateDocumentType" /> Methode.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der qualifizierte Name darf nicht das Präfix "xmlns" enthalten.</param>
        <summary>Erstellt ein Element mit dem angegebenen Namen.</summary>
        <returns>Die neue <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Instanz, implementiert zurückgegeben die `XmlElement` -Schnittstelle ein, sodass Standardattribute direkt für das zurückgegebene Objekt erstellt werden.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) Elementknoten dürfen in Dokument und Element-Knoten und in EntityReference-Knoten, wenn der EntityReference-Knoten nicht untergeordnet ist ein Attributknoten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Element und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Der qualifizierte Name des Elements. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der qualifizierte Name darf nicht das Präfix "xmlns" enthalten.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlElement" /> mit dem qualifizierten Namen und dem <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der folgende C#-code  
  
```  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 / / ergibt ein Element, die in den folgenden XML-Text entspricht.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) Elementknoten dürfen in Dokument und Element-Knoten und in EntityReference-Knoten, wenn der EntityReference-Knoten nicht untergeordnet ist ein Attributknoten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des neuen Elements (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <param name="localName">Der lokale Name des neuen Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Elements (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <summary>Erstellt ein Element mit dem angegebenen <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> und der <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der folgende C#-code  
  
```  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 erstellt ein Element in den folgenden XML-Text entspricht:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind Elementknoten in Dokument und Element-Knoten und in EntityReference-Knoten zulässig, wenn die EntityReference außerhalb ein Attributknoten ist.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Im folgende Beispiel wird das vorhandene XML-Dokument ein neues Element hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Entitätsverweises.</param>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlEntityReference" /> mit dem angegebenen Namen.</summary>
        <returns>Die neue <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Entität, auf die verwiesen wird bekannt, wird die Liste der untergeordneten Elemente der `XmlEntityReference` Knoten erfolgt mit der entsprechenden identisch <xref:System.Xml.XmlEntity> Knoten.  
  
 Die in den Ersetzungstext für den Entitätsverweis verwendeten Namespaces sind zum Zeitpunkt gebunden, die das übergeordnete Element des Entitätsverweisknotens zuerst festgelegt ist (z. B. wenn der Entitätsverweisknoten in das Dokument eingefügt wird). Betrachten Sie z. B. die folgende Entität:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Beim Aufrufen `CreateEntityReference("a")` Sie zurückkehren einen einzelnen Knoten vom Typ EntityReference ohne untergeordnete Elemente. Wenn Sie diesen Knoten als untergeordnetes Element des folgenden Knotens anfügen,  
  
```  
<item xmlns="urn:1"/>  
```  
  
 Klicken Sie dann zum Zeitpunkt des Aufrufs <xref:System.Xml.XmlNode.AppendChild%2A>, das übergeordnete Element des neu erstellten Entitätsverweisknoten festgelegt ist und die untergeordneten Elemente werden in diesem Namespacekontext erweitert. Die untergeordneten Elementknoten `b` müssen gleich NamespaceURI `urn:1`. Die untergeordneten Knoten des Entitätsverweises bleiben unverändert, auch wenn Sie den Entitätsverweis an eine Stelle im Dokument verschieben, die über einen anderen Namespace Standardkontext verfügt. Dies wird nicht für vorhandene Entitätsverweisknoten ausgeführt, oder Sie entfernen, und fügen Sie sie für Entitätsverweise, Klonen mit <xref:System.Xml.XmlDocument.CloneNode%2A>. Dies geschieht nur für neu erstellte Entitätsverweise.  
  
 Wenn die entsprechende Entität nicht in der DocumentType definiert ist bei der Entitätsverweisknoten hinzugefügt wird, da der Entitätsverweis nicht definiert ist, wird der einzige untergeordnete Knoten ein leerer Textknoten sein.  
  
 Die integrierten Entitäten Amp, Lt, Gt, Apos und Quot sind ebenfalls zulässig können, zudem sie einen untergeordneten Textknoten mit der entsprechenden erweiterten Zeichenwert.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind EntityReference-Knoten nur innerhalb von Element, Attribut und EntityReference-Knoten zulässig.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zwei Entitätsverweisknoten und fügt sie in einem XML-Dokument.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name ist ungültig (z. B. sind Namen ungültig, die mit "#" beginnen.)</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> für ein Beispiel für die Verwendung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.XmlNode" />, auf dem Sie den Navigator zunächst positionieren möchten.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument, das auf dem angegebenen <see cref="T:System.Xml.XmlNode" /> positioniert ist.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> für ein Beispiel für die Verwendung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Zeichenfolgenversion des <see cref="T:System.Xml.XmlNodeType" /> für den neuen Knoten. Dieser Parameter muss einer der in der folgenden Tabelle aufgelisteten Werte sein.</param>
        <param name="name">Der qualifizierte Name des neuen Knotens. Wenn der Name einen Doppelpunkt enthält, wird er in eine <see cref="P:System.Xml.XmlNode.Prefix" />-Komponente und eine <see cref="P:System.Xml.XmlDocument.LocalName" />-Komponente aufgelöst.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen Knotentyp, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `nodeTypeString` -Parameter wird die Groß-/Kleinschreibung beachtet und muss einen der Werte in der folgenden Tabelle.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|Attribut|Attribut|  
|CDATASection|CDATA|  
|comment|Kommentar|  
|Dokument|Dokument|  
|DocumentFragment|DocumentFragment|  
|DocumentType|DocumentType|  
|Element|Element|  
|EntityReference|EntityReference|  
|ProcessingInstruction|ProcessingInstruction|  
|SignificantWhitespace|SignificantWhitespace|  
|Text|Text|  
|whitespace|Whitespace|  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Die folgende Tabelle zeigt, welche NodeType [Zeile] innerhalb eines anderen NodeType [Column] gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Nein|nein|nein|nein|nein|nein|nein|nein|nein|  
|`DocumentType`|ja|nein|nein|nein|nein|nein|nein|nein|Nein|  
|`XmlDeclaration`|Ja *|nein|nein|nein|nein|nein|nein|nein|nein|  
|`Element`|ja|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Attribute`|Nein|nein|nein|Ja ***|nein|nein|nein|nein|nein|  
|`Text`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
|`CDATA`|nein|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Markup**`|ja|nein|nein|ja|nein|nein|nein|nein|nein|  
|`EntityReference`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
  
 \*Der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokumentknotens.  
  
 ** Markup enthält ProcessingInstruction und Comment-Knoten.  
  
 Element- und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten nicht über ein untergeordnetes Element eines Attributknotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Elementknotens. Attribute sind in einer attributauflistung enthalten, die zu einem Elementknoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Element und fügt es in das Dokument.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt und <see langword="XmlNodeType" /> erfordert einen Namen, oder <paramref name="nodeTypeString" /> zählt nicht zu den unten aufgeführten Zeichenfolgen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der <see langword="XmlNodeType" /> des neuen Knotens.</param>
        <param name="name">Der qualifizierte Name des neuen Knotens. Wenn der Name einen Doppelpunkt enthält, wird er in eine <see cref="P:System.Xml.XmlNode.Prefix" />-Komponente und eine <see cref="P:System.Xml.XmlDocument.LocalName" />-Komponente aufgelöst.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Die folgende Tabelle zeigt, welche NodeType [Zeile] innerhalb eines anderen NodeType [Column] gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Nein|nein|nein|nein|nein|nein|nein|nein|nein|  
|`DocumentType`|ja|nein|nein|nein|nein|nein|nein|nein|Nein|  
|`XmlDeclaration`|Ja *|nein|nein|nein|nein|nein|nein|nein|nein|  
|`Element`|ja|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Attribute`|Nein|nein|nein|Ja ***|nein|nein|nein|nein|nein|  
|`Text`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
|`CDATA`|nein|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Markup**`|ja|nein|nein|ja|nein|nein|nein|nein|nein|  
|`EntityReference`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
  
 \*Der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokumentknotens.  
  
 ** Markup enthält ProcessingInstruction und Comment-Knoten.  
  
 Element- und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten nicht über ein untergeordnetes Element eines Attributknotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Elementknotens. Attribute sind in einer attributauflistung enthalten, die zu einem Elementknoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Element und fügt es in ein XML-Dokument.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt, und <see langword="XmlNodeType" /> erfordert einen Namen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der <see langword="XmlNodeType" /> des neuen Knotens.</param>
        <param name="prefix">Das Präfix des neuen Knotens.</param>
        <param name="name">Der lokale Name des neuen Knotens.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Die folgende Tabelle zeigt, welche NodeType [Zeile] innerhalb eines anderen NodeType [Column] gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Nein|nein|nein|nein|nein|nein|nein|nein|nein|  
|`DocumentType`|ja|nein|nein|nein|nein|nein|nein|nein|Nein|  
|`XmlDeclaration`|Ja *|nein|nein|nein|nein|nein|nein|nein|nein|  
|`Element`|ja|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Attribute`|Nein|nein|nein|Ja ***|nein|nein|nein|nein|nein|  
|`Text`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
|`CDATA`|nein|nein|nein|ja|nein|nein|nein|nein|Ja ***|  
|`Markup**`|ja|nein|nein|ja|nein|nein|nein|nein|nein|  
|`EntityReference`|nein|nein|nein|ja|ja|nein|nein|nein|ja|  
  
 \*Der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokumentknotens.  
  
 ** Markup enthält ProcessingInstruction und Comment-Knoten.  
  
 Element- und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten nicht über ein untergeordnetes Element eines Attributknotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Elementknotens. Attribute sind in einer attributauflistung enthalten, die die Element-Knoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Im folgende Beispiel wird dem Dokument ein neues Element hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt, und <see langword="XmlNodeType" /> erfordert einen Namen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Der Name der Verarbeitungsanweisung.</param>
        <param name="data">Die Daten für die Verarbeitungsanweisung.</param>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlProcessingInstruction" /> mit dem angegebenen Namen und den angegebenen Daten.</summary>
        <returns>Die neue <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind ProcessingInstruction-Knoten nur im Dokument, Element- und EntityReference-Knoten zulässig, wenn der EntityReference-Knoten nicht untergeordnet ist eines Attributknotens.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein ProcessingInstruction-Knoten erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge darf nur die folgenden Zeichen enthalten &amp;#20; &amp;#10; &amp;#13; und &amp;#9;</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlSignificantWhitespace" />-Knoten.</summary>
        <returns>Ein neuer <see langword="XmlSignificantWhitespace" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL). Es wird verwendet, wenn Sie Ihr Dokument manuell formatieren möchten.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
   
  
## Examples  
 Im folgende Beispiel wird dem Dokument signifikanten Leerraum hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der Text für den Text-Knoten.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlText" /> mit dem angegebenen Text.</summary>
        <returns>Der neue <see langword="XmlText" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) sind nur die Textknoten in Element, Attribut und EntityReference-Knoten zulässig.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Element und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge darf nur die folgenden Zeichen enthalten &amp;#20; &amp;#10; &amp;#13; und &amp;#9;</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlWhitespace" />-Knoten.</summary>
        <returns>Ein neuer <see langword="XmlWhitespace" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL). Es wird verwendet, wenn Sie Ihr Dokument manuell formatieren möchten.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
   
  
## Examples  
 Im folgende Beispiel wird dem Dokument Leerzeichen hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">Die Version muss "1.0" sein.</param>
        <param name="encoding">Der Wert des Codierungsattributs. Dies ist die Codierung, die für das Speichern des <see cref="T:System.Xml.XmlDocument" /> in einer Datei oder einem Stream verwendet wird. Daher muss das Codierungsattribut auf eine von der <see cref="T:System.Text.Encoding" />-Klasse unterstützte Zeichenfolge festgelegt werden. Andernfalls schlägt <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> fehl. Wenn der Wert <see langword="null" /> oder „String.Empty“ ist, schreibt die <see langword="Save" />-Methode kein Codierungsattribut für die XML-Deklaration, und es wird daher die Standardcodierung UTF-8 verwendet.  
  
 Wenn das <see langword="XmlDocument" /> in einem <see cref="T:System.IO.TextWriter" /> oder einem <see cref="T:System.Xml.XmlTextWriter" /> gespeichert wird, wird dieser Codierungswert verworfen. Stattdessen wird die Codierung des <see langword="TextWriter" /> oder <see langword="XmlTextWriter" /> verwendet. Dadurch ist gewährleistet, dass die geschriebenen XML-Daten mit der richtigen Codierung eingelesen werden können.</param>
        <param name="standalone">Der Wert muss entweder yes oder no sein. Wenn der Wert <see langword="null" /> oder String.Empty ist, schreibt die <see langword="Save" />-Methode kein eigenständiges Attribut für die XML-Deklaration.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlDeclaration" />-Knoten mit den angegebenen Werten.</summary>
        <returns>Der neue <see langword="XmlDeclaration" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Attribute werden verfügbar gemacht als spezielle Eigenschaften für die `XmlDeclaration` Knoten, und nicht als <xref:System.Xml.XmlAttribute> Knoten.  
  
 Obwohl diese Methode das neue Objekt im Kontext des Dokuments erstellt wird, ist es nicht das neue Objekt automatisch zur Dokumentstruktur hinzugefügt. Um das neue Objekt hinzuzufügen, müssen Sie einen der Knoten Einfügemethoden aufrufen.  
  
 Gemäß der W3C Extensible Markup Language (XML) 1.0-Empfehlung (www.w3.org/TR/1998/REC-xml-19980210) die `XmlDeclaration` Knoten muss der erste Knoten im Dokument sein.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine XML-Deklaration und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Werte der <paramref name="version" /> oder <paramref name="standalone" /> unterscheiden sich die oben angegebenen Werten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Stamm-<see cref="T:System.Xml.XmlElement" /> für das Dokument ab.</summary>
        <value>Das <see langword="XmlElement" />, das den Stamm der XML-Dokumentstruktur darstellt. Wenn kein Stamm vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt das Stammelement des XML-Dokuments.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Ausgabe:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knoten ab, der die DOCTYPE-Deklaration enthält.</summary>
        <value>Der <see cref="T:System.Xml.XmlNode" />, der DocumentType (DOCTYPE-Deklaration) enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein `XmlDocument` können nur ein untergeordnetes Element mit einem <xref:System.Xml.XmlNodeType> DocumentType gleich.  
  
> [!NOTE]
>  Diese Eigenschaft ist schreibgeschützt. Um DocumentType-Knoten zu ändern, löschen Sie den vorhandenen Knoten aus, erstellen Sie eine neue eine mit das <xref:System.Xml.XmlDocument.CreateDocumentType%2A> -Methode, und fügen Sie den neuen Knoten auf das Dokument.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft ab und zeigt die DOCTYPE-Deklaration für das Dokument.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementId">Die Attribut-ID, mit der eine Übereinstimmung gefunden werden soll.</param>
        <summary>Ruft das <see cref="T:System.Xml.XmlElement" /> mit der angegebenen ID ab.</summary>
        <returns>Das <see langword="XmlElement" /> mit der passenden ID oder <see langword="null" />, wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Dokument mehrere Elemente mit der passenden ID verfügt, gibt diese Methode das erste übereinstimmende Element im Dokument.  
  
> [!NOTE]
>  Die DOM-Implementierung muss Informationen verfügen, die definiert, welche Attribute vom Typ ID sind. Obwohl Attribute vom Typ ID in XSD-Schemas oder DTDs definiert werden können, unterstützt diese Version des Produkts nur diejenigen, die in DTDs definiert. Attribute mit dem Namen "ID" nicht aufweisen geben-ID an, es sei denn, dies in der DTD definiert. Implementierungen, wo es unbekannt ist, ob die Attribute vom Typ ID sind, voraussichtlich zurückzugebenden `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `GetElementById`-Methode verwendet:  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `ids.xml`als Eingabe.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED>]>  
<root>  
  <Person SSN='A111' Name='Fred'/>  
  <Person SSN='A222' Name='Tom'/>  
  <Customer id='A222334444'/>  
  <Team members='A222334444 A333445555'/>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name, mit dem eine Übereinstimmung gefunden werden soll. Er wird mit der <see langword="Name" />-Eigenschaft des übereinstimmenden Knotens verglichen. Der spezielle Wert „*“ entspricht allen Tags.</param>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller untergeordneten Elemente zurück, die mit dem angegebenen <see cref="P:System.Xml.XmlDocument.Name" /> übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller übereinstimmenden Knoten. Wenn mit <paramref name="name" /> keine Knoten übereinstimmen, ist die zurückgegebene Auflistung leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Knoten werden in der Reihenfolge platziert, in denen sie im Dokument erkannt werden würden.  
  
> [!NOTE]
>  Es wird empfohlen, Sie verwenden die <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> oder <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> -Methode anstelle der <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine `XmlDocument` -Objekt und verwendet die `GetElementsByTagName` -Methode und die daraus resultierende <xref:System.Xml.XmlNodeList> alle Buchtitel anzuzeigenden Objekttyp.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 In diesem Beispiel wird die Datei `books.xml` als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der LocalName, mit dem eine Übereinstimmung gefunden werden soll. Der spezielle Wert „*“ entspricht allen Tags.</param>
        <param name="namespaceURI">Der NamespaceURI, mit dem eine Übereinstimmung gefunden werden soll.</param>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller untergeordneten Elemente zurück, die mit dem angegebenen <see cref="P:System.Xml.XmlDocument.LocalName" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" /> übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller übereinstimmenden Knoten. Wenn keine mit dem angegebenen <paramref name="localName" /> und dem <paramref name="namespaceURI" /> kein Knoten übereinstimmt, ist die zurückgegebene Auflistung leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Knoten werden in der Reihenfolge platziert, in denen sie in der Dokumentstruktur angetroffen werden würden.  
  
> [!NOTE]
>  Es wird empfohlen, Sie verwenden die <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> oder <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> -Methode anstelle der <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlImplementation" />-Objekt für das aktuelle Dokument ab.</summary>
        <value>Das <see langword="XmlImplementation" />-Objekt für das aktuelle Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument`Objekte, die aus der gleichen erstellt `XmlImplementation` verwenden dieselbe <xref:System.Xml.XmlNameTable>. Dies ermöglicht Benutzern Attribut- und Elementnamen als Objekte anstelle von Zeichenfolgen zu vergleichen.  
  
 Obwohl die `XmlDocument` Objekte Teilen dieselbe Implementierung, Knoten aus einem Dokument in einen anderen verschieben müssen Sie die <xref:System.Xml.XmlDocument.ImportNode%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues `XmlDocument` mit einem anderen Dokument-Implementierung.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Der Knoten, der importiert wird.</param>
        <param name="deep">
          <see langword="true" /> für das Erstellen eines tiefen Klons, andernfalls <see langword="false" />.</param>
        <summary>Importiert einen Knoten aus einem anderen Dokument in das aktuelle Dokument.</summary>
        <returns>Der importierte <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Knoten verfügt über kein übergeordnetes Element. Der Quellknoten wird nicht geändert oder entfernt aus dem Originaldokument; `ImportNode` erstellt eine Kopie des Quellknotens.  
  
 Importieren von einem Knoten erstellt ein `XmlNode` Objekt, dessen Besitzer des Importieren von Dokuments mit <xref:System.Xml.XmlNode.Name%2A> und <xref:System.Xml.XmlNode.NodeType%2A> auf den Quellknoten identisch. Das neue Objekt verfügt auch über die Attribute, die im Zusammenhang mit Namespaces (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, und <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 Abhängig vom Knotentyp des importierten Knotens und der Wert von der `deep` Parameter, zusätzliche Informationen kopiert. Diese Methode versucht, Mirror, die das Verhalten zu erwarten, wenn ein Fragment eines XML- oder HTML-Quelle aus einem Dokument in ein anderes kopiert wurden (erkennen, dass im Fall XML die beiden Dokumente unterschiedliche DTDs haben können).  
  
 Die folgende Tabelle beschreibt das spezifische Verhalten für jeden <xref:System.Xml.XmlNodeType>.  
  
|XmlNodeType|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Attribut|Die <xref:System.Xml.XmlAttribute.Specified%2A> -Eigenschaftensatz auf `true` über die generierten <xref:System.Xml.XmlAttribute>. Die Nachfolger der Quelle `XmlAttribute` werden rekursiv importiert und die daraus resultierenden Knoten werden neu assembliert bilden die entsprechende Teilstruktur.|Die `deep` Parameter gilt nicht für `XmlAttribute` Knoten, die sie deren untergeordnete Elemente beim Importieren stets ausführen.|  
|CData|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|Kommentar|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|DocumentFragment|Die untergeordneten Elemente des Quellknotens werden rekursiv importiert. Die daraus resultierenden Knoten werden neu assembliert und bilden die entsprechende Teilstruktur.|Ein leeres <xref:System.Xml.XmlDocumentFragment> generiert wird.|  
|DocumentType|Kopiert den Knoten einschließlich der zugehörigen Daten.*|Kopiert den Knoten einschließlich der zugehörigen Daten.*|  
|Element|Die abhängigen Elemente des Quellelements und die angegebenen Attributknoten werden rekursiv importiert und die daraus resultierenden Knoten werden neu assembliert bilden die entsprechende Teilstruktur.<br /><br /> Hinweis: Standardattribute werden nicht kopiert. Wenn das Dokument, in das importiert wird, Standardattribute für diesen Elementnamen definiert, werden diese zugewiesen.|Angegebene Attribut Knoten des Quellelements werden importiert, und die generierten `XmlAttribute` Knoten angefügt werden auf die generierten <xref:System.Xml.XmlElement>.<br /><br /> Hinweis: Standardattribute werden nicht kopiert. Wenn das Dokument, in das importiert wird, Standardattribute für diesen Elementnamen definiert, werden diese zugewiesen.|  
|EntityReference|Da die Quell- und Zieldokument die Entitäten, die unterschiedlich definiert sein können, kopiert diese Methode nur den <xref:System.Xml.XmlEntityReference> Knoten. Der Ersetzungstext ist davon nicht betroffen. Wenn die Entität des Zieldokuments definiert ist, wird deren Wert zugewiesen.|Da die Quell- und Zieldokument die Entitäten, die unterschiedlich definiert sein können, kopiert diese Methode nur den <xref:System.Xml.XmlEntityReference> Knoten. Der Ersetzungstext ist davon nicht betroffen. Wenn die Entität des Zieldokuments definiert ist, wird deren Wert zugewiesen.|  
|ProcessingInstruction|Kopiert den Ziel- und Datenwert des importierten Knotens.|Kopiert den Ziel- und Datenwert des importierten Knotens.|  
|Text|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|SignificantWhitespace|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|Whitespace|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|XmlDeclaration|Kopiert den Ziel- und Datenwert des importierten Knotens.|Kopiert den Ziel- und Datenwert des importierten Knotens.|  
|Alle anderen Knotentypen.|Diese Knotentypen können nicht importiert werden.|Diese Knotentypen können nicht importiert werden.|  
  
 * Obwohl DocumentType-Knoten importiert werden können, kann ein Dokument nur einen DocumentType aufweisen. Wenn das Dokument derzeit einen DocumentType-Knoten aufweist, muss er entfernt werden, bevor Sie ein neues Konto hinzufügen.  
  
   
  
## Examples  
 Im folgende Beispiel werden einen Buchknoten aus einem zweiten XML-Dokument in der ursprünglichen XML-Dokument importiert.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `books.xml`als Eingabe.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aufrufen dieser Methode für einen Knotentyp, der nicht importiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst in allen Fällen eine <see cref="T:System.InvalidOperationException" /> aus.</summary>
        <value>Die Werte des Knotens und aller diesem untergeordneten Knoten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nicht implementiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Markup ab, das die untergeordneten Elemente des aktuellen Knotens darstellt, oder legt dieses fest.</summary>
        <value>Das Markup der untergeordneten Elemente des aktuellen Knotens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft ersetzt die untergeordneten Knoten durch analysierten Inhalt der angegebenen Zeichenfolge. Die Analyse wird im Kontext des aktuellen Namespaces durchgeführt.  
  
 `InnerXml`entfernt redundante Namespacedeklarationen. Daher wird die Größe des Dokuments nicht mit redundanten Namespacedeklarationen erhöht, wenn zahlreiche Ausschneide- und Einfügevorgänge erfolgen. Betrachten Sie die folgenden XSL-Dokument:  
  
```  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 Die `InnerXml` Eigenschaft auf der Stylesheetknoten gibt die folgende Zeichenfolge:  
  
```  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Beachten Sie die zusätzliche Namespacedeklaration die verwendet wird, um die Identität des Knotens beizubehalten. Wenn Sie diesen inneren XML-Zeichenfolge erneut einfügen, erhalten Sie das ursprüngliche Dokument zurück. Das heißt, `InnerXml` erkennt, dass die Namespacedeklaration redundant ist, davon ausgehend, dass das XSL-Stammelement verfügt bereits über die xmlns: xsl-Namespace verfügt, und daher wird entfernt.  
  
 Wenn Sie verschieben `InnerXml` aus einem Dokument kein Standardnamespace in ein Dokument mit einem Standardnamespace, ist das Verhalten etwas anders. Betrachten Sie das folgende XML-Zeichenfolge:  
  
```  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml`Gibt eine einfache XML-Zeichenfolge ohne Namespacedeklarationen zurück:  
  
```  
<item>123</item>  
```  
  
 Wenn Sie dann diese Zeichenfolge in ein Dokument, die einen Standardnamespace, z. B. die folgende verfügt einfügen:  
  
```  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml`analysiert die Zeichenfolge im Kontext und den neuen Knoten übernehmen den Namespace Urn: 1. Das Ergebnis sieht wie folgt:  
  
```  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Jetzt Wenn Sie Fragen für die `InnerXml` erhalten Sie wieder die folgende:  
  
```  
<item xmlns="urn:1">123</item>  
```  
  
 Gegebenenfalls explizit das eingefügte Element an die Tatsache zu vermerken, dass er ein Dokument, die keinen Namespace besäße stammt, müssen Sie manuell hinzufügen, Xmlns = "" Deklaration und die resultierende Zeichenfolge einfügen:  
  
```  
<item xmlns="">123</item>  
```  
  
 Im Endeffekt alles, was wie folgt sieht:  
  
1.  Ausschneiden und Einfügen `InnerXml` zwischen Dokumenten, von denen keine Namespaces und einfache ist und erstellt keine redundanten "Xmlns"-Zeichenfolgen.  
  
2.  `InnerXml`kann auch zum Ausschneiden und Einfügen zwischen Dokumenten, die mehrere Namespaces verfügen (d. h. xsl-Stylesheets) verwendet werden.  
  
3.  xmlns: xsl-Deklarationen wird automatisch in den Zeichenfolgen angezeigt und nicht mehr in Ihrer Hierarchie von Knoten angezeigt.  
  
4.  Im Fall, in dem Sie wechseln werden `InnerXml` aus einem Dokument mit kein Standardnamespace in ein Dokument, das einen Standardnamespace besitzt, der neuen Knoten übernimmt die neue Standard-Namespace.  
  
 Wenn `InnerXml` festgelegt ist mit Text mit Entitätsverweise, die derzeit nicht in das Dokument definiert sind, wird die resultierende Struktur leere EntityReference-Knoten enthalten.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der beim Festlegen dieser Eigenschaft angegebene XML-Code ist nicht ordnungsgemäß formatiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Knoten schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Knoten schreibgeschützt ist, andernfalls <see langword="false" />. <see langword="XmlDocument" />-Knoten geben immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein nur-Lese Knoten ist, deren Eigenschaften, Attribute oder untergeordnete Elemente geändert werden. Sie können einen schreibgeschützten Knoten aus der Struktur entfernen und an anderer Stelle einfügen.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsReadOnly`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Der Stream, der das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load` Methode wird immer signifikanten Leerraum beibehalten. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Eigenschaft legt fest, ob signifikanter Leerraum, die Leerzeichen im Elementinhalt steht, beibehalten wird. Die Standardeinstellung ist `false`; Leerraum im Elementinhalt wird nicht beibehalten.  
  
 Wenn die Validierung ausgeführt werden soll, können Sie erstellen, eines validierenden <xref:System.Xml.XmlReader> Instanz mithilfe der <xref:System.Xml.XmlReaderSettings> Klasse und die <xref:System.Xml.XmlReader.Create%2A> Methode. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 Diese Methode erkennt automatisch das Zeichenfolgenformat der Eingabe-XML (z. B. UTF-8, ANSI und So weiter). Wenn Ihre Anwendung muss wissen, welche Codierung zum Lesen des Streams verwendet wird, können Sie verwenden ein <xref:System.Xml.XmlTextReader> -Objekt zum Lesen des Streams und verwenden Sie dann die <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> Eigenschaft bestimmt die Codierung. Wenn Sie verwenden müssen eine <xref:System.Xml.XmlDocument> Objekt zur Bearbeitung von XML, können Sie die <xref:System.Xml.XmlTextReader> Objekt zu erstellen. Weitere Informationen finden Sie unter [Lesen von XML-Daten mithilfe von XPathDocument und XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall eine <see cref="T:System.IO.FileNotFoundException" /> ausgelöst wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">Der zum Übertragen von XML-Daten in das Dokument verwendete <see langword="TextReader" />.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load` Methode wird immer signifikanten Leerraum beibehalten. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Eigenschaft legt fest, ob signifikanter Leerraum, die Leerzeichen im Elementinhalt steht, beibehalten wird. Die Standardeinstellung ist `false`; Leerraum im Elementinhalt wird nicht beibehalten.  
  
 Wenn die Validierung ausgeführt werden soll, können Sie erstellen, eines validierenden <xref:System.Xml.XmlReader> Instanz mithilfe der <xref:System.Xml.XmlReaderSettings> Klasse und die <xref:System.Xml.XmlReader.Create%2A> Methode. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.StringReader> Klasse geladen wird eine Zeichenfolge mit XML-Daten in die `XmlDocument` Objekt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Die URL für die Datei, die das zu ladende XML-Dokument enthält. Die URL kann eine lokale Datei oder eine HTTP-URL (eine Webadresse) sein.</param>
        <summary>Lädt das XML-Dokument aus der angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load` Methode wird immer signifikanten Leerraum beibehalten. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Eigenschaft legt fest, ob signifikanter Leerraum, die Leerzeichen im Elementinhalt steht, beibehalten wird. Die Standardeinstellung ist `false`; Leerraum im Elementinhalt wird nicht beibehalten.  
  
 Wenn die Validierung ausgeführt werden soll, können Sie erstellen, eines validierenden <xref:System.Xml.XmlReader> Instanz mithilfe der <xref:System.Xml.XmlReaderSettings> Klasse und die <xref:System.Xml.XmlReader.Create%2A> Methode. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall eine <see cref="T:System.IO.FileNotFoundException" /> ausgelöst wird.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filename" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="filename" /> hat eine schreibgeschützte Datei angegeben.  
  
 - oder -   
  
 Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 - oder -   
  
 <paramref name="filename" /> hat ein Verzeichnis angegeben.  
  
 - oder -   
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei <paramref name="filename" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="filename" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zum Übertragen von XML-Daten in das Dokument verwendete <see langword="XmlReader" />.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load` Methode wird immer signifikanten Leerraum beibehalten. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Eigenschaft legt fest, ob signifikanter Leerraum, die Leerzeichen im Elementinhalt steht, beibehalten wird. Die Standardeinstellung ist `false`; Leerraum im Elementinhalt wird nicht beibehalten.  
  
 Wenn der Reader in den Ausgangszustand befindet (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial zurück), `Load` nutzt den gesamten Inhalt des Readers und erstellt das DOM von was er findet.  
  
 Wenn der Reader bereits auf einem Knoten der Tiefe "n" positioniert ist, lädt diese Methode diesen Knoten und alle nachfolgenden gleichgeordneten Elemente bis zum Endtag, das Tiefe "n" schließt. Dies hat folgende Ergebnisse.  
  
 Wenn der aktuelle Knoten und ihre gleichgeordneten Elemente wie folgt aussehen:  
  
```  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load`löst eine Ausnahme aus, da ein Dokument zwei Elemente der Stammebene enthalten kann. Wenn der aktuelle Knoten und ihre gleichgeordneten Elemente wie folgt aussehen:  
  
```  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load`ist erfolgreich, doch Sie haben eine unvollständige DOM-Struktur, da kein Root-Level-Element vorhanden ist. Bevor Sie das Dokument zu speichern, müssen Sie ein Element der Stammebene, andernfalls hinzufügen <xref:System.Xml.XmlDocument.Save%2A> wird eine Ausnahme ausgelöst.  
  
 Wenn der Reader auf einem Endknoten positioniert ist, der nicht für die Stammebene eines Dokuments, z. B. ein Leerraum- oder ein Attributknoten kann weiterhin der Reader gelesen, bis der Cursor positioniert ist auf einen Knoten, der für den Stammknoten verwendet werden kann. Das Dokument beginnt an dieser Stelle mit dem Laden.  
  
 Wenn die Validierung ausgeführt werden soll, können Sie erstellen, eines validierenden <xref:System.Xml.XmlReader> Instanz mithilfe der <xref:System.Xml.XmlReaderSettings> Klasse und die <xref:System.Xml.XmlReader.Create%2A> Methode. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Im folgende Beispiel lädt der letzten Buchknoten, der die `books.xml` -Datei in das XML-Dokument.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `books.xml`als Eingabe.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Zeichenfolge, die das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das XML-Dokument aus der angegebenen Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig die `LoadXml` Methode Leerzeichen oder signifikanter Leerraum nicht beibehalten.  
  
 Diese Methode DTDs analysiert, aber keine DTD oder dem Schema-Validierung. Wenn die Validierung ausgeführt werden soll, können Sie erstellen, eines validierenden <xref:System.Xml.XmlReader> Instanz mithilfe der <xref:System.Xml.XmlReaderSettings> Klasse und die <xref:System.Xml.XmlReader.Create%2A> Methode. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Wenn Sie von laden möchten eine <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, oder <xref:System.Xml.XmlReader>, verwenden Sie statt dieser Methode die Load-Methode.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Im folgende Beispiel lädt XML-Dokument in ein `XmlDocument` -Objekt und speichert es in einer Datei.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Namen des Knotens ab.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten lautet der lokale Name „#document“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der lokale Name zurückgegeben wird, hängt die <xref:System.Xml.XmlDocument.NodeType%2A> des Knotens. Eine Tabelle, die Beschreibung des lokalen Namens für jeden der Knotentypen zurückgegeben, finden Sie unter der <xref:System.Xml.XmlNode.LocalName%2A> Eigenschaft in der <xref:System.Xml.XmlNode> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den qualifizierten Namen des Knotens ab.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten lautet der Name „#document“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Name hängt die <xref:System.Xml.XmlDocument.NodeType%2A> des Knotens. Eine Tabelle, die Beschreibung des Namens für jede der Knotentypen zurückgegeben, finden Sie unter der <xref:System.Xml.XmlNode.Name%2A> Eigenschaft in der <xref:System.Xml.XmlNode> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xml.XmlNameTable" /> ab, die dieser Implementierung zugeordnet ist.</summary>
        <value>Eine <see langword="XmlNameTable" />, die das Abrufen der atomisierten Version einer Zeichenfolge im Dokument ermöglicht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede `XmlDocument` Objekt verfügt über eine <xref:System.Xml.NameTable> Objekt. Element-und Attributnamen werden gespeichert, der `NameTable` als atomisierten Zeichenfolgen. Dies bedeutet, dass selbst wenn Sie ein Namen in das Dokument verwiesen wird mehrere Male sie nur einmal in gespeichert ist die `NameTable`. Angenommen, das Dokument mehrere Elemente mit dem Namen "Kunde", mussten `NameTable` dasselbe Objekt zurück, wenn er eine Anforderung für diesen Namen empfängt. Folglich können Benutzer Objektvergleiche teurer Zeichenfolgenvergleiche, anstatt diese Zeichenfolgen mit Code schreiben.  
  
 Weitere Informationen zu atomisierten Zeichenfolgen finden Sie unter <xref:System.Xml.XmlNameTable>.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Xml.XmlNode.Value" /> eines zu diesem Dokument gehörenden Knotens geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis gilt nur für Knoten, die einen Wert aufweisen.  
  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Xml.XmlNode.Value" /> eines zu diesem Dokument gehörenden Knotens gerade geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis kann der Benutzer zusätzliche Überprüfung und, falls erforderlich, lösen eine Ausnahme aus, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, die `XmlDocument` gibt den ursprünglichen Zustand zurück. Dieses Ereignis gilt nur für Knoten, die einen Wert aufweisen.  
  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten in einen anderen Knoten eingefügt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten gerade in einen anderen Knoten eingefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis kann der Benutzer zusätzliche Überprüfung und, falls erforderlich, lösen eine Ausnahme aus, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, die `XmlDocument` gibt den ursprünglichen Zustand zurück.  
  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten aus dem übergeordneten Element entfernt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten gerade aus dem Dokument entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis kann der Benutzer zusätzliche Überprüfung und, falls erforderlich, lösen eine Ausnahme aus, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, die `XmlDocument` gibt den ursprünglichen Zustand zurück.  
  
 Alle Knoten, die von diesem Dokument erstellt wird, unabhängig davon, ob sie in das Dokument eingefügt wurden, sind in diesem Fall enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des aktuellen Knotens ab.</summary>
        <value>Der Knotentyp. Für <see langword="XmlDocument" />-Knoten ist dieser Wert „XmlNodeType.Document“.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlDocument" /> ab, zu dem der aktuelle Knoten gehört.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten (<see cref="P:System.Xml.XmlDocument.NodeType" /> entspricht „XmlNodeType.Document“) gibt diese Eigenschaft immer <see langword="null" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den übergeordneten Knoten dieses Knotens ab (bei Knoten, die über übergeordnete Knoten verfügen können).</summary>
        <value>Gibt immer <see langword="null" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Leerraum im Elementinhalt beibehalten wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um Leerraum beizubehalten, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, wie Leerraum behandelt wird, während des Ladens und Speichervorgang.  
  
 Wenn `PreserveWhitespace` ist `true` vor <xref:System.Xml.XmlDocument.Load%2A> oder <xref:System.Xml.XmlDocument.LoadXml%2A> wird aufgerufen, Leerraumknoten beibehalten werden; andernfalls, wenn diese Eigenschaft ist `false`, signifikanter Leerraum wird beibehalten, Leerraum jedoch nicht.  
  
 Wenn `PreserveWhitespace` ist `true` vor <xref:System.Xml.XmlDocument.Save%2A> wird aufgerufen, Leerraum im Dokument ist in der Ausgabe beibehalten, wenn diese Eigenschaft ist, andernfalls `false`, `XmlDocument` automatische Einzüge die Ausgabe.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Leerzeichen aus einer Datei zu entfernen.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `book.xml` als Eingabe.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die XML-Quelle</param>
        <summary>Erstellt anhand der Informationen im <see cref="T:System.Xml.XmlReader" /> ein <see cref="T:System.Xml.XmlNode" />-Objekt. Der Reader muss auf einem Knoten oder Attribut positioniert sein.</summary>
        <returns>Der neue <see langword="XmlNode" /> oder <see langword="null" />, wenn keine weiteren Knoten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liest einen `XmlNode` aus dem angegebenen Reader und positioniert den Reader auf den nächsten Knoten. Diese Methode erstellt den Typ des `XmlNode` Abgleich der <xref:System.Xml.XmlNode.NodeType%2A> auf dem der Reader derzeit positioniert ist. (Wenn der Reader in den Ausgangszustand `ReadNode` verschiebt den Reader auf den ersten Knoten, und klicken Sie dann auf diesem Knoten ausgeführt wird.)  
  
 Wenn der Reader, auf den Anfang des Elements positioniert ist, `ReadNode` liest, liest alle Attribute und alle untergeordneten Knoten, bis zu und einschließlich des Endtags des aktuellen Knotens. Die `XmlNode` zurückgegeben, enthält die Teilstruktur, die alle gelesenen Elemente darstellt. Der Reader unmittelbar nach dem Endtag positioniert.  
  
 `ReadNode`Attribute können auch lesen, aber in diesem Fall es nicht weitergeführt wird, des Readers zum nächsten Attribut. Dadurch können Sie den folgenden C#-Code schreiben:  
  
```  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode`nutzen die Attribut-Wert, d. h. nach dem Aufruf `ReadNode` für ein Attribut <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> gibt `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird `ReadNode` um einen neuen Knoten zu erstellen, und klicken Sie dann den neuen Knoten in das Dokument eingefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `cd.xml`als Eingabe.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Der Reader ist auf einem Knotentyp positioniert, der nicht in einen gültigen DOM-Knoten übersetzt wird (z. B. EndElement oder EndEntity).</exception>
        <block subset="none" type="overrides">
          <para>Diese Methode hat eine vererbungsanforderung. Volle Vertrauenswürdigkeit ist erforderlich, um das Überschreiben der <see langword="ReadNode" /> Methode.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Der Stream, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird beibehalten, wenn nur <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> festgelegt ist, um `true`.  
  
 Die XmlDeclaration des aktuellen `XmlDocument` Objekt bestimmt das encoding-Attribut in das gespeicherte Dokument. Der Wert des Codierungsattributs stammt aus dem <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Eigenschaft. Wenn die `XmlDocument` ist keine "XmlDeclaration", oder wenn XmlDeclaration keinen encoding-Attribut, das gespeicherte Dokument wird nicht über einen entweder.  
  
 Wenn das Dokument gespeichert wird, werden Xmlns-Attribute generiert, um die Identität des Knotens (lokalen Namen und Namespace-URI) richtig beibehalten. Beispielsweise wird der folgende C#-code  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 Xmls-Attribut `<item xmls="urn:1"/>`.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A> Methode erzwingt ein wohlgeformtes XML-Dokument. Alle anderen `Save` Überladungen gewährleisten nur ein Fragment wohlgeformt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see langword="TextWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Codierung für die `TextWriter` bestimmt die Codierung, die geschrieben wird (die Codierung des XmlDeclaration Knotens wird durch die Codierung des ersetzt die `TextWriter`). Wenn keine angegeben werden Codierung, auf die `TextWriter`, die `XmlDocument` ohne Codierungsattribut gespeichert ist.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A> Methode erzwingt ein wohlgeformtes XML-Dokument. Alle anderen `Save` Überladungen gewährleisten nur ein Fragment wohlgeformt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Speicherort der Datei, in der Sie das Dokument speichern möchten.</param>
        <summary>Speichert das XML-Dokument in der angegebenen Datei. Die angegebene Datei existiert, diese Methode überschreibt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird beibehalten, in die Ausgabe nur, wenn <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> festgelegt ist, um `true`.  
  
 Die XmlDeclaration des aktuellen `XmlDocument` Objekt bestimmt das encoding-Attribut in das gespeicherte Dokument. Der Wert des Codierungsattributs stammt aus dem <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Eigenschaft. Wenn die `XmlDocument` ist keine "XmlDeclaration", oder wenn XmlDeclaration keinen encoding-Attribut, das gespeicherte Dokument wird nicht über einen entweder.  
  
 Wenn das Dokument gespeichert wird, werden Xmlns-Attribute generiert, um die Identität des Knotens (lokalen Namen und Namespace-URI) richtig beibehalten. Beispielsweise wird der folgende C#-code  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 Xmls-Attribut `<item xmls="urn:1"/>`.  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A> Methode erzwingt ein wohlgeformtes XML-Dokument. Alle anderen `Save` Überladungen gewährleisten nur ein Fragment wohlgeformt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird XML-Daten in ein XmlDocument-Objekt geladen, ändert sie und klicken Sie dann in eine Datei namens data.xml gespeichert.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Die Datei "data.xml" enthält das folgende XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird beibehalten, wenn nur <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> festgelegt ist, um `true`.  
  
 Die Codierung für die `XmlWriter` bestimmt die Codierung, die geschrieben wird (die Codierung des XmlDeclaration Knotens wird durch die Codierung des ersetzt die `XmlWriter`). Wenn keine angegeben werden Codierung, auf die `XmlWriter`, die `XmlDocument` ohne Codierungsattribut gespeichert ist.  
  
 Wenn das Dokument gespeichert wird, werden Xmlns-Attribute generiert, um die Identität des Knotens (LocalName + NamespaceURI) richtig beibehalten. Beispielsweise wird der folgende C#-code  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 wird dieses Attribut für die XML-Dateien generiert:  
  
```  
<item  
    xmls="urn:1"/>  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A> Methode erzwingt ein wohlgeformtes XML-Dokument. Alle anderen `Save` Überladungen gewährleisten nur ein Fragment wohlgeformt ist.  
  
   
  
## Examples  
 Im folgende Beispiel lädt XML-Dokument in ein `XmlDocument` -Objekt und speichert es in einer Datei.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das PSVI (Post-Schema-Validation Infoset) des Knotens zurück.</summary>
        <value>Das <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />-Objekt, das das PSVI des Knotens darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der PSVI-Inhalt dieser Eigenschaft werden festgelegt, nachdem der Knoten überprüft wurde.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt ab, das diesem <see cref="T:System.Xml.XmlDocument" /> zugeordnet ist, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt, das die diesem <see cref="T:System.Xml.XmlDocument" /> zugeordneten XSD-Schemas (XML Schema Definition) enthält, andernfalls ein leeres <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schemas in ein <xref:System.Xml.Schema.XmlSchemaSet> Objekt zugeordnet ein <xref:System.Xml.XmlDocument> Objekt dienen zur Überprüfung bei der <xref:System.Xml.XmlDocument.Validate%2A> Methode eine <xref:System.Xml.XmlDocument> ausgeführt wird.  
  
 Wenn ein <xref:System.Xml.XmlDocument> -Objekt initialisiert wird, mit XML-Daten aus ein <xref:System.Xml.XmlReader> -Objekt, der <xref:System.Xml.Schema.XmlSchemaSet> -Objekt ist geladen, aus der <xref:System.Xml.XmlReaderSettings.Schemas%2A> Eigenschaft der <xref:System.Xml.XmlReader> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Das <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt, das Informationen zu Warnungen und Fehlern der Schemavalidierung empfängt.</param>
        <summary>Validiert das <see cref="T:System.Xml.XmlDocument" /> anhand der in der <see cref="P:System.Xml.XmlDocument.Schemas" />-Eigenschaft enthaltenen XSD-Schemas (XML Schema Definition).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlDocument.Validate%2A> Methode überprüft, ob die XML-Daten in der <xref:System.Xml.XmlDocument> für die Schemas in der <xref:System.Xml.XmlDocument.Schemas%2A> Eigenschaft. Die <xref:System.Xml.XmlDocument.Validate%2A> -Methode führt Infosets. Insbesondere nach erfolgreicher Validierung werden Schemastandards angewendet, Textwerte in atomare Werte nach Bedarf konvertiert und Typinformationen validierten Informationselementen zugeordnet ist. Das Ergebnis ist eine zuvor nicht typisierte XML-Teilstruktur in der <xref:System.Xml.XmlDocument> durch eine typisierte Teilstruktur ersetzt.  
  
 Im folgenden sind wichtige Hinweise zum Verwenden der <xref:System.Xml.XmlDocument.Validate%2A> Methode.  
  
-   Schemaspeicherort wie `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` werden ignoriert.  
  
-   Inlineschemas werden ignoriert.  
  
-   Schema-Validierungsfehler treten während der Überprüfung der <xref:System.Xml.XmlDocument> wird mit einigen Knoten mit der richtigen Typinformationen und einigen ohne teilweise validiert.  
  
-   Dieser Vorgang umfasst Überprüfung auf Eindeutigkeit und Referenz-Einschränkungen (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, und `xs:unique`).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Xml.XmlDocument.Validate%2A>-Methode veranschaulicht. Das Beispiel erstellt eine <xref:System.Xml.XmlDocument> , enthält eine verknüpfte XSD-Schema mithilfe der <xref:System.Xml.XmlReaderSettings> und <xref:System.Xml.XmlReader> Objekte. Anschließend wird die <xref:System.Xml.XPath.XPathNavigator> Klasse, um den typisierten Wert eines Elements im XML-Dokument generieren einen Schemavalidierungsfehler falsch ändern.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 In diesem Beispiel wird die `contosoBooks.xml` und `contosoBooks.xsd` -Dateien als Eingabe.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ein Schemavalidierungsereignis ist aufgetreten und es wird kein <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Objekt wurde angegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Das <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt, das Informationen zu Warnungen und Fehlern der Schemavalidierung empfängt.</param>
        <param name="nodeToValidate">Das <see cref="T:System.Xml.XmlNode" />-Objekt, das aus einem zu validierenden <see cref="T:System.Xml.XmlDocument" /> erstellt wurde.</param>
        <summary>Validiert das angegebene <see cref="T:System.Xml.XmlNode" />-Objekt anhand der in der <see cref="P:System.Xml.XmlDocument.Schemas" />-Eigenschaft enthaltenen XSD-Schemas (XML Schema Definition).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlDocument.Validate%2A> Methode überprüft, ob die XML-Daten in der <xref:System.Xml.XmlNode> Objekt anhand der in enthaltenen Schemas die <xref:System.Xml.XmlDocument.Schemas%2A> Eigenschaft. Die <xref:System.Xml.XmlDocument.Validate%2A> -Methode führt Infosets. Insbesondere nach erfolgreicher Validierung werden Schemastandards angewendet, Textwerte in atomare Werte nach Bedarf konvertiert und Typinformationen validierten Informationselementen zugeordnet ist. Das Ergebnis ist eine zuvor nicht typisierte XML-Teilstruktur in der <xref:System.Xml.XmlDocument> durch eine typisierte Teilstruktur ersetzt.  
  
 Im folgenden sind wichtige Hinweise zum Verwenden der <xref:System.Xml.XmlDocument.Validate%2A> Methode.  
  
-   Schemaspeicherort wie `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` werden ignoriert.  
  
-   Inlineschemas werden ignoriert.  
  
-   Schema-Validierungsfehler treten während der Überprüfung der <xref:System.Xml.XmlDocument> wird mit einigen Knoten mit der richtigen Typinformationen und einigen ohne teilweise validiert.  
  
 Bei der zu überprüfende Knoten den Stammknoten des Überprüfungsprozesses enthält Überprüfung auf Eindeutigkeit und Referenz-Einschränkungen (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, und `xs:unique`) ist, andernfalls Eindeutigkeits- und Referenz Einschränkungen werden ausgelassen.  
  
   
  
## Examples  
 Ein Beispiel für die <xref:System.Xml.XmlDocument.Validate%2A> -Methode finden Sie unter der <xref:System.Xml.XmlDocument.Validate%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="T:System.Xml.XmlNode" /> -Objektparameter wurde nicht aus einer <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Xml.XmlNode" /> -Objektparameters ist nicht an ein Element, Attribut, Dokumentfragment oder der Stammknoten.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ein Schemavalidierungsereignis ist aufgetreten und es wird kein <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Objekt wurde angegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert alle untergeordneten Elemente des <see langword="XmlDocument" />-Knotens im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL). Es ist funktionell gleichwertig mit der <xref:System.Xml.XmlDocument.InnerXml%2A> Eigenschaft.  
  
 Die <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Eigenschaft bestimmt die Codierung, die geschrieben wird. Wenn die `Encoding` Eigenschaft verfügt nicht über einen Wert, der `XmlDocument` ohne Codierungsattribut geschrieben wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Dokument auf dem Bildschirm angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert den <see langword="XmlDocument" />-Knoten im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung, die (DOKUMENTOBJEKTMODELL). Es ist funktionell gleichwertig mit der <xref:System.Xml.XmlNode.OuterXml%2A> Eigenschaft.  
  
 Die <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Eigenschaft bestimmt die Codierung, die geschrieben wird. Wenn die `Encoding` Eigenschaft verfügt nicht über einen Wert, der `XmlDocument` ohne Codierungsattribut geschrieben wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Dokument auf dem Bildschirm angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den für die Auflösung externer Ressourcen zu verwendenden <see cref="T:System.Xml.XmlResolver" /> fest.</summary>
        <value>Der zu verwendende <see langword="XmlResolver" />.  
  
 In .NET Framework, Version 1.1, kann nur ein vollständig vertrauenswürdiger Aufrufer einen <see langword="XmlResolver" /> festlegen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `XmlResolver` dienen zum Laden von DTDs oder Erweitern von Entitätsverweisen. Mithilfe der <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> -Eigenschaft, können Sie die Anmeldeinformationen festlegen, auf die `XmlResolver` den Zugriff auf Ressourcen in einer sicheren Netzwerkressource gespeichert.  
  
-   Wenn das Dokument nicht geladen wurde ein <xref:System.Xml.XmlReader> (d. h., wenn es geladen wurde, mithilfe eines Datenstroms, Datei usw.) der `XmlResolver` auf die `XmlDocument` wird immer verwendet.  
  
-   Wenn das Dokument geladen wurde, mit einer <xref:System.Xml.XmlTextReader>, den Konfliktlöser auf den `XmlTextReader` wird verwendet, um alle DTD-Verweise im DocumentType-Knoten zu beheben. Der Resolver für die `XmlDocument` wird verwendet, um alle Entitätsverweise zu erweitern.  
  
-   Wenn das Dokument geladen wurde, mit einer <xref:System.Xml.XmlValidatingReader>, den Konfliktlöser auf die `XmlDocument` wird nie verwendet.  
  
-   Wenn das Dokument mit einer Klasse geladen wurde, das erweitert `XmlReader` und die `XmlReader` keine Entitäten auflösen kann (<xref:System.Xml.XmlReader.CanResolveEntity%2A> gibt `false`), die `XmlResolver` auf die `XmlDocument` dient zum Auflösen von Verweisen im DocumentType-Knoten und um Entitätsverweise zu erweitern.  
  
> [!NOTE]
>  Wenn die `XmlDocument` mit geladen wird ein <xref:System.Xml.XmlReader> mussten die ein `XmlResolver` festgelegt, die `XmlResolver` auf die `XmlReader` wird nicht zwischengespeichert, indem Sie die `XmlDocument` nach <xref:System.Xml.XmlDocument.Load%2A> abgeschlossen ist.  
  
 Wenn diese Eigenschaft nicht festgelegt ist, bestimmt die Vertrauensebene der Anwendung in.NET Framework Version 1.1, das Standardverhalten.  
  
 `Fully trusted code:`Das Dokument verwendet den Standardwert <xref:System.Xml.XmlUrlResolver> mit keine Anmeldeinformationen des Benutzers. Wenn Zugriff auf eine Netzwerkressource eine Authentifizierung erforderlich ist, verwenden Sie die `XmlResolver` -Eigenschaft an ein `XmlResolver` mit den erforderlichen Anmeldeinformationen.  
  
 `Semi-trusted code:`Die `XmlResolver` -Eigenschaftensatz auf `null`. Externe Ressourcen nicht aufgelöst.  
  
 Weitere Informationen zur Sicherheit und die `XmlResolver` Eigenschaft finden Sie unter [externe Ressourcen auflösen](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgende Beispiel wird ein XML-Dokument enthält einen Verweis auf eine DTD-Datei geladen. Die `XmlResolver` Eigenschaft wird zum Festlegen der Anmeldeinformationen erforderlich, auf die Netzwerkressource zugreifen.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 Im Beispiel werden die folgenden Dateien als Eingabe verwendet.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Diese Eigenschaft wird festgelegt, um <see langword="null" /> und eine externe DTD oder Entität gefunden wird.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
