<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Reader dar, der einen schnellen Zugriff auf XML-Daten bietet, ohne Zwischenspeicher und welcher nur vorwärts möglich ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Core/XmlReader.cs#086471e5cca0825f). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 <xref:System.Xml.XmlReader>bietet Vorwärtscursor, nur-Lese Zugriff auf XML-Daten in Adocument oder den Stream. Diese Klasse entspricht dem W3C [Extensible Markup Language (XML) 1.0 (vierte Ausgabe)](http://www.w3.org/TR/2006/REC-xml-20060816/) und [Namespaces in XML 1.0 (dritte Edition)](http://www.w3.org/TR/REC-xml-names/) Empfehlungen.  
  
 <xref:System.Xml.XmlReader>Methoden können Sie die XML-Daten durchlaufen und den Inhalt eines Knotens lesen. Den Wert des aktuellen Knotens, auf dem der Reader positioniert ist also entsprechen den Eigenschaften der Klasse. Die <xref:System.Xml.XmlReader.ReadState%2A> Eigenschaftswert gibt den aktuellen Status des XML-Readers. Beispielsweise ist die Eigenschaft auf festgelegt <xref:System.Xml.ReadState.Initial> von der <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Methode und <xref:System.Xml.ReadState.Closed> durch die <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> Methode. <xref:System.Xml.XmlReader>bietet Überprüfungen der Compilerkonformität Daten und eine DTD oder dem Schema-Validierung.  
  
 <xref:System.Xml.XmlReader>verwendet ein Pull-Modell zum Abrufen von Daten an. Dieses Modell:  
  
-   Vereinfacht die Zustandsverwaltung durch eine prozedurale Verfeinerung der natürlichen, oben nach unten.  
  
-   Unterstützt mehrere Eingabedatenströme und aufbauen.  
  
-   Ermöglicht dem Client dem Parser vergeben eines Puffers in dem die Zeichenfolge wird direkt geschrieben, und vermeidet somit die Notwendigkeit einer zusätzlichen Zeichenfolge, die Kopie an.  
  
-   Unterstützt das selektive Verarbeitung. Der Client kann Elemente überspringen und zu verarbeiten, die für die Anwendung von Interesse sind. Sie können auch festlegen, dass Eigenschaften im voraus, um die Art der Verarbeitung des XML-Streams (z. B. Normalisierung) zu verwalten.  
  
 In diesem Abschnitt  
  
 [Erstellen eines XML-Lesers](#xmlreader_create)   
 [Validieren von XML-Daten](#xmlreader_validate)   
 [Datenkonformität](#xmlreader_data)   
 [Navigieren durch die Knoten](#xmlreader_nodes)   
 [Lesen der XML-Elemente](#xmlreader_elements)   
 [Lesen der XML-Attribute](#xmlreader_attributes)   
 [Lesen der XML-Inhalt](#xmlreader_content)   
 [Konvertieren CLR-Typen](#xmlreader_clr)   
 [Asynchrones Programmieren](#xmlreader_async)   
 [Überlegungen zur Sicherheit](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Erstellen eines XML-Lesers  
 Verwenden der <xref:System.Xml.XmlReader.Create%2A> Methode zum Erstellen einer <xref:System.Xml.XmlReader> Instanz.  
  
 Wird zwar von .NET Framework konkrete Implementierungen bereitgestellt der <xref:System.Xml.XmlReader> Klasse, z. B. die <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, und die <xref:System.Xml.XmlValidatingReader> Klassen, es wird empfohlen, die speziellen Klassen nur in diesen Szenarien verwendet werden:  
  
-   Wenn möchten Readan XML-DOM-Teilstruktur aus einer <xref:System.Xml.XmlNode> -Objekts die <xref:System.Xml.XmlNodeReader> Klasse. (Allerdings nicht diese Klasse DTD- oder schemavalidierung unterstützt.)  
  
-   Wenn müssen Sie Entitäten auf Anforderung erweitern, Sie nicht den Text Content normalisiert, oder Sie möchten schließlich nicht standardmäßig über Attribute, die zurückgegeben wird, verwenden Sie die <xref:System.Xml.XmlTextReader> Klasse.  
  
 Um den Satz von Funktionen geben Sie auf der XML-Reader aktivieren möchten, übergeben Sie ein <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> -Objekt an die <xref:System.Xml.XmlReader.Create%2A> Methode. Können Sie ein einzelnes <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> Objekt, das um mehrere Reader mit denselben Funktionen zu erstellen oder Ändern der <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> Objekt, das kein neuen Leser mit einem anderen Satz von Funktionen zu erstellen. Sie können einem vorhandenen Reader leicht Funktionen hinzufügen.  
  
 Wenn Sie nicht verwenden eine <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> -Objekt Standardeinstellungen verwendet werden. Finden Sie unter der <xref:System.Xml.XmlReader.Create%2A> Referenzseite für Details.  
  
 <xref:System.Xml.XmlReader>Löst ein <xref:System.Xml.XmlException> auf XML-Analysefehler. Nachdem eine Ausnahme ausgelöst wird, ist der Zustand des Readers nicht vorhersagbar. Beispielsweise kann der angegebene Knotentyp von der tatsächlichen Knotentyp des aktuellen Knotens unterscheiden. Verwenden der <xref:System.Xml.XmlReader.ReadState%2A> Eigenschaft zu überprüfen, ob der Reader befindet sich im Status "Fehler".  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validieren von XML-Daten  
 Um die Struktur eines XML-Dokuments und dessen elementbeziehungen, Datentypen und inhaltseinschränkungen zu definieren, verwenden Sie eine Dokumenttypdefinition (DTD) oder das Schema für XML Schema Definition Language (XSD). Ein XML-Dokument wohlgeformt sein, wenn es alle syntaktischen Anforderungen, die durch definierten erfüllt gilt die [W3C XML 1.0-Empfehlung](http://www.w3.org/TR/2006/REC-xml-20060816/). Es ist gültig, wenn es wohlgeformt ist und auch die Einschränkungen der DTD oder dem Schema entspricht. (Finden Sie unter der [W3C XML Schema Part 1: Strukturen](http://www.w3.org/TR/xmlschema-1/) und [W3C XML Schema Part 2: Datatypes](http://www.w3.org/TR/xmlschema-2/)Empfehlungen.) Das heißt, dass alle gültigen XML-Dokumente wohlgeformt sind, jedoch nicht alle wohlgeformten XML-Dokumente gültig sein müssen.  
  
 Sie können überprüfen, dass die Daten einer DTD eine Inline-XSD-Schema oder ein XSD-Schema gespeichert, ein <xref:System.Xml.Schema.XmlSchemaSet> Objekt (ein Cache) werden diese Szenarien beschrieben, auf die <xref:System.Xml.XmlReader.Create%2A> Referenzseite. <xref:System.Xml.XmlReader>Schema-Validierung von XML-Data Reduced (XDR) nicht unterstützt werden.  
  
 Verwenden Sie die folgenden Einstellungen auf der <xref:System.Xml.XmlReaderSettings> Klasse an, welche Art von Validierung, sofern vorhanden, die <xref:System.Xml.XmlReader> Instanz unterstützt.  
  
|Verwenden Sie diese <xref:System.Xml.XmlReaderSettings> Member|Angabe von|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>-Eigenschaft|Ob die DTD-Verarbeitung ermöglicht. In der Standardeinstellung ist die DTD-Verarbeitung nicht zulässig.|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>-Eigenschaft|Gibt an, ob der Reader die Daten überprüfen soll, und welche Art von Validierung (DTD oder dem Schema) ausführen. In der Standardeinstellung erfolgt keine Validierung.|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler>-Ereignis|Ein Ereignishandler für den Empfang von Informationen zu Validierungsereignisse. Wenn kein Ereignishandler bereitgestellt wird, wird beim ersten Validierungsfehler eine <xref:System.Xml.XmlException> ausgelöst.|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>-Eigenschaft|Zusätzliche Validierung "Optionen" über die <xref:System.Xml.Schema.XmlSchemaValidationFlags> Enumerationsmember:<br /><br /> -   `AllowXmlAttributes`– Ermöglichen Sie die XML-Attribute (`xml:*`) in Instanzdokumenten, selbst wenn sie nicht im Schema definiert sind. Die Attribute werden basierend auf deren Datentyp überprüft. Finden Sie unter der <xref:System.Xml.Schema.XmlSchemaValidationFlags> Referenzseite für die Einstellung, die in bestimmten Szenarien zu verwenden. (Standardmäßig deaktiviert.)<br />-   `ProcessIdentityConstraints`--Identitätseinschränkungen verarbeiten (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) während der Validierung gefunden. (Standardmäßig aktiviert).<br />-   `ProcessSchemaLocation`--Verarbeiten Schemas, die gemäß der `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` Attribut. (Standardmäßig aktiviert).<br />-   `ProcessInlineSchema`--Verarbeiten Sie Inline-XML-Schemas während der Validierung. (Standardmäßig deaktiviert.)<br />-   `ReportValidationWarnings`--Melden Sie Ereignisse, wenn eine überprüfungswarnung auftritt. Eine Warnung wird normalerweise ausgegeben, wenn keine DTD oder kein XML-Schema vorhanden ist, anhand derer bzw. dessen ein bestimmtes Attribut oder Element validiert werden kann. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> wird zur Benachrichtigung verwendet. (Standardmäßig deaktiviert.)|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Die für die Validierung zu verwendende <xref:System.Xml.Schema.XmlSchemaSet>.|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft|Die <xref:System.Xml.XmlResolver> zum Auflösen von und Zugreifen auf externe Ressourcen. Dies kann z. B. DTD, Schemas und eine externe Entitäten umfassen `xs:include` oder `xs:import` in das XML-Schema enthaltenen Elemente. Wenn Sie nicht angeben einer <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> verwendet den Standardwert <xref:System.Xml.XmlUrlResolver> mit keine Anmeldeinformationen des Benutzers.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Datenkonformität  
 Durch die erstellte XML-Reader die <xref:System.Xml.XmlReader.Create%2A> Methodmeet standardmäßig die folgenden Compliance-Anforderungen:  
  
-   Neue Zeilen und Attributwert werden gemäß der W3C normalisiert [XML 1.0-Empfehlung](http://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Alle Entitäten werden automatisch erweitert.  
  
-   Standardattribute deklariert in die Dokumenttypdefinition werden immer hinzugefügt werden, selbst wenn der Reader überprüft nicht.  
  
-   Deklaration eines XML-Namespacepräfix, den richtigen XML-Namespace-URI zugeordnet ist zulässig.  
  
-   Die Notationsnamen in einer einzelnen `NotationType` -Attributdeklaration und`NmTokens` in einer einzelnen `Enumeration` -Attribut Declarationare distinct.  
  
 Verwenden Sie diese <xref:System.Xml.XmlReaderSettings> Eigenschaften zur Angabe der Art der Übereinstimmung prüft Sie aktivieren möchten:  
  
|Verwenden Sie diese <xref:System.Xml.XmlReaderSettings> Eigenschaft|Beschreibung|Standard|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>-Eigenschaft|Aktivieren Sie oder deaktivieren Sie Folgendes überprüft:<br /><br /> -Zeichen werden innerhalb des Bereichs der gültigen XML-Zeichen gemäß der [2.2 Zeichen](http://www.w3.org/TR/2006/REC-xml-20060816/#charsets) Abschnitt der W3C-Empfehlung für XML 1.0.<br />-Alle XML-Namen sind gültig, gemäß der [2.3 allgemeine Syntaktische Konstrukte](http://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) Abschnitt der W3C-Empfehlung für XML 1.0.<br /><br /> Wenn diese Eigenschaft festgelegt wird, um `true` (Standard), ein <xref:System.Xml.XmlException> Ausnahme wird ausgelöst, die XML-Datei enthält ungültige Zeichen oder eine ungültige XML-Namen (z. B. Namen eines Elements mit einer Zahl beginnt).|Zeichen- und namensüberprüfung aktiviert ist.<br /><br /> Durch Festlegen von <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> auf `false` wird die Zeichenüberprüfung für Zeichenentitätsverweise deaktiviert. Wenn der Reader Textdaten verarbeitet, werden stets, dass die XML-Namen ungültig, unabhängig von dieser Einstellung werden überprüft. **Hinweis:** XML 1.0-Empfehlung muss bei eine DTD vorhanden ist die Übereinstimmung auf Dokumentebene. Deshalb, wenn der Reader für die Unterstützung konfiguriert ist <xref:System.Xml.ConformanceLevel?displayProperty=nameWithType>, aber die XML-Daten enthält eine Dokumenttypdefinition (DTD), ein <xref:System.Xml.XmlException> ausgelöst wird.|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>-Eigenschaft|Wählen Sie die Ebene Übereinstimmungsniveau erzwungen:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Entspricht den Regeln für einem [wohlgeformtes XML 1.0-Dokument](http://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Entspricht den Regeln für ein wohlgeformtes Dokument-Fragment, das als genutzt werden, kann ein [extern analysierte Entität](http://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Die Ebene, die vom Reader entschieden entspricht.<br /><br /> Wenn die Daten in Übereinstimmung, ist ein <xref:System.Xml.XmlException> Ausnahme wird ausgelöst.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Navigieren durch die Knoten  
 Der aktuelle Knoten ist der XML-Knoten, auf dem der XML-Reader derzeit positioniert ist. Alle <xref:System.Xml.XmlReader> Methoden führen Vorgänge in Bezug auf diesen Knoten und alle <xref:System.Xml.XmlReader> Eigenschaften entsprechen den Wert des aktuellen Knotens.  
  
 Die folgenden Methoden erleichtern das Navigieren von Knoten und die Daten analysieren.  
  
|Verwenden Sie diese <xref:System.Xml.XmlReaderSettings> Methode|Beschreibung|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Lesen Sie den ersten Knoten, und blättern Sie durch den Datenstrom ein Knoten zu einem Zeitpunkt. Solche Aufrufe erfolgen in der Regel innerhalb einer `while` Schleife.<br /><br /> Verwenden der <xref:System.Xml.XmlReader.NodeType%2A> Eigenschaft beim Abrufen des Typs (z. B. Attribut, Kommentar, Element usw.) des aktuellen Knotens.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Überspringen Sie die untergeordneten Elemente des aktuellen Knotens, und wechseln Sie zum nächsten Knoten.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> und <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Überspringen Sie nicht-Inhalt Knoten, und wechseln Sie zum nächsten Inhaltsknoten oder an das Ende der Datei.<br /><br /> Nicht-Inhalt Knoten enthalten <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, und <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Inhalt Knoten enthalten, nicht-Leerzeichen-Text, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , und <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Ein Element und alle seine untergeordneten Elemente und gibt ein neues <xref:System.Xml.XmlReader> -Instanzensatz auf <xref:System.Xml.ReadState?displayProperty=nameWithType>.<br /><br /> Diese Methode ist nützlich zum Erstellen von XML-Elemente für die Begrenzung. Wenn Sie Daten an eine andere Komponente zur Verarbeitung übergeben möchten und wie viele Daten einschränken möchten kann z. B. die Komponente zugegriffen.|  
  
 Finden Sie unter der <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Referenzseite für ein Beispiel für das Navigieren durch ein Stream Textknoten zu einem Zeitpunkt und die Anzeige des Typs der einzelnen Knoten.  
  
 In den folgenden Abschnitten wird beschrieben, wie Sie bestimmte Typen von Daten, z. B. Elemente, Attribute lesen können und typisierte Daten.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Lesen der XML-Elemente  
 Die folgende Tabelle enthält die Methoden und Eigenschaften, die die <xref:System.Xml.XmlReader> Klasse für die Verarbeitung von Elementen enthält. Nachdem der <xref:System.Xml.XmlReader> auf einem Element platziert wurde, spiegeln die Knoteneigenschaften, z. B. <xref:System.Xml.XmlReader.Name%2A>, die Elementwerte wider. Zusätzlich zu den unten beschriebenen Membern können auch alle allgemeinen Methoden und Eigenschaften der <xref:System.Xml.XmlReader>-Klasse zum Verarbeiten von Elementen verwendet werden. Sie können beispielsweise mit der <xref:System.Xml.XmlReader.ReadInnerXml%2A>-Methode den Inhalt eines Elements lesen.  
  
> [!NOTE]
>  Finden Sie im Abschnitt 3.1 die [W3C XML 1.0-Empfehlung](http://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) für Definitionen von Starttags, beenden, und leeres Element-Tags.  
  
|Verwenden Sie diese <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A>-Methode|Überprüfen Sie, ob der aktuelle Knoten ein Starttag oder ein leeres Elementtag ist.|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A>-Methode|Überprüfen Sie, dass der aktuelle Knoten ein Element ist und den Reader auf den nächsten Knoten zu gelangen (Aufrufe <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von <xref:System.Xml.XmlReader.Read%2A>).|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A>-Methode|Überprüfen Sie, dass der aktuelle Knoten ein Endtag ist, und gelangen Sie den Reader auf den nächsten Knoten zu.|  
|<xref:System.Xml.XmlReader.ReadElementString%2A>-Methode|Lesen eines nur-Text-Elements.|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A>-Methode|Späterer Status des XML-Readers zum nächsten Nachfolger (untergeordnete)-Element, das dem angegebenen Namen ab.|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A>-Methode|Den XML-Reader an das nächste nebengeordnete Element mit dem angegebenen Namen zu gelangen.|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A>-Eigenschaft|Überprüfen Sie, ob das aktuelle Element Endtag aufweist. Zum Beispiel:<br /><br /> -   `<item num="123"/>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> ist `true`.)<br />-   `<item num="123"> </item>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> ist `false`, obwohl der Inhalt des Elements leer ist.)|  
  
 Ein Beispiel zum Lesen des Textinhalts von Elementen finden Sie unter der <xref:System.Xml.XmlReader.ReadString%2A> Methode. Im folgende Beispiel verarbeitet die Elemente mithilfe einer `while` Schleife.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Lesen der XML-Attribute  
 XML-Attribute werden am häufigsten auf Elemente gefunden, aber sie können auch auf die XML-Deklaration und Dokumenttypknoten zulässig.  
  
 Wenn auf einem Elementknoten positioniert die <xref:System.Xml.XmlReader.MoveToAttribute%2A> -Methode ermöglicht es Ihnen das Durchlaufen der Attributliste des Elements. Beachten Sie, dass nach dem <xref:System.Xml.XmlReader.MoveToAttribute%2A> aufgerufen wurde, Eigenschaften des Knotens wie z. B. <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> die Eigenschaften dieses Attributs entsprechen, nicht die Eigenschaften des Elements das Attribut gehört.  
  
 Die <xref:System.Xml.XmlReader> Klasse enthält diese Methoden und Eigenschaften zum Lesen und Verarbeiten von Attributen für Elemente.  
  
|Verwenden Sie diese <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A>-Eigenschaft|Überprüfen Sie, ob der aktuelle Knoten über Attribute verfügt.|  
|<xref:System.Xml.XmlReader.AttributeCount%2A>-Eigenschaft|Ruft die Anzahl von Attributen für das aktuelle Element ab.|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>-Methode|Wechseln Sie zum ersten Attribut in einem Element.|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A>-Methode|Wechseln Sie zum nächsten Attribut in einem Element.|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A>-Methode|Verschieben Sie in einem angegebenen Attribut.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A>Methode oder <xref:System.Xml.XmlReader.Item%2A> Eigenschaft|Ruft den Wert eines angegebenen Attributs.|  
|<xref:System.Xml.XmlReader.IsDefault%2A>-Eigenschaft|Überprüfen Sie, ob der aktuelle Knoten ein Attribut ist, aus dem in der DTD oder dem Schema definierten Standardwert generiert wurde.|  
|<xref:System.Xml.XmlReader.MoveToElement%2A>-Methode|Verschieben Sie das Element, das das aktuelle Attribut besitzt. Verwenden Sie diese Methode, um auf ein Element zurückzugeben, nach dessen Attribute das navigieren.|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A>-Methode|Analysieren Sie den Attributwert in einen oder mehrere `Text`, `EntityReference`, oder `EndEntity` Knoten.|  
  
 Alle allgemeinen Methoden und Eigenschaften von <xref:System.Xml.XmlReader> können auch für die Verarbeitung von Attributen verwendet werden. Beispielsweise reflektieren die <xref:System.Xml.XmlReader>-Eigenschaft und die <xref:System.Xml.XmlReader.Name%2A>-Eigenschaft nach dem Positionieren von <xref:System.Xml.XmlReader.Value%2A> auf einem Attribut die Werte des Attributs. Sie können den Wert des Attributs auch mit einer beliebigen `Read`-Methode für den Inhalt abrufen.  
  
 Dieses Beispiel verwendet die <xref:System.Xml.XmlReader.AttributeCount%2A> Eigenschaft, um alle Attribute für ein Element zu navigieren.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Dieses Beispiel verwendet die <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> Methode in einer `while` Schleife zum Navigieren durch die Attribute.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Lesen von Attributen in XML-Deklarationsknoten**  
  
 Wenn der XML-Reader auf einem XML-Deklarationsknoten positioniert ist die <xref:System.Xml.XmlReader.Value%2A> Eigenschaft gibt die Version, die eigenständige und die Codierungsinformationen als einzelne Zeichenfolge zurück. <xref:System.Xml.XmlReader>Objekte erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, die <xref:System.Xml.XmlTextReader> -Klasse, und die <xref:System.Xml.XmlValidatingReader> Klasse verfügbar machen, die Version, die eigenständige und die Codierung Elemente als Attribute.  
  
 **Lesen von Attributen auf Dokumenttypknoten**  
  
 Wenn der XML-Reader in einem Dokument Typknoten positioniert ist die <xref:System.Xml.XmlReader.GetAttribute%2A> Methode und <xref:System.Xml.XmlReader.Item%2A> Eigenschaft kann verwendet werden, um die Werte für die System- und öffentlichen Literale zurückzugeben. Durch das Aufrufen von `reader.GetAttribute("PUBLIC")` wird beispielsweise der Wert PUBLIC zurückgegeben.  
  
 **Lesen von Attributen auf Verarbeitungsanweisungsknoten**  
  
 Wenn der <xref:System.Xml.XmlReader> auf einem Verarbeitungsanweisungsknoten positioniert ist, gibt die <xref:System.Xml.XmlReader.Value%2A>-Eigenschaft den gesamten Textinhalt zurück. Elemente in der Verarbeitungsanweisungsknoten werden nicht als Attribute behandelt. Sie können nicht gelesen werden, mit der <xref:System.Xml.XmlReader.GetAttribute%2A> oder <xref:System.Xml.XmlReader.MoveToAttribute%2A> Methode.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Lesen der XML-Inhalt  
 Der XMLReader-Klasse enthält die folgenden Elemente, die Lesen von Inhalt aus einer XML-Datei, und geben Sie den Inhalt als Zeichenfolgenwerte zurück. (Um CLR-Typen zurückzugeben, finden Sie unter der [nächsten Abschnitt](#xmlreader_clr).)  
  
|Verwenden Sie diese <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A>-Eigenschaft|Ruft den Textinhalt des aktuellen Knotens. Der zurückgegebene Wert hängt von Knotentyp ab. finden Sie unter der <xref:System.Xml.XmlReader.Value%2A> Referenzseite für Details.|  
|<xref:System.Xml.XmlReader.ReadString%2A>-Methode|Inhalt eines Knotens Element- oder Textknotens als Zeichenfolge abrufen. Diese Methode beendet auf verarbeitungsanweisungen und Kommentare.<br /><br /> Weitere Informationen zur Behandlung von dieser Methode auf bestimmte Knotentypen aufgeführt sind, finden Sie unter der <xref:System.Xml.XmlReader.ReadString%2A> Referenzseite.|  
|Die Methoden <xref:System.Xml.XmlReader.ReadInnerXml%2A> und <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Rufen Sie alle Inhalte des aktuellen Knotens, einschließlich Markup, aber ohne die Start- und Endtags. Z. B. für:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A>Gibt zurück:<br /><br /> `this<child id="123"/>`|  
|Die Methoden <xref:System.Xml.XmlReader.ReadOuterXml%2A> und <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Rufen Sie alle Inhalte des aktuellen Knotens und seine untergeordneten Elemente, einschließlich Markup und Start-/Endtags ein. Z. B. für:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A>Gibt zurück:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Konvertieren CLR-Typen  
 Können Sie die Mitglieder der <xref:System.Xml.XmlReader> Klasse (in der folgenden Tabelle aufgeführten) zum Lesen von XML-Daten und Rückgabewerte als common Language Runtime (CLR)-Typen anstelle von Zeichenfolgen. Diese Elemente ermöglichen es Ihnen, Werte in der Darstellung zu erhalten, die ohne manuell analysieren oder konvertieren Zeichenfolgenwerte für Ihre Codierung Aufgabe am besten geeignet ist.  
  
-   Die **ReadElementContentAs** Methoden können nur für Elementknotentypen aufgerufen werden. Diese Methoden können nur für Elemente verwendet werden, die untergeordnete Elemente oder gemischten Inhalt enthalten. Bei einem Aufruf liest das <xref:System.Xml.XmlReader>-Objekt das Anfangstag und den Elementinhalt und wird hinter das Endelementtag verschoben. Verarbeitungsanweisungen und Kommentare werden ignoriert und Entitäten erweitert.  
  
-   Die **ReadContentAs**Methoden lesen den Textinhalt an der aktuellen Position des Readers, und wenn die XML-Daten keine Schema- oder Daten, die Typinformationen zugeordnet, konvertieren Sie den Textinhalt in den angeforderten Rückgabetyp. Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte sind verkettet. Kommentare und verarbeitungsanweisungen werden übersprungen und Entitätsverweise automatisch aufgelöst werden.  
  
 Die <xref:System.Xml.XmlReader> Klasse verwendet die Regeln der [W3C XML Schema Part 2: Datatypes](http://www.w3.org/TR/xmlschema-2/)Empfehlung.  
  
|Verwenden Sie diese <xref:System.Xml.XmlReader> Methode|Um diese CLR-Typ zurückzugeben.|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> und <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Der Typ, die Sie angeben, mit der `returnType` Parameter|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Die am besten geeignete Typ ist, entsprechend den Angaben von der <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> Eigenschaft. Finden Sie unter [Typenunterstützung in den System.Xml-Klassen](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) für die Zuordnungsinformationen zu.|  
  
 Wenn ein Element problemlos in einen CLR-Typ aufgrund dessen Format konvertiert werden kann, können Sie eine schemazuordnung, um eine erfolgreiche Konvertierung sicherzustellen. Im folgenden Beispiel wird eine XSD-Datei konvertieren die `hire-date` Element an der `xs:date` Typ zugewiesen und dann verwendet der <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> Methode, um das Element als zurückzugeben eine <xref:System.DateTime> Objekt.  
  
 **Eingabe (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schema (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Code:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Ausgabe:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Asynchrone Programmierung  
 Die meisten der <xref:System.Xml.XmlReader> Methoden verfügen über asynchrone Entsprechungen, die "Async" am Ende der Methodennamen aufweisen. Angenommen, das asynchrone Äquivalent von <xref:System.Xml.XmlReader.ReadContentAsObject%2A> ist <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Die folgenden Methoden können mit asynchrone Methodenaufrufe verwendet werden:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 Den folgenden Abschnitten werden die asynchrone Verwendung für Methoden, die nicht über asynchrone Entsprechungen verfügen.  
  
 **ReadStartElement-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Beachten Sie Folgendes bei der Arbeit mit der <xref:System.Xml.XmlReader> Klasse:  
  
-   Ausnahmen, die von der <xref:System.Xml.XmlReader> können Pfadinformationen, die nicht besser protokolliert, bis zu Ihrer app anzugeben. Ihrer app muss Ausnahmen auffangen und entsprechend verarbeiten.  
  
-   Aktivieren Sie nicht, wenn Sie Bedenken bezüglich eines Denial-of-Service-Problemen-sind oder wenn Sie mit nicht vertrauenswürdigen Quellen arbeiten, DTD-Verarbeitung. DTD-Verarbeitung ist standardmäßig deaktiviert, um <xref:System.Xml.XmlReader> Objekte erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> Methode.  
  
     Wenn die DTD-Verarbeitung aktiviert ist, können die Ressourcen, auf die der <xref:System.Xml.XmlSecureResolver> Zugriff hat, mit dem <xref:System.Xml.XmlReader> eingeschränkt werden. Sie können auch Ihre app entwerfen, damit die XML-Verarbeitung bezüglich Arbeitsspeicher und Zeit eingeschränkt. Sie können z. B. Timeouts in Ihrer ASP.NET app konfigurieren.  
  
-   XML-Daten können Verweise auf externe Ressourcen (z. B. eine Schemadatei) enthalten. Standardmäßig werden externe Ressourcen aufgelöst, mithilfe einer <xref:System.Xml.XmlUrlResolver> Objekt mit keine Anmeldeinformationen des Benutzers. Durch die folgenden Aktionen können Sie die Sicherheit weiter erhöhen:  
  
    -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
  
    -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
-   Die <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> und <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> Validierungsflag eines ein <xref:System.Xml.XmlReaderSettings> -Objekts werden nicht standardmäßig festgelegt. Dadurch wird der <xref:System.Xml.XmlReader> bei der Verbarbeitung von XML-Daten aus einer nicht vertrauenswürdigen Quelle vor schemabasierten Angriffen geschützt. Wenn diese Flags festgelegt sind, wird der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> des <xref:System.Xml.XmlReaderSettings>-Objekts verwendet, um die im Instanzdokument des <xref:System.Xml.XmlReader> erkannten Schemaspeicherorte aufzulösen. Wenn die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> -Eigenschaftensatz auf `null`, Schemaspeicherorten werden nicht aufgelöst selbst wenn die <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> und <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> Validierungsflag festgelegt werden.  
  
     Durch während der Validierung hinzugefügte Schemas werden neue Typen hinzugefügt, sodass das Validierungsergebnis des überprüften Dokuments möglicherweise geändert wird. Daher sollten externe Schemata nur von vertrauenswürdigen Quellen aufgelöst werden.  
  
     Es wird empfohlen, das Deaktivieren der <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> flag beim Überprüfen der nicht vertrauenswürdigen, große XML-Dokumente in Szenarien mit hoher Verfügbarkeit anhand eines Schemas, die Identity-Einschränkung über einen großen Teil des Dokuments besitzt. Dieses Flag ist standardmäßig aktiviert.  
  
-   XML-Daten können eine Vielzahl von Attributen, Namespacedeklarationen, geschachtelten Elementen usw. enthalten, deren Verarbeitung sehr zeitaufwendig ist. Die Größe der Eingabe zu beschränken, die an die <xref:System.Xml.XmlReader>, können Sie:  
  
    -   Begrenzen Sie die Größe des Dokuments durch Festlegen der <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> Eigenschaft.  
  
    -   Die Anzahl der Zeichen, das Erweitern von Entitäten ergeben durch Festlegen der <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> Eigenschaft.  
  
    -   Erstellen eines benutzerdefinierten `IStream` Implementierung für die <xref:System.Xml.XmlReader>.  
  
-   Die <xref:System.Xml.XmlReader.ReadValueChunk%2A> Methode kann verwendet werden, um umfangreiche Streams mit Daten zu behandeln. Mit dieser Methode wird jeweils eine kleine Anzahl von Zeichen gelesen, anstatt dem ganzen Wert eine einzelne Zeichenfolge zuzuweisen.  
  
-   Beim Lesen eines XML-Dokuments mit einer großen Anzahl von eindeutigen lokalen Namen, Namespaces oder Präfixen kann ein Problem auftreten. Bei Verwendung eine Klasse, die abgeleitet <xref:System.Xml.XmlReader>, und rufen Sie die <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, oder <xref:System.Xml.XmlReader.NamespaceURI%2A> Eigenschaft für jedes Element der zurückgegebene Zeichenfolge hinzugefügt wird eine <xref:System.Xml.NameTable>. Die Auflistung von reservierten die <xref:System.Xml.NameTable> Größe der in ein virtueller Speicherverlust Zeichenfolgenhandles nie verringert. Eine Lösung für dieses ist die Ableitung der <xref:System.Xml.NameTable> Klasse, und erzwingen Sie ein maximales Größenkontingent. (Es gibt keine Möglichkeit, um zu verhindern, dass die Verwendung von einer <xref:System.Xml.NameTable>, oder Wechseln der <xref:System.Xml.NameTable> vollen). Eine andere Entschärfung besteht darin genannten Eigenschaften vermeiden und stattdessen die <xref:System.Xml.XmlReader.MoveToAttribute%2A> Methode mit der <xref:System.Xml.XmlReader.IsStartElement%2A> Methode möglichst; diese Methoden nicht Zeichenfolgen zurück und umgehen somit das Problem eines Überlaufs der <xref:System.Xml.NameTable> Auflistung.  
  
-   <xref:System.Xml.XmlReaderSettings>-Objekte können vertrauliche Informationen (z. B. Anmeldeinformationen des Benutzers) enthalten. Eine nicht vertrauenswürdige Komponente könnte mithilfe des <xref:System.Xml.XmlReaderSettings>-Objekts und den Anmeldeinformationen des Benutzers <xref:System.Xml.XmlReader>-Objekte erstellen, mit denen Daten gelesen werden können. Seien Sie vorsichtig beim Zwischenspeichern von <xref:System.Xml.XmlReaderSettings> Objekte, oder bei der Übergabe der <xref:System.Xml.XmlReaderSettings> -Objekts von einer Komponente zu einem anderen.  
  
-   Achten Sie darauf, keine Unterstützung für Komponenten aus einer nicht vertrauenswürdigen Quelle zu gewähren (z. B. den Objekten <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> und <xref:System.Xml.XmlResolver>).  
  
   
  
## Examples  
 Der folgende Beispielcode zeigt, wie die asynchrone APIto Analyse XML zu verwenden.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlReader" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassenkonstruktoren Zustand bei dieser Art initialisiert aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Attribute für den aktuellen Knoten ab.</summary>
        <value>Die Anzahl der Attribute im aktuellen Knoten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist relevant für `Element`, `DocumentType` und `XmlDeclaration` nur Knoten. (Andere Knotentypen Attribute keine.)  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Basis-URI des aktuellen Knotens ab.</summary>
        <value>Der Basis-URI des aktuellen Knotens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Netzwerk-XML-Dokument besteht aus Segmenten der Daten unter Verwendung verschiedener W3C standard aggregiert und enthält daher Knoten, die aus verschiedenen Quellen stammen. DTD-Entitäten sind ein Beispiel dafür, aber dies ist nicht auf DTDs beschränkt. Die Basis-URI gibt, woher diese Knoten stammen. Wenn Sie keinen Basis-URI für die zurückgegebenen Knoten vorhanden ist (z. B. sie ermittelt wurden aus einer Zeichenfolge im Arbeitsspeicher), `String.Empty` wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Xml.XmlReader" /> die Methoden für das Lesen von Inhalt im Binärformat implementiert.</summary>
        <value>
          <see langword="true" />, wenn die Methoden für das Lesen von Inhalt im Binärformat implementiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inhalt im Binärformat zu lesen, erfolgen die <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, und <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> Methoden. Wenn diese Eigenschaft gibt `false` eine <xref:System.NotSupportedException> wird zurückgegeben, wenn die Binärdatei lesen Methoden aufgerufen wird.  
  
 Alle Microsoft .NET Framework-Implementierungen von der <xref:System.Xml.XmlReader> -Klasse Return `true` für diese Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Xml.XmlReader" /> die angegebene <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />-Methode implementiert.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Xml.XmlReader" /> die <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />-Methode implementiert, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Analysieren von Text <xref:System.Xml.XmlReader> Objekte, aus der statischen erstellt wurden <xref:System.Xml.XmlReader.Create%2A> immer-Methodenrückgabe `true`. Alle anderen Microsoft .NET Framework-Implementierungen von der <xref:System.Xml.XmlReader> Klasse, einschließlich der <xref:System.Xml.XmlTextReader> , geben Sie `false`.  
  
 Wenn diese Eigenschaft gibt `false` eine <xref:System.NotSupportedException> wird zurückgegeben, wenn die <xref:System.Xml.XmlReader.ReadValueChunk%2A> -Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser Reader Entitäten analysieren und auflösen kann.</summary>
        <value>
          <see langword="true" />, wenn der Reader Entitäten analysieren und auflösen kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt diese Eigenschaft immer `false` für Implementierungen der <xref:System.Xml.XmlReader> , die keine DTD-Informationen unterstützen. In diesem Fall aufrufen <xref:System.Xml.XmlReader.ResolveEntity%2A> löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ändert beim Überschreiben in einer abgeleiteten Klassen den <see cref="P:System.Xml.XmlReader.ReadState" /> in <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt auch alle beim Lesen reservierten Ressourcen frei. Wenn <xref:System.Xml.XmlReader.Close%2A> wurde bereits aufgerufen wird, wird keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten der <xref:System.Xml.XmlReader.Create%2A> Überladungen enthalten einen `settings` Parameter, akzeptiert eine <xref:System.Xml.XmlReaderSettings> Objekt. Sie können dieses Objekt zu verwenden:  
  
-   Angeben, welche Funktionen unterstützt werden soll die <xref:System.Xml.XmlReader> Objekt.  
  
-   Wiederverwenden der <xref:System.Xml.XmlReaderSettings> zu erstellenden mehrere Reader-Objekts. Sie können dieselben Einstellungen verwenden, um mehrere Reader mit denselben Funktionen zu erstellen. Oder Sie können die Einstellungen ändern, auf eine <xref:System.Xml.XmlReaderSettings> Instanz, und erstellen Sie einen neuen Reader mit einem anderen Satz von Funktionen.  
  
-   Hinzufügen von Funktionen zu einer vorhandenen XML-Reader. Die <xref:System.Xml.XmlReader.Create%2A>-Methode kann ein anderes <xref:System.Xml.XmlReader>-Objekt annehmen. Die zugrunde liegende <xref:System.Xml.XmlReader> Objekt kann es sich um einen benutzerdefinierten Reader eine <xref:System.Xml.XmlTextReader> Objekt oder eine andere <xref:System.Xml.XmlReader> -Instanz, die zusätzliche Funktionen hinzugefügt werden soll.  
  
-   In vollem Umfang vom Funktionen, z. B. eine bessere Übereinstimmung überprüft und Kompatibilität zu den [XML 1.0 (vierte Ausgabe)](http://www.w3.org/TR/2006/REC-xml-20060816/)Empfehlung, die nur auf verfügbaren <xref:System.Xml.XmlReader> Objekte erstellt, die von der statischen <xref:System.Xml.XmlReader.Create%2A> Methode.  
  
> [!NOTE]
>  Zwar .NET Framework konkrete Implementierungen enthält die <xref:System.Xml.XmlReader> Klasse, z. B. die <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, und die <xref:System.Xml.XmlValidatingReader> Klassen, es wird empfohlen, Sie erstellen <xref:System.Xml.XmlReader> Instanzen mithilfe der <xref:System.Xml.XmlReader.Create%2A> Methode.  
  
## <a name="default-settings"></a>Standardeinstellungen  
 Bei Verwendung einer <xref:System.Xml.XmlReader.Create%2A> Überladung, die nicht akzeptieren ein <xref:System.Xml.XmlReaderSettings> -Objekt, werden die folgenden Standardeinstellungen Reader verwendet:  
  
|Einstellung|Standard|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Ein leeres <xref:System.Xml.Schema.XmlSchemaSet>-Objekt.|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>aktiviert|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Ein neues <xref:System.Xml.XmlUrlResolver>-Objekt.  Ab der .NET Framework-Version 4.5.2 hat diese Einstellung den Standardwert `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Einstellungen für häufige Szenarien  
 Hier werden die <xref:System.Xml.XmlReaderSettings> Eigenschaften sollten Sie für einige typische Szenarien, XML-Reader festlegen.  
  
|Anforderung|Set|  
|-----------------|---------|  
|Daten muss ein wohlgeformtes XML-Dokument ist.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>um <xref:System.Xml.ConformanceLevel.Document>.|  
|Daten müssen eine wohlgeformte analysierte XML-Entität sein.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>um <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Daten müssen einer DTD überprüft werden.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> bis <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A>um <xref:System.Xml.ValidationType.DTD>.|  
|Daten müssen anhand eines XML-Schemas überprüft werden.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> bis <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>um die <xref:System.Xml.Schema.XmlSchemaSet> zur Validierung verwendet. Beachten Sie, dass <xref:System.Xml.XmlReader> unterstützt keine XML-Data Reduced (XDR) Schema-Validierung.|  
|Daten müssen für ein Inline-XML-Schema überprüft werden.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> bis <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>um <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Geben Sie die Unterstützung.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> bis <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>um die <xref:System.Xml.Schema.XmlSchemaSet> verwenden.|  
  
 <xref:System.Xml.XmlReader>Schema-Validierung von XML-Data Reduced (XDR) nicht unterstützt werden.  
  
## <a name="asynchronous-programming"></a>Asynchrone Programmierung  
 Im synchronen Modus der <xref:System.Xml.XmlReader.Create%2A> Methode liest den ersten Block von Daten aus dem Puffer von der Datei, Stream- oder Text-Reader. Dies kann eine Ausnahme ausgelöst, wenn ein e/a-Vorgang fehlschlägt. Im asynchronen Modus tritt auf, der erste e/a-Vorgang mit einem Lesevorgang, damit auftretenden Ausnahmen ausgelöst werden, wenn der Lesevorgang auftritt.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wird standardmäßig die <xref:System.Xml.XmlReader> verwendet ein <xref:System.Xml.XmlUrlResolver> Objekt keine Benutzeranmeldeinformationen Ressourcen öffnen. Dies bedeutet, dass standardmäßig der XML-Reader einem beliebigen Speicherort zugreifen kann, die keine Anmeldeinformationen erforderlich. Verwenden der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um den Zugriff auf Ressourcen zu steuern:  
  
-   Legen Sie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> auf ein <xref:System.Xml.XmlSecureResolver> Objekt, das die Ressourcen zu beschränken, die der XML-Reader zugreifen können.  
  
 - oder -   
  
-   Legen Sie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> zu `null` um zu verhindern, dass den XML-Reader keine externen Ressourcen öffnen.  
  
   
  
## Examples  
 Dieses Beispiel erstellt einen XML-Reader, der bedeutungslose Leerzeichen entfernt werden Kommentare entfernt und auf Fragmentebene übereinstimmungsprüfung führt.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 Im folgenden Beispiel wird ein <xref:System.Xml.XmlUrlResolver> mit Standardanmeldeinformationen auf eine Datei zuzugreifen.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Der folgende Code dient als Wrapper für eine Readerinstanz in einem anderen Reader.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 In diesem Beispiel verkettet Leser DTD und XML-Schema-Validierung hinzufügen.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
 Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <summary>Erstellt mit dem angegebenen Stream mit den Standardeinstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung von des erstellte Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert ein <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente ein, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> Objekt, das aus einem <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung von des erstellte Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert ein <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente ein, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.StringReader> Klasse, um eine XML-Zeichenfolge zu lesen.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Mit der <see cref="T:System.Xml.XmlUrlResolver" />-Klasse wird der Pfad in eine kanonische Datendarstellung konvertiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz mit angegebenem URI.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung von des erstellte Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert ein <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente ein, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein <xref:System.Xml.XmlReader> Objekt, das vom URI angegebene XML-Datendatei liest.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI bezeichnete Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
 Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz mit dem angegebenen Stream und den angegebenen Einstellungen.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für den neuen <see cref="T:System.Xml.XmlReader" />. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Das <see cref="T:System.Xml.XmlResolver" />-Objekt für das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt wird zum Konvertieren des Pfads in eine kanonische Datendarstellung verwendet. Wenn <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> <see langword="null" /> ist, wird ein neues <see cref="T:System.Xml.XmlUrlResolver" />-Objekt verwendet.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen URI und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Dies bedeutet, dass die <xref:System.Xml.XmlReader> erreichen Speicherorte, die keine Authentifizierung erforderlich ist. Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können die Ressourcen beschränken, die <xref:System.Xml.XmlReader> zugreifen können, indem Sie festlegen der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um ein <xref:System.Xml.XmlSecureResolver> Objekt.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> -Objekt, das Validierung Document Type Definition (DTD) unterstützt.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.FormatException" />, stattdessen.  
  
</para>
          </block>  
  
 Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">Das Objekt, dass Sie als zugrunde liegenden XML-Reader verwenden möchten.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz.  
  
 Der Konformitätsgrad des <see cref="T:System.Xml.XmlReaderSettings" />-Objekts muss mit dem Konformitätsgrad des zugrunde liegenden Readers übereinstimmen oder auf <see cref="F:System.Xml.ConformanceLevel.Auto" /> festgelegt werden.</param>
        <summary>Erstellt mit dem angegebenen XML-Reader und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, das das angegebene <see cref="T:System.Xml.XmlReader" />-Objekt umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie zusätzliche Funktionen hinzufügen, auf eine zugrunde liegende <xref:System.Xml.XmlReader> Objekt. Die zugrunde liegende <xref:System.Xml.XmlReader> Objekt kann es sich um eine andere <xref:System.Xml.XmlReader> Objekt erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, oder ein <xref:System.Xml.XmlReader> Objekt mithilfe einer konkreten erstellt <xref:System.Xml.XmlReader> Implementierungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen wird Zugriff auf externe Ressourcen, z. B. ein Schema verwendet.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein validierendes <xref:System.Xml.XmlReader> Objekt, das umschließt ein <xref:System.Xml.XmlNodeReader> Objekt.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="reader" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wenn das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt einen Konformitätsgrad angibt, der mit dem Konformitätsgrad des zugrunde liegenden Readers nicht übereinstimmt.  
  
 - oder -   
  
 Der zugrunde liegende <see cref="T:System.Xml.XmlReader" /> befindet im Zustand <see cref="F:System.Xml.ReadState.Error" /> oder <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
 Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="baseUri">Der Basis-URI der gelesenen Entität oder des gelesenen Dokuments. Dieser Wert kann <see langword="null" /> sein.  
  
 **Sicherheitshinweis** die Basis-URI verwendet wird, um den relativen URI des XML-Dokuments aufzulösen. Verwenden Sie keinen Basis-URI von einer nicht vertrauenswürdigen Quelle.</param>
        <summary>Erstellt mit dem angegebenen Stream, dem Basis-URI und den Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
 Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen zählen die <see cref="T:System.Xml.XmlNameTable" /> zu verwenden, Codierung, Namespacebereich, den aktuellen <c>XML: lang</c> und <c>XML: Space</c> Bereich, die Basis-URI und die Dokumenttypdefinition.  
  
 Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Stream, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom <see cref="T:System.Xml.XmlReader" /> zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="baseUri">Der Basis-URI der gelesenen Entität oder des gelesenen Dokuments. Dieser Wert kann <see langword="null" /> sein.  
  
 **Sicherheitshinweis** die Basis-URI verwendet wird, um den relativen URI des XML-Dokuments aufzulösen. Verwenden Sie keinen Basis-URI von einer nicht vertrauenswürdigen Quelle.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader, den angegebenen Einstellungen und dem angegebenen Basis-URI eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen zählen die <see cref="T:System.Xml.XmlNameTable" /> zu verwenden, Codierung, Namespacebereich, den aktuellen <c>XML: lang</c> und <c>XML: Space</c> Bereich, die Basis-URI und die Dokumenttypdefinition.  
  
 Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden verwenden, um zu steuern, welche Ressourcen der <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -   
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein <xref:System.Xml.XmlReader> Objekt, das ein XML-Fragment liest.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> und <see cref="P:System.Xml.XmlParserContext.NameTable" /> Eigenschaften beide Werte enthalten. (Nur eine dieser <see langword="NameTable" />-Eigenschaften kann festgelegt sein und verwendet werden.)</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Das <see cref="T:System.Xml.XmlResolver" />-Objekt für das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt wird zum Konvertieren des Pfads in eine kanonische Datendarstellung verwendet. Wenn <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> <see langword="null" /> ist, wird ein neues <see cref="T:System.Xml.XmlUrlResolver" />-Objekt verwendet.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen zählen die <see cref="T:System.Xml.XmlNameTable" /> zu verwenden, Codierung, Namespacebereich, den aktuellen <c>XML: lang</c> und <c>XML: Space</c> Bereich, die Basis-URI und die Dokumenttypdefinition.  
  
 Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen URI, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen verwendet, Zugriff auf externe Ressourcen, z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Beginnend mit .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> bereitgestellt wird. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Dies bedeutet, dass die <xref:System.Xml.XmlReader> erreichen Speicherorte, die keine Authentifizierung erforderlich ist. Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an ein <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können die Ressourcen beschränken, die <xref:System.Xml.XmlReader> zugreifen können, indem Sie festlegen der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um ein <xref:System.Xml.XmlSecureResolver> Objekt.  
  
 Der erstellte <xref:System.Xml.XmlReader> Objekt Entitätsverweise erweitert und führt die XML-Normalisierung von neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see langword="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> und <see cref="P:System.Xml.XmlParserContext.NameTable" /> Eigenschaften beide Werte enthalten. (Nur eine dieser <see langword="NameTable" />-Eigenschaften kann festgelegt sein und verwendet werden.)</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.UriFormatException">Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Tiefe des aktuellen Knotens im XML-Dokument ab.</summary>
        <value>Die Tiefe des aktuellen Knotens im XML-Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.Depth%2A> (in der `XmlTextReader` Klasse) für ein Beispiel für die Verwendung dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Xml.XmlReader" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Xml.XmlReader" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob sich der Reader am Ende des Streams befindet.</summary>
        <value>
          <see langword="true" />, wenn der Reader am Ende des Streams positioniert ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs. Der Index ist nullbasiert. (Das erste Attribut hat den Index 0.)</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen Index ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Diese Methode verschiebt den Reader nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel ruft den Wert des dritten Attributs ab.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> liegt außerhalb des Bereichs. Es muss nicht negativ und kleiner als die Größe der attributauflistung.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wird oder Wert <see langword="String.Empty" /> ist, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt den Reader nicht.  
  
 Wenn der Reader positioniert ist, auf eine `DocumentType` Knoten, diese Methode kann verwendet werden, die öffentlichen und SYSTEM-Literale, z. B. Abrufen`reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Wert des Attributs ISBN-Nummer.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI dieses Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wird oder Wert <see langword="String.Empty" /> ist, wird <see langword="null" /> zurückgegeben. Diese Methode verschiebt den Reader nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende XML-Code enthält ein Attribut in einem bestimmten Namespace:  
  
```  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Sie können Suchen der `dt:type` -Attribut mit einem Argument (Präfix und lokaler Name) oder zwei Argumente (lokaler Name und Namespace-URI):  
  
```  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Für die Suche der `xmlns:dt` -Attribut angegeben wird, verwenden Sie eine der folgenden Argumente:  
  
```  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Sie können auch abrufen, diese Informationen mithilfe der <xref:System.Xml.XmlReader.Prefix%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Wert des aktuellen Knotens asynchron ab.</summary>
        <returns>Der Wert des aktuellen Knotens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Knoten über Attribute verfügt.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Knoten über Attribute verfügt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Knoten einen <see cref="P:System.Xml.XmlReader.Value" /> aufweisen kann.</summary>
        <value>
          <see langword="true" />, wenn der Knoten, auf dem der Reader derzeit positioniert ist, einen <see langword="Value" /> aufweisen darf, andernfalls <see langword="false" />. Wenn <see langword="false" />, weist der Knoten den Wert <see langword="String.Empty" /> auf.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Knotentypen aufgeführt, die einen zurückzugebenden Wert haben.  
  
|Knotentyp|Wert|  
|---------------|-----------|  
|`Attribute`|Der Wert des Attributs.|  
|`CDATA`|Der Inhalt des CDATA-Abschnitts.|  
|`Comment`|Der Inhalt des Kommentars.|  
|`DocumentType`|Die interne Teilmenge.|  
|`ProcessingInstruction`|Der gesamte Inhalt mit Ausnahme des Ziels.|  
|`SignificantWhitespace`|Der Leerraum zwischen Markups bei einem Modell für gemischten Inhalt.|  
|`Text`|Der Inhalt des Textknotens.|  
|`Whitespace`|Der Leerraum zwischen Markups.|  
|`XmlDeclaration`|Der Inhalt der Deklaration.|  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.HasValue%2A> (in der `XmlTextReader` Klasse) ein Beispiel, das mit dieser Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Knoten ein Attribut ist, das aus dem in der DTD oder dem Schema definierten Standardwert generiert wurde.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Knoten ein Attribut ist, dessen Wert aus dem in der DTD oder dem Schema definierten Standardwert generiert wurde. <see langword="false" />, wenn der Attributwert explizit festgelegt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault`Gibt immer `false` für Implementierungen der `XmlReader` , die unterstützen keine Schema- oder DTD-Informationen. Diese Eigenschaft gilt nur für einen Attributknoten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle Attribute für das Stammelement.  
  
```  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 Im Beispiel werden die folgenden Dateien als Eingabe verwendet.  
  
 `book4.xml`  
  
```  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Wert ab, ob der aktuelle Knoten ein leeres Element ist (z. B. <c> &lt;MyElement /&gt;</c>).</summary>
        <value>
          <see langword="true" />Wenn der aktuelle Knoten ein Element ist (<see cref="P:System.Xml.XmlReader.NodeType" /> gleich <see langword="XmlNodeType.Element" />) endet mit <c> / &gt; </c>ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht Ihnen, die Unterschiede zwischen den folgenden Elementen zu bestimmen:  
  
 `<item num="123"/>`(`IsEmptyElement` ist `true`).  
  
 `<item num="123"></item>`(`IsEmptyElement` ist `false`, obwohl der Inhalt des Elements leer ist).  
  
 Ein entsprechendes `EndElement` Knoten ist nicht für leere Elemente generiert.  
  
 Wenn ein Element aufgrund-Schema-Validation Standardinhalt hinzugefügt wurden `IsEmptyElement` dennoch zurück `true`. Sie hat keinen Einfluss auf, und zwar unabhängig davon, ob das Element einen Standardwert verfügt. Das heißt, `IsEmptyElement` einfach meldet, und zwar unabhängig davon, ob das Element im Quelldokument Endtag hatte.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Textinhalt des jeweiligen Elements.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 Im Beispiel wird die Datei `elems.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Der Name, dessen Gültigkeit validiert werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das Zeichenfolgenargument ein gültiger XML-Name ist.</summary>
        <returns>
          <see langword="true" />, wenn der Name gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [W3C-Empfehlung für XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) zu bestimmen, ob der Name gültig ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Das zu validierende Namenstoken.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das Zeichenfolgenargument ein gültiges XML-Namenstoken ist.</summary>
        <returns>
          <see langword="true" />, wenn es sich um ein gültiges Namenstoken handelt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [W3C XML 1.0-Empfehlung](http://go.microsoft.com/fwlink/?LinkId=49863) um zu bestimmen, ob das Namenstoken gültig ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="M:System.Xml.XmlReader.MoveToContent" /> ein Starttag oder ein leeres Elementtag findet. <see langword="false" />, wenn ein anderer Knotentyp als <see langword="XmlNodeType.Element" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überspringt Leerraum, Kommentare und verarbeitungsanweisungen, bis der Reader auf einem Knoten positioniert ist. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Textinhalt des jeweiligen Elements.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 Im Beispiel wird die Datei `elems.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wird in den Eingabedatenstrom gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die mit der <see langword="Name" />-Eigenschaft des gefundenen Elements verglichene Zeichenfolge.</param>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist und die <see cref="P:System.Xml.XmlReader.Name" />-Eigenschaft des gefundenen Elements mit dem angegebenen Argument übereinstimmt.</summary>
        <returns>
          <see langword="true" />Wenn der resultierende Knoten ein Element ist und die <see langword="Name" /> Eigenschaft mit der angegebene Zeichenfolge übereinstimmt. <see langword="false" />Wenn ein anderer als Knotentyp <see langword="XmlNodeType.Element" /> gefunden wurde oder wenn das Element <see langword="Name" /> Eigenschaft entspricht nicht die angegebene Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überspringt Leerraum, Kommentare und verarbeitungsanweisungen, bis der Reader auf einem Knoten positioniert ist. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt jede Price-Element.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wird in den Eingabedatenstrom gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Die mit der <see langword="LocalName" />-Eigenschaft des gefundenen Elements zu vergleichende Zeichenfolge.</param>
        <param name="ns">Die mit der <see langword="NamespaceURI" />-Eigenschaft des gefundenen Elements zu vergleichende Zeichenfolge.</param>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist und ob die <see cref="P:System.Xml.XmlReader.LocalName" />-Eigenschaft und die <see cref="P:System.Xml.XmlReader.NamespaceURI" />-Eigenschaft des gefundenen Elements mit den angegebenen Zeichenfolgen übereinstimmen.</summary>
        <returns>
          <see langword="true" />Wenn der resultierende Knoten ein Element ist. <see langword="false" />Wenn ein anderer als Knotentyp <see langword="XmlNodeType.Element" /> gefunden wurde oder wenn die <see langword="LocalName" /> und <see langword="NamespaceURI" /> Eigenschaften des Elements stimmen die angegebenen Zeichenfolgen nicht überein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überspringt Leerraum, Kommentare und verarbeitungsanweisungen, bis der Reader auf einem Knoten positioniert ist. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wird in den Eingabedatenstrom gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen Index ab.</summary>
        <value>Der Wert des angegebenen Attributs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verschiebt den Reader nicht.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ab.</summary>
        <value>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verschiebt den Reader nicht.  
  
 Wenn der Reader positioniert ist, auf eine `DocumentType` Knoten, diese Methode kann verwendet werden, die öffentlichen und SYSTEM-Literale, z. B. Abrufen`reader["PUBLIC"]`  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Wert des Attributs ISBN-Nummer.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI dieses Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ab.</summary>
        <value>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verschiebt den Reader nicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den lokalen Namen des aktuellen Knotens ab.</summary>
        <value>Der Name des aktuellen Knotens ohne das Präfix. Beispielsweise <see langword="LocalName" /> ist <see langword="book" /> für das Element <c> &lt;bk: book&gt;</c>.  
  
 Bei unbenannten Knotentypen wie <see langword="Text" />, <see langword="Comment" /> usw. gibt diese Eigenschaft <see langword="String.Empty" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten und, sofern vorhanden, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix, dessen Namespace-URI aufgelöst werden soll. Um eine Übereinstimmung mit dem Standardnamespace zu erhalten, übergeben Sie eine leere Zeichenfolge.</param>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse ein Namespacepräfix im Gültigkeitsbereich des aktuellen Elements auf.</summary>
        <returns>Der Namespace-URI, dem das Präfix zugeordnet ist, oder <see langword="null" />, wenn kein entsprechendes Präfix gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden XML-Zeichenfolge, wenn der Reader positioniert ist, auf die `href` Attribut, das Präfix `a` durch den Aufruf von `reader.LookupNamespace("a")`. Die zurückgegebene Zeichenfolge ist `urn:456`.  
  
```  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Parameter hat einen negativen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>
          <see langword="true" />, wenn das Attribut gefunden wurde, andernfalls <see langword="false" />. Bei einem Wert von <see langword="false" /> ändert sich die Position des Readers nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> entsprechen Eigenschaften die Eigenschaften dieses Attributs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="ns">Der Namespace-URI dieses Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und dem angegebenen <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>
          <see langword="true" />, wenn das Attribut gefunden wurde, andernfalls <see langword="false" />. Bei einem Wert von <see langword="false" /> ändert sich die Position des Readers nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> entsprechen Eigenschaften die Eigenschaften dieses Attributs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Knoten ein Inhaltsknoten (Textknoten ohne Leerraum, <see langword="CDATA" />-, <see langword="Element" />-, <see langword="EndElement" />-, <see langword="EntityReference" />- oder <see langword="EndEntity" />-Knoten) ist. Wenn der Knoten kein Inhaltsknoten ist, springt der Reader zum nächsten Inhaltsknoten oder an das Ende der Datei. Knoten folgender Typen werden übersprungen: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> und <see langword="SignificantWhitespace" />.</summary>
        <returns>Der <see cref="P:System.Xml.XmlReader.NodeType" /> des von der Methode gefundenen aktuellen Knotens oder <see langword="XmlNodeType.None" />, wenn der Reader das Ende des Eingabestreams erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der aktuelle Knoten einen Attributknoten ist, verschiebt diese Methode den Reader zurück auf das Element, das das Attribut besitzt.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Dies ist hilfreich, wenn Sie möchten Code schreiben, der zufälligen XML-Markup ohne Unterbrechung überspringen können. Nehmen wir beispielsweise an, dass Sie den folgenden Code verfügen:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Dieser Code kann die folgenden Eingaben ohne Unterbrechung behandeln:  
  
```  
<price>123.4</price>  
```  
  
 und  
  
```  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 und  
  
```  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 und  
  
```  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML im Eingabedatenstrom gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;MoveToContentAsync&gt;c__async5))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchrone Überprüfungen, ob der aktuelle Knoten ein Inhaltsknoten ist. Wenn der Knoten kein Inhaltsknoten ist, springt der Reader zum nächsten Inhaltsknoten oder an das Ende der Datei.</summary>
        <returns>Der <see cref="P:System.Xml.XmlReader.NodeType" /> des von der Methode gefundenen aktuellen Knotens oder <see langword="XmlNodeType.None" />, wenn der Reader das Ende des Eingabestreams erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.MoveToContent%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zu dem Element, das den aktuellen Attributknoten enthält.</summary>
        <returns>
          <see langword="true" />, wenn der Reader auf einem Attribut positioniert ist (der Reader wechselt zu dem Element, das das Attribut besitzt); <see langword="false" />, wenn der Reader nicht auf einem Attribut positioniert ist (die Position des Readers bleibt unverändert).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um auf ein Element zurückzugeben, nach dessen Attribute das navigieren. Diese Methode verschiebt den Reader auf einen der folgenden Knotentypen: `Element`, `DocumentType`, oder `XmlDeclaration`.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum ersten Attribut.</summary>
        <returns>
          <see langword="true" />, wenn ein Attribut vorhanden ist (der Reader wechselt zum ersten Attribut), andernfalls <see langword="false" /> (die Position des Readers bleibt unverändert).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel ruft den Wert des ersten Attributs ab.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum nächsten Attribut.</summary>
        <returns>
          <see langword="true" />, wenn ein nächstes Attribut vorhanden ist; <see langword="false" />, wenn keine weiteren Attribute vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der aktuelle Knoten ein Elementknoten ist, entspricht diese Methode <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Wenn `MoveToNextAttribute` gibt `true`, der Reader wechselt zum nächsten Attribut; andernfalls wird die Position des Readers nicht geändert.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute im aktuellen Knoten angezeigt.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den qualifizierten Namen des aktuellen Knotens ab.</summary>
        <value>Der gekennzeichnete Name des aktuellen Knotens. Beispielsweise <see langword="Name" /> ist <see langword="bk:book" /> für das Element <c> &lt;bk: book&gt;</c>.  
  
 Der zurückgegebene Name hängt vom <see cref="P:System.Xml.XmlReader.NodeType" /> des Knotens ab. Die folgenden Knotentypen geben die jeweils aufgeführten Werte zurück. Alle anderen Knotentypen geben eine leere Zeichenfolge zurück.  
  
 <list type="table"><listheader><term>Knotentyp  
  
 </term><description>Name  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description>Der Name des Attributs.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description>Der Name des Dokumenttyps.  
  
 </description></item><item><term><see langword="Element" /></term><description>Der Tagname.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description>Der Name der Entität, auf die verwiesen wird.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description>Das Ziel der verarbeitungsanweisung.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description>Das Zeichenfolgenliteral <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt die einzelnen Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Namespace-URI (entsprechend der Definition in der Namespacespezifikation des W3C) des Knotens ab, auf dem der Reader positioniert ist.</summary>
        <value>Der Namespace-URI des aktuellen Knotens, andernfalls eine leere Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist relevant für `Element` und `Attribute` nur Knoten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten und, sofern vorhanden, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Xml.XmlNameTable" /> ab, die dieser Implementierung zugeordnet ist.</summary>
        <value>Die <see langword="XmlNameTable" />, die das Abrufen der atomisierten Version einer Zeichenfolge innerhalb des Knotens erlaubt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Namen von Knoten und Attributnamen zurückgegebenen aus <xref:System.Xml.XmlReader> mit atomisiert werden die `NameTable`. Bei Rückgabe der gleichnamigen mehrmals (z. B. `Customer`), klicken Sie dann in die gleiche `String` Objekt wird für diesen Namen zurückgegeben werden. Dadurch möglich, dass Sie effizientem Code schreiben, Objektvergleiche an diesen Zeichenfolgen statt teure Zeichenfolgenvergleiche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Typ des aktuellen Knotens ab.</summary>
        <value>Einer der Enumerationswerte, die den Typ des aktuellen Knotens angeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt die einzelnen Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse das dem aktuellen Knoten zugeordnete Namespacepräfix ab.</summary>
        <value>Das dem aktuellen Knoten zugeordnete Namespacepräfix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten und, sofern vorhanden, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse das Anführungszeichen ab, mit dem der Wert eines Attributknotens eingeschlossen wird.</summary>
        <value>Das Anführungszeichen (" oder '), mit dem der Wert eines Attributknotens eingeschlossen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gilt nur für einen Attributknoten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den nächsten Knoten aus dem Stream.</summary>
        <returns>
          <see langword="true" />, wenn der nächste Knoten erfolgreich gelesen wurde, andernfalls, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein <xref:System.Xml.XmlReader> zuerst erstellt und initialisiert, es gibt keine Informationen verfügbar. Rufen Sie <xref:System.Xml.XmlReader.Read%2A> auf den ersten Knoten lesen. Die <xref:System.Xml.XmlReader.Read%2A> Methode legt den Zustand des der XML-Reader zum Initiieren <xref:System.Xml.ReadState> und durchläuft die XML-Datei sequenziell, bis das Ende der Datei erreicht an diesem Punkt gibt die Methode einen Wert zurück, mit denen `false`.  
  
 Diese Methode erfordert mindestens vier Bytes aus dem Datenstream, um die Analyse zu starten. Wenn weniger als vier Bytes zurückgegeben werden, und es keine weitere Daten in den Stream sind, gibt die Methode `false`. Wenn weitere Daten in den Datenstrom vorhanden ist, blockiert die Methode die Analyse bis zum Empfang von das vierte Byte an.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt die einzelnen Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Ausgabe:**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]><![CDATA[]> def</Item><Item>Test with a char entity: A</Item><!-- Fourteen chars in this element.--><Item>1234567890ABCD</Item></Items>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten Knoten aus dem Stream asynchron.</summary>
        <returns>
          <see langword="true" />, wenn der nächste Knoten erfolgreich gelesen wurde, <see langword="false" />, wenn keine weiteren zu lesenden Knoten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.Read%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse den Attributwert in einen oder mehrere Knoten vom Typ <see langword="Text" />, <see langword="EntityReference" /> oder <see langword="EndEntity" /> auf.</summary>
        <returns>
          <see langword="true" />, wenn zurückzugebende Knoten vorhanden sind.  
  
 <see langword="false" />, wenn der Reader beim ersten Aufruf nicht auf einem Attributknoten positioniert ist oder alle Attributwerte gelesen wurden.  
  
 Ein leeres Attribut, z. B. <c>Verschiedenes = ""</c>, gibt <see langword="true" /> mit einem einzelnen Knoten mit einem Wert von <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nach dem Aufruf <xref:System.Xml.XmlReader.MoveToAttribute%2A> den Text oder eine Entität zu lesen, aus denen der Attributwert besteht. Die <xref:System.Xml.XmlReader.Depth%2A> der Attributwertknoten ist eins plus der Tiefe des Attributknotens; es inkrementiert und dekrementiert Einerschritten Einzelschritts in und aus allgemeine Entitätsverweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** mit der Version von .NET Framework 3.5, der Wert der <c>ReturnType</c> -Parameters nun auch die <see cref="T:System.DateTimeOffset" /> Typ.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen. Z. B. Dies kann verwendet werden, bei der Konvertierung ein <see cref="T:System.Xml.XmlQualifiedName" /> -Objekt an eine <c>xs: String</c>.  
  
 Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Liest den Inhalt als Objekt vom angegebenen Typ.</summary>
        <returns>Der verkettete Textinhalt oder Attributwert, der in den angeforderten Typ konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Textinhalt an der aktuellen Readerposition und konvertiert ihn in den angeforderten Rückgabetyp. Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte sind verkettet. Kommentare und Verarbeitungsanweisungen werden übersprungen und Entitätsverweise automatisch aufgelöst.  
  
 Diese Methode wird verwendet, lesen, bei Bedarf zu konvertieren und atomaren Wertelemente aus dem aktuellen Knoten Inhalt zurück. Wenn der Typ der Eingabe einer gültigen Zuordnungen für den Typ des aktuellen Knotens klicken Sie dann eine Instanz des Zieltyps an, die den Wert des aktuellen Knotens ist, wird zurückgegeben. Finden Sie im Abschnitt "Hinweise" in der <xref:System.Xml.XmlReader> Referencepage eine Liste der standardzuordnungen.  
  
 Angenommen, mussten Sie den folgenden XML-Text:  
  
```  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Wenn die Eingabe der Daten und ein Array von Zeichenfolgen angegeben die <xref:System.Xml.XmlReader.ReadContentAs%2A> -Methodenaufruf, und klicken Sie dann auf die ganzzahligen Werte aus Zeichenfolgen gemäß der Liste der gültigen Zuordnungen von CLR-Typ konvertiert werden.  
  
 Wenn die Daten nicht typisiert ist, und ein Array von Zeichenfolgen, um angegeben wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methode aufzurufen, und klicken Sie dann der Inhalt in separate Zeichenfolgen analysiert wird. Ein Array mit zwei Zeichenfolgen wird mit den Werten "123" und "456" zurückgegeben. Die Leerzeichen aus dem Inhalt nicht beibehalten.  
  
 Im Allgemeinen beim Lesen von nicht typisierter Daten wird der Inhalt entsprechend den angegebenen Typ analysiert. Angenommen, ein Array von Ganzzahlen bereitgestellt wird, um die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methode aufzurufen, und klicken Sie dann die Zeichenfolge in ein Array von Ganzzahlen {123,456} analysiert wird.  
  
 Im folgenden Beispiel wird der XML-Text nicht durch Leerzeichen getrennt  
  
```  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Wenn der Inhalt nicht typisiert ist, und ein Array von Zeichenfolgen angegeben die <xref:System.Xml.XmlReader.ReadContentAs%2A> -Methode rufen Sie ein Array mit einer verketteten Zeichenfolge mit dem Wert "123456789" zurückgegeben.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methode, um den Inhalt des Elements Farben in ein Array von Zeichenfolgenobjekten zurückzugeben.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 In diesem Beispiel wird die Datei `dataFile_2.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Inhalt ist nicht im richtigen Format für den Zieltyp.</exception>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="returnType" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsAsync&gt;c__async1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest den Inhalt asynchron als Objekt vom angegebenen Typ.</summary>
        <returns>Der verkettete Textinhalt oder Attributwert, der in den angeforderten Typ konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAs%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt und gibt die Base64-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Inhalt, decodiert die `Base64` Inhalt und gibt die decodierten Binärbytes zurück (beispielsweise ein Inline `Base64` codiertes GIF-Bild) in den Puffer. Diese Methode kann nacheinander aufgerufen werden, um umfangreiche Streams mit eingebettetem Text zu lesen. Weitere Informationen finden Sie unter RFC 1521, "MIME (Multipurpose Internet Mail Extensions) Teil einer: Mechanismen zum angeben und beschreibt das Format of Internet Message Bodies". Sie erhalten RFCs auf der [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Greifen Sie keines der Eigenschaften der datenreaderrolle zwischen den Aufrufen der <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Methode, bis die Methode den Wert zurückgibt `0`.  
  
 Diese Methode hat das folgende Verhalten:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>Gibt den Wert `0` Wenn das Ende der Bytedatenstrom, der es tätig auf erreicht wurde. Der Reader auf dem ersten nicht-Inhalt Knoten positioniert.  
  
-   Wenn Sie aufgefordert, die weniger oder die genaue Anzahl von Bytes, die als der Reader die aktuelle Position behält im Stream übrig sind.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>wird auf die folgenden Typen von XML-Knoten nicht unterstützt: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index in den Puffer oder Index + Count ist größer als die Größe des reservierten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" /> Implementierung dieser Methode nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt asynchron und gibt die Base64-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt und gibt die <see langword="BinHex" />-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Inhalt, decodiert die `BinHex` Inhalt und gibt die decodierten Binärbytes zurück (beispielsweise ein Inline `BinHex` codiertes GIF-Bild) in den Puffer. Diese Methode kann nacheinander aufgerufen werden, um umfangreiche Streams mit eingebettetem Text zu lesen.  
  
> [!NOTE]
>  Greifen Sie keines der Eigenschaften der datenreaderrolle zwischen den Aufrufen der <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Methode, bis die Methode den Wert zurückgibt `0`.  
  
 Diese Methode hat das folgende Verhalten:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>Gibt den Wert `0` Wenn das Ende der Bytedatenstrom, der es tätig auf erreicht wurde. Der Reader auf dem ersten nicht-Inhalt Knoten positioniert.  
  
-   Wenn Sie weniger anfordern oder die genaue Anzahl an, der als im Datenstrom den Reader bleiben Bytes in seiner derzeitigen Position bleibt.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>wird auf die folgenden Typen von XML-Knoten nicht unterstützt: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index in den Puffer oder Index + Count ist größer als die Größe des reservierten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" /> Implementierung dieser Methode nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt asynchron und gibt die <see langword="BinHex" />-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see langword="Boolean" />.</summary>
        <returns>Der Textinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:boolean`, der Reader gibt einen nicht geschachtelten <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader, die sie zum Konvertieren einer <xref:System.Boolean> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie unter der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> Methode zum Lesen des Attributs als B`oolean` Wert.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 In diesem Beispiel wird die Datei `dataFile_2.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.DateTime" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, der Reader gibt einen nicht geschachtelten <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader, die sie zum Konvertieren einer <xref:System.DateTime> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader>Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie unter der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.DateTimeOffset" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.DateTimeOffset" />-Objekt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.Decimal" />-Objekt.</summary>
        <returns>Der Textinhalt an der aktuellen Position als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:decimal`, der Reader gibt einen nicht geschachtelten <xref:System.Decimal> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:decimal`, versucht der Reader, die sie zum Konvertieren einer <xref:System.Decimal> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie unter der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Der Textinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader für die Konvertierung in eine mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie unter der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Der Textinhalt an der aktuellen Position als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:float`, der Reader gibt eine mittels Unboxing konvertiert eine Gleitkommazahl mit einfacher Genauigkeit. Wenn der Inhalt nicht typisiert ist `xsd:float`, versucht der Reader für die Konvertierung in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Der Textinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine nicht geschachtelte 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader für die Konvertierung in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Der Textinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader nicht geschachtelte 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader für die Konvertierung in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die folgende Tabelle beschreibt diese Methode behandelt jeden Knotentyp.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit `XmlConvert.ToXxx` für den Attributwert.|Der Reader behält die aktuelle Position|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.Object" />.</summary>
        <returns>Der Textinhalt als geeignetstes CLR-Objekt (Common Language Runtime).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist, gibt der Reader eine geschachtelte CLR des geeignetsten Typs, angegeben durch die <xref:System.Xml.XmlReader.ValueType%2A> Eigenschaft. Wenn der Inhalt einem Listentyp ist, gibt der Reader ein Array der geschachtelten Objekte des geeigneten Typs zurück.  
  
> [!NOTE]
>  Wenn ein Validierungsfehler, beim Analysieren des Inhalts auftritt und der Reader ist ein <xref:System.Xml.XmlReader> Objekt erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, gibt der Reader den Inhalt als Zeichenfolge zurück. Mit anderen Worten tritt ein Validierungsfehler oder eine Warnung, werden der Inhalt gilt nicht typisiert sein.  
  
 Wenn der Inhalt nicht typisiert ist, gibt der Reader den Inhalt als Zeichenfolge zurück.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Der Wert des Elements, wenn der Reader befindet sich ein Schema überprüfen Reader (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> festgelegt ist, um <xref:System.Xml.ValidationType.Schema>); andernfalls eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsObjectAsync&gt;c__async0))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position asynchron als <see cref="T:System.Object" />.</summary>
        <returns>Der Textinhalt als geeignetstes CLR-Objekt (Common Language Runtime).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.String" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Diese Methode kann verwendet werden in eine Zeichenfolge oder den Textinhalt lesen, während überspringen Kommentare und verarbeitungsanweisungen typisierte Werte konvertieren.  
  
 In der folgenden Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, konvertiert in den angeforderten Typ.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit dem Aufruf von `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position bei.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die Verarbeitungsanweisung oder den Kommentar und liest den verketteten Textinhalt, der auf die Verarbeitungsanweisung oder den Kommentar folgt.|Wird zum nächsten Anfangselement- oder Endelementtag verschoben. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position bei.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert, der Reader behält jedoch i. d. R. die aktuelle Position bei.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Umwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position asynchron als <see cref="T:System.String" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsString%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** mit der Version von .NET Framework 3.5, der Wert der <c>ReturnType</c> -Parameters nun auch die <see cref="T:System.DateTimeOffset" /> Typ.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest den Elementinhalt als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAs%2A> Methode, um den Inhalt Lesen der `date` Knoten.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** mit der Version von .NET Framework 3.5, der Wert der <c>ReturnType</c> -Parameters nun auch die <see cref="T:System.DateTimeOffset" /> Typ.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, und liest dann den Elementinhalt als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsAsync&gt;c__async4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest den Elementinhalt asynchron als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element und decodiert den <see langword="Base64" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Elementinhalt, decodiert Sie ihn mit `Base64` Codierung und gibt die decodierten Binärbytes zurück (beispielsweise ein Inline `Base64`-codiertes GIF-Bild) in den Puffer. Weitere Informationen finden Sie unter RFC 1521, "MIME (Multipurpose Internet Mail Extensions) Teil einer: Mechanismen zum angeben und beschreibt das Format of Internet Message Bodies". Sie erhalten RFCs auf der [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>Elemente mit einfachem Inhalt können nur gelesen werden. Das Element kann es sich um Text, Leerraum, signifikanter Leerraum, CDATA-Abschnitte, Kommentare und verarbeitungsanweisungen enthalten. Sie können auch Entitätsverweise enthalten, die automatisch erweitert werden. Das Element keine untergeordneten Elemente.  
  
 Diese Methode ist vergleichbar mit der <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Methode, außer dass sie kann nur für Elementknotentypen aufgerufen werden.  
  
 Wenn die `count` Wert ist höher als die Anzahl der Bytes im Dokument oder gleich der Anzahl der Bytes im Dokument ist die <xref:System.Xml.XmlReader> liest die restlichen Bytes im Dokument und gibt die Anzahl der gelesenen Bytes zurück. Das nächste <xref:System.Xml.XmlReader> Methodenaufruf gibt 0 zurück, und verschiebt den Reader auf den Knoten hinter dem `EndElement`.  
  
 Beim Aufrufen <xref:System.Xml.XmlReader.Read%2A> vor allen des Elementinhalts verbraucht ist, kann der Reader so, als ob der erste Inhalt genutzt wurde und dann die <xref:System.Xml.XmlReader.Read%2A> -Methode wurde aufgerufen. Dies bedeutet, dass der Reader wird der gesamte Text lesen, bis das EndElement gefunden wird. Es wird dann lesen den Knoten am Endtag, lesen den nächsten Knoten und positionieren Sie selbst auf den nächsten nachfolgenden Knoten.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest ein Inlineschema `Base64` codiertes Bild. Die `Base64` Daten eingebettet ist die `<image>` Element. Ein <xref:System.IO.BinaryWriter> dient zum Erstellen einer neuen Datei mit Binärdaten.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index in den Puffer oder Index + Count ist größer als die Größe des reservierten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" /> Implementierung dieser Methode nicht unterstützt.</exception>
        <exception cref="T:System.Xml.XmlException">Das Element enthält gemischten Inhalt.</exception>
        <exception cref="T:System.FormatException">Der Inhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element asynchron und decodiert den <see langword="Base64" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element und decodiert den <see langword="BinHex" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Elementinhalt, decodiert Sie ihn mit `BinHex` Codierung und gibt die decodierten Binärbytes zurück (beispielsweise ein Inline `BinHex`-codiertes GIF-Bild) in den Puffer.  
  
 Diese Methode kann nur Elemente mit einfachem Inhalt lesen. Das Element kann es sich um Text, Leerraum, signifikanter Leerraum, CDATA-Abschnitte, Kommentare und verarbeitungsanweisungen enthalten. Sie können auch Entitätsverweise enthalten, die automatisch erweitert werden. Das Element keine untergeordneten Elemente.  
  
 Diese Methode ist vergleichbar mit der <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Methode, außer dass sie kann nur für Elementknotentypen aufgerufen werden.  
  
 Wenn die `count` Wert ist höher als die Anzahl der Bytes im Dokument oder gleich der Anzahl der Bytes im Dokument ist die <xref:System.Xml.XmlReader> liest die restlichen Bytes im Dokument und gibt die Anzahl der gelesenen Bytes zurück. Das nächste <xref:System.Xml.XmlReader> Methodenaufruf gibt 0 zurück, und verschiebt den Reader auf den Knoten hinter dem `EndElement`.  
  
 Beim Aufrufen <xref:System.Xml.XmlReader.Read%2A> vor allen des Elementinhalts verbraucht ist, kann der Reader so, als ob der erste Inhalt genutzt wurde und dann die <xref:System.Xml.XmlReader.Read%2A> -Methode wurde aufgerufen. Dies bedeutet, dass der Reader wird der gesamte Text lesen, bis das EndElement gefunden wird. Es wird dann lesen den Knoten am Endtag, lesen den nächsten Knoten und positionieren Sie selbst auf den nächsten nachfolgenden Knoten.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest ein Inlineschema `BinHex` codiertes Bild. Die `BinHex` Daten eingebettet ist die `<image>` Element. Ein <xref:System.IO.BinaryWriter> dient zum Erstellen einer neuen Datei mit Binärdaten.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index in den Puffer oder Index + Count ist größer als die Größe des reservierten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" /> Implementierung dieser Methode nicht unterstützt.</exception>
        <exception cref="T:System.Xml.XmlException">Das Element enthält gemischten Inhalt.</exception>
        <exception cref="T:System.FormatException">Der Inhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element asynchron und decodiert den <see langword="BinHex" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Boolean" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt des Elements typisiert ist `xsd:boolean`, der Reader gibt einen nicht geschachtelten <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader, die sie zum Konvertieren einer <xref:System.Boolean> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.Boolean" /> Objekt.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Boolean" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:boolean`, der Reader gibt einen nicht geschachtelten <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader, die sie zum Konvertieren einer <xref:System.Boolean> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.DateTime" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, der Reader gibt einen nicht geschachtelten <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader, die sie zum Konvertieren einer <xref:System.DateTime> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader>Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> Methode, um den Inhalt Lesen der `date` Element.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.DateTime" /> Objekt.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.DateTime" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, der Reader gibt einen nicht geschachtelten <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader, die sie zum Konvertieren einer <xref:System.DateTime> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader>Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Decimal" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Versucht der Reader den Elementinhalt zum Konvertieren einer <xref:System.Decimal> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Decimal" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Versucht der Reader den Elementinhalt zum Konvertieren einer <xref:System.Decimal> Objekt gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader für die Konvertierung in eine mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgenden Beispiel wird mithilfe der Methode den Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine Gleitkommazahl mit doppelter Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader für die Konvertierung in eine mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Den Inhalt des Elements in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln konvertiert versucht der Reader den [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine Gleitkommazahl mit einfacher Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Den Inhalt des Elements in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln konvertiert versucht der Reader den [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine Gleitkommazahl mit einfacher Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine nicht geschachtelte 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader für die Konvertierung in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine nicht geschachtelte 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader für die Konvertierung in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader nicht geschachtelte 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader für die Konvertierung in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> Methode, um den Inhalt Lesen der `longValue` Element.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader nicht geschachtelte 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader für die Konvertierung in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt diese Methode ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Methode zum Lesen des Inhalts von den `price` Knoten. Der Reader verwendet die Informationen im Schema den Inhalt in den richtigen Datentyp zuordnen.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 Im Beispiel werden die folgenden beiden Dateien als Eingabe verwendet.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt diese Methode ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsObjectAsync&gt;c__async2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element asynchron und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt diese Methode ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest der `stringValue` Element und gibt den Textinhalt (den Kommentar wird ignoriert, und die Anweisung zur Verarbeitung) zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.String" /> Objekt.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements an, und verschiebt den Reader hinter das Endelementtag. Es erweitert die Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. D. h., kann er nicht untergeordnete Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
   
  
## Examples  
 Das folgende Beispiel liest der `stringValue` Element und gibt den Textinhalt (den Kommentar wird ignoriert, und die Anweisung zur Verarbeitung) zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
 - oder -   
  
 Der Inhalt des Elements kann nicht konvertiert werden, um eine <see cref="T:System.String" /> Objekt.</exception>
        <exception cref="T:System.ArgumentNullException">Die-Methode aufgerufen wird und <see langword="null" /> Argumente.</exception>
        <exception cref="T:System.ArgumentException">Die angegebenen lokalen Namen und Namespace-URI stimmen nicht mit der das aktuelle Element gelesenen überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsStringAsync&gt;c__async3))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element asynchron und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <summary>Liest die einfachen Nur-Text-Elemente. Sie sollten stattdessen allerdings die <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bereitstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> -Methode zum Lesen von Text-Element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein Nur-Text-Element. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bereitstellt.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString> -Methode zum Lesen von Text-Element.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Nächste Inhaltsknoten ist ein Starttag; oder gefundenen Elements keinen einfachen Text-Wert enthält.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der zu überprüfende Name.</param>
        <summary>Überprüft vor dem Lesen eines Nur-Text-Elements, ob die <see cref="P:System.Xml.XmlReader.Name" />-Eigenschaft des gefundenen Elements mit der angegebenen Zeichenfolge übereinstimmt. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bereitstellt.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString> -Methode zum Lesen von Text-Element.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wenn der nächste Knoten kein Starttag ist; Wenn das Element <see langword="Name" /> entspricht nicht das angegebene Argument; oder wenn das Element gefunden wurde keinen einfachen Text-Wert enthält.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Der zu überprüfende lokale Name.</param>
        <param name="ns">Der zu überprüfende Namespace-URI.</param>
        <summary>Überprüft vor dem Lesen eines Nur-Text-Elements, ob die <see cref="P:System.Xml.XmlReader.LocalName" />- und die <see cref="P:System.Xml.XmlReader.NamespaceURI" />-Eigenschaft des gefundenen Elements mit den angegebenen Zeichenfolgen übereinstimmen. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bereitstellt.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> -Methode zum Lesen von Text-Element.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wenn der nächste Knoten kein Starttag ist; Wenn das Element <see langword="LocalName" /> oder <see langword="NamespaceURI" /> die angegebenen Argumenten; stimmen nicht überein, oder wenn das Element gefunden enthält einen einfachen Text-Wert nicht.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Endtag ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den Textinhalt des jeweiligen Elements.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 Im Beispiel wird die `book3.xml` Datei.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Es ist nicht der aktuelle Knoten ein Endtag oder falsches XML im Eingabedatenstrom gefunden wird.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den gesamten Inhalt, einschließlich Markup, als Zeichenfolge.</summary>
        <returns>Der gesamte XML-Inhalt (einschließlich Markup) im aktuellen Knoten. Wenn der aktuelle Knoten keine untergeordneten Elemente besitzt, wird eine leere Zeichenfolge zurückgegeben.  
  
 Wenn der aktuelle Knoten weder ein Element noch ein Attribut ist, wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Inhalte des aktuellen Knotens einschließlich Markup zurück. Der aktuelle Knoten (Starttag) und der entsprechende Endknoten (Endtag) werden nicht zurückgegeben. Angenommen, betrachten Sie Folgendes:  
  
```  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` gibt `this <child id="123"/>` zurück  
  
 Diese Methode behandelt Element-und Attributknoten auf folgende Weise:  
  
|Knotentyp|Die Position vor dem Aufruf|XML-Fragment|Rückgabewert|Position nach dem Aufruf|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Auf dem `item1`-Starttag.|\<Item1 > text1\</item1 >\<item2 > "Text2"\</item2 >|text1|Auf dem `item2`-Starttag.|  
|`Attribute`|Auf dem `attr1`-Attributknoten.|\<Element attr1 = "Wert1" attr2 = "" Wert2 "> Text \< /item >|val1|Verbleibt auf dem `attr1`-Attributknoten.|  
  
 Wenn der Reader auf einem Endknoten positioniert ist, entspricht das Aufrufen von `ReadInnerXml` dem Aufrufen von <xref:System.Xml.XmlReader.Read%2A>. Die Methode gibt `String.Empty` (außer bei Attributknoten, in diesem Fall wird der Wert des Attributs zurückgegeben wird).  
  
 Diese Methode überprüft wohlgeformter XML-Code. Wenn `ReadInnerXml` aus aufgerufen wird ein <xref:System.Xml.XmlValidatingReader>, diese Methode überprüft auch den Inhalt, der zurückgegeben wird.  
  
 Bei Implementierung in der <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> und `XmlValidatingReader` Klassen die `ReadOuterXml` Methode ist Namespaces.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht die `ReadInnerXml` und <xref:System.Xml.XmlReader.ReadOuterXml%2A> Methoden.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 Im Beispiel wird `2books.xml` Datei als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der XML-Code ist nicht wohlgeformt oder beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadInnerXmlAsync&gt;c__async6))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest asynchron den gesamten Inhalt, einschließlich Markup als Zeichenfolge.</summary>
        <returns>Der gesamte XML-Inhalt (einschließlich Markup) im aktuellen Knoten. Wenn der aktuelle Knoten keine untergeordneten Elemente besitzt, wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadInnerXml%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den Inhalt (einschließlich Markup) ab, der diesen Knoten und alle untergeordneten Elemente darstellt.</summary>
        <returns>Wenn der Reader auf einem Elementknoten oder einem Attributknoten positioniert ist, gibt diese Methode den gesamten XML-Inhalt (einschließlich Markup) des aktuellen Knotens sowie aller untergeordneten Elemente zurück. Andernfalls wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist vergleichbar mit <xref:System.Xml.XmlReader.ReadInnerXml%2A> außer sie überdies die Start- und Endtags gibt.  
  
 Diese Methode behandelt Element-und Attributknoten auf folgende Weise:  
  
|Knotentyp|Die Position vor dem Aufruf|XML-Fragment|Rückgabewert|Position nach dem Aufruf|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Auf dem `item1`-Starttag.|\<Item1 > text1\</item1 >\<item2 > "Text2"\</item2 >|\<Item1 > text1\</item1 >|Auf dem `item2`-Starttag.|  
|`Attribute`|Auf dem `attr1`-Attributknoten.|\<Element attr1 = "Wert1" attr2 = "" Wert2 "> Text \< /item >|attr1 = "Wert1"|Verbleibt auf dem `attr1`-Attributknoten.|  
  
 Wenn der Reader auf einem Endknoten positioniert ist, entspricht das Aufrufen von `ReadOuterXml` dem Aufrufen von <xref:System.Xml.XmlReader.Read%2A>. Die Methode gibt `String.Empty` (außer bei Attributknoten, in diesem Fall wird das Attributmarkup zurückgegeben wird).  
  
 Diese Methode überprüft wohlgeformter XML-Code. Wenn `ReadOuterXml` aus aufgerufen wird ein <xref:System.Xml.XmlValidatingReader>, überprüft diese Methode auch den zurückgegebenen Inhalt.  
  
 Bei Implementierung in der <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> und `XmlValidatingReader` Klassen die `ReadOuterXml` Methode ist Namespaces. Die folgenden XML-Text angegeben `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, wenn der Reader positioniert ist, auf die `S:B` Starttag, `ReadOuterXml` gibt `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht die `ReadInnerXml` und `ReadOuterXml` Methoden.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 Im Beispiel wird `2books.xml` Datei als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der XML-Code ist nicht wohlgeformt oder beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadOuterXmlAsync&gt;c__async8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Inhalt, einschließlich Markup, das diesen Knoten und alle untergeordneten Elemente darstellt, asynchron.</summary>
        <returns>Wenn der Reader auf einem Elementknoten oder einem Attributknoten positioniert ist, gibt diese Methode den gesamten XML-Inhalt (einschließlich Markup) des aktuellen Knotens sowie aller untergeordneten Elemente zurück. Andernfalls wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadOuterXml%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Knoten ein Element ist, und rückt den Reader zum nächsten Knoten vor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von <xref:System.Xml.XmlReader.Read%2A> auf, um den Inhalt des jeweiligen Elements im Eingabedatenstrom gefunden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wurde im Eingabedatenstrom gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements.</param>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Element mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf dieser Methode entspricht, zu einem Aufruf von <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von einem Aufruf von <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Textinhalt des jeweiligen Elements.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 Im Beispiel wird die `book3.xml` Datei.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wurde im Eingabedatenstrom gefunden.  
  
 - oder -   
  
 Die <see cref="P:System.Xml.XmlReader.Name" /> des Elements entspricht nicht dem angegebenen <paramref name="name" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Der lokale Name des Elements.</param>
        <param name="ns">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Element mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und dem angegebenen <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf dieser Methode entspricht, zu einem Aufruf von <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von einem Aufruf von <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Falsches XML wurde im Eingabedatenstrom gefunden.  
  
 - oder -   
  
 Die <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> Eigenschaften des gefundenen Elements entsprechen nicht die angegebenen Argumenten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Zustand des Readers ab.</summary>
        <value>Einer der Enumerationswerte, der den Status des Readers angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlReader.ReadState%2A> Eigenschaft hat einen der folgenden Werte:  
  
-   <xref:System.Xml.ReadState.Initial>, wenn die <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> -Methode aufgerufen wird.  
  
-   <xref:System.Xml.ReadState.Interactive>, wenn die <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> -Methode aufgerufen wurde und für den Reader können Sie weitere Methoden aufgerufen werden.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, wenn das Ende des XML-Dokuments erreicht haben erfolgreich.  
  
-   <xref:System.Xml.ReadState.Closed>, wenn die <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> -Methode aufgerufen wird.  
  
-   <xref:System.Xml.ReadState.Error>, wenn ein Fehler verhindert, dass den Lesevorgang nicht fortgesetzt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den Inhalt eines Element- oder Textknotens als Zeichenfolge. Sie sollten stattdessen allerdings die <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bereitstellt.</summary>
        <returns>Der Inhalt des Elements oder eine leere Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> -Methode zum Lesen der Inhalt eines Element- oder Textknotens als Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine neue <see langword="XmlReader" />-Instanz zurück, die zum Lesen des aktuellen Knotens und aller Nachfolgerknoten verwendet werden kann.</summary>
        <returns>Eine neue auf <see cref="F:System.Xml.ReadState.Initial" /> festgelegte XML-Reader-Instanz. Durch den Aufruf der <see cref="M:System.Xml.XmlReader.Read" />-Methode wird der neue Reader auf dem Knoten positioniert, der vor dem Aufruf der <see cref="M:System.Xml.XmlReader.ReadSubtree" />-Methode aktuell war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A>kann nur für Elementknoten aufgerufen werden. Wenn die gesamte Unterstruktur gelesen wurde, Aufrufe von der <xref:System.Xml.XmlReader.Read%2A> -Methode zurückkehrt `false`. Wenn die neue XML-Reader geschlossen wurde, den ursprünglichen Readeris positioniert das `EndElement` Knoten der Teilstruktur. Daher bei einem Aufruf der <xref:System.Xml.XmlReader.ReadSubtree%2A> -Methode für das Starttag des Book-Element, nachdem die Teilstruktur lesen "und" die neue XML-Reader wurde geschlossen wurde, der ursprüngliche XML-Reader im Endtag des Book-Element positioniert ist.  
  
 Es sollten keine Operationen für den ursprünglichen Reader ausgeführt werden, bevor der neue Reader geschlossen wurde. Diese Aktion wird nicht unterstützt und kann unvorhersehbares Verhalten zur Folge haben.  
  
> [!NOTE]
>  Die <xref:System.Xml.XmlReader.ReadSubtree%2A> Methode ist nicht vorgesehen für Creatingcopies der XML-Daten, die Sie unabhängig voneinander arbeiten können. Der Designedto erstellen Sie eine Begrenzung um ein XML-Element. Dies ist nützlich, wenn Sie Daten an eine andere Komponente zur Verarbeitung übergeben möchten, und möchten Sie den Umfang der Daten zu begrenzen, die die Komponente zugegriffen werden kann. Wenn Sie einen XML-Reader zurückgegebene übergeben der <xref:System.Xml.XmlReader.ReadSubtree%2A> Methode auf eine andere Anwendung, die Anwendung kann nur auf dieses XML-Element, nicht das gesamte XML-Dokument zuzugreifen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Xml.XmlReader.ReadSubtree%2A>-Methode gezeigt.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Verwenden Sie die folgenden XML-Daten in den Beispielen in diesem Thema ausführen:  
  
```  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see cref="T:System.Xml.XmlReader" /> auf das nächste Nachfolgerelement mit dem angegebenen qualifizierten Namen.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes Nachfolgerelement gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes untergeordnetes Element gefunden wurde, wird der <see cref="T:System.Xml.XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des Elements positioniert.  
  
 Wenn der <see cref="T:System.Xml.XmlReader" /> beim Aufruf von <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> nicht in einem Element positioniert wird, gibt diese Methode <see langword="false" /> zurück, und die Position des <see cref="T:System.Xml.XmlReader" /> wird nicht geändert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird analysiert den zweiten Book-Knoten.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 Im Beispiel wird die Datei `2books.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements, zu dem Sie wechseln möchten.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see cref="T:System.Xml.XmlReader" /> auf das nächste Nachfolgerelement mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes Nachfolgerelement gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes untergeordnetes Element gefunden wurde, wird der <see cref="T:System.Xml.XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des Elements positioniert.  
  
 Wenn der <see cref="T:System.Xml.XmlReader" /> beim Aufruf von <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> nicht in einem Element positioniert wird, gibt diese Methode <see langword="false" /> zurück, und die Position des <see cref="T:System.Xml.XmlReader" /> wird nicht geändert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements.</param>
        <summary>Liest, bis ein Element mit dem angegebenen qualifizierten Namen gefunden wird.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes Element gefunden wird, andernfalls <see langword="false" />, und der <see cref="T:System.Xml.XmlReader" /> in einem Dateiendezustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist funktionell gleichwertig Ausführen der `following::name` XPath-Ausdruck aus dem aktuellen Knoten. Es bietet eine schnelle Möglichkeit, ein benanntes Element ermitteln können im XML-Dokument. Er verschiebt den Reader zum nächsten folgenden Element, das mit dem angegebenen Namen übereinstimmt, und gibt `true` Wenn kein übereinstimmendes Element gefunden wird. Verwenden das folgende Beispiel, würde der Reader lesen an die erste Instanz des angegebenen Elements beim Lesen der weiterleiten.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Diese Methode kann für alle Knotentypen aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Liest, bis ein Element mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI gefunden wird.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes Element gefunden wird, andernfalls <see langword="false" />, und der <see cref="T:System.Xml.XmlReader" /> in einem Dateiendezustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist funktionell gleichwertig Ausführen der `following::name` XPath-Ausdruck aus dem aktuellen Knoten. Es bietet eine schnelle Möglichkeit, ein benanntes Element ermitteln können im XML-Dokument. Er verschiebt den Reader zum nächsten folgenden Element, das mit dem angegebenen Namen übereinstimmt, und gibt `true` Wenn kein übereinstimmendes Element gefunden wird.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Diese Methode kann für alle Knotentypen aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see langword="XmlReader" /> auf das nächste nebengeordnete Element mit dem angegebenen qualifizierten Namen.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes nebengeordnetes Element gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes nebengeordnetes Element gefunden wurde, wird der <see langword="XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des übergeordneten Elements positioniert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Rufen Sie nicht <xref:System.Xml.XmlReader.ReadToNextSibling%2A> bei der `XmlReader` ist ein Anfangszustand (<xref:System.Xml.XmlReader.ReadState%2A> ist <xref:System.Xml.ReadState.Initial>). Sie erreichen <xref:System.Xml.XmlReader.Read%2A> auf, wechseln die `XmlReader` und rufen Sie anschließend die <xref:System.Xml.XmlReader.ReadToNextSibling%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel liest der ISBN-Attribut für jeden Buchknoten.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <param name="namespaceURI">Der Namespace-URI des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see langword="XmlReader" /> auf das nächste nebengeordnete Element mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI.</summary>
        <returns>
          <see langword="true" />, wenn ein übereinstimmendes nebengeordnetes Element gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes nebengeordnetes Element gefunden wurde, wird der <see langword="XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des übergeordneten Elements positioniert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Rufen Sie nicht <xref:System.Xml.XmlReader.ReadToNextSibling%2A> bei der `XmlReader` ist ein Anfangszustand (<xref:System.Xml.XmlReader.ReadState%2A> ist <xref:System.Xml.ReadState.Initial>). Sie erreichen <xref:System.Xml.XmlReader.Read%2A> auf, wechseln die `XmlReader` und rufen Sie anschließend die <xref:System.Xml.XmlReader.ReadToNextSibling%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array von Zeichen, das als Puffer dient, in den der Textinhalt geschrieben wird. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, ab dem der <see cref="T:System.Xml.XmlReader" /> die Ergebnisse kopieren kann.</param>
        <param name="count">Die maximale Anzahl von Zeichen, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl der kopierten Zeichen zurück.</param>
        <summary>Liest umfangreiche Streams von Text, der in ein XML-Dokument eingebettet ist.</summary>
        <returns>Die Anzahl der in den Puffer gelesenen Zeichen. Der Wert 0 (null) wird zurückgegeben, wenn kein weiterer Textinhalt vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Lesen von sehr umfangreiche Streams von Text in einem XML-Dokument Streamingprinzip, d. h. eingebetteten einer kleineren Anzahl von Zeichen zu einem Zeitpunkt, anstatt dem ganzen Wert eine einzelne Zeichenfolge zuzuweisen. Diese Methode kann aufgerufen werden, auf einem beliebigen Knoten, dessen Wert (<xref:System.Xml.XmlReader.HasValue%2A> ist `true`), aber der tatsächliche streaming von den Knotenwert erfolgt nur, wenn für einen Text, Leerraum und signifikantem Leerraumknoten aufgerufen. Andere Knoten Type-Werte werden zwischengespeichert, einschließlich Attributen und CDATA-Knoten.  
  
 Diese Methode gibt nur den Inhalt des der <xref:System.Xml.XmlReader.Value%2A> Eigenschaft und verschiebt nicht die <xref:System.Xml.XmlReader>.  
  
 Diese Methode liest die angegebene Anzahl von Zeichen (`count`) des Knotenwerts in einen Zeichenpuffer (`buffer`) an einem angegebenen Offset (`index`) und gibt die Anzahl der in den Puffer geschriebenen Zeichen zurück. Gibt die `0` Wenn das Ende des Werts erreicht wurde. Es kann nicht neu gestartet werden, um über den Wert erneut gelesen wird.  
  
 Zwischen Aufrufen von <xref:System.Xml.XmlReader.ReadValueChunk%2A> der <xref:System.Xml.XmlReader> Eigenschaften sind keine Änderungen mit Ausnahme der <xref:System.Xml.XmlReader.Value%2A> Eigenschaft. Wenn die <xref:System.Xml.XmlReader.Value%2A> Eigenschaft erfolgt entweder ein Teil eines Werts zurückgeben (mit noch nicht von zurückgegebenen Zeichen <xref:System.Xml.XmlReader.ReadValueChunk%2A>) oder ein vollständiger Wert je nach Implementierung. Alle der <xref:System.Xml.XmlReader> Implementierungen in der <xref:System.Xml> Zurückgeben des Namespaces ein Teil eines Werts für die <xref:System.Xml.XmlReader.Value%2A> eigenschaftenimplementierung.  
  
 Lesevorgänge Methode kann aufgerufen werden, zwischen Aufrufe <xref:System.Xml.XmlReader.ReadValueChunk%2A>. In diesem Fall die <xref:System.Xml.XmlReader> wechselt zur nächsten <xref:System.Xml.XmlNodeType> in den Stream und alle Zeichen, die noch nicht zurückgegeben werden übersprungen.  
  
 Möglicherweise liegt ein Fall bei <xref:System.Xml.XmlReader.ReadValueChunk%2A> kleiner als die angeforderte Anzahl von Zeichen zurückgibt. Wenn mussten Sie einen 200 Zeichen langen Wert mit einem Ersatzzeichenpaar an den Positionen 127 und 128, und Sie wird aufgerufen, z. B. <xref:System.Xml.XmlReader.ReadValueChunk%2A> mit einem Puffer 128 Zeichen würde der Methodenaufruf 127 Zeichen anstelle der angeforderten 128 zurückgeben. Das Ersatzzeichenpaar würde dann zurückgegeben werden, in der nächsten <xref:System.Xml.XmlReader.ReadValueChunk%2A> aufrufen. In diesem Fall <xref:System.Xml.XmlReader.ReadValueChunk%2A> hat nicht die angeforderten 128 Zeichen zurückgegeben, da dies zu einem unvollständigen Ersatzzeichenpaar am Ende des Puffers geführt hätte.  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index in den Puffer oder Index + Count ist größer als die Größe des reservierten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" /> Implementierung dieser Methode nicht unterstützt.</exception>
        <exception cref="T:System.Xml.XmlException">Die XML-Daten ist nicht ordnungsgemäß formatiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array von Zeichen, das als Puffer dient, in den der Textinhalt geschrieben wird. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, ab dem der <see cref="T:System.Xml.XmlReader" /> die Ergebnisse kopieren kann.</param>
        <param name="count">Die maximale Anzahl von Zeichen, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl der kopierten Zeichen zurück.</param>
        <summary>Liest asynchron umfangreiche Streams von Text, der in ein XML-Dokument eingebettet ist.</summary>
        <returns>Die Anzahl der in den Puffer gelesenen Zeichen. Der Wert 0 (null) wird zurückgegeben, wenn kein weiterer Textinhalt vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadValueChunk%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse den Entitätsverweis für <see langword="EntityReference" />-Knoten auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Reader positioniert ist, auf ein `EntityReference` Knoten (`XmlNodeType.EntityReference`), wenn <xref:System.Xml.XmlReader.Read%2A> aufgerufen wird, nach dem Aufruf dieser Methode wird der Ersetzungstext der Entität wird analysiert. Nach Abschluss der Ersetzungstext der Entität ein `EndEntity` Knoten zurückgegeben, um den Gültigkeitsbereich des Entitätsverweises zu schließen.  
  
> [!NOTE]
>  Nach dem Aufrufen dieser Methode, wenn die Entität Teil eines Attributwerts ist müssen Sie aufrufen <xref:System.Xml.XmlReader.ReadAttributeValue%2A> um einen Einzelschritt für die Entität.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schemainformationen ab, die dem aktuellen Knoten nach der Schemavalidierung zugewiesen wurden.</summary>
        <value>Ein <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />-Objekt, das die Schemainformationen für den aktuellen Knoten enthält. Schemainformationen können auf Elemente, Attribute oder Textknoten mit einem <see cref="P:System.Xml.XmlReader.ValueType" /> festgelegt werden, der nicht NULL (typisierte Werte) ist.  
  
 Wenn der aktuelle Knoten keinem der oben angegebenen Knotentypen angehört oder wenn die <see langword="XmlReader" />-Instanz keine Schemainformationen übermittelt, gibt diese Eigenschaft <see langword="null" /> zurück.  
  
 Wenn diese Eigenschaft von einem <see cref="T:System.Xml.XmlTextReader" />-Objekt oder einem <see cref="T:System.Xml.XmlValidatingReader" />-Objekt aufgerufen wird, gibt diese Eigenschaft stets <see langword="null" /> zurück. Die <see langword="XmlReader" />-Implementierungen machen über die <see langword="SchemaInfo" />-Eigenschaft keine Schemainformationen verfügbar.  
  
 <block subset="none" type="note"><para>  
 Wenn Sie den Informationensatz für die Post-Schema-Validierung (PSVI) für ein Element abrufen müssen, positionieren Sie den Reader im Endtag des Elements und nicht im Starttag. Der PSVI wird über die <see langword="SchemaInfo" />-Eigenschaft eines Readers abgerufen. Der überprüfende Reader, der durch <see cref="Overload:System.Xml.XmlReader.Create" /> mit der <see cref="P:System.Xml.XmlReaderSettings.ValidationType" />-Eigenschaft erstellt wurde, welche auf <see cref="F:System.Xml.ValidationType.Schema" /> festgelegt ist, verfügt nur über den vollständigen PSVI für ein Element, wenn der Reader im Endtag eines Elements positioniert ist.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.Schema.IXmlSchemaInfo> Schnittstelle verfügbar macht, eine Teilmenge des Post Schema Validation Infoset (PSVI) eines XML-Knotens zugeordnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Erstellen dieser <see cref="T:System.Xml.XmlReaderSettings" />-Instanz verwendete <see cref="T:System.Xml.XmlReader" />-Objekt ab.</summary>
        <value>Das zum Erstellen dieser Reader-Instanz verwendete <see cref="T:System.Xml.XmlReaderSettings" />-Objekt. Wenn dieser Reader nicht mit der <see cref="Overload:System.Xml.XmlReader.Create" />-Methode erstellt wurde, gibt diese Eigenschaft <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Xml.XmlReaderSettings> -Objekt vertraulichen Informationen wie z. B. Anmeldeinformationen des Benutzers enthalten kann. Anwendungen müssen darauf achten beim Zwischenspeichern von diesem Objekt oder an eine andere Komponente übergeben.  
  
 Die <xref:System.Xml.XmlReaderSettings> Klasse wird verwendet, um den Satz von Funktionen zur Unterstützung von der erstellte Reader-Instanz angeben. Die <xref:System.Xml.XmlReaderSettings> von dieser Eigenschaft zurückgegebene Objekt kann nicht geändert werden. Jeder Versuch, die einzelnen Einstellungen zu einer Ausnahme, die ausgelöst wird, zu ändern.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überspringt die untergeordneten Elemente des aktuellen Knotens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie in den folgenden XML-Code, wenn der Reader positioniert ist, auf die `<a>` Knoten oder eines seiner Attribute, Aufrufen von `Skip` positioniert den Reader auf den `<b>` Knoten.  
  
 Wenn der Reader bereits auf einem Endknoten positioniert ist (z. B. die `<x>` Textknoten "oder" `abc`) wird beim Aufrufen `Skip` entspricht dem Aufruf von <xref:System.Xml.XmlReader.Read%2A>.  
  
```  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Diese Methode überprüft wohlgeformter XML-Code.  
  
 Wenn der Reader ist ein <xref:System.Xml.XmlValidatingReader>, diese Methode überprüft auch den übersprungenen Inhalt.  
  
 Die `XmlReader` Implementierung bestimmt, und zwar unabhängig davon, ob die `Skip` Methode externe Entitäten erweitert. Die folgende Tabelle beschreibt, ob die externen Entitäten, für die verschiedenen Typen von erweitert werden `XmlReader` Objekte.  
  
|Typ des XmlReader|Externe Entitäten erweitert|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nein.|  
|<xref:System.Xml.XmlReader>Instanz erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, die Textdaten liest.|Nein.|  
|<xref:System.Xml.XmlReader>Instanz erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, die binäre Daten liest.|Nicht zutreffend.|  
|Ein Schema überprüfen <xref:System.Xml.XmlReader> Instanz erstellt, indem die <xref:System.Xml.XmlReader.Create%2A> Methode.|Ja.|  
|<xref:System.Xml.XmlValidatingReader>|Ja.|  
|<xref:System.Xml.XmlReader>vom zurückgegebene Instanz eine <xref:System.Xml.XPath.XPathNavigator> Objekt.|Nicht zutreffend.|  
|<xref:System.Xml.XmlNodeReader>|Nein.|  
|<xref:System.Xml.XmlReader>Umschließt eine andere Instanz <xref:System.Xml.XmlReader> Instanz.|Richtet sich nach der Implementierung des zugrunde liegenden <xref:System.Xml.XmlReader>. (Die `Skip` Methode für den zugrunde liegenden <xref:System.Xml.XmlReader> aufgerufen wird).|  
  
 Die asynchrone Version dieser Methode finden Sie <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird analysiert, eine XML-Datei auf dem zweiten Book-Knoten ab.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 Im Beispiel wird die Datei `2books.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überspringt die untergeordneten Elemente des aktuellen Knotens asynchron.</summary>
        <returns>Der aktuelle Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.Skip%2A>, mit der gleichen Funktionalität. Wenn diese Methode verwenden möchten, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "Set-XmlReaderSettings.Async auf" true ", wenn asynchrone Methoden verwendet werden sollen."</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Textwert des aktuellen Knotens ab.</summary>
        <value>Der zurückgegebene Wert hängt vom <see cref="P:System.Xml.XmlReader.NodeType" /> des Knotens ab. In der folgenden Tabelle sind Knotentypen aufgeführt, die einen zurückzugebenden Wert haben. Alle anderen Knotentypen geben <see langword="String.Empty" /> zurück.  
  
 <list type="table"><listheader><term>Knotentyp  
  
 </term><description>Wert  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description>Der Wert des Attributs.  
  
 </description></item><item><term><see langword="CDATA" /></term><description>Der Inhalt des CDATA-Abschnitts.  
  
 </description></item><item><term><see langword="Comment" /></term><description>Der Inhalt des Kommentars.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description>Die interne Teilmenge.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description>Der gesamte Inhalt mit Ausnahme des Ziels.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description>Die Leerzeichen zwischen Markup in einem Modell mit gemischtem Inhalt.  
  
 </description></item><item><term><see langword="Text" /></term><description>Der Inhalt des Textknotens.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description>Der Leerraum zwischen Markups.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description>Der Inhalt der Deklaration.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone Version von dieser Eigenschaft finden Sie unter der <xref:System.Xml.XmlReader.GetValueAsync%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt die einzelnen Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den CLR-Typ (Common Language Runtime) für den aktuellen Knoten ab.</summary>
        <value>Der CLR-Typ, der dem typisierten Wert des Knotens entspricht. Die Standardeinstellung ist <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter [Typenunterstützung in den System.Xml-Klassen](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) eine Liste der standardzuordnungen.  
  
 Ein Element des Typs `xs:int` verfügt über eine `ValueType` von `System.Int32` standardmäßig. Allerdings die `ValueType` möglicherweise eine der gültigen Datentypen, die zugeordnet werden können `xs:int`, wie z. B. `System.Int16` oder `System.Double`.  
  
 Wenn ein Knoten nicht typisiert ist oder wenn der Knoten ein Element ist, gemischten Inhalt enthält, der Knotenwert zugeordnet ist die `System.String` Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
        <block subset="none" type="overrides">
          <para>Implementierer bereitstellen müssen eine <see langword="ValueType" /> für jeden Knoten, auch wenn sie nur die <see langword="System.String" /> Typ.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den aktuellen <see langword="xml:lang" />-Bereich ab.</summary>
        <value>Der aktuelle <see langword="xml:lang" />-Bereich.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die `xml:lang` Bereich, in dem sich der aktuelle Knoten befindet. Hier ist z. B. ein XML-Fragment mit `xml:lang` in das Stammelement auf Englisch (USA) festgelegt:  
  
```  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Wenn der Reader positioniert ist, auf die `name` Element, können Sie diese Eigenschaft fest, dass es im Rahmen einer US-Englisch ist `xml:lang` Attribut.  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> ein Beispiel für die Verwendung dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den aktuellen <see langword="xml:space" />-Bereich ab.</summary>
        <value>Einer der <see cref="T:System.Xml.XmlSpace" />-Werte. Wenn kein <see langword="xml:space" />-Bereich vorhanden ist, wird für diese Eigenschaft standardmäßig <see langword="XmlSpace.None" /> festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.XmlSpace%2A> (in der `XmlTextReader` Klasse) für ein Beispiel für die Verwendung dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall <see cref="T:System.InvalidOperationException" /> wird ausgelöst, mit der Meldung "ein asynchroner Vorgang wird bereits ausgeführt."</exception>
      </Docs>
    </Member>
  </Members>
</Type>
