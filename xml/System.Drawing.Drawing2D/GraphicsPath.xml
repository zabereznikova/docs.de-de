<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Reihe von miteinander verbundenen Linien und Kurven. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen verwenden die Pfade zum Zeichnen von Formen und füllen das Innere der Formen Clipping Regionen erstellen. Das Graphics-Modul behält die Koordinaten der geometrische Formen in einem Pfad im World Koordinatenbereich.  
  
 Ein Pfad kann einer beliebigen Anzahl von Zahlen (Pfade) bestehen. Abbildung besteht entweder aus einer Folge von miteinander verbundenen Linien und Kurven oder einer geometrischen Grundform. Der Ausgangspunkt der Abbildung ist der erste Punkt in der Sequenz von miteinander verbundenen Linien und Kurven. Der Endpunkt ist der letzte Punkt in der Sequenz. Der Start- und Enddatum Punkte einer geometrischen Grundform werden durch die primitiven-Spezifikation definiert.  
  
 Eine Abbildung, die besteht aus einer Folge von miteinander verbundenen Linien und Kurven (, deren Start- und Enddatum Punkte zusammenfallenden sein können) ist eine offene Figur, es sei denn, sie explizit geschlossen wurde. Eine Abbildung kann explizit geschlossen werden, mithilfe der <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> -Methode, die die aktuelle Abbildung durch Herstellen einer Verbindung eine Linie vom Endpunkt zum Anfangspunkt geschlossen wird. Eine Abbildung, die aus einer geometrischen Grundform besteht, ist eine geschlossene Form.  
  
 Zum Zweck der ausfüllen und Ausschneiden (z. B., wenn Sie ein Pfad mit gerendert wird <xref:System.Drawing.Graphics.FillPath%2A>), werden alle offenen Zahlen werden durch Hinzufügen einer Zeile bei erstem Punkt in der Abbildung auf den letzten Zeitpunkt geschlossen.  
  
 Eine neue Abbildung wird implizit gestartet, wenn ein Pfad erstellt wird oder eine Abbildung geschlossen wird. Eine neue Abbildung wird explizit erstellt, wenn die <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> -Methode aufgerufen wird.  
  
 Wenn ein Pfad eine geometrische Form primitiven hinzugefügt wird, fügt eine Abbildung, die die geometrische Form enthält, und auch implizit eine neue Abbildung beginnt. Folglich besteht immer eine aktuelle Abbildung in einem Pfad. Wenn Linien und Kurven zu einem Pfad hinzugefügt werden, wird eine implizite Zeile hinzugefügt, nach Bedarf, um den Endpunkt der aktuellen Abbildung zum Anfangspunkt der der neue Zeilen und zum bilden einer Sequenz von miteinander verbundenen Linien und Kurven zu verbinden.  
  
 Eine Abbildung weist eine Richtung, die beschreibt, wie die Linien- und Segmente zwischen den Ausgangspunkt und den Endpunkt verfolgt werden. Die Richtung wird definiert, in der Reihenfolge, die Linien und Kurven Abbildung hinzugefügt werden, oder durch die geometrische Grundform definiert ist. Die Richtung wird verwendet, bei der Bestimmung der Innenbereiche der Pfad zum Ausschneiden und füllen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> -Klasse mit einer <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> Wert <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">Die <see cref="T:System.Drawing.Drawing2D.FillMode" /> -Enumeration, der bestimmt, wie das Innere dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt wird.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Klasse mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumeration.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die die Koordinaten der Punkte definiert werden, die diese bilden <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" /> Enumerationselementen, der angibt, den Typ für jeden entsprechenden Punkt in der <c>Pts</c> Array.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Klasse mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" /> und <see cref="T:System.Drawing.Point" /> Arrays.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die die Koordinaten der Punkte definiert werden, die diese bilden <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" /> Enumerationselementen, der angibt, den Typ für jeden entsprechenden Punkt in der <c>Pts</c> Array.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Array mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" /> und <see cref="T:System.Drawing.PointF" /> Arrays.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die die Koordinaten der Punkte definiert werden, die diese bilden <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" /> Enumerationselementen, der angibt, den Typ für jeden entsprechenden Punkt in der <c>Pts</c> Array.</param>
        <param name="fillMode">Ein <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumeration, der angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt werden.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Klasse mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" /> und <see cref="T:System.Drawing.Point" /> Arrays und mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumerationselement ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die die Koordinaten der Punkte definiert werden, die diese bilden <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" /> Enumerationselementen, der angibt, den Typ für jeden entsprechenden Punkt in der <c>Pts</c> Array.</param>
        <param name="fillMode">Ein <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumeration, der angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt werden.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Array mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" /> und <see cref="T:System.Drawing.PointF" /> Arrays und mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumerationselement ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" /> die rechteckige Begrenzung der Ellipse, die der Bogen aus dem stammt darstellt.</param>
        <param name="startAngle">Der Startwinkel des Bogens, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Bogens.</param>
        <summary>Fügt einen elliptischen Bogen in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Zeile hinzugefügt, Verbindung den Endpunkt des vorherigen Abschnitts auf den Anfang des Bogens.  
  
 Der Bogen wird entlang des Umfangs der Ellipse, die durch das angegebene Rechteck begrenzt, die nachverfolgt werden. Der Anfangspunkt des Bogens richtet sich nach zwischen der x-Achse der Ellipse (in der 0-Grad-Winkel) durch die Anzahl der in der Startwinkel Grad im Uhrzeigersinn gemessen. Der Endpunkt wird der Speicherort auf ähnliche Weise am Anfangspunkt durch die Anzahl der in der mittelpunktswinkel Grad im Uhrzeigersinn gemessen. Wenn der mittelpunktswinkel 360 Grad oder kleiner als-360 Grad übersteigt, wird der Bogen durch genau 360 Grad oder-360 Grad überflüssig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck, von dem der Bogen definiert ist.  
  
-   Erstellt einen Pfad `myPath`.  
  
-   Definiert einen elliptischen Bogens von 180 Grad an, die aus 0 Grad um 180 Grad fasst zusammen und fügt es in einen Pfad an.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" /> die rechteckige Begrenzung der Ellipse, die der Bogen aus dem stammt darstellt.</param>
        <param name="startAngle">Der Startwinkel des Bogens, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Bogens.</param>
        <summary>Fügt einen elliptischen Bogen in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Zeile hinzugefügt, Verbindung den Endpunkt des vorherigen Abschnitts auf den Anfang des Bogens.  
  
 Der Bogen wird entlang des Umfangs der Ellipse, die durch das angegebene Rechteck begrenzt, die nachverfolgt werden. Der Anfangspunkt des Bogens richtet sich nach zwischen der x-Achse der Ellipse (in der 0-Grad-Winkel) durch die Anzahl der in der Startwinkel Grad im Uhrzeigersinn gemessen. Der Endpunkt wird der Speicherort auf ähnliche Weise am Anfangspunkt durch die Anzahl der in der mittelpunktswinkel Grad im Uhrzeigersinn gemessen. Wenn der mittelpunktswinkel 360 Grad oder kleiner als-360 Grad übersteigt, wird der Bogen durch genau 360 Grad oder-360 Grad überflüssig.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die X-Koordinate der oberen linken Ecke des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="width">Die Breite des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="height">Die Höhe des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel des Bogens, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Bogens.</param>
        <summary>Fügt einen elliptischen Bogen in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Zeile hinzugefügt, Verbindung den Endpunkt des vorherigen Abschnitts auf den Anfang des Bogens.  
  
 Der Bogen wird entlang des Umfangs der Ellipse, die durch das angegebene Rechteck begrenzt, die nachverfolgt werden. Der Anfangspunkt des Bogens richtet sich nach zwischen der x-Achse der Ellipse (in der 0-Grad-Winkel) durch die Anzahl der in der Startwinkel Grad im Uhrzeigersinn gemessen. Der Endpunkt wird der Speicherort auf ähnliche Weise am Anfangspunkt durch die Anzahl der in der mittelpunktswinkel Grad im Uhrzeigersinn gemessen. Wenn der mittelpunktswinkel 360 Grad oder kleiner als-360 Grad übersteigt, wird der Bogen durch genau 360 Grad oder-360 Grad überflüssig.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die X-Koordinate der oberen linken Ecke des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="width">Die Breite des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="height">Die Höhe des rechteckigen Bereichs, das die Ellipse definiert, aus der der Bogen gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel des Bogens, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Bogens.</param>
        <summary>Fügt einen elliptischen Bogen in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Zeile hinzugefügt, Verbindung den Endpunkt des vorherigen Abschnitts auf den Anfang des Bogens.  
  
 Der Bogen wird entlang des Umfangs der Ellipse, die durch das angegebene Rechteck begrenzt, die nachverfolgt werden. Der Anfangspunkt des Bogens richtet sich nach zwischen der x-Achse der Ellipse (in der 0-Grad-Winkel) durch die Anzahl der in der Startwinkel Grad im Uhrzeigersinn gemessen. Der Endpunkt wird der Speicherort auf ähnliche Weise am Anfangspunkt durch die Anzahl der in der mittelpunktswinkel Grad im Uhrzeigersinn gemessen. Wenn der mittelpunktswinkel 360 Grad oder kleiner als-360 Grad übersteigt, wird der Bogen durch genau 360 Grad oder-360 Grad überflüssig.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein <see cref="T:System.Drawing.Point" /> , die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.Point" /> , die den ersten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt3">Ein <see cref="T:System.Drawing.Point" /> , die den zweiten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt4">Ein <see cref="T:System.Drawing.Point" /> , die den Endpunkt der Kurve darstellt.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine kubische Bézier-Kurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Bezier-Kurve wird aus den ersten Punkt bis zum vierten Punkt erstellt, mit dem zweiten und dritten Punkt als Steuerpunkte.  
  
 Wenn eine zuvor ausgegebene Zeile oder ein Kurvensegment in der Abbildung vorhanden ist, wird eine Zeile für den Ausgangspunkt der kubische Bezier-Kurve die Verbindung den Endpunkt der vorherigen Segment hinzugefügt.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein <see cref="T:System.Drawing.PointF" /> , die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.PointF" /> , die den ersten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt3">Ein <see cref="T:System.Drawing.PointF" /> , die den zweiten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt4">Ein <see cref="T:System.Drawing.PointF" /> , die den Endpunkt der Kurve darstellt.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine kubische Bézier-Kurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Bezier-Kurve wird aus den ersten Punkt bis zum vierten Punkt erstellt, mit dem zweiten und dritten Punkt als Steuerpunkte.  
  
 Wenn eine zuvor ausgegebene Zeile oder ein Kurvensegment in der Abbildung vorhanden ist, wird eine Zeile für den Ausgangspunkt der kubische Bezier-Kurve die Verbindung den Endpunkt der vorherigen Segment hinzugefügt.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die X-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die X-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die X-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine kubische Bézier-Kurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Bezier-Kurve wird aus den ersten Punkt bis zum vierten Punkt erstellt, mit dem zweiten und dritten Punkt als Steuerpunkte.  
  
 Wenn eine zuvor ausgegebene Zeile oder ein Kurvensegment in der Abbildung vorhanden ist, wird eine Zeile für den Ausgangspunkt der kubische Bezier-Kurve die Verbindung den Endpunkt der vorherigen Segment hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Fügt eine kubische Bézier-Kurve, die durch Punkte (50, 50), definiert (70, 0), (100, 120) und (150, 50) in den Pfad.  
  
-   Schließt die Kurve.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die X-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die X-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die X-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine kubische Bézier-Kurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Bezier-Kurve wird aus den ersten Punkt bis zum vierten Punkt erstellt, mit dem zweiten und dritten Punkt als Steuerpunkte.  
  
 Wenn eine zuvor ausgegebene Zeile oder ein Kurvensegment in der Abbildung vorhanden ist, wird eine Zeile für den Ausgangspunkt der kubische Bezier-Kurve die Verbindung den Endpunkt der vorherigen Segment hinzugefügt.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die die Kurven zu definieren.</param>
        <summary>Fügt eine Sequenz von verbundenen kubische Bézier-Kurven in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `points` Parameter gibt ein Array von Endpunkten und Steuerpunkte der verbundenen Kurven. Die erste Kurve aus dem ersten Punkt erstellt wird, bis zum vierten Punkt in der `points` Array mithilfe der zweite und dritte Punkt als Steuerpunkte. Zusätzlich zu den Endpunkt der Kurve an der vorherigen, benötigt jede nachfolgende Kurve in der Sequenz genau drei weitere Punkte: die folgenden beiden Punkte in der Sequenz sind Steuerpunkte, und der dritte ist der Endpunkt der Kurve hinzugefügt.  
  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Linie Verbindung den Endpunkt des vorherigen Abschnitts zum Anfangspunkt der Kurve an der ersten kubische in der Sequenz hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von sieben Punkte (zwei verbundene Bézier-Kurven darstellt).  
  
-   Erstellt einen Pfad und den Pfad der Reihe von Punkten für Bézier-Kurve hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die die Kurven zu definieren.</param>
        <summary>Fügt eine Sequenz von verbundenen kubische Bézier-Kurven in der aktuellen Form an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `points` Parameter gibt ein Array von Endpunkten und Steuerpunkte der verbundenen Kurven. Die erste Kurve aus dem ersten Punkt erstellt wird, bis zum vierten Punkt in der `points` Array mithilfe der zweite und dritte Punkt als Steuerpunkte. Zusätzlich zu den Endpunkt der Kurve an der vorherigen, benötigt jede nachfolgende Kurve in der Sequenz genau drei weitere Punkte: die folgenden beiden Punkte in der Sequenz sind Steuerpunkte, und der dritte ist der Endpunkt der Kurve hinzugefügt.  
  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Linie Verbindung den Endpunkt des vorherigen Abschnitts zum Anfangspunkt der Kurve an der ersten kubische in der Sequenz hinzugefügt.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <summary>Fügt eine geschlossene Kurve an diesen Pfad an. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte. Wenn der erste und letzte Punkt in der `points` Array nicht den gleichen Zeitpunkt, die Kurve wird durch diese beiden Punkte verbindet geschlossen. Der Spannungswert kann nicht festgelegt werden, damit diese Methode, und der Standardwert ist der Wert 0,5.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <summary>Fügt eine geschlossene Kurve an diesen Pfad an. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte. Wenn der erste und letzte Punkt in der `points` Array nicht den gleichen Zeitpunkt, die Kurve wird durch diese beiden Punkte verbindet geschlossen. Der Spannungswert kann nicht festgelegt werden, damit diese Methode, und der Standardwert ist der Wert 0,5.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="tension">Ein Wert zwischen 0 bis 1, der den Betrag angibt, den zwischen Punkten, wobei 0 die kleinste Kurve (besten Ecke) und 1 wird die bestmögliche Kurve Steuerpunkte.</param>
        <summary>Fügt eine geschlossene Kurve an diesen Pfad an. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte. Wenn der erste und letzte Punkt in der `points` Array nicht den gleichen Zeitpunkt, die Kurve wird durch diese beiden Punkte verbindet geschlossen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von sechs Punkten (die eine cardinal-Splinekurve darstellen).  
  
-   Erstellt einen Pfad und den Pfad (aus dem Endpunkt zum Anfangspunkt geschlossen) die geschlossene cardinal-Splinekurve Kurven hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 Beachten Sie, dass eine Spannung von 0,5 verwendet wird.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="tension">Ein Wert zwischen 0 bis 1, der den Betrag angibt, den zwischen Punkten, wobei 0 die kleinste Kurve (besten Ecke) und 1 wird die bestmögliche Kurve Steuerpunkte.</param>
        <summary>Fügt eine geschlossene Kurve an diesen Pfad an. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte. Wenn der erste und letzte Punkt in der `points` Array nicht den gleichen Zeitpunkt, die Kurve wird durch diese beiden Punkte verbindet geschlossen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve. Eine cardinal-Splinekurve wird verwendet, weil die Kurve durch jeden Punkt im Array geleitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="tension">Ein Wert, der den Betrag angibt, den zwischen Steuerpunkte Steuerpunkte. Werte größer als 1 zu unvorhersehbare Ergebnissen führen.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="tension">Ein Wert, der den Betrag angibt, den zwischen Steuerpunkte Steuerpunkte. Werte größer als 1 zu unvorhersehbare Ergebnissen führen.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="offset">Der Index des Elements in der <c>Punkte</c> Array, das verwendet wird, als der erste Punkt in der Kurve.</param>
        <param name="numberOfSegments">Ein Wert, der den Betrag angibt, den zwischen Steuerpunkte Steuerpunkte. Werte größer als 1 zu unvorhersehbare Ergebnissen führen.</param>
        <param name="tension">Ein Wert, der den Betrag angibt, den zwischen Steuerpunkte Steuerpunkte. Werte größer als 1 zu unvorhersehbare Ergebnissen führen.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
 Die Kurve beginnt an dem Punkt im Array gemäß der `offset` Parameter und enthält die Anzahl von Punkten (Segmente) gemäß `numberOfSegments`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von vier Punkte (eine cardinal-Splinekurve darstellt).  
  
-   Erstellt einen Pfad ein, und verwenden das Array von Punkten an, der die Kurve zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 Beachten Sie, dass das Array zwar vier Punkte enthält, nur drei Segmente vorhanden sind, also in der Zahl in das dritte Argument des Aufrufs von <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die Definition des Kurvenverlaufs.</param>
        <param name="offset">Der Index des Elements in der <c>Punkte</c> Array, das verwendet wird, als der erste Punkt in der Kurve.</param>
        <param name="numberOfSegments">Die Anzahl der Segmente verwendet, um die Kurve zu zeichnen. Ein Segment kann als eine verbindende Linie zwischen zwei Punkten betrachtet werden.</param>
        <param name="tension">Ein Wert, der den Betrag angibt, den zwischen Steuerpunkte Steuerpunkte. Werte größer als 1 zu unvorhersehbare Ergebnissen führen.</param>
        <summary>Die aktuelle Abbildung hinzugefügt eine Splinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
 Die Kurve beginnt an dem Punkt im Array vom angegebenen `offset`, und enthält die Anzahl von Punkten (Segmente) gemäß `numberOfSegments`.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" /> , die das umschließende Rechteck, das die Ellipse definiert, darstellt.</param>
        <summary>Fügt eine Ellipse, die den aktuellen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
 Erstellt ein umschließendes Rechteck, das eine Ellipse definiert.  
  
 Erstellt einen Pfad und den Pfad die Ellipse hinzugefügt.  
  
 Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" /> , die das umschließende Rechteck, das die Ellipse definiert, darstellt.</param>
        <summary>Fügt eine Ellipse, die den aktuellen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Fügt eine Ellipse, die den aktuellen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Fügt eine Ellipse, die den aktuellen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein <see cref="T:System.Drawing.Point" /> , der den Ausgangspunkt der Zeile darstellt.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.Point" /> , die den Endpunkt der Linie darstellt.</param>
        <summary>Fügt ein Liniensegment dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das Liniensegment definiert, durch die angegebenen Punkte am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>. Wenn vorherige Linien und Kurven in stehen die <xref:System.Drawing.Drawing2D.GraphicsPath>, Liniensegment zur Verbindung mit des ersten Punkts im neuen Liniensegment letzten Punkts in den Pfad gezeichnet wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein <see cref="T:System.Drawing.PointF" /> , der den Ausgangspunkt der Zeile darstellt.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.PointF" /> , die den Endpunkt der Linie darstellt.</param>
        <summary>Fügt ein Liniensegment dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das Liniensegment definiert, durch die angegebenen Punkte am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>. Wenn vorherige Linien und Kurven in stehen die <xref:System.Drawing.Drawing2D.GraphicsPath>, Liniensegment zur Verbindung mit des ersten Punkts im neuen Liniensegment letzten Punkts in den Pfad gezeichnet wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Die X-Koordinate des Anfangspunkts der Linie.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Linie.</param>
        <param name="x2">Die X-Koordinate des Endpunkts der Linie.</param>
        <param name="y2">Die y-Koordinate des Endpunkts der Linie.</param>
        <summary>Fügt ein Liniensegment an die aktuelle Abbildung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt Liniensegments durch die angegebenen Punkte am Ende der aktuellen Abbildung definiert. Wenn vorherige Linien und Kurven in stehen die <xref:System.Drawing.Drawing2D.GraphicsPath>, Liniensegment zur Verbindung mit des ersten Punkts im neuen Liniensegment letzten Punkts in den Pfad gezeichnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code erstellt einen Pfad, fügt drei Zeilen, die ein Dreieck bilden und klicken Sie dann den Pfad auf dem Bildschirm zeichnet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Die X-Koordinate des Anfangspunkts der Linie.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Linie.</param>
        <param name="x2">Die X-Koordinate des Endpunkts der Linie.</param>
        <param name="y2">Die y-Koordinate des Endpunkts der Linie.</param>
        <summary>Fügt ein Liniensegment dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das Liniensegment definiert, durch die angegebenen Punkte am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>. Wenn vorherige Linien und Kurven in stehen die <xref:System.Drawing.Drawing2D.GraphicsPath>, Liniensegment zur Verbindung mit des ersten Punkts im neuen Liniensegment letzten Punkts in den Pfad gezeichnet wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die Punkte darstellt, die die hinzuzufügenden Liniensegmente definieren.</param>
        <summary>Fügt eine Reihe von Liniensegmenten verbundenen am Ende dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Linie Verbindung für den Endpunkt des vorherigen Abschnitts den Ausgangspunkt der Zeile hinzugefügt. Die `points` Parameter gibt ein Array von Endpunkten. Die ersten beiden Geben Sie die erste Zeile. Jeder zusätzlicher Punkt gibt den Endpunkt des Liniensegments, dessen Startpunkt der Endpunkt der vorherigen Zeile ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von vier Punkte, die ein Dreieck beschreiben.  
  
-   Erstellt einen Pfad und fügt das Array von Zeilen.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 Beachten Sie, dass jede Zeile nach dem ersten Punkt am vorherigen Punkt als den Ausgangspunkt und den neuen Punkt als Endpunkt verwendet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die Punkte darstellt, die die hinzuzufügenden Liniensegmente definieren.</param>
        <summary>Fügt eine Reihe von Liniensegmenten verbundenen am Ende dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vorherige Positionen oder Kurven in der Abbildung sind, wird eine Linie Verbindung für den Endpunkt des vorherigen Abschnitts den Ausgangspunkt der Zeile hinzugefügt. Die `points` Parameter gibt ein Array von Endpunkten. Die ersten beiden Geben Sie die erste Zeile. Jeder zusätzlicher Punkt gibt den Endpunkt des Liniensegments, dessen Startpunkt der Endpunkt der vorherigen Zeile ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">Das hinzuzufügende <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="connect">Ein boolescher Wert, der angibt, ob die erste Abbildung im hinzugefügten Pfad Teil der letzten Figur in diesem Pfad ist. Der Wert <see langword="true" /> gibt an, dass (sofern möglich) die erste Abbildung im hinzugefügten Pfad Teil der letzten Figur in diesem Pfad ist. Der Wert <see langword="false" /> gibt an, dass es sich bei die erste Abbildung im hinzugefügten Pfad von der letzten Figur in diesem Pfad getrennt ist.</param>
        <summary>Fügt das angegebene <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> auf diesen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Pfade: ein, ein Dreieck rechts-nach oben und der andere ein Dreieck Seite nach oben.  
  
-   Die erste hinzugefügt der zweiten Pfads.  
  
-   Zeichnet den resultierenden Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" /> , die das umschließende Rechteck, das die Ellipse definiert, aus der der Kreis gezeichnet wird, darstellt.</param>
        <param name="startAngle">Der Startwinkel der Kreisausschnitt, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Kreisausschnitts im, gemessen in Grad im Uhrzeigersinn aus <c>StartAngle</c>.</param>
        <summary>Fügt der Außenlinie des eine Kreisform auf diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreisform wird definiert, durch einen partiellen Umriss einer Ellipse und zwei Radien ein, die die Endpunkte der Kontur teilweise überschneiden. Die partielle Gliederung beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse aus gemessen) und endet bei `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die X-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel der Kreisausschnitt, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Kreisausschnitts im, gemessen in Grad im Uhrzeigersinn aus <c>StartAngle</c>.</param>
        <summary>Fügt der Außenlinie des eine Kreisform auf diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreisform wird definiert, durch einen partiellen Umriss einer Ellipse und zwei Radien ein, die die Endpunkte der Kontur teilweise überschneiden. Die partielle Gliederung beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse aus gemessen) und endet bei `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code erstellt einen Grafikpfad, fügt die Kreisform und klicken Sie dann den Pfad auf dem Bildschirm zeichnet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die X-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der Kreis gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel der Kreisausschnitt, gemessen in Grad gegen den Uhrzeigersinn von der x-Achse aus.</param>
        <param name="sweepAngle">Der Winkel zwischen <c>StartAngle</c> und das Ende des Kreisausschnitts im, gemessen in Grad im Uhrzeigersinn aus <c>StartAngle</c>.</param>
        <summary>Fügt der Außenlinie des eine Kreisform auf diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreisform wird definiert, durch einen partiellen Umriss einer Ellipse und zwei Radien ein, die die Endpunkte der Kontur teilweise überschneiden. Die partielle Gliederung beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse aus gemessen) und endet bei `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" /> Strukturen, die das hinzuzufügende Vieleck definiert.</param>
        <summary>Fügt ein Polygon an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Punkte in der `points` Array geben die Eckpunkte des Vielecks. Wenn der erste Punkt im Array nicht der letzte Punkt identisch ist, werden diese zwei Punkten verbunden, damit um das Polygon zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von Punkten, die ein Polygon definiert.  
  
-   Erstellt einen Pfad und den Pfad des Polygons hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die das hinzuzufügende Vieleck definiert.</param>
        <summary>Fügt ein Polygon an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Punkte in der `points` Array geben die Eckpunkte des Vielecks. Wenn der erste Punkt im Array nicht der letzte Punkt identisch ist, werden diese zwei Punkten verbunden, damit um das Polygon zu schließen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" /> zum Darstellen des Rechtecks hinzufügen.</param>
        <summary>Dieser Pfad wird ein Rechteck hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Erstellt ein Rechteck und das Rechteck zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks hinzufügen.</param>
        <summary>Dieser Pfad wird ein Rechteck hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Ein Array von <see cref="T:System.Drawing.Rectangle" /> Strukturen, die die hinzuzufügenden Rechtecke darstellt.</param>
        <summary>Fügt eine Reihe von Rechtecken, die an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Erstellt ein Array von Rechtecken und Rechtecke zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Ein Array von <see cref="T:System.Drawing.RectangleF" /> Strukturen, die die hinzuzufügenden Rechtecke darstellt.</param>
        <summary>Fügt eine Reihe von Rechtecken, die an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Ein <see cref="T:System.Drawing.FontFamily" /> , die den Namen der Schriftart an, mit denen der Test gezeichnet wird, darstellt.</param>
        <param name="style">Ein <see cref="T:System.Drawing.FontStyle" /> -Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Dies muss eine ganze Zahl umgewandelt werden (Siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe der quadratische Em-Box, die das Zeichen begrenzt.</param>
        <param name="origin">Ein <see cref="T:System.Drawing.Point" /> , die den Punkt, an der der Text beginnt, darstellt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" /> , Textformatierungsinformationen, z. B. Zeilenabstand und Ausrichtung angibt.</param>
        <summary>Fügt eine Textzeichenfolge an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Richtet Zeichenfolgen- und Schriftart-Argumente.  
  
-   Fügt die Zeichenfolge in den Pfad an.  
  
-   Zeichnet die Zeichenfolge an den Bildschirm an.  
  
 Es gibt zwei wichtige Aspekte zu berücksichtigen. Beachten Sie, dass zunächst die `fontStyle` Argument als eine ganze Zahl umgewandelt wird. Die <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> -Methode erforderlich, sodass zwei oder mehr <xref:System.Drawing.FontStyle> Mitglieder können kombiniert werden, um den gewünschten Schriftschnitt zu erstellen (in diesem Fall <xref:System.Drawing.FontStyle.Italic> und <xref:System.Drawing.FontStyle.Underline>). Zweitens, beachten Sie, dass die <xref:System.Drawing.Graphics.FillPath%2A> Methode wird verwendet, anstatt die <xref:System.Drawing.Graphics.DrawPath%2A> Methode. Wenn <xref:System.Drawing.Graphics.FillPath%2A> verwendet wird, wird dargestellt, wenn <xref:System.Drawing.Graphics.DrawPath%2A> wird verwendet, wird der Text einer umrissstil werden.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Ein <see cref="T:System.Drawing.FontFamily" /> , die den Namen der Schriftart an, mit denen der Test gezeichnet wird, darstellt.</param>
        <param name="style">Ein <see cref="T:System.Drawing.FontStyle" /> -Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Dies muss eine ganze Zahl umgewandelt werden (Siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe der quadratische Em-Box, die das Zeichen begrenzt.</param>
        <param name="origin">Ein <see cref="T:System.Drawing.PointF" /> , die den Punkt, an der der Text beginnt, darstellt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" /> , Textformatierungsinformationen, z. B. Zeilenabstand und Ausrichtung angibt.</param>
        <summary>Fügt eine Textzeichenfolge an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Ein <see cref="T:System.Drawing.FontFamily" /> , die den Namen der Schriftart an, mit denen der Test gezeichnet wird, darstellt.</param>
        <param name="style">Ein <see cref="T:System.Drawing.FontStyle" /> -Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Dies muss eine ganze Zahl umgewandelt werden (Siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe der quadratische Em-Box, die das Zeichen begrenzt.</param>
        <param name="layoutRect">Ein <see cref="T:System.Drawing.Rectangle" /> zum Darstellen des Rechtecks, das den Text umschließt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" /> , Textformatierungsinformationen, z. B. Zeilenabstand und Ausrichtung angibt.</param>
        <summary>Fügt eine Textzeichenfolge an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Ein <see cref="T:System.Drawing.FontFamily" /> , die den Namen der Schriftart an, mit denen der Test gezeichnet wird, darstellt.</param>
        <param name="style">Ein <see cref="T:System.Drawing.FontStyle" /> -Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Dies muss eine ganze Zahl umgewandelt werden (Siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe der quadratische Em-Box, die das Zeichen begrenzt.</param>
        <param name="layoutRect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks, das den Text umschließt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" /> , Textformatierungsinformationen, z. B. Zeilenabstand und Ausrichtung angibt.</param>
        <summary>Fügt eine Textzeichenfolge an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Marker aus diesem Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> Methode zum Erstellen der Marker am aktuellen Speicherort in einem <xref:System.Drawing.Drawing2D.GraphicsPath>. Verwenden der <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> Methode, um die vorhandenen Marker in einem Pfad durchlaufen.  
  
 Marker werden verwendet, um Gruppen von pfadsegmentenden zu trennen. Eine oder mehrere Pfade können zwischen zwei Marker enthalten sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Fügt mehrere Objekte auf den Pfad an.  
  
-   Marker hinzugefügt zum Pfad.  
  
-   Löscht alle Marker aus dem Pfad an.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine genaue Kopie dieses Pfads.</summary>
        <returns>Das von dieser Methode erstellte <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, umgewandelt in ein Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Fügt mehrere Zahlen auf den Pfad an.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
-   Klont eine Kopie des Pfades.  
  
-   Zeichnet den neuen Pfad auf dem Bildschirm an.  
  
 Beachten Sie, dass der Aufruf der <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> Methode umgewandelt werden muss, als eine <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt alle geöffneten Abbildungen in diesem Pfad und eine neue Abbildung beginnt. Es schließt jede geöffnete Figur durch Herstellen einer Verbindung eine Zeile aus dem Endpunkt an seinem Ausgangspunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Mehrere offene Figuren hinzugefügt zum Pfad.  
  
-   Schließt alle Zahlen in den Pfad an.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die aktuelle Abbildung und eine neue Abbildung beginnt. Wenn die aktuelle Abbildung eine Sequenz von miteinander verbundenen Linien und Kurven enthält, schließt die Methode die Schleife durch Herstellen einer Verbindung eine Linie vom Endpunkt zum Anfangspunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code erstellt ein Dreieck, indem Sie beim Erstellen eines neuen Pfads, starten eine Abbildung, in der Abbildung werden zwei sich überschneidenden Linien hinzugefügt und dann zum Bilden eines Dreiecks geschlossen. Der Pfad wird auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> können die von diesem verwendeten Ressourcen <xref:System.Drawing.Drawing2D.GraphicsPath> neu für andere Zwecke reserviert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest ein <see cref="T:System.Drawing.Drawing2D.FillMode" /> -Enumeration, der bestimmt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt werden.</summary>
        <value>Ein <see cref="T:System.Drawing.Drawing2D.FillMode" /> Enumeration, der angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt werden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert jede Kurve in diesem Pfad in eine Folge von verbundenen Liniensegmente an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , um diese Transformation <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> vor vereinfachen.</param>
        <summary>Wendet die angegebene Transformation, und klicken Sie dann konvertiert jede Kurve in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in eine Folge von verbundenen Liniensegmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , um diese Transformation <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> vor vereinfachen.</param>
        <param name="flatness">Gibt den maximal zulässigen Fehler zwischen der Kurve und seine vereinfachten Angleichung an. Der Standardwert ist 0,25. Der Abflachungswert verringert, erhöhen Sie die Anzahl von Liniensegmenten, die in die Näherung.</param>
        <summary>Konvertiert jede Kurve in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in eine Folge von verbundenen Liniensegmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafikpfad und eine translationsmatrix.  
  
-   Fügt eine Kurve in den Pfad, der mithilfe von vier Punkte.  
  
-   Zeichnet den Pfad (Kurve) auf dem Bildschirm mit einem schwarzen Stift.  
  
-   Verlagert die Kurve unten 10 Pixel, und es vereinfacht.  
  
-   Zeichnet die Kurve mit einem roten Stift auf dem Bildschirm an.  
  
 Beachten Sie, dass die rote Kurve Linien zwischen den Punkten vereinfacht wurde.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Rechteck, das dies umschließt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" /> , die ein Rechteck, das dies umschließt darstellt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der Linienenden Stiftbreite und Stift Spitz Grenzwert beeinflusst, und daher erzeugt eine "loose Fit" auf den begrenzten Pfad. Die ungefähre Formel ist: das ursprüngliche umschließende Rechteck von Stiftbreite vergrößert wird, und dieses Ergebnis wird der Grenzwert für den Winkel sowie einige zusätzliche Rand Linienenden sicherungsspeicherverwendung multipliziert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafikpfad.  
  
-   Eine Ellipse (Kreis) hinzugefügt und auf dem Bildschirm gezeichnet.  
  
-   Ruft das umschließende Rechteck für den Kreis mit einem Aufruf von <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> und zeichnet das Rechteck auf dem Bildschirm.  
  
-   Erstellt einen zweite Grafikpfad.  
  
-   Fügt einen Kreis und erweitert den Pfad zu einer Breite von 10.  
  
-   Zeichnet den Pfad auf dem Bildschirm an.  
  
-   Ruft das umschließende Rechteck für den zweiten Kreis ab.  
  
-   Zeichnet das umschließende Rechteck auf dem Bildschirm an.  
  
-   Zeigt die Größe des Rechtecks in einem Dialogfeld an.  
  
 Beachten Sie, dass auf der rechten Seite des umschließenden Rechtecks (zum Konto für die zusätzliche Stärke der Linie) größer ist.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Die <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die angibt, dass einer Transformations, die auf diesen Pfad angewendet werden, bevor das umschließende Rechteck berechnet wird. Dieser Pfad ist nicht dauerhaft transformiert. die Transformation wird nur während des Prozesses zur Berechnung des umschließenden Rechtecks verwendet.</param>
        <summary>Gibt ein Rechteck, das dies umschließt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Wenn dieser Pfad transformiert wird durch das angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" /> , die ein Rechteck, das dies umschließt darstellt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der Linienenden Stiftbreite und Stift Spitz Grenzwert beeinflusst, und daher erzeugt eine "loose Fit" auf den begrenzten Pfad. Die ungefähre Formel ist: das ursprüngliche umschließende Rechteck von Stiftbreite vergrößert wird, und dieses Ergebnis wird der Grenzwert für den Winkel sowie einige zusätzliche Rand Linienenden sicherungsspeicherverwendung multipliziert.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">Die <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die angibt, dass einer Transformations, die auf diesen Pfad angewendet werden, bevor das umschließende Rechteck berechnet wird. Dieser Pfad ist nicht dauerhaft transformiert. die Transformation wird nur während des Prozesses zur Berechnung des umschließenden Rechtecks verwendet.</param>
        <param name="pen">Die <see cref="T:System.Drawing.Pen" /> mit dem Zeichnen der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Gibt ein Rechteck, das dies umschließt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Wenn der aktuelle Pfad transformiert wird durch das angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" /> und mit dem angegebenen gezeichnet <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" /> , die ein Rechteck, das dies umschließt darstellt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der Linienenden Stiftbreite und Stift Spitz Grenzwert beeinflusst, und daher erzeugt eine "loose Fit" auf den begrenzten Pfad. Die ungefähre Formel ist: das ursprüngliche umschließende Rechteck von Stiftbreite vergrößert wird, und dieses Ergebnis wird der Grenzwert für den Winkel sowie einige zusätzliche Rand Linienenden sicherungsspeicherverwendung multipliziert.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den letzten Punkt der <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> Array dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ein <see cref="T:System.Drawing.PointF" /> , die den letzten Punkt in dieser darstellt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code erstellt einen Pfad, eine Zeile zum Pfad hinzugefügt und ruft dann den letzten Punkt im Pfad.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.Point" /> , die die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.PointF" /> , die die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" /> , die die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" /> und unter Verwendung des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> mit dem angegebenen gezeichnet <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist. Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Der Transformationsmatrix des `graphics` wird vorübergehend angewendet werden, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.PointF" /> , die die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" /> und unter Verwendung des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> mit dem angegebenen gezeichnet <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist. Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Der Transformationsmatrix des `graphics` wird vorübergehend angewendet werden, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" /> und unter Verwendung des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb der Gliederung dieses enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> mit dem angegebenen gezeichnet <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist. Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Der Transformationsmatrix des `graphics` wird vorübergehend angewendet werden, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wird ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Der Pfad hinzugefügt ein Rechteck.  
  
-   Erstellt einen breiten Stift und erweitert den Pfad mit diesem Stift (um das Beispiel deutlicher zu machen),  
  
-   Testet einen Punkt (100, 50), um festzustellen, ob es innerhalb des Randes des Rechtecks (unter) einem durch Aufrufen von liegt <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 Das Ergebnis wird im Meldungsfenster angezeigt (in diesem Fall, "true"). Am Rand wird also über diesen Punkt gerendert.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> beim Zeichnen mit dem angegebenen <see cref="T:System.Drawing.Pen" /> und unter Verwendung des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> , wenn der angegebene Punkt innerhalb (der Gliederung dieses unter) enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> mit dem angegebenen gezeichnet <see cref="T:System.Drawing.Pen" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, um festzustellen, ob die Gliederung des jeweiligen Pfads am angegebenen Punkt sichtbar ist. Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Die Transformationsmatrix, die von der `graphics` Parameter ist vorübergehend angewendet, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.Point" /> , die die zu überprüfenden Punkt darstellt.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.PointF" /> , die die zu überprüfenden Punkt darstellt.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" /> , die die zu überprüfenden Punkt darstellt.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Die Transformationsmatrix, die von der `graphics` Parameter ist vorübergehend angewendet, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.PointF" /> , die die zu überprüfenden Punkt darstellt.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> ist der angegebene Punkt in dieser enthalten ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Die Transformationsmatrix, die von der `graphics` Parameter ist vorübergehend angewendet, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, unter Verwendung des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Der Transformationsmatrix des `graphics` wird vorübergehend angewendet werden, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und eine Ellipse, die zum Pfad hinzugefügt.  
  
-   Testet, ob der angegebene Punkt im Pfad enthalten ist.  
  
-   Zeigt das Ergebnis in einem Dialogfeld an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="graphics">Die <see cref="T:System.Drawing.Graphics" /> für die Sichtbarkeit zu testen.</param>
        <summary>Gibt an, ob der angegebene Punkt in dieser enthalten ist <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in des sichtbaren Ausschneidebereichs des angegebenen <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Diese Methode gibt <see langword="true" /> Wenn sich der angegebene Punkt in dieser befindet <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des Punkts, der darauf getestet werden, sind in globalen Koordinaten angegeben. Die Transformationsmatrix, die von der `graphics` Parameter ist vorübergehend angewendet, bevor die Tests für Sichtbarkeit.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Drawing.Drawing2D.PathData" /> , kapselt Arrays von Punkten (<paramref name="points" />) und Typen (<paramref name="types" />) für diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>Ein <see cref="T:System.Drawing.Drawing2D.PathData" /> , kapselt Arrays für die Punkte und Typen für diese <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Punkte im Pfad.</summary>
        <value>Ein Array von <see cref="T:System.Drawing.PointF" /> Objekte, die den Pfad darstellen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Typen der entsprechenden Punkte in der <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> Array.</summary>
        <value>Ein Array von Bytes, die die Typen der entsprechenden Punkte im Pfad angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von Bytes, die <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> Eigenschaft gibt die Arten von Überprüfungspunkten aufweisen und Flags für die Datenpunkte in einem Pfad. Für jeden Punkt Bits 0 bis 2 Geben Sie den Typ eines Punkts, und Bits 3 bis 7 enthalten einen Satz von Flags, die die Attribute eines Punkts angeben. Die folgende Tabelle zeigt die möglichen Werte und ihre Bedeutung.  
  
|Wert|Bedeutung|  
|-----------|-------------|  
|0|Gibt an, dass der Punkt am Anfang einer Abbildung ist.|  
|1|Gibt an, dass der Punkt eine der beiden Endpunkte einer Zeile ist.|  
|3|Gibt an, dass der Punkt ein Endpunkt oder ein Kontrollpunkt der kubische Bézier-Spline ist.|  
|0 x 7|Maskiert alle Bits mit Ausnahme der drei niederwertigen Bits, die was darauf hindeuten, der Typ des Punkts dass an.|  
|0 x 20|Gibt an, dass der Punkt ein Marker.|  
|0 x 80|Gibt an, dass der Zeitpunkt der letzten Punkts in einer geschlossenen Unterpfad (Abbildung).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente in der <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> oder <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> Array.</summary>
        <value>Eine ganze Zahl, die angibt, die Anzahl der Elemente in der <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> oder <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> Array.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Leert die <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> und <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> arrays und legt die <see cref="T:System.Drawing.Drawing2D.FillMode" /> auf <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Mehrere primitiven hinzugefügt.  
  
-   Zeichnet den Pfad Punktearray auf dem Bildschirm an.  
  
-   Setzt den Pfad auf einen leeren Zustand zurück.  
  
-   Erneut Punktearray das (falls vorhanden).  
  
-   Zeichnet das Array auf dem Bildschirm an.  
  
 Beachten Sie, dass kein Array nach dem Zurücksetzen der Aufruf gefunden.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Punkte in der <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> Array dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und mehrere primitiven zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad Punktearray auf dem Bildschirm an.  
  
-   Zeichnet die umgekehrten Punktearray auf dem Bildschirm an.  
  
 Beachten Sie, dass die zweite Auflistung von Punkten in umgekehrter Reihenfolge vom ersten ist.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt einen Marker für diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt einen Marker für den Pfad, der verwendet werden kann, um Abschnitte des Pfads zu trennen. Anschließend können Sie die <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> Methoden zum iterieren durch die Marker im Pfad.  
  
 Marker werden verwendet, um Gruppen von pfadsegmentenden zu trennen. Eine oder mehrere Pfade können zwischen zwei Marker im Pfad enthalten sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code erstellt einen Pfad und den Pfad an, getrennt durch Marker mehrere primitiven hinzugefügt und zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet eine neue Abbildung ohne die aktuelle Abbildung schließen. Alle nachfolgenden Punkte, die dem Pfad hinzugefügt werden in diese neue Form hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer muss die ursprünglichen Punkte beibehalten, wenn sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerpunkte konvertiert, es gibt daher keinen Mechanismus für die Rückgabe der ursprünglichen Punkte.  
  
 Diese Methode startet einen neuen untergeordneten im Pfad. Pfade können Sie einen Pfad in Abschnitte zu unterteilen, und verwenden die <xref:System.Drawing.Drawing2D.GraphicsPathIterator> Klasse, um die Pfade zu durchlaufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad an.  
  
-   Fügt zwei Sätze von Zahlen. Der erste Satz von Abbildungen kombiniert vier primitive in beiden Abbildungen. Die zweite Gruppe von Abbildungen kombiniert vier dieselben Grundelemente (außer, dass sie auf der y-Achse offset) in drei Zahlen.  
  
-   Zeichnet alle Zahlen auf dem Bildschirm an.  
  
 Beachten Sie den Unterschied in der Darstellung zwischen den beiden Sätzen von Zahlen ein.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die die anzuwendende Transformation darstellt.</param>
        <summary>Weist dieser eine Transformationsmatrix <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformation für das Skalieren, übersetzen, gedreht oder Verzerren der <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und eine Ellipse, die zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
-   Erstellt eine Transformationsmatrix, um den Pfad 100 Einheiten in Richtung der x-Achse zu übersetzen.  
  
-   Zeichnet den transformierten Pfad auf dem Bildschirm an.  
  
 Beachten Sie, dass die ursprüngliche Ellipse in Schwarz und die transformierte Ellipse gezeichnet wird, wird Rot gezeichnet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die ein Parallelogramm definieren, der das Rechteck durch definierten <c>SrcRect</c> transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, wird der unteren rechten Ecke des Parallelogramms ergibt, durch die ersten drei Punkte impliziert.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks, das transformiert wird, in der durch definierte Parallelogramm <c>DestPoints</c>.</param>
        <summary>Wendet eine Warp-Transformation, definiert durch ein Rechteck und ein Parallelogramm dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die ein Parallelogramm definieren, der das Rechteck durch definierten <c>SrcRect</c> transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, wird der unteren rechten Ecke des Parallelogramms ergibt, durch die ersten drei Punkte impliziert.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks, das transformiert wird, in der durch definierte Parallelogramm <c>DestPoints</c>.</param>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die eine geometrische Transformation anwenden auf den Pfad angibt.</param>
        <summary>Wendet eine Warp-Transformation, definiert durch ein Rechteck und ein Parallelogramm dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die ein Parallelogramm definiert, der das Rechteck durch definierten <c>SrcRect</c> transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, wird der unteren rechten Ecke des Parallelogramms ergibt, durch die ersten drei Punkte impliziert.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks, das transformiert wird, in der durch definierte Parallelogramm <c>DestPoints</c>.</param>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die eine geometrische Transformation anwenden auf den Pfad angibt.</param>
        <param name="warpMode">Ein <see cref="T:System.Drawing.Drawing2D.WarpMode" /> -Enumeration, der angibt, ob dieser Vorgang Warp Perspektive oder bilineare Modus verwendet.</param>
        <summary>Wendet eine Warp-Transformation, definiert durch ein Rechteck und ein Parallelogramm dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" /> Strukturen, die ein Parallelogramm definieren, der das Rechteck durch definierten <c>SrcRect</c> transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, wird der unteren rechten Ecke des Parallelogramms ergibt, durch die ersten drei Punkte impliziert.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" /> zum Darstellen des Rechtecks, das transformiert wird, in der durch definierte Parallelogramm <c>DestPoints</c>.</param>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , die eine geometrische Transformation anwenden auf den Pfad angibt.</param>
        <param name="warpMode">Ein <see cref="T:System.Drawing.Drawing2D.WarpMode" /> -Enumeration, der angibt, ob dieser Vorgang Warp Perspektive oder bilineare Modus verwendet.</param>
        <param name="flatness">Ein Wert zwischen 0 und 1, der angibt, wie flachen den resultierenden Pfad ist. Weitere Informationen finden Sie unter der <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> Methoden.</param>
        <summary>Wendet eine Warp-Transformation, definiert durch ein Rechteck und ein Parallelogramm dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und den Pfad ein Rechteck hinzugefügt.  
  
-   Zeichnet das Rechteck in Schwarz auf dem Bildschirm an.  
  
-   Verzerrt den Pfad mit einer Perspektive Warp.  
  
-   Zeichnet das verzerrte Rechteck (Pfad) in Rot auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" /> , der den Abstand zwischen dem ursprünglichen Umriss des Pfads und der neue Gliederung diese Methode erstellt angibt.</param>
        <summary>Fügt einen weiteren Umriss auf den Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kontur um die ursprünglichen Zeilen in dieser <xref:System.Drawing.Drawing2D.GraphicsPath>, mit einem Abstand zwischen vorhandenen Zeilen und die neue Gliederung gleich, die der Breite des der <xref:System.Drawing.Pen> verwendet, die im Aufruf von <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Wenn Sie den Platz zwischen den Zeilen ausfüllen möchten müssen Sie verwenden die <xref:System.Drawing.Graphics.FillPath%2A> anstelle der <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" /> , der den Abstand zwischen dem ursprünglichen Umriss des Pfads und der neue Gliederung diese Methode erstellt angibt.</param>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , eine Transformation auf den Pfad vor dem Verbreitern zugewiesen angibt.</param>
        <summary>Fügt eine zusätzliche Kontur der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kontur um die ursprünglichen Zeilen in dieser <xref:System.Drawing.Drawing2D.GraphicsPath>, mit einem Abstand zwischen vorhandenen Zeilen und die neue Gliederung gleich, die der Breite des der <xref:System.Drawing.Pen> verwendet, die im Aufruf von <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Wenn Sie den Platz zwischen den Zeilen ausfüllen möchten müssen Sie verwenden die <xref:System.Drawing.Graphics.FillPath%2A> anstelle der <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" /> , der den Abstand zwischen dem ursprünglichen Umriss des Pfads und der neue Gliederung diese Methode erstellt angibt.</param>
        <param name="matrix">Ein <see cref="T:System.Drawing.Drawing2D.Matrix" /> , eine Transformation auf den Pfad vor dem Verbreitern zugewiesen angibt.</param>
        <param name="flatness">Ein Wert, der die Abflachung von Kurven angibt.</param>
        <summary>Dies ersetzt <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> mit Kurven, die den Bereich einschließen, das ausgefüllt wird, wenn dieser Pfad mit dem angegebenen Stift gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kontur um die ursprünglichen Zeilen in dieser <xref:System.Drawing.Drawing2D.GraphicsPath>, mit einem Abstand zwischen vorhandenen Zeilen und die neue Gliederung gleich, die der Breite des der <xref:System.Drawing.Pen> verwendet, die im Aufruf von <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Wenn Sie den Platz zwischen den Zeilen ausfüllen möchten müssen Sie verwenden die <xref:System.Drawing.Graphics.FillPath%2A> anstelle der <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, einem <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignisobjekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad, und zwei Ellipsen zum Pfad hinzugefügt.  
  
-   Zeichnet den Pfad in Schwarz.  
  
-   Erweitert den Pfad an.  
  
-   Zeichnet den Pfad in Rot.  
  
 Beachten Sie, das zweite Rendering verwendet <xref:System.Drawing.Graphics.FillPath%2A> anstelle von <xref:System.Drawing.Graphics.DrawPath%2A>, und daher in der Abbildung dargestellten Kontur gefüllt wurde.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
