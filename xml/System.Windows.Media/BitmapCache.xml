<Type Name="BitmapCache" FullName="System.Windows.Media.BitmapCache">
  <TypeSignature Language="C#" Value="public sealed class BitmapCache : System.Windows.Media.CacheMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed BitmapCache extends System.Windows.Media.CacheMode" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.BitmapCache" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.CacheMode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Erstellt und speichert eine Bitmapdarstellung einer <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.BitmapCache> Klasse zur Verbesserung der Leistung beim Rendern eines komplexen <xref:System.Windows.UIElement>. Erstellen einer <xref:System.Windows.Media.BitmapCache> und weisen Sie ihn der <xref:System.Windows.UIElement.CacheMode%2A> Eigenschaft eine <xref:System.Windows.UIElement> auf das Element und seine Teilstruktur als Bitmap in Videospeicher zwischenzuspeichern. Dies ist nützlich, wenn Sie animieren, übersetzen oder skalieren müssen eine <xref:System.Windows.UIElement> so schnell wie möglich. Dieser Ansatz ermöglicht eine Abwägung zwischen Leistung und visuelle Qualität, während der Inhalt zwischengespeichert wird.  
  
 Verwenden der <xref:System.Windows.Media.BitmapCacheBrush> Klasse, um effizient wiederverwenden eines zwischengespeicherten Elements.  
  
 Legen Sie die <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> Eigenschaft, um den BitmapCache zu skalieren. Dies ist hilfreich, wenn ein Element vergrößert werden wird, und möchten, dass das Element zum Rendern besser als dies der Fall wäre, wenn der Cache einfach in systemeigenen Auflösung des Elements generiert wurden.  
  
 Legen Sie die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> Eigenschaft, wenn der Cache Inhalte, die anzeigt für das einwandfreie, z. B. ClearType-Text Rendering-Pixel-Ausrichtung benötigt. Diese Eigenschaft wird ignoriert, durch die <xref:System.Windows.Media.BitmapCacheBrush> und <xref:System.Windows.Media.Media3D.Viewport2DVisual3D> Klassen.  
  
 Das Zwischenspeichern eines Steuerelements wirkt sich nicht auf Mouseover-Verhalten, also Mouseovereffekte Treffertests arbeitet, als handele es sich um das Bitmuster ein live-Steuerelement.  
  
 Cache Regenerierung tritt nur auf, wenn die Struktur der der <xref:System.Windows.UIElement> oder dessen Teilstruktur ändert oder wenn die <xref:System.Windows.Media.CacheMode> Einstellungen ändern. Festlegen der <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> oder <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaften Ursachen Zwischenspeichern Regenerierung. Änderungen an der übergeordneten visuellen Struktur für die zwischengespeicherten <xref:System.Windows.UIElement>, z. B. Transformationen, Skalen Deckkraft und Effekte, nicht auf den Cache auswirken.  
  
 Die Cachefunktionen, wenn die Hardwarebeschleunigung nicht verfügbar ist. In diesem Fall wird die Bitmap in der Software gerendert, und die maximale Bitmapdimensionen sind 2048 x 2048.  
  
> [!NOTE]
>  <xref:System.Windows.Media.RenderOptions>und <xref:System.Windows.Media.TextOptions> werden nicht über ein zwischengespeichertes Element weitergegeben. Möglicherweise wird diese Optionen nicht erneut in untergeordneten Elementen unter dem Cache festgelegt.  
  
   
  
## Examples  
 Das folgende XAML zeigt wie Cache eine <xref:System.Windows.Controls.Canvas> Element. Das vollständige Codebeispiel finden Sie unter [wie: Verbessern der Rendern Leistung durch Zwischenspeichern eines Elements](~/docs/framework/wpf/graphics-multimedia/how-to-improve-rendering-performance-by-caching-an-element.md).  
  
 [!code-xaml[System.Windows.Media.BitmapCache#_BitmapCacheCreation](~/samples/snippets/csharp/VS_Snippets_Wpf/system.windows.media.bitmapcache/cs/window1.xaml#_bitmapcachecreation)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitmapCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.BitmapCache" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitmapCache (double renderAtScale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 renderAtScale) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.#ctor(System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="renderAtScale" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="renderAtScale">Ein Double-Wert, der die Bitmap skaliert.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Windows.Media.BitmapCache" /> Klasse mit dem angegebenen Maßstab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende XAML-Code wird gezeigt, wie zum Erstellen und Zuweisen einer <xref:System.Windows.Media.BitmapCache> zu einem <xref:System.Windows.Controls.Canvas> Element. Das vollständige Codebeispiel finden Sie unter [wie: Verbessern der Rendern Leistung durch Zwischenspeichern eines Elements](~/docs/framework/wpf/graphics-multimedia/how-to-improve-rendering-performance-by-caching-an-element.md).  
  
 [!code-xaml[System.Windows.Media.BitmapCache#_BitmapCacheCreation](~/samples/snippets/csharp/VS_Snippets_Wpf/system.windows.media.bitmapcache/cs/window1.xaml#_bitmapcachecreation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapCache Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.BitmapCache Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapCache</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Media.BitmapCache" />-Objekts, indem tiefe Kopien der Werte des Objekts erstellt werden. Beim Kopieren der Abhängigkeitseigenschaften des Objekts kopiert diese Methode Ausdrücke (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapCache CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.BitmapCache CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.CloneCurrentValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapCache</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon (tiefe Kopie) von der <see cref="T:System.Windows.Media.BitmapCache" /> mit den aktuellen Werten.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.CreateInstanceCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableClearType">
      <MemberSignature Language="C#" Value="public bool EnableClearType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClearType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.EnableClearType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Bitmap mit aktiviertem ClearType gerendert wird.</summary>
        <value>
          <see langword="true" />Wenn ClearType aktiv ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaft ClearType-Text im Cache gerendert werden kann.  
  
 Wenn die <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaft `true`, Rendern der Anwendung muss alle ClearType-Text auf ein nicht transparenter Hintergrund.  
  
 Wenn die <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaft `false`, Text im Cache mit Graustufenantialiasing gerendert wird.  
  
 ClearType-Text erfordert eine korrekt Pixel Ausrichtung der gerenderten Zeichen so festgelegt werden soll die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> Eigenschaft `true`. Wenn Sie diese Eigenschaft nicht festgelegt, kann der Inhalt nicht ordnungsgemäß gemischt.  
  
 Verwenden der <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaft, wenn Sie wissen, dass den Cache auf Pixelgrenzen, gerendert wird, sodass ClearType-Text zwischengespeichert werden kann. Diese Situation tritt häufig in Szenarien Durchführen eines Bildlaufs Text.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableClearTypeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EnableClearTypeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EnableClearTypeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.EnableClearTypeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.BitmapCache.EnableClearType" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderAtScale">
      <MemberSignature Language="C#" Value="public double RenderAtScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 RenderAtScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.RenderAtScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der die Dezimalstellen angibt, die für die Bitmap angewendet wird.</summary>
        <value>Die Dezimalstellen, die für die Bitmap angewendet wird. Der Standard ist 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> Eigenschaft zum Rendern der <xref:System.Windows.Media.BitmapCache> auf ein Vielfaches der Größe des normalen Bitmusters. Die normale Größe wird durch die lokale Größe des Elements bestimmt.  
  
 Werte größer als 1 ist, die Auflösung der Bitmap relativ zur Auflösung des Elements erhöht, und Werte kleiner als 1 verringern die Auflösung. Z. B. wenn die <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> Eigenschaft auf 2.0 festgelegt ist und Sie eine Skalierungstransformation, die den Inhalt durch den Faktor von 2 vergrößert anwenden, des Inhalts müssen die gleiche visuelle Qualität als derselbe Inhalt mit <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> 1.0 und einer Transformation Skala von 1 festgelegt.  
  
 Wenn <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> festgelegt ist, 0 (null) keine Bitmap gerendert wird. Negative Werte werden auf 0 festgelegt.  
  
 Wenn Sie diesen Wert ändern, wird der Cache in der entsprechenden neuen Auflösung erneut generiert.  
  
 Folgende Abbildungen zeigen der gleiche Inhalt wie für verschiedene Werte des erscheint die <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> Eigenschaft.  
  
 **RenderAtScale = 1**  
  
 ![RenderAtScale &#61; 1](~/add/media/ndp-scale-1.png "RenderAtScale = 1")  
  
 **RenderAtScale = 0,5**  
  
 ![RenderAtScale &#61; 0,5](~/add/media/ndp-scale05.png "RenderAtScale = 0,5")  
  
 **RenderAtScale = 0,2**  
  
 ![RenderAtScale &#61; 0,2](~/add/media/ndp-scale02.png "RenderAtScale = 0,2")  
  
 Die folgende Abbildung zeigt eine Zoomtransformation, die an einen Vorgänger des zwischengespeicherten Elements angewendet wird. Wenn der Zoomfaktor auf 1 festgelegt ist und <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> festgelegt ist auf 1, ist die Bildqualität fast genauso wie beim <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> auf 2 festgelegt ist. Aber wenn Zoom größer als 1 ist, Festlegen von <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> auf 2 wird die Bildqualität.  
  
 **RenderAtScale = 1,0**  
  
 ![RenderAtScale &#61; 1.0](~/add/media/ndp-scale-10.png "RenderAtScale = 1,0")  
  
 **RenderAtScale = 2.0**  
  
 ![RenderAtScale &#61; 2.0](~/add/media/ndp-scale-20.png "RenderAtScale = 2.0")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderAtScaleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderAtScaleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderAtScaleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.RenderAtScaleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.BitmapCache.RenderAtScale" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Bitmap mit Andocken Pixel gerendert wird.</summary>
        <value>
          <see langword="true" />Wenn Pixel Andocken aktiv ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> Eigenschaft, wenn der Cache Inhalte, die anzeigt für das einwandfreie Rendering-Pixel-Ausrichtung benötigt. Dies ist der Fall bei ClearType-Text. Wenn Sie festlegen, die <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> Eigenschaft, um `true`, legen Sie <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> zu `true` zum richtigen Rendern sicherzustellen.  
  
 Wenn die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> -Eigenschaftensatz auf `false`, können Sie verschieben und skalieren Sie das zwischengespeicherte Element, um den Bruchteil eines Pixels und bilineare Filterung angewendet wird.  
  
 Wenn die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> -Eigenschaftensatz auf `true`, der BitmapCache mithilfe einer Pixelgrenzen des Ziels ausgerichtet ist. Wenn Sie verschieben oder das zwischengespeicherte Element, indem Sie auf einen Teil eines Pixels skalieren, rastet die Bitmap Pixelraster. In diesem Fall der oberen linken Ecke der Bitmap wird aufgerundet, und "angedockt", um Pixelraster, aber die unteren rechten Ecke befindet sich auf einer Pixelgrenze für die Sekundenbruchteile.  
  
 Die <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> Eigenschaft wird ignoriert, indem <xref:System.Windows.Media.BitmapCacheBrush> und bei Verwendung mit einem <xref:System.Windows.Media.Media3D.Viewport2DVisual3D>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.BitmapCache.SnapsToDevicePixels" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
