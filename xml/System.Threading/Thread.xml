<Type Name="Thread" FullName="System.Threading.Thread">
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Erstellt und steuert einen Thread, legt dessen Priorität fest und ruft den Status ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Starten eines Prozesses erstellt die common Language Runtime automatisch einen einzelne Vordergrundthread um Anwendungscode auszuführen. Zusammen mit diesem Hauptmenü Vordergrundthread kann ein Prozess einen oder mehrere Threads zum Ausführen eines Teils des Programmcodes, die dem Prozess zugeordnet erstellen. Diese Threads können im Vordergrund oder im Hintergrund ausgeführt. Darüber hinaus können Sie die <xref:System.Threading.ThreadPool> Klasse zum Ausführen von Code von Arbeitsthreads, die von der common Language Runtime verwaltet werden.  
  
 In diesem Abschnitt  
  
 [Starten eines Threads](#Starting)   
 [Thread-Serverobjekte werden abgerufen](#Retrieving)   
 [Vordergrund-und Hintergrundthreads](#Foreground)   
 [Kultur und threads](#Culture)   
 [Abrufen von Informationen zu und Steuern von threads](#Properties)   
 [Zugriff auf den Quellcode für die Thread-Klasse](#Source)  
  
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Starten eines Threads  
 Starten Sie einen Thread, indem ein Delegat, der die Methode darstellt, die der Thread zum Ausführen in den Klassenkonstruktor wird angeben. Rufen Sie dann die <xref:System.Threading.Thread.Start%2A> Methode, um die Ausführung zu starten.  
  
 Die <xref:System.Threading.Thread> Konstruktoren können eine der beiden Delegattypen, je nachdem, ob Sie ein Argument an die Methode ausgeführt werden weitergeben können:  
  
-   Wenn die Methode keine Argumente verfügt, übergeben Sie eine <xref:System.Threading.ThreadStart> an den Konstruktor zu delegieren. Es hat die Signatur:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Das folgende Beispiel erstellt und startet einen Thread, der ausgeführt wird die `ExecuteInForeground` Methode. Die Methode zeigt Informationen zu einigen Threadeigenschaften, und führt eine Schleife in der für eine halbe Sekunde angehalten und zeigt die verstrichene Anzahl von Sekunden. Wenn der Thread mindestens fünf Sekunden lang ausgeführt wurde, wird die Schleife beendet, und der Thread Ausführung beendet.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Wenn die Methode ein Argument verfügt, übergeben Sie eine <xref:System.Threading.ParameterizedThreadStart> an den Konstruktor zu delegieren. Es hat die Signatur:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Die Methode ausgeführt wird, durch den Delegaten kann dann umgewandelt (in c#) oder (in Visual Basic) die Parameter in den entsprechenden Typ konvertieren.  
  
     Das folgende Beispiel ist identisch mit der vorherigen Abfrage, außer dass sie ruft die <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktor. Diese Version von den `ExecuteInForeground` Methode verfügt über einen einzelnen Parameter, der die ungefähre Anzahl von Millisekunden darstellt, die Schleife ausgeführt wird.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Es ist nicht notwendig, behalten einen Verweis auf ein <xref:System.Threading.Thread> -Objekt, sobald Sie den Thread gestartet haben. Der Thread weiterhin ausgeführt, bis die Threadprozedur abgeschlossen ist.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Thread-Serverobjekte werden abgerufen  
 Sie können die statische (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft um einen Verweis auf den gerade ausgeführten Thread aus dem Code abzurufen, die der Thread ausgeführt wird. Im folgenden Beispiel wird die <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft zum Anzeigen von Informationen zum Thread der hauptanwendung, der eine andere Vordergrundthread, einen Hintergrundthread weitergeben und ein Thread des Threadpools.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Vordergrund-und Hintergrundthreads  
 Instanzen der <xref:System.Threading.Thread> Vordergrundthreads oder Hintergrundthreads Klasse darstellen. Hintergrundthreads sind identisch mit Vordergrundthreads mit einer Ausnahme: ein Hintergrundthread behält keinen laufenden Prozess aus, wenn alle Vordergrundthreads beendet haben. Sobald alle Vordergrundthreads beendet wurden, wird die Common Language Runtime beendet alle Hintergrundthreads und heruntergefahren.  
  
 Standardmäßig werden die folgenden Threads im Vordergrund:  
  
-   Der Thread der hauptanwendung.  
  
-   Alle Threads durch Aufruf erstellt einen <xref:System.Threading.Thread> Klassenkonstruktor.  
  
 Die folgenden Threads, die standardmäßig im Hintergrund ausgeführt werden:  
  
-   Der Thread im Threadpool, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden.  Sie können die Thread-Pool und den Zeitplan Arbeit auf Threads im Threadpool konfigurieren, mit der <xref:System.Threading.ThreadPool> Klasse.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch auf Threads im Threadpool ausgeführt. Aufgabenbasierte asynchrone Vorgänge verwenden die <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> Klassen zum Implementieren der [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.  
  
 Sie können ändern, einen Thread zum Ausführen im Hintergrund durch Festlegen der <xref:System.Threading.Thread.IsBackground%2A> Eigenschaft zu einem beliebigen Zeitpunkt.  Hintergrundthreads eignen sich für jeden Vorgang, der als eine Anwendung ausgeführt wird, jedoch verhindert nicht, die Anwendung beendet wird dass sollten, wie z. B. das Überwachen von dateisystemänderungen oder eingehenden Socketverbindungen fortgesetzt werden soll.  
  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen Vordergrund-und Hintergrundthreads. Er ist wie im ersten Beispiel in der [Starten eines Threads](#Starting) Abschnitt Ausnahme, dass den Thread im Hintergrund ausgeführt werden soll, vor dem starten. Wie die Ausgabe zeigt, wird die Schleife unterbrochen, bevor er fünf Sekunden ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultur und threads  
 Jeder Thread verfügt über eine Kultur, dargestellt durch die <xref:System.Threading.Thread.CurrentCulture%2A> -Eigenschaft und eine UI-Kultur, dargestellt durch die <xref:System.Threading.Thread.CurrentUICulture%2A> Eigenschaft.  Die aktuelle Kultur kulturabhängige Vorgänge wie das Analysieren und formatieren, Zeichenfolgenvergleich und-Sortierung unterstützt, und steuert auch, das Schriftsystem und Kalender, die von einem Thread verwendet. Die aktuelle Benutzeroberflächenkultur bietet für kulturabhängige Abruf von Ressourcen in Ressourcendateien.  
  
 Wenn Sie ein neuer Thread instanziiert wird, werden seine Kultur und Benutzeroberflächenkultur definiert, durch die aktuelle Systemkultur und die Kultur der Benutzeroberfläche und nicht von der Kultur und Benutzeroberflächenkultur des Threads, die aus der neue Thread erstellt wird. Dies bedeutet beispielsweise, dass wenn die aktuelle Systemkultur Englisch (Vereinigte Staaten ist) und der primäre Thread der aktuellen Kultur Französisch (Frankreich), die Kultur eines neuen Threads durch Aufruf erstellt die <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktor vom primären Thread ist Englisch (Vereinigte Staaten) und nicht Französisch (Frankreich). Weitere Informationen finden Sie im Abschnitt "Kultur und Threads" die <xref:System.Globalization.CultureInfo> klassenthema.  
  
> [!IMPORTANT]
>  Dies gilt nicht für Threads, die asynchrone Vorgänge für apps ausgeführt werden, die auf die [!INCLUDE[net_v46](~/includes/net-v46-md.md)] und höhere Versionen, In diesem Fall werden die Kultur und Benutzeroberflächenkultur ist Teil eines asynchronen Vorgangskontext; der Thread auf dem einen asynchronen Vorgang führt standardmäßig erbt, die Kultur und Benutzeroberflächenkultur des Threads, in dem der asynchrone Vorgang gestartet wurde. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im Thema zur <xref:System.Globalization.CultureInfo>-Klasse.  
  
 Führen Sie eine der folgenden Optionen, um sicherzustellen, dass alle Threads in einer Anwendung ausführen freigeben, das dieselbe Kultur und Benutzeroberflächenkultur:  
  
-   Können Sie übergeben ein <xref:System.Globalization.CultureInfo> -Objekt, das diese Kultur entspricht der <xref:System.Threading.ParameterizedThreadStart> delegieren oder <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> Methode.  
  
-   Für apps, die unter der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höheren Versionen können Sie definieren, die Kultur und Benutzeroberflächenkultur, die für alle Threads in einer Anwendungsdomäne erstellt, durch Festlegen des Werts der zugewiesen werden soll die <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> Eigenschaften. Beachten Sie, dass dies eine pro-AppDomain-Einstellung ist.  
  
 Weitere Informationen und Beispiele finden Sie im Abschnitt "Kultur und Threads" die <xref:System.Globalization.CultureInfo> klassenthema.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Abrufen von Informationen zu und Steuern von threads  
 Sie können eine Anzahl an Eigenschaftenwerten abrufen, die Informationen über einen Thread bereitstellen. In einigen Fällen können Sie auch diese Eigenschaftswerte die Ausführung des Threads steuern festlegen. Zu diesen Threadeigenschaften zählen:  
  
-   Einen Namen. <xref:System.Threading.Thread.Name%2A>ist ein Schreibvorgang-einmal-Eigenschaft, die Sie verwenden können, um einen Thread zu identifizieren.  Der Standardwert ist `null`.  
  
-   Ein Hashcode, d. h. Sie, durch Aufrufen abrufen können der <xref:System.Threading.Thread.GetHashCode%2A> Methode. Der Hashcode kann zur eindeutigen Identifizierung von einem Thread verwendet werden. für die Lebensdauer des Threads wird dessen Hashcode nicht mit dem Wert eines anderen Threads, unabhängig von der Anwendungsdomäne Konflikte zwischen von dem Sie den Wert abrufen.  
  
-   Ein Thread-ID. Der Wert der Read-only <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaft wird von der Laufzeit zugewiesen und einen Thread in einem Prozess eindeutig identifiziert.  
  
    > [!NOTE]
    >  Eine Betriebssystem-[ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann. Insbesondere können ein komplexer Host die [CLR Hosting-API](https://msdn.microsoft.com/library/ms404385.aspx) um viele verwaltete Threads mit demselben Betriebssystemthread zu planen oder einen verwalteten Thread zwischen verschiedenen Betriebssystemthreads zu verschieben.  
  
-   Aktueller Status für den Thread. Für die Dauer des sein Vorhandensein überprüft werden soll, ein Thread ist immer in einem oder mehreren der Zustände definiert, indem Sie die <xref:System.Threading.ThreadState> Eigenschaft.  
  
-   Eine Prioritätsstufe planen, die durch festgelegt sind die <xref:System.Threading.ThreadPriority> Eigenschaft. Obwohl Sie diesen Wert zum Anfordern der Priorität des Threads festlegen können, ist es nicht garantiert, die vom Betriebssystem berücksichtigt werden.  
  
-   Die schreibgeschützte <xref:System.Threading.Thread.IsThreadPoolThread%2A> -Eigenschaft, die angibt, ob ein Thread ein Thread des Threadpools ist.  
  
-   Die <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft Weitere Informationen finden Sie unter der [Vordergrund-und Hintergrundthreads](#Foreground) Abschnitt.  
  
<a name="Source"></a>   
## <a name="accessing-the-source-code-for-the-thread-class"></a>Zugriff auf den Quellcode für die Thread-Klasse  
 Anzeigen des .NET Framework-Quellcodes für die <xref:System.Threading.Thread> Klasse, finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einfachen threading-Funktionen.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt eine Ausgabe ähnlich der folgenden:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Ein Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten an, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ausgeführt wird, während der Erstellung nicht gestartet. Wenn den Thread für die Ausführung planen möchten, rufen Sie die <xref:System.Threading.Thread.Start%2A> Methode. Um ein Datenobjekt an den Thread übergeben, verwenden die <xref:System.Threading.Thread.Start%28System.Object%29> -methodenüberladung.  
  
> [!NOTE]
>  Visual Basic-Benutzer können weglassen der <xref:System.Threading.ThreadStart> Konstruktor beim Erstellen eines Threads. Verwenden der `AddressOf` Operator, wenn die Methode übergeben, z. B. `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart> Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Syntax zum Erstellen und Verwenden einer <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen Methode und eine Instanzenmethode.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ausgeführt wird, während der Erstellung nicht gestartet. Wenn den Thread für die Ausführung planen möchten, rufen Sie die <xref:System.Threading.Thread.Start%2A> Methode.  
  
> [!NOTE]
>  Visual Basic-Benutzer können weglassen der <xref:System.Threading.ThreadStart> Konstruktor beim Erstellen eines Threads. Verwenden der `AddressOf` Operator, wenn die Methode übergeben, z. B. `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic ruft automatisch den <xref:System.Threading.ThreadStart> Konstruktor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Thread zu erstellen, der eine statische Methode ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Thread zu erstellen, der eine Instanzmethode ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="start" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  
  
 Wichtig für teilweise vertrauenswürdigen Code <c>MaxStackSize</c> wird ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht, sowie eine maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vermeiden Sie die Verwendung dieser Überladung des Konstruktors. Die Standardgröße des Stapel verwendet werden, indem die <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktorüberladung ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Arbeitsspeicherprobleme hat, ist die wahrscheinlichste Ursache, z. B. eine unbegrenzte Rekursion Programmierfehler.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], nur für vollständig vertrauenswürdige Code festlegen kann `maxStackSize` auf einen Wert, der größer als die Standardstapelgröße (1 MB). Wenn ein größerer Wert, für angegeben wird `maxStackSize` Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird `maxStackSize` wird ignoriert, und die Standardgröße des Stapel verwendet wird. Es werden keine Ausnahmen ausgelöst. Auf jeder Ebene der Vertrauenswürdigkeit können zeichencodesatz-ID `maxStackSize` auf einen Wert, der kleiner als die Standardstapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie entwickeln eine voll vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, und Sie Starten eines Threads müssen erfordert, dass eine große Stack, Sie müssen volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden. Tun Sie dies, wenn Sie den Code vollständig steuern, der auf dem Thread ausgeführt wird.  
  
 Wenn `maxStackSize` ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` ist kein Vielfaches der Seitengröße, gerundet auf das nächste größere Vielfache der Seitengröße. Bei Verwendung von .NET Framework, Version 2.0 unter Windows Vista 256KB (262.144 Bytes) ist die minimale Stapelgröße ein, und das Seitenformat beträgt 64KB (65.536 Byte).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 `maxStackSize` ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie u. u. Stapelüberlaufs deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann, auf dem selbst einen Stapelüberlauf verursachen die Überprüfung. Fügen Sie folgenden in der Anwendungskonfigurationsdatei, um Stapelüberlaufs zu deaktivieren.  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  
  
 Wichtig für teilweise vertrauenswürdigen Code <c>MaxStackSize</c> wird ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt die maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vermeiden Sie die Verwendung dieser Überladung des Konstruktors. Die Standardgröße des Stapel verwendet werden, indem die <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Konstruktorüberladung ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Arbeitsspeicherprobleme hat, ist die wahrscheinlichste Ursache, z. B. eine unbegrenzte Rekursion Programmierfehler.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], nur für vollständig vertrauenswürdige Code festlegen kann `maxStackSize` auf einen Wert, der größer als die Standardstapelgröße (1 MB). Wenn ein größerer Wert, für angegeben wird `maxStackSize` Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird `maxStackSize` wird ignoriert, und die Standardgröße des Stapel verwendet wird. Es werden keine Ausnahmen ausgelöst. Auf jeder Ebene der Vertrauenswürdigkeit können zeichencodesatz-ID `maxStackSize` auf einen Wert, der kleiner als die Standardstapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie entwickeln eine voll vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, und Sie Starten eines Threads müssen erfordert, dass eine große Stack, Sie müssen volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden. Tun Sie dies, wenn Sie den Code vollständig steuern, der auf dem Thread ausgeführt wird.  
  
 Wenn `maxStackSize` ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` ist kein Vielfaches der Seitengröße, gerundet auf das nächste größere Vielfache der Seitengröße. Bei Verwendung von .NET Framework, Version 2.0 unter Windows Vista 256KB (262.144 Bytes) ist die minimale Stapelgröße ein, und das Seitenformat beträgt 64KB (65.536 Byte).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 `maxStackSize` ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie u. u. Stapelüberlaufs deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann, auf dem selbst einen Stapelüberlauf verursachen die Überprüfung. Fügen Sie folgenden in der Anwendungskonfigurationsdatei, um Stapelüberlaufs zu deaktivieren.  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um ihn abzubrechen. `ThreadAbortException`ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst, am Ende der `catch` blockieren, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort`Bricht die Anforderung zum Abbrechen und verhindert, dass die `ThreadAbortException` aus Beenden des Threads. Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.  
  
> [!NOTE]
>  Wenn ein Thread aufruft, `Abort` auf sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme; die <xref:System.Threading.ThreadAbortException> wird sofort ausgeführt, und das Ergebnis ist eine vorhersehbare. Jedoch, wenn ein Thread ruft `Abort` in einem anderen Thread, unterbricht der Abbruch der Code ausgeführt wird. Es ist auch möglich, dass ein statischer Konstruktor abgebrochen werden konnte. In seltenen Fällen kann dadurch verhindert, dass Instanzen dieser Klasse in der Anwendungsdomäne erstellt wird. In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit der Thread während einer `finally` Block ausgeführt wird, in diesem Fall die `finally` Block wird abgebrochen.  
  
 Der Thread wird nicht unbedingt sofort oder überhaupt abgebrochen. Diese Situation kann auftreten, wenn ein Thread eine unbegrenzte Berechnung in der Fall ist die `finally` Blöcke, die im Rahmen des Abbruchvorgangs, wodurch unbegrenzt der Abbruch verzögert aufgerufen werden. Warten, bis ein Thread abgebrochen wurde, rufen Sie die <xref:System.Threading.Thread.Join%2A> Methode für den Thread nach dem Aufruf der <xref:System.Threading.Thread.Abort%2A> -Methode, aber es gibt keine Garantie der Wartevorgang wird beendet.  
  
> [!NOTE]
>  Der aufrufende Thread <xref:System.Threading.Thread.Abort%2A> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, wie eine `catch` Block `finally` Block oder eingeschränkten Ausführungsbereich. Wenn der Thread aufruft <xref:System.Threading.Thread.Abort%2A> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.  
  
 Wenn `Abort` wird aufgerufen, auf einen Thread, der nicht gestartet wurde, wird der Thread abgebrochen Wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` wird aufgerufen, auf einen Thread, der blockiert ist oder im Ruhezustand ist, wird der Thread unterbrochen und dann abgebrochen.  
  
 Wenn `Abort` aufgerufen wird, auf einen Thread, der angehalten wurde, eine <xref:System.Threading.ThreadStateException> wird ausgelöst, in dem Thread, <xref:System.Threading.Thread.Abort%2A>, und <xref:System.Threading.ThreadState.AbortRequested> hinzugefügt wird die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft des abgebrochenen Thread. Ein <xref:System.Threading.ThreadAbortException> wird nicht ausgelöst, in den angehaltenen Thread, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während der Ausführung von nicht verwalteten Codes wird eine `ThreadAbortException` nicht ausgelöst, bis der Thread zu verwaltetem Code zurückgegeben wird.  
  
 Wenn zwei Aufrufe `Abort` stammen zur gleichen Zeit ist es möglich, dass ein Aufruf zum Festlegen der Informationen über den Zustand und der andere Aufruf zum Ausführen der `Abort`. Eine Anwendung kann nicht jedoch diese Situation erkennen.  
  
 Nach dem `Abort` wird aufgerufen, in einem Thread der Zustand des Threads enthält <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf beendet wurde `Abort`, der Status des Threads wird geändert, um <xref:System.Threading.ThreadState.Stopped>. Ein Thread, der ist mit ausreichenden Berechtigungen das Ziel einer `Abort` "Abbrechen" können diesen Vorgang unter Verwendung der `ResetAbort` Methode. Ein Beispiel für die Aufrufen der `ResetAbort` -Methode finden Sie unter der `ThreadAbortException` Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Ein Objekt, das anwendungsspezifische Informationen enthält (z. B. über den Zustand), die vom abgebrochenen Thread verwendet werden können.</param>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Gleichzeitig werden Ausnahmeinformationen über das Beenden des Threads bereitgestellt. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um ihn abzubrechen. `ThreadAbortException`ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst, am Ende der `catch` blockieren, es sei denn, <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort`Bricht die Anforderung zum Abbrechen und verhindert, dass die `ThreadAbortException` aus Beenden des Threads. Nicht ausgeführte `finally` Blöcke werden ausgeführt, bevor der Thread abgebrochen wird.  
  
> [!NOTE]
>  Wenn ein Thread aufruft, `Abort` auf sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme; die <xref:System.Threading.ThreadAbortException> wird sofort ausgeführt, und das Ergebnis ist eine vorhersehbare. Jedoch, wenn ein Thread ruft `Abort` in einem anderen Thread, unterbricht der Abbruch der Code ausgeführt wird. Es besteht die Möglichkeit, dass ein statischer Konstruktor abgebrochen werden konnte. In seltenen Fällen kann dadurch verhindert, dass Instanzen dieser Klasse in der Anwendungsdomäne erstellt wird. In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit der Thread während einer `finally` Block ausgeführt wird, in diesem Fall die `finally` Block wird abgebrochen.  
  
 Der Thread wird nicht unbedingt sofort oder überhaupt abgebrochen. Diese Situation kann auftreten, wenn ein Thread eine unbegrenzte Berechnung in der Fall ist die `finally` Blöcke, die im Rahmen des Abbruchvorgangs, wodurch unbegrenzt der Abbruch verzögert aufgerufen werden. Warten, bis ein Thread abgebrochen wurde, rufen Sie die <xref:System.Threading.Thread.Join%2A> Methode für den Thread nach dem Aufruf der <xref:System.Threading.Thread.Abort%2A> -Methode, aber es gibt keine Garantie, die der Wartevorgang beendet wird.  
  
> [!NOTE]
>  Der aufrufende Thread <xref:System.Threading.Thread.Abort%2A> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, wie eine `catch` Block `finally` Block oder eingeschränkten Ausführungsbereich. Wenn der Thread aufruft <xref:System.Threading.Thread.Abort%2A> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.  
  
 Wenn `Abort` wird aufgerufen, auf einen Thread, der nicht gestartet wurde, wird der Thread abgebrochen Wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` wird aufgerufen, auf einen Thread, der blockiert ist oder im Ruhezustand ist, wird der Thread unterbrochen und dann abgebrochen.  
  
 Wenn `Abort` aufgerufen wird, auf einen Thread, der angehalten wurde, eine <xref:System.Threading.ThreadStateException> wird ausgelöst, in dem Thread, <xref:System.Threading.Thread.Abort%2A>, und <xref:System.Threading.ThreadState.AbortRequested> hinzugefügt wird die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft des abgebrochenen Thread. Ein <xref:System.Threading.ThreadAbortException> wird nicht ausgelöst, in den angehaltenen Thread, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während der Ausführung von nicht verwalteten Codes wird eine `ThreadAbortException` nicht ausgelöst, bis der Thread zu verwaltetem Code zurückgegeben wird.  
  
 Wenn zwei Aufrufe `Abort` stammen zur gleichen Zeit ist es möglich, dass ein Aufruf zum Festlegen der Informationen über den Zustand und der andere Aufruf zum Ausführen der `Abort`. Eine Anwendung kann nicht jedoch diese Situation erkennen.  
  
 Nach dem `Abort` wird aufgerufen, in einem Thread der Zustand des Threads enthält <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf beendet wurde `Abort`, der Status des Threads wird geändert, um <xref:System.Threading.ThreadState.Stopped>. Ein Thread, der ist mit ausreichenden Berechtigungen das Ziel einer `Abort` "Abbrechen" können diesen Vorgang unter Verwendung der `ResetAbort` Methode. Ein Beispiel für die Aufrufen der `ResetAbort` -Methode finden Sie unter der `ThreadAbortException` Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Informationen an einen Thread übergeben, die abgebrochen wird.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserviert einen unbenannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Der Slot wird für alle Threads zugeordnet.  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu reservierenden Datenslots.</param>
        <summary>Reserviert einen benannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
 Es ist nicht notwendig, verwenden Sie die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode, um einen benannten Datenslot reserviert werden, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A> -Methode den Slot zuweist, wenn er noch nicht zugeordnet wurde.  
  
> [!NOTE]
>  Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode wird verwendet, es sollte im Hauptthread bei Programmstart aufgerufen werden, da es eine Ausnahme auslöst, wenn ein Slot mit dem angegebenen Namen bereits zugeordnet wurde. Es gibt keine Möglichkeit zum Überprüfen, ob ein Slot bereits zugeordnet wurde.  
  
 Mit dieser Methode reservierten Slots müssen mit freigegeben werden <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
> [!NOTE]
>  Der Beispielcode verwendet nicht die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> -Methode, da der <xref:System.Threading.Thread.GetNamedDataSlot%2A> -Methode den Slot zuweist, wenn er noch nicht zugeordnet wurde. Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode verwendet wird, sollte im Hauptthread beim Programmstart aufgerufen werden.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es ist bereits ein benannter Datenslot mit dem angegebenen Namen vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Apartmentzustand dieses Threads ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte. Der Anfangswert ist <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft ist veraltet.**  Die nicht veraltete alternativen lauten die <xref:System.Threading.Thread.GetApartmentState%2A> Methode, um den Apartmentzustand abzurufen und die <xref:System.Threading.Thread.SetApartmentState%2A> Methode, um der Apartmentzustand festgelegt.  
  
 In der .NET Framework-Versionen 1.0 und 1.1 kann die `ApartmentState` Eigenschaft kennzeichnet einen Thread, um anzugeben, dass er in einem Singlethread-Apartment oder einem Multithread-Apartment ausgeführt wird. Diese Eigenschaft kann festgelegt werden, wenn der Thread die `Unstarted` oder `Running` Threadzustand befindet; allerdings es kann nur einmal festgelegt werden für einen Thread. Wenn die Eigenschaft nicht festgelegt wurde, gibt es `Unknown`.  
  
 Versuch, verwenden die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft, um den Apartmentzustand eines Threads festzulegen, dessen Apartmentzustand bereits festgelegt wurde wurde, wird ignoriert. Allerdings die <xref:System.Threading.Thread.SetApartmentState%2A> -Methode löst eine <xref:System.InvalidOperationException> in diesem Fall.  
  
> [!IMPORTANT]
>  In .NET Framework, Version 2.0, werden neue Threads als initialisiert <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden. Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState?displayProperty=nameWithType> standardmäßig. Thread der hauptanwendung können nicht mehr festgelegt werden, um <xref:System.Threading.ApartmentState?displayProperty=nameWithType> durch Festlegen der <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Eigenschaft auf die erste Zeile des Codes. Verwenden der <xref:System.STAThreadAttribute> stattdessen.  
  
 In .NET Framework, Version 2.0, können Sie angeben, die COM-Threadingmodell für eine C++-Anwendung mithilfe der [/CLRTHREADATTRIBUTE (festlegen CLR-Thread-Attribut)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) (Linkeroption).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Apartmentzustand eines Threads fest.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wird versucht, diese Eigenschaft in einen Zustand zu versetzen, der kein gültiger Apartmentzustand ist, d. h. in einen anderen Zustand als Singlethread-Apartment (<see langword="STA" />) oder Multithread-Apartment (<see langword="MTA" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme andere Aufgaben in der Anwendungsdomäne gefährden könnten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Bereiche des Codes eingerichtet. Ein kritischen Bereich ist in dem die Auswirkungen eines Threadabbruchs oder einer unbehandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden. Im Gegensatz dazu, wirkt sich auf einen Abbruch oder ein Fehler in einem unkritische Codebereich nur auf den Task, in dem der Fehler auftritt.  
  
 Betrachten Sie beispielsweise eine Aufgabe, die versucht, die beim Sperren Arbeitsspeicher belegt werden. Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <xref:System.AppDomain>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Tasks blockiert.  
  
 Tritt ein Fehler in einer kritischen Bereichs, kann der Host die gesamte entladen <xref:System.AppDomain> statt nehmen das Risiko, dass das Fortsetzen der Ausführung in einem potenziell instabilen Zustand. Aufrufen, um dem Host darüber zu informieren, dass Code in einen kritischen Bereich eintritt, <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Rufen Sie <xref:System.Threading.Thread.EndCriticalRegion%2A> Ausführung in einem unkritische Codebereich zurück.  
  
 Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code im Begriff ist, Anweisungen auszuführen, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threadverwaltung. Ein Host, der eine eigene Threadverwaltung bereitstellt, kann eine derzeit ausgeführte Aufgabe jederzeit von einem physischen Betriebssystemthreads in eine andere verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Jedoch einige Aufgaben Threadaffinität - d. h., sie von der Identität des physischen Betriebssystemthreads abhängig sind. Diese Aufgaben müssen den Host informieren, wenn sie Code ausführen, der nicht umgeschaltet werden soll.  
  
 Sie müssen z. B., wenn Ihre Anwendung ein System-API aufruft, erwerben Sie ein älteres Betriebssystem sperren, die Threadaffinität, z. B. eine Win32-CRITICAL_SECTION Aufrufen <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Abrufen der Sperre und <xref:System.Threading.Thread.EndThreadAffinity%2A> nach der Freigabe der Sperre.  
  
 Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Kontext ab, in dem der Thread ausgeführt wird.</summary>
        <value>Ein <see cref="T:System.Runtime.Remoting.Contexts.Context" /> der den aktuellen Kontext des Threads darstellt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die Kultur für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Globalization.CultureInfo> -Objekt, das von dieser Eigenschaft zusammen mit der ihr zugeordneten Objekte zurückgegeben wird, bestimmen das Standardformat für Datumsangaben, Uhrzeiten, Zahlen, Currency-Werte, die Sortierreihenfolge des Texts, Groß-/ Kleinschreibungskonventionen und Zeichenfolgenvergleiche. Finden Sie unter der <xref:System.Globalization.CultureInfo> Klasse, um weitere Informationen zu Kulturnamen und Bezeichnern, die Unterschiede zwischen invariante, neutrale und spezifische Kulturen und die Möglichkeit kulturinformationen wirkt sich auf Threads und Anwendungsdomänen. Finden Sie unter der <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft, um zu erfahren, wie die Standardkultur des Threads bestimmt wird, und wie Benutzer die kulturinformationen für ihre Computer festlegen.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], Sie können festlegen, die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft, um eine neutrale Kultur. Grund hierfür ist das Verhalten von der <xref:System.Globalization.CultureInfo> Klasse hat sich geändert: Wenn es eine neutrale Kultur, die Eigenschaftswerte darstellt (insbesondere der <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, und <xref:System.Globalization.CultureInfo.TextInfo%2A> Eigenschaften) jetzt wider, die bestimmte Kultur, die die neutrale Kultur zugeordnet ist. In früheren Versionen von .NET Framework die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft ausgelöst hat eine <xref:System.NotSupportedException> -Ausnahme aus, wenn eine neutrale Kultur zugewiesen wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die threading-Anweisung, die ermöglicht der Benutzeroberfläche von Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt ist. Es ist kein zusätzlicher Code erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Eigenschaft festlegen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Prinzipal des Threads (für rollenbasierte Sicherheit) ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IPrincipal" />-Wert, der den Sicherheitskontext darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen und Abrufen des Prinzipals eines Threads.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Festlegen des Prinzipals.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bearbeiten Sie das principal-Objekt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den derzeit ausgeführten Thread ab.</summary>
        <value>Ein <see cref="T:System.Threading.Thread" />, der den derzeit ausgeführten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Aufgabe, die wiederum 20 untergeordneten Aufgaben erstellt. Ruft die Anwendung selbst, als auch jede Aufgabe, die `ShowThreadInformation` Methode, die verwendet die <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft, um Informationen zum Thread anzuzeigen, auf dem er ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Jede untergeordnete Aufgabe 1 Million Zufallszahlen zwischen 1 und 1 Million generiert und gibt zurück, deren Mittelwert. Die Aufrufe der übergeordneten Aufgabe der <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass die untergeordneten Aufgaben abgeschlossen haben, ehe den Mittelwert zurückgegeben, die für jede Aufgabe und das Berechnen der Mittelwert der bedeutet.  
  
 Beachten Sie, dass während die Anwendung auf einen Vordergrundthread ausgeführt wird, jede Aufgabe in einem Threadpoolthread ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Kultur ab, mit deren Hilfe der Ressourcen-Manager zur Laufzeit kulturabhängige Ressourcen sucht, oder legt diese fest.</summary>
        <value>Ein Objekt, das die aktuelle Kultur darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Benutzeroberflächenkultur gibt die Ressourcen, die eine Anwendung muss Benutzer ein- und Ausgaben unterstützen, die und in der Standardeinstellung ist identisch mit dem Betriebssystem-Kultur, an. Finden Sie unter der <xref:System.Globalization.CultureInfo> Klasse, um weitere Informationen zu Kulturnamen und Bezeichnern, die Unterschiede zwischen invariante, neutrale und spezifische Kulturen und die Möglichkeit kulturinformationen wirkt sich auf Threads und Anwendungsdomänen. Finden Sie unter der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft, um zu erfahren, wie die Standard-UI-Kultur des Threads bestimmt wird.  
  
 Die <xref:System.Globalization.CultureInfo> von dieser Eigenschaft zurückgegebene kann eine neutrale Kultur. Neutrale Kulturen sollte nicht verwendet werden, z. B. Formatierungsmethoden <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, und <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Methode, um eine bestimmte Kultur abrufen oder verwenden Sie die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft.  
  
> [!NOTE]
>  Die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> -Methode löst <xref:System.ArgumentException> für die neutralen Kulturen "Zh-Hant" ("Zh-CHT") und "Zh-Hans" ("Zh-CHS").  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Sprache des UI-Kultur des aktuellen Threads Französisch. Wenn sie nicht der Fall ist, wird der UI-Kultur des aktuellen Threads auf Englisch (Vereinigte Staaten) festgelegt.  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Das folgende Codebeispiel zeigt die threading-Anweisung, die ermöglicht der Benutzeroberfläche von Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt ist. Es ist kein zusätzlicher Code erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft ist auf einen Kulturnamen festgelegt, der nicht zum Suchen einer Ressourcendatei verwendet werden kann. Ressourcendateinamen dürfen nur Buchstaben, Zahlen, Bindestriche oder Unterstriche enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die automatische Bereinigung von Runtime Callable Wrappern (RCW) für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig bereinigt die common Language Runtime (CLR) Runtime callable Wrappern automatisch. Die CLR Pumps Nachrichten während der Bereinigung aus, die für einige Anwendungen Reentranz-Probleme verursachen können, die die folgenden ungewöhnlichen Kriterien erfüllen:  
  
-   Die Anwendung führt einen eigenen meldungsweiterleitung.  
  
-   Die Anwendung muss genau, wann meldungsweiterleitung tritt auf, zu steuern.  
  
 Solche Anwendungen können die <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> Methode, um zu verhindern, dass die CLR auf diese Weise Automatische Freigabe von Runtime callable Wrapper.  
  
 Beim Aufrufen dieser Methode in einem Thread darf nicht die automatische Bereinigung aktiviert werden, damit diesem Thread sein. Wenn Ihre Anwendung zum Bereinigen von Runtime callable Wrapper bereit ist, verwenden die <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> Methode, um die Laufzeitkomponente anzuweisen, bereinigen alle Runtime callable Wrapper im aktuellen Kontext. Meldungsweiterleitung tritt auf, während die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme auf die aktuelle Aufgabe beschränkt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritischen Bereiche des Codes eingerichtet. Ein kritischen Bereich ist in dem die Auswirkungen eines Threadabbruchs oder einer unbehandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden. Im Gegensatz dazu, wirkt sich auf einen Abbruch oder ein Fehler in einem unkritische Codebereich nur auf den Task, in dem der Fehler auftritt.  
  
 Betrachten Sie beispielsweise eine Aufgabe, die versucht, die beim Sperren Arbeitsspeicher belegt werden. Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <xref:System.AppDomain>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Tasks blockiert.  
  
 Tritt ein Fehler in einer kritischen Bereichs, kann der Host die gesamte entladen <xref:System.AppDomain> statt nehmen das Risiko, dass das Fortsetzen der Ausführung in einem potenziell instabilen Zustand. Aufrufen, um dem Host darüber zu informieren, dass Code in einen kritischen Bereich eintritt, <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Rufen Sie <xref:System.Threading.Thread.EndCriticalRegion%2A> Ausführung in einem unkritische Codebereich zurück.  
  
 Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code die Ausführung von Anweisungen beendet hat, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threadverwaltung. Ein Host, der eine eigene Threadverwaltung bereitstellt, kann eine derzeit ausgeführte Aufgabe jederzeit von einem physischen Betriebssystemthreads in eine andere verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Jedoch einige Aufgaben Threadaffinität - d. h., sie von der Identität des physischen Betriebssystemthreads abhängig sind. Diese Aufgaben müssen den Host informieren, wenn sie Code ausführen, der nicht umgeschaltet werden soll.  
  
 Sie müssen z. B., wenn Ihre Anwendung ein System-API aufruft, erwerben Sie ein älteres Betriebssystem sperren, die Threadaffinität, z. B. eine Win32-CRITICAL_SECTION Aufrufen <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Abrufen der Sperre und <xref:System.Threading.Thread.EndThreadAffinity%2A> nach der Freigabe der Sperre.  
  
 Verwenden diese Methode im Code, die unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.ExecutionContext" />-Objekt ab, das Informationen zu den verschiedenen Kontexten des aktuellen Threads enthält.</summary>
        <value>Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das Kontextinformationen für den aktuellen Thread konsolidiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.ExecutionContext> Klasse stellt einen einzelnen Container für alle Informationen über einen logischen Thread der Ausführung. Dies schließt Sicherheitskontext, Aufrufkontext, Synchronisierungskontext, Lokalisierungskontext und bereits verwendeten Transaktionskontext.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Threading.Thread" />-Objekt verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft <xref:System.Threading.Thread.Finalize%2A> Wenn das aktuelle Objekt wird finalisiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des freizugebenden Datenslots.</param>
        <summary>Entfernt die Zuordnung zwischen einem Namen und einem Slot für alle Threads in dem Prozess. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Nach dem Aufrufen `FreeNamedDataSlot`, eines anderen Threads, die Aufrufe <xref:System.Threading.Thread.GetNamedDataSlot%2A> mit dem gleichen Namen wird einen neuen Slot verknüpft sind, mit dem Namen zuweisen. Nachfolgende Aufrufe `GetNamedDataSlot` durch einen beliebigen Thread des neuen Slots zurück. Jedoch einen beliebigen Thread, die immer noch eine <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> durch einen früheren Aufruf zurückgegebene `GetNamedDataSlot` können weiterhin den alten Slot verwenden.  
  
 Ein Slot, die mit einem Namen zugeordnet wurde freigegeben ist nur, wenn alle `LocalDataStoreSlot` , die vor dem Aufruf von abgerufen wurde `FreeNamedDataSlot` freigegeben und Garbage Collection durchgeführt wurde.  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Threading.ApartmentState" />-Wert zurück, der den Apartmentzustand angibt.</summary>
        <returns>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte, der den Apartmentzustand des verwalteten Threads angibt. Die Standardeinstellung ist <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zusammen mit der <xref:System.Threading.Thread.SetApartmentState%2A> Methode und die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Bevor der Thread gestartet wird, <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern <xref:System.Threading.ApartmentState?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt ist. Mit der gleiche Vorgang versucht wurde, hatte <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wird, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , weil der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Threading.CompressedStack" />-Objekt zurück, mit dem der Stapel für den aktuellen Thread erfasst werden kann.</summary>
        <returns>Keine</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, aus dem der Wert abgerufen werden soll.</param>
        <summary>Ruft in der aktuellen Domäne des aktuellen Threads den Wert aus dem angegebenen Slot für den aktuellen Thread ab. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der abgerufene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A>ist eine `Shared` Methode, die immer auf den gerade ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen. Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen beim Aufrufen von `Shared` Methoden: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Das folgende Beispiel veranschaulicht einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Domäne zurück, in der der aktuelle Thread ausgeführt wird.</summary>
        <returns>Eine <see cref="T:System.AppDomain" />, die die aktuelle Anwendungsdomäne des ausgeführten Threads darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der `AppDomain` in der der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen eindeutigen Bezeichner der Anwendungsdomäne zurück.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Anwendungsdomäne eindeutig bezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der `AppDomain` in der der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für den aktuellen Thread zurück.</summary>
        <returns>Ein ganzzahliger Hashcodewert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hashcode ist nicht unbedingt eindeutig sein. Verwenden der <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaft, wenn Sie einen eindeutigen Bezeichner für einen verwalteten Thread benötigen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des lokalen Datenslots.</param>
        <summary>Sucht einen benannten Datenslot. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Ein für diesen Thread reservierter <see cref="T:System.LocalDataStoreSlot" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen von Daten Wert im Slot des Slots für die Wiederverwendung freizugeben, nach Ablauf des Threads. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
 Wenn der benannte Datenslot nicht vorhanden ist, wird ein neuer Slot zugeordnet. Benannte Datenslots sind öffentlich und können von einem Benutzer bearbeitet werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht einen Thread, der sich im <see langword="WaitSleepJoin" />-Threadzustand befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Thread in einer warten, Standby- oder Verknüpfungszustand derzeit nicht gesperrt ist, ist unterbrochen, bei Beginn des nächsten blockiert.  
  
 <xref:System.Threading.ThreadInterruptedException>in den unterbrochenen THEAD, jedoch erst, nachdem der Thread blockiert wird ausgelöst werden. Wenn der Thread nie blockiert wird, die Ausnahme wird nie ausgelöst und daher kann der Thread ohne jegliche Unterbrechung wird abgeschlossen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten der einen laufenden Thread auf, wenn er unterbrochen und anschließend gesperrt wird.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die entsprechende <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Ausführungsstatus des aktuellen Threads angibt.</summary>
        <value>
          <see langword="true" />, wenn dieser Thread gestartet und ordnungsgemäß beendet bzw. abgebrochen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei einem Thread um einen Hintergrundthread handelt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn dieser Thread ein Hintergrundthread ist oder zu einem solchen wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ist ein Hintergrundthread oder ein Vordergrundthread. Hintergrundthreads sind mit Vordergrundthreads identisch, außer dass Hintergrundthreads verhindert nicht, einen Prozess beendet ist. Sobald alle zu einem Prozess gehörenden Vordergrundthreads beendet wurden, beendet die common Language Runtime den Prozess an. Alle verbleibenden Hintergrundthreads werden beendet und nicht abgeschlossen.  
  
 Wird standardmäßig die folgenden Threads, die im Vordergrund ausgeführt (d. h. deren <xref:System.Threading.Thread.IsBackground%2A> -Eigenschaft gibt `false`):  
  
-   Der primäre Thread (oder den Hauptthread der Anwendung).  
  
-   Alle Threads durch Aufruf erstellt einen <xref:System.Threading.Thread> Klassenkonstruktor.  
  
 Standardmäßig werden die folgenden Threads im Hintergrund ausgeführt (d. h. ihre <xref:System.Threading.Thread.IsBackground%2A> -Eigenschaft gibt `true`):  
  
-   Der Thread im Threadpool, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden. Sie können die Thread-Pool und den Zeitplan Arbeit auf Threads im Threadpool konfigurieren, mit der <xref:System.Threading.ThreadPool> Klasse.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch auf Threads im Threadpool ausgeführt.  
  
-   Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Unterschiede zwischen des Verhaltens von Vordergrund-und Hintergrundthreads. Erstellt einen Vordergrundthread und einen Hintergrundthread weitergeben. Der Vordergrundthread erhält den Prozess ausgeführt wird, bis Abschluss seine `for` Schleife und beendet. Jedoch, wie die Ausgabe des Beispiels zeigt, da der Vordergrundthread Ausführung abgeschlossen ist, wird der Prozess beendet, bevor der Hintergrundthread Ausführung abgeschlossen wurde.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread ist deaktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Thread zu dem verwalteten Threadpool gehört.</summary>
        <value>
          <see langword="true" />, wenn der Thread zu dem verwalteten Threadpool gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [die verwalteter Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zu bestimmen, ob ein Thread aus dem Threadpool ist.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird, während das Standard-COM- und das <see langword="SendMessage" />-Pumping fortgesetzt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A>ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis der Thread, dessen <xref:System.Threading.Thread.Join%2A> Methode wird aufgerufen, abgeschlossen wurde. Verwenden Sie diese Methode, um sicherzustellen, dass ein Thread beendet wurde. Der Aufrufer wird unendlich lang blockiert, wenn der Thread nicht beendet wird. Im folgenden Beispiel die `Thread1` thread Aufrufen der <xref:System.Threading.Thread.Join> Methode `Thread2`, wodurch `Thread1` zu blockieren, bis `Thread2` wurde abgeschlossen.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, gibt die Methode sofort zurück.  
  
> [!WARNING]
>  Sie sollten niemals aufrufen, die <xref:System.Threading.Thread.Join%2A> Methode der <xref:System.Threading.Thread> Objekt, das den aktuellen Thread aus dem aktuellen Thread darstellt. Dies bewirkt, dass Ihre app nicht mehr reagiert, da der aktuelle Thread auf sich selbst unbegrenzt wartet,  
  
 Diese Methode ändert den Zustand des aufrufenden Threads enthalten <xref:System.Threading.ThreadState?displayProperty=nameWithType>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in dem <xref:System.Threading.ThreadState?displayProperty=nameWithType> Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread wird beim Warten unterbrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, die auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns>
          <see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="millisecondsTimeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29>ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall abgelaufen. Im folgenden Beispiel die `Thread1` thread Aufrufen der <xref:System.Threading.Thread.Join> Methode `Thread2`, wodurch `Thread1` entweder bis zum Blockieren `Thread2` abgeschlossen wurde oder 2 Sekunden verstrichen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> wird angegeben, für die `millisecondsTimeout` Parameter, diese Methode verhält sich genauso wie die <xref:System.Threading.Thread.Join> methodenüberladung, mit Ausnahme der Rückgabewert.  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, gibt die Methode sofort zurück.  
  
 Diese Methode ändert den Zustand des aufrufenden Threads enthalten <xref:System.Threading.ThreadState?displayProperty=nameWithType>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in dem <xref:System.Threading.ThreadState?displayProperty=nameWithType> Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />-Wert, der auf den Zeitraum festgelegt ist, während dessen auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns>
          <see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="timeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29>ist eine Synchronisierungsmethode, die den aufrufenden Thread (d. h. der Thread, der die Methode aufruft) blockiert, bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall abgelaufen. Im folgenden Beispiel die `Thread1` thread Aufrufen der <xref:System.Threading.Thread.Join> Methode `Thread2`, wodurch `Thread1` entweder bis zum Blockieren `Thread2` abgeschlossen wurde oder 2 Sekunden verstrichen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für angegeben `timeout`, diese Methode verhält sich genauso wie die <xref:System.Threading.Thread.Join> methodenüberladung, mit Ausnahme der Rückgabewert.  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, gibt die Methode sofort zurück.  
  
 Diese Methode ändert den Zustand des aktuellen Threads enthalten <xref:System.Threading.ThreadState.WaitSleepJoin>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in dem <xref:System.Threading.ThreadState?displayProperty=nameWithType> Zustand.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine `TimeSpan` Wert mit der `Join` Methode.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eines Threads <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaftswert dient zur eindeutigen Identifizierung von diesem Thread in einem Prozess.  
  
 Der Wert, der die <xref:System.Threading.Thread.ManagedThreadId%2A> variiert Eigenschaft nicht im Laufe der Zeit, auch wenn nicht verwalteter Code, der die common Language Runtime hostet, den Thread als Fiber implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> erfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A>ist nur auf Systemen mit mehreren Prozessoren mit schwachen Sortierung (z. B. ein System mit mehreren Prozessoren der Intel Itanium) Arbeitsspeicher erforderlich.  
  
 Für die Mehrzahl der Fälle, die C#- `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung oder der <xref:System.Threading.Monitor> Klasse bereitstellen einfachere Möglichkeiten zur Synchronisierung von Daten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Threads ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit dem Namen des Threads, oder <see langword="null" />, wenn kein Name festgelegt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für Write-sobald. Da der Standardwert eines Threads <xref:System.Threading.Thread.Name%2A> Eigenschaft `null`, können Sie bestimmen, ob ein Name bereits explizit an den Thread zugewiesen wurde durch einen Vergleich mit `null`.  
  
 Die zugewiesene Zeichenfolge die <xref:System.Threading.Thread.Name%2A> -Eigenschaft kann beliebige Unicode-Zeichen enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie einen Thread zu benennen.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein SET-Vorgang wurde angefordert, aber die <see langword="Name" />-Eigenschaft wurde bereits festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Planungspriorität eines Threads angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadPriority" />-Werte. Der Standardwert ist <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread kann eines der folgenden Priorität zugewiesen werden <xref:System.Threading.ThreadPriority> Werte:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Betriebssysteme sind nicht erforderlich, die Priorität eines Threads beachten müssen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Ergebnis einer Änderung der Priorität eines Threads. Drei Threads erstellt, die Priorität eines Threads wird festgelegt, um <xref:System.Threading.ThreadPriority?displayProperty=nameWithType>, und die Priorität eines zweiten wird festgelegt, um <xref:System.Threading.ThreadPriority?displayProperty=nameWithType>. Jeder Thread inkrementiert den Wert einer Variablen in einem `while` Schleife und Testläufe für einen festgelegten Zeitraum.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread hat einen Endzustand erreicht, z. B. <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für ein Set-Vorgang kein gültiger ist <see cref="T:System.Threading.ThreadPriority" /> Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht ein <see cref="M:System.Threading.Thread.Abort(System.Object)" /> ab, das für den aktuellen Thread angefordert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur von Code mit den entsprechenden Berechtigungen aufgerufen werden.  
  
 Wenn ein Aufruf ausgelöst wird, um `Abort` um einen Thread zu beenden, löst das System eine <xref:System.Threading.ThreadAbortException>. `ThreadAbortException`ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, aber am Ende des Catch-Blocks erneut ausgelöst wird, wenn `ResetAbort` aufgerufen wird. `ResetAbort`Bricht die Anforderung zum Abbrechen und verhindert, dass die `ThreadAbortException` aus Beenden des Threads.  
  
 Finden Sie unter <xref:System.Threading.ThreadAbortException> ein Beispiel für die Aufrufen der `ResetAbort` Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" />wurde für den aktuellen Thread nicht aufgerufen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Sicherheitsberechtigungen für den aktuellen Thread.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die Ausführung eines angehaltenen Threads wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Verwenden Sie nicht die <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> Methoden zum Synchronisieren der Aktivitäten von Threads. Sie haben keine Möglichkeit, zu wissen, welcher Code ein Thread ausgeführt wird, wenn Sie ihn anhalten. Wenn Sie einen Thread anhalten, während sie Sperren während der Auswertung von Sicherheitsberechtigungen enthält, andere threads in der <xref:System.AppDomain> blockiert werden. Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <xref:System.AppDomain> , die versuchen, verwenden Sie, dass die Klasse werden blockiert. Deadlocks können leicht auftreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet, ist deaktiviert oder befindet sich nicht im angehaltenen Zustand.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die entsprechende <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als initialisiert <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden. Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState?displayProperty=nameWithType> standardmäßig. Die einzige Möglichkeit zum Festlegen des Status Apartment des Threads hauptanwendung, <xref:System.Threading.ApartmentState?displayProperty=nameWithType> angewendet wird die <xref:System.STAThreadAttribute> -Attribut auf die Einstiegspunktmethode.  
  
 Die <xref:System.Threading.Thread.SetApartmentState%2A> -Methode, zusammen mit den <xref:System.Threading.Thread.GetApartmentState%2A> Methode und die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Bevor der Thread gestartet wird, <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern <xref:System.Threading.ApartmentState?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt ist. Mit der gleiche Vorgang versucht wurde, hatte <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wird, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , weil der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.InvalidOperationException">Der Apartmentzustand wurde bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">Das <see cref="T:System.Threading.CompressedStack" />-Objekt, das für den aktuellen Thread übernommen werden soll.</param>
        <summary>Übernimmt einen erfassten <see cref="T:System.Threading.CompressedStack" /> für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, in dem der Wert festgelegt werden soll.</param>
        <param name="data">Der festzulegende Wert.</param>
        <summary>Legt die Daten im angegebenen Slot auf den derzeit ausgeführten Thread und für die aktuelle Domäne des betreffenden Threads fest. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework stellt zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder eine viel bessere Leistung erzielt als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [lokaler Threadspeicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokalen Speichermechanismus threadspezifische Daten zu speichern. Die common Language Runtime belegt eine Multi-Slot Datenarray-Speicher für die einzelnen Prozesse während der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und der Slot für die Wiederverwendung freigeben, nachdem die Threadprozedur beendet und die <xref:System.Threading.Thread> Objekt von der Garbagecollection zurückgefordert wurde. Datenslots sind pro Thread eindeutig. Keine anderen Threads (auch nicht in einem untergeordneten Thread), kann diese Daten abrufen.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A>ist eine `Shared` Methode, die immer auf den gerade ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen. Um Verwirrung zu vermeiden, verwenden Sie den Klassennamen beim Aufrufen von `Shared` Methoden: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im erste Beispiel wird gezeigt, wie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut, um die Thread-spezifische Informationen zu halten. Im zweite Beispiel wird gezeigt, wie auf einen Datenslot zu verwenden, um die Ausführung wird.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit <xref:System.ThreadStaticAttribute> , Thread-spezifische Informationen aufnimmt. Diese Technik bietet eine bessere Leistung als das Verfahren, das im zweiten Beispiel dargestellt ist.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen benannten Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die der Thread angehalten wird. Wenn der Wert der <c>MillisecondsTimeout</c> -Argument 0 (null) ist, gibt der Thread den Rest der Zeit an einen beliebigen Thread mit gleicher Priorität, die für die Ausführung bereit ist Zeitanteils. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread für die angegebene Anzahl von Millisekunden an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird nicht vom Betriebssystem für den angegebenen Zeitraum für die Ausführung geplant. Diese Methode ändert den Zustand des Threads enthalten <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Sie können angeben, <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für die `millisecondsTimeout` Parameter auf unbestimmte Zeit Anhalten des Threads vor. Allerdings wird empfohlen, dass Sie andere verwenden <xref:System.Threading?displayProperty=nameWithType> Klassen wie <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, oder <xref:System.Threading.Semaphore> stattdessen für Threads synchronisieren oder Ressourcen zu verwalten.  
  
 Das System Zeiteinheiten in einer bestimmten Rate wird aufgerufen, die Auflösung der Uhr. Die tatsächliche timeoutsekunden möglicherweise nicht genau das festgelegte Timeout, da das festgelegte Timeout mit Teilstrichen zur berichtsausführung die Verarbeitung angepasst wird. Weitere Informationen zur Auflösung der Uhr und die Wartezeit finden Sie unter der [Standbymodus Funktion](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) Thema. Diese Methode ruft die [Standbymodus Funktion](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) aus der Windows-Dateisystem-APIs.  
  
 Diese Methode führt keine standard COM- und das SendMessage-Pumping fortgesetzt werden.  
  
> [!NOTE]
>  Wenn Sie in einem Thread im Ruhezustand verbleiben, die aufweist, müssen <xref:System.STAThreadAttribute>, aber Sie verwenden möchten, führen Sie standard COM- und das SendMessage-Pumping fortgesetzt werden, sollten eine der Überladungen der die <xref:System.Threading.Thread.Join%2A> Methode, die ein Timeoutintervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%2A> Methode, um den Hauptthread der Anwendung blockiert.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Timeoutwert ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Der Zeitraum, während dessen der Thread angehalten wird. Wenn der Wert der <c>MillisecondsTimeout</c> Argument ist <see cref="F:System.TimeSpan.Zero" />, gibt der Thread den Rest der Zeit an einen beliebigen Thread mit gleicher Priorität, die für die Ausführung bereit ist Zeitanteils. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread während des angegebenen Zeitraums an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird nicht vom Betriebssystem für den angegebenen Zeitraum für die Ausführung geplant. Diese Methode ändert den Zustand des Threads enthalten <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Sie können angeben, <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> für die `timeout` Parameter auf unbestimmte Zeit Anhalten des Threads vor. Allerdings wird empfohlen, dass Sie andere verwenden <xref:System.Threading?displayProperty=nameWithType> Klassen wie <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, oder <xref:System.Threading.Semaphore> stattdessen für Threads synchronisieren oder Ressourcen zu verwalten.  
  
 Diese Überladung der <xref:System.Threading.Thread.Sleep%2A> verwendet die Gesamtanzahl von ganzen Millisekunden in `timeout`. Bruchteile von Millisekunden werden verworfen.  
  
 Diese Methode führt keine standard COM- und das SendMessage-Pumping fortgesetzt werden.  
  
> [!NOTE]
>  Wenn Sie in einem Thread im Ruhezustand verbleiben, die aufweist, müssen <xref:System.STAThreadAttribute>, aber Sie verwenden möchten, führen Sie standard COM- und das SendMessage-Pumping fortgesetzt werden, sollten eine der Überladungen der die <xref:System.Threading.Thread.Join%2A> Methode, die ein Timeoutintervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> methodenüberladung Hauptthread der Anwendung zwei Sekunden jedes Mal fünf Mal blockieren.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Zeitraum definiert, den ein Thread warten soll.</param>
        <summary>Veranlasst, dass ein Thread so oft wartet, wie vom <paramref name="iterations" />-Parameter definiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.SpinWait%2A> Methode eignet sich zum Implementieren von Sperren. Klassen in .NET Framework, z. B. <xref:System.Threading.Monitor> und <xref:System.Threading.ReaderWriterLock>, verwenden Sie diese Methode intern. <xref:System.Threading.Thread.SpinWait%2A>setzt im Wesentlichen den Prozessor in eine sehr enge Schleife mit der Schleifenanzahl gemäß der `iterations` Parameter. Die Dauer des Wartevorgangs hängt daher von der Geschwindigkeit des Prozessors.  
  
 Vergleichen Sie dies mit der <xref:System.Threading.Thread.Sleep%2A> Methode. Ein Thread, der Aufrufe <xref:System.Threading.Thread.Sleep%2A> ergibt den Rest des aktuellen Zeitanteils, selbst wenn das angegebene Intervall 0 (null) ist. Angeben eines Intervalls ungleich NULL für <xref:System.Threading.Thread.Sleep%2A> entfernt den Thread aus der Threadplanung, bis das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Threading.Thread.SpinWait%2A>ist nicht für gewöhnliche Anwendungen in der Regel sinnvoll. In den meisten Fällen sollten Sie von .NET Framework bereitgestellten Synchronisierungsklassen verwenden. Rufen Sie z. B. <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> oder eine Anweisung, die umschließt <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in c# oder `SyncLock` in Visual Basic).  
  
> [!CAUTION]
>  Stellen Sie in den seltenen Fällen, in denen ist es vorteilhaft sein, einen Kontextwechsel, z. B. Wenn Sie wissen, dass eine Zustandsänderung bevorsteht, vermeiden Sie, einen Aufruf der <xref:System.Threading.Thread.SpinWait%2A> -Methode in der Schleife. Der Code <xref:System.Threading.Thread.SpinWait%2A> führt wurde entwickelt, um Probleme zu vermeiden, die auf Computern mit mehreren Prozessoren auftreten können. Auf Computern mit mehreren Intel-Prozessoren mit Hyperthreading-Technologie, beispielsweise <xref:System.Threading.Thread.SpinWait%2A> Prozessor verhungern in bestimmten Situationen verhindert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist das Betriebssystem an, den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald ein Thread die <xref:System.Threading.ThreadState?displayProperty=nameWithType> Zustand befindet, wird das Betriebssystem für die Ausführung planen. Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, dargestellt durch die <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> -Delegaten an den Threadkonstruktor. Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
> [!NOTE]
>  Wenn diese Überladung mit einem Thread mit erstellt verwendet wird eine <xref:System.Threading.ParameterizedThreadStart> zu delegieren, `null` an die vom Thread ausgeführte Methode übergeben wird.  
  
 Sobald der Thread beendet wird, er kann nicht neu gestartet werden mit einem weiteren Aufruf von `Start`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt und startet einen Thread.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Ein Objekt mit Daten, die von der vom Thread ausgeführten Methode verwendet werden sollen.</param>
        <summary>Bewirkt, dass das Betriebssystem den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> ändert, und stellt optional ein Objekt mit Daten bereit, die von der vom Thread ausgeführten Methode verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald ein Thread die <xref:System.Threading.ThreadState?displayProperty=nameWithType> Zustand befindet, wird das Betriebssystem für die Ausführung planen. Der Thread beginnt mit der Ausführung in der ersten Zeile der Methode, dargestellt durch die <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> -Delegaten an den Threadkonstruktor. Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
 Sobald der Thread beendet wird, er kann nicht neu gestartet werden mit einem weiteren Aufruf von `Start`.  
  
 Diese Überladung und <xref:System.Threading.ParameterizedThreadStart> Delegaten erleichtern die Daten an eine Threadprozedur übergeben, aber das Verfahren ist nicht typsicher, da ein Objekt für diese Überladung übergeben werden kann. Eine robustere Möglichkeit, Daten an eine Threadprozedur übergeben wird, die Threadprozedur und Datenfelder zu einem Worker-Objekt eingefügt werden soll. Weitere Informationen finden Sie unter [Threads erstellen und übergeben von Daten zur Startzeit](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Threading.ParameterizedThreadStart> Delegaten mit einer statischen Methode und eine Instanzenmethode.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Thread wurde mithilfe eines <see cref="T:System.Threading.ThreadStart" />-Delegaten anstelle eines <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegaten erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den Thread an. Hat keine Auswirkungen, wenn der Thread bereits angehalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Thread bereits angehalten ist, hat diese Methode keine Auswirkung.  
  
> [!CAUTION]
>  Verwenden Sie nicht die <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> Methoden zum Synchronisieren der Aktivitäten von Threads. Sie haben keine Möglichkeit, zu wissen, welcher Code ein Thread ausgeführt wird, wenn Sie ihn anhalten. Wenn Sie einen Thread anhalten, während sie Sperren während der Auswertung von Sicherheitsberechtigungen enthält, andere threads in der <xref:System.AppDomain> blockiert werden. Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <xref:System.AppDomain> , die versuchen, verwenden Sie, dass die Klasse werden blockiert. Deadlocks können leicht auftreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet oder reagiert nicht.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die entsprechende <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge für Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zustände des aktuellen Threads enthält.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadState" />-Werte, der den Zustand des aktuellen Threads angibt. Der Anfangswert ist <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft erhalten Sie genauere Informationen als die <xref:System.Threading.Thread.IsAlive%2A> Eigenschaft.  
  
> [!IMPORTANT]
>  Threadzustand ist nur in Debugszenarien von Interesse. Sie sollten den Threadzustand niemals verwenden, um die Aktivitäten von Threads zu synchronisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht den Zugriff auf die `ThreadState` eines Threads.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <returns>
          <see langword="true" />, wenn der Apartmentzustand festgelegt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als initialisiert <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Wenn ihre Apartmentzustand nicht festgelegt wurde, bevor sie gestartet wurden. Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState?displayProperty=nameWithType> standardmäßig. Die einzige Möglichkeit zum Festlegen des Status Apartment des Threads hauptanwendung, <xref:System.Threading.ApartmentState?displayProperty=nameWithType> angewendet wird die <xref:System.STAThreadAttribute> -Attribut auf die Einstiegspunktmethode.  
  
 Die <xref:System.Threading.Thread.TrySetApartmentState%2A> -Methode, zusammen mit den <xref:System.Threading.Thread.GetApartmentState%2A> Methode und die <xref:System.Threading.Thread.SetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Bevor der Thread gestartet wird, <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern <xref:System.Threading.ApartmentState?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt ist. Mit der gleiche Vorgang versucht wurde, hatte <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wird, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , weil der Thread bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den letzten Wert auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>und <xref:System.Threading.Thread.VolatileWrite%2A> sind für Sonderfälle der Synchronisierung. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung und die <xref:System.Threading.Monitor> Klasse bereitstellen einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies könnte Prozessorcache geleert werden.  
  
 Auch bei einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Sie folglich können verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Beim Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld zu gewährleisten, muss alle Zugriff auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer auf ein Feld wird sichergestellt, dass alle Zugriffe auf dieses Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass der aufrufende Thread die Ausführung an einen anderen Thread übergibt, der auf dem aktuellen Prozessor ausgeführt werden kann. Das Betriebssystem wählt den Thread für die Übergabe aus.</summary>
        <returns>
          <see langword="true" />, wenn das Betriebssystem die Ausführung an einen anderen Thread übergeben hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode erfolgreich ist, wird der Rest der aktuellen Zeitscheibe des Threads zurückgegeben. Das Betriebssystem plant den aufrufenden Thread für eine andere Zeitscheibe nach seiner Priorität und den Status von anderen Threads, die zum Ausführen verfügbar sind.  
  
 Gewinnung ist beschränkt, für den Prozessor an, der den aufrufenden Thread ausgeführt wird. Das Betriebssystem wird nicht mit einem anderen Prozessor Ausführung wechseln, selbst wenn der Prozessor im Leerlauf befindet oder einen Thread mit geringerer Priorität ausgeführt wird. Wenn es sind keine anderen Threads, die auf dem aktuellen Prozessor ausgeführt werden und das Betriebssystem keine Arbeitsvorgänge von Ausführung zugunsten dieser Methode `false`.  
  
 Diese Methode ist gleichbedeutend mit Plattformaufruf zum Aufrufen von systemeigenen Win32 `SwitchToThread` Funktion. Rufen Sie die <xref:System.Threading.Thread.Yield%2A> Methode anstelle der Plattform aufrufen, da ein Plattformaufruf umgeht alle benutzerdefiniertes threading Verhalten der Host angefordert hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
