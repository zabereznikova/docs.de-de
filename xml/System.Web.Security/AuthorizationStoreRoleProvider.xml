<Type Name="AuthorizationStoreRoleProvider" FullName="System.Web.Security.AuthorizationStoreRoleProvider">
  <TypeSignature Language="C#" Value="public class AuthorizationStoreRoleProvider : System.Web.Security.RoleProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AuthorizationStoreRoleProvider extends System.Web.Security.RoleProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.AuthorizationStoreRoleProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.Security.RoleProvider</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet die Speicherung der Rollenmitgliedschaft Informationen für eine ASP.NET-Anwendung in einem Richtlinienspeicher Autorisierungs-Manager, entweder in eine XML-Datei, die in einer Active Directory oder auf einem Active Directory Application Mode-Server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird verwendet, durch die <xref:System.Web.Security.Roles> und <xref:System.Web.Security.RolePrincipal> Klassen um Rollenverwaltungsdienste für eine ASP.NET-Anwendung mit einem Autorisierungs-Manager Speicher bereitzustellen. Rollenverwaltung können Sie verschiedene Ebenen der Autorisierung für Ihre Anwendung angeben. Der Autorisierungs-Manager kann über die Microsoft-Verwaltungskonsole zugegriffen werden.  
  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt funktioniert mit beiden Windows-Authentifizierung und bildet die Authentifizierungsmodi.  
  
 Sie können konfigurieren, die <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt, das entweder eine lokale XML-Datei oder ein Active Directory oder Active Directory Application Mode (ADAM)-Server verwendet. Wenn Sie eine lokale Datei zu verwenden, sollte die Verbindungszeichenfolge wie im folgenden Beispiel aussehen.  
  
```  
msxml://<path to xml file>  
```  
  
 Wenn die lokale Datei in der Verzeichnisstruktur für eine ASP.NET-Webanwendung gespeichert ist, können Sie die Tilde ("~") an, dass das Stammverzeichnis Zeichen. Um anzugeben, dass die lokale Datei im Datenverzeichnis der Anwendung gespeichert ist, würden Sie z. B. eine Verbindungszeichenfolge ähnlich wie im folgenden Beispiel verwenden.  
  
 `msxml://~\App_Data\datafilename.xml`  
  
> [!IMPORTANT]
>  Speichern einer XML-Datendatei im Anwendungsverzeichnis Web ist ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig wird IIS XML-Datendateien im Web dienen. Zur Erhöhung der Sicherheit, wenn Sie eine lokale Datendatei in einer ASP.NET-Anwendung zu verwenden, sollten Sie die Datendatei in speichern die `App_Data` Verzeichnis. Dateien in den `App_Data` Verzeichnis wird nicht im Web bedient werden.  
  
 Wenn Sie einen Active Directory- oder ADAM-Server für den Richtlinienspeicher verwenden, sollte Ihre Verbindungszeichenfolge im folgenden Beispiel ähnlich sein.  
  
 `msldap://myserver/CN=MyAzManStore,OU=MyOU,DC=MyDomain,DC=MyDC,DC=Com`  
  
 Die Ausnahmen aufgelistet, in der Dokumentation für <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objektmethoden werden die Ausnahmen, die vom ausgelöst werden die <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt. Da der Anbieter auf die zugrunde liegenden Authentifizierungs-Manager-Laufzeit angewiesen ist ein <xref:System.Runtime.InteropServices.COMException> Ausnahme möglicherweise ausgelöst, wenn die <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt leitet den Aufruf einer Methode für die Authentifizierungs-Manager-Laufzeit.  
  
> [!IMPORTANT]
>  Die <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt hat die folgenden Anforderungen zum Ausführen in teilweise vertrauenswürdigen Umgebungen:  
>   
>  Mit einem dateibasierten Richtlinienspeicher in einer ASP.NET-Anwendung die-e/a-Dateiberechtigungen, die von der aktuellen Vertrauensebene gewährt zum bestimmen, ob lesen, und schreibaktionen vom Anbieter zulässig sind. Die ASP.NET-Anwendung muss über Leseberechtigung für die Datei zum Lesen von Daten aus den Richtlinienspeicher und muss über die Schreibberechtigung für das Speichern von Informationen zur neuen oder vorhandenen Informationen in den Richtlinienspeicher aktualisiert haben. Die Standardrichtliniendatei für mittlere Vertrauenswürdigkeit bietet eine ASP.NET Anwendung Lese-/Schreibberechtigungen im Anwendungsverzeichnis. Die Standardrichtliniendatei wenig vertrauenswürdigem bietet nur eine ASP.NET-Anwendung read-Berechtigung im Anwendungsverzeichnis. Die Prozess-ID, unter der die ASP.NET-Anwendung ausgeführt wird, benötigen Dateisystemberechtigungen zum Lesen und/oder schreiben die Richtliniendatei.  
>   
>  Wenn Sie einen Active Directory- oder ADAM-Server verwenden zu können, benötigt die ASP.NET-Anwendung nicht verwaltetem Code Berechtigung an, da das interne <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objektcode COM-Interop verwendet.  
>   
>  Bei Verwendung der <xref:System.Web.Security.AuthorizationStoreRoleProvider> Objekt außerhalb von ASP.NET, benötigt der aufrufende Code nicht verwalteten Code eine Berechtigung.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt eine Datei "Web.config" so festgelegt, dass die <xref:System.Web.Security.AuthorizationStoreRoleProvider> für Rollenverwaltung.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="AuthorizationServices" connectionString="msxml://~\App_Data\SampleStore.xml" />  
  </connectionStrings>  
  
  <system.web>  
  
    <authentication mode="Windows" />  
    <identity impersonate="true" />  
  
    <roleManager defaultProvider="AuthorizationStoreRoleProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="false"  
      cookieSlidingExpiration="true"  
      cookieProtection="All" >  
      <providers>  
        <clear />  
          <add  
            name="AuthorizationStoreRoleProvider"  
            type="System.Web.Security.AuthorizationStoreRoleProvider"  
            connectionStringName="AuthorizationServices"  
            applicationName="SampleApplication"   
            cacheRefreshInterval="60"  
            scopeName="" />  
      </providers>  
    </roleManager>  
  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AuthorizationStoreRoleProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.%23ctor%2A> Konstruktor wird aufgerufen, von ASP.NET zum Erstellen einer Instanz von der <xref:System.Web.Security.AuthorizationStoreRoleProvider> -Klasse entsprechend den Angaben in der Konfiguration für die Anwendung. Dieser Konstruktor ist nicht für die Verwendung aus dem Code vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public override void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.AddUsersToRoles(System.String[],System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Ein Zeichenfolgenarray mit Benutzernamen, die den angegebenen Rollen hinzugefügt werden sollen.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollennamen, denen die angegebenen Benutzernamen hinzugefügt werden sollen.</param>
        <summary>Fügt die angegebenen Benutzernamen an jeden der angegebenen Rollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.AddUsersToRoles%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse um einen oder mehrere Benutzer eine oder mehrere Rollen im Autorisierungs-Manager Datenspeicher in die ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegebenen zuzuordnen. Diese Methode wird aufgerufen, indem Sie die <xref:System.Web.Security.Roles.AddUserToRole%2A?displayProperty=nameWithType>, <xref:System.Web.Security.Roles.AddUserToRoles%2A?displayProperty=nameWithType>, <xref:System.Web.Security.Roles.AddUsersToRole%2A?displayProperty=nameWithType>, und <xref:System.Web.Security.Roles.AddUsersToRoles%2A?displayProperty=nameWithType> Methoden die <xref:System.Web.Security.Roles> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine oder mehrere Benutzer zu einer Rolle hinzugefügt oder entfernt einen Benutzer aus einer Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Einer der angegebenen Benutzernamen ist <see langword="null" />.  
  
 - oder -   
  
 Einer der angegebenen Rollennamen ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="usernames" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="roleNames" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Einer der angegebenen Benutzernamen ist eine leere Zeichenfolge oder ein Komma (,) enthält.  
  
 - oder -   
  
 Eine der angegebenen Rolle ist eine leere Zeichenfolge oder ein Komma (,) enthält.  
  
 - oder -   
  
 <paramref name="usernames" />enthält ein doppeltes Element.  
  
 - oder -   
  
 <paramref name="roleNames" />enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public override string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namen der Autorisierung Store-Anwendung für das Speichern und Abrufen von Rolleninformationen.</summary>
        <value>Anwendung für das Speichern und Abrufen von Rolleninformationen Speichern des Namens der Autorisierung. Die Standardeinstellung ist die <see cref="P:System.Web.HttpRequest.ApplicationPath" /> Eigenschaftswert für die aktuelle <see cref="P:System.Web.HttpContext.Request" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> dient der <xref:System.Web.Security.AuthorizationStoreRoleProvider> zum Zuordnen von Benutzern und Rollen mit anderen Autorisierungs-Manager-Anwendungen, die mehrere ASP.NET ermöglicht Anwendungen für die Verwendung derselben Autorisierungs-Manager Richtlinie, die zum Speichern von Rolleninformationen ohne Speichern Ausführen von in Konflikt zwischen doppelten Rollennamen. Alternativ können mehrere ASP.NET-Anwendungen den gleichen Richtlinienspeicher verwenden, indem derselbe Wert in der <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft. Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft programmgesteuert festgelegt werden kann, oder sie können mithilfe von deklarativ in der Anwendungsdatei "Web.config" festgelegt werden die `applicationName` Attribut.  
  
 Wenn kein Wert für angegeben wird die `applicationName` Attribut in der Datei "Web.config" und dann die <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> Eigenschaftswert für die aktuelle <xref:System.Web.HttpContext.Request%2A?displayProperty=nameWithType> Objekt verwendet wird.  
  
> [!NOTE]
>  Autorisierungs-Manager Anwendung-dürfen nicht die Zeichen "/", die in enthalten ist enthalten die <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> Eigenschaft. Daher den Standardwert für die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft kann nicht als Name für eine Autorisierungs-Manager Anwendung verwendet werden, und Sie müssen immer angeben, in der Datei "Web.config" der Anwendung ein `applicationName` Attribut in der `provider` -Elements konfiguriert Ihre <xref:System.Web.Security.AuthorizationStoreRoleProvider> Instanz.  
  
> [!CAUTION]
>  Da eine einzelne Rolle Anbieter Standardinstanz, für alle Anforderungen vom verwendet wird ein <xref:System.Web.HttpApplication> -Objekt können mehrere Anforderungen gleichzeitig ausgeführt und versucht, legen Sie die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaftswert. Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft ist nicht für mehrere Schreibvorgänge threadsicher sind, und ändern die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaftswert kann zu unerwartetem Verhalten führen, wenn mehrere einer Anwendung Benutzer. Es wird empfohlen, dass Sie keinen Code schreiben, der Benutzern ermöglicht, legen Sie die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft es sei denn, Sie müssen. Ein Beispiel für eine Anwendung in dem das Festlegen der <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft kann erforderlich sein, sollte eine verwaltende Anwendung, die Daten der Rolle für mehrere Anwendungen verwaltet wird. Eine solche Anwendung sollte einen Einzelbenutzer-Anwendung und nicht um eine Webanwendung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, der Anwendungsverzeichnis <xref:System.Web.Security.AuthorizationStoreRoleProvider> Instanz und legt die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName%2A> Eigenschaft `MyApplication`.  
  
```  
<roleManager defaultProvider="AuthorizationStoreProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.AuthorizationStoreRoleProvider"  
      connectionStringName="AuthorizationStoreServices"   
      scopeName="MyScope"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Es wurde versucht, Festlegen der <see cref="P:System.Web.Security.AuthorizationStoreRoleProvider.ApplicationName" /> in eine Zeichenfolge, die länger als 256 Zeichen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheRefreshInterval">
      <MemberSignature Language="C#" Value="public int CacheRefreshInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CacheRefreshInterval" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.AuthorizationStoreRoleProvider.CacheRefreshInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Minuten zwischen den Aktualisierungen des Caches der Richtlinienspeicher Daten ab.</summary>
        <value>Die Anzahl der Minuten zwischen den Aktualisierungen von zwischengespeicherten Richtlinienspeicher Daten. Der Standardwert ist 60.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public override void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.CreateRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der zu erstellenden Rolle.</param>
        <summary>Der rollenspeicher für Autorisierungs-Manager Richtlinie hinzugefügt eine neue Rolle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.CreateRole%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse zum Erstellen einer Rolle im Autorisierungs-Manager Datenspeicher in die ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegeben.  
  
 Rollennamen sind nicht in der Groß-/Kleinschreibung beachtet.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Rolle im Richtlinienspeicher Autorisierungs-Manager. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public override bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.DeleteRole(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der zu löschenden Rolle.</param>
        <param name="throwOnPopulatedRole">Wenn <see langword="true" />, löst eine Ausnahme aus, wenn <c>RoleName</c> verfügt über eine oder mehrere Member.</param>
        <summary>Entfernt eine Rolle aus den Richtlinienspeicher Autorisierungs-Manager.</summary>
        <returns>
          <see langword="true" />Wenn die Rolle gelöscht wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.DeleteRole%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse so löschen Sie eine Rolle aus den Autorisierungs-Manager Richtlinienspeicher in der ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegeben. Wenn eine Rolle gelöscht wird, wird die Liste der Benutzer, die dieser Rolle zugeordneten auch aus den Richtlinienspeicher gelöscht. Die Benutzerinformationen in der Datenbank ist nicht betroffen.  
  
 Wenn `throwOnPopulatedRole` ist `true`, wird eine Ausnahme ausgelöst und die Rolle wird nicht gelöscht werden, wenn die Rolle von identifiziert die `roleName` Parameter hat ein oder mehrere Elemente. Wenn `throwOnPopulatedRole` ist `false`, und klicken Sie dann die Rolle, ob sie leer oder nicht ist gelöscht werden.  
  
   
  
## Examples  
 Das folgende Beispiel löscht eine Rolle aus den Richtlinienspeicher Autorisierungs-Manager. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" />verfügt über eine oder mehrere Member und <paramref name="throwOnPopulatedRole" /> ist <see langword="true" />.  
  
 - oder -   
  
 Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public override string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.FindUsersInRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Die Rolle, in der gesucht werden soll.</param>
        <param name="usernameToMatch">Der zu suchende Benutzername.</param>
        <summary>Diese Methode wird von den Rollenanbieter für Autorisierungsspeicher nicht unterstützt.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Benutzer enthält, deren Benutzername mit <paramref name="usernameToMatch" /> übereinstimmt und die Mitglieder der angegebenen Rolle sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Eine nicht unterstützte Methode wurde aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public override string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.GetAllRoles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Liste aller Rollen für die Anwendung ab.</summary>
        <returns>Ein Zeichenfolgenarray mit den Namen aller Rollen, die in den Richtlinienspeicher Autorisierungs-Manager für eine bestimmte Anwendung gespeichert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.GetAllRoles%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse zum Abrufen einer Liste aller Rollen im Richtlinienspeicher Autorisierungs-Manager in der ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetAllRoles%2A> Methode zum Abrufen der Liste der Rollen für eine Anwendung, und binden die Ergebnisse in einem <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public override string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.GetRolesForUser(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzer, für den eine Liste der Rollen zurückgegeben werden soll.</param>
        <summary>Ruft eine Liste der Rollen ab, die ein Benutzer innehat.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Rollen des angegebenen Benutzers enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.GetRolesForUser%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse, um eine Liste der Rollen des angegebenen Benutzers aus dem Autorisierungs-Manager Richtlinienspeicher, die in der ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegebenen abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methode zum Abrufen einer Liste der Rollen für einen angegebenen Benutzer und bindet sie an einer <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="username" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public override string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.GetUsersInRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der Rolle, für die die Liste der Benutzer abgerufen werden soll.</param>
        <summary>Ruft eine Liste der Benutzer mit der angegebenen Rolle ab.</summary>
        <returns>Ein Zeichenfolgenarray mit den Namen aller Benutzer, die Mitglieder der angegebenen Rolle sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.GetUsersInRole%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse beim Abrufen der Liste der Benutzer die angegebene Rolle im Richtlinienspeicher Autorisierungs-Manager in der ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegebenen zugeordnet.  
  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.GetUsersInRole%2A> nur Methodenrückgabe Benutzernamen, die direkt enthalten sind in der Autorisierungs-Manager Rolle, die gemäß der `roleName` Parameter. Die zugrunde liegenden autorisierungsverwalter-API-wird aufgerufen, indem Sie die <xref:System.Web.Security.AuthorizationStoreRoleProvider.GetUsersInRole%2A> Methode unterstützt keine gruppenerweiterung, damit Benutzer in geschachtelten NT-Gruppen, geschachtelte Autorisierungs-Manager-Gruppen und LDAP-Abfragegruppen nicht zurückgegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetUsersInRole%2A> Methode zum Abrufen einer Liste der Benutzer in einer bestimmten Rolle, und binden die Ergebnisse in einem <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public override void Initialize (string name, System.Collections.Specialized.NameValueCollection config);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Initialize(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.Initialize(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des der <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz initialisiert werden.</param>
        <param name="config">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" /> , die die Namen und Werte der Konfigurationsoptionen für den Rollenanbieter enthält.</param>
        <summary>Initialisiert den Autorisierungs-Manager Rollenanbieter mit den Eigenschaftswerten, die in der ASP.NET-Anwendung Konfigurationsdatei angegeben. Diese Methode ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.Initialize%2A> Methode initialisiert die <xref:System.Web.Security.AuthorizationStoreRoleProvider> mit der Eigenschaft Werte, die in der Anwendungskonfigurationsdatei (Web.config) für das ASP.NET angegeben sind, und nicht direkt aus Ihrem Code verwendet werden soll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="config" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die <see langword="connectionStringName" /> Attribut ist leer oder ist nicht in der [ConnectionStrings-Element ((ASP.NET Settings Schema)](http://msdn.microsoft.com/en-us/b6ffbb2e-a4d1-410e-8f7e-9755e92c65de) Konfigurationsabschnitt.  
  
 - oder -   
  
 Die konfigurierte <see langword="applicationName" /> ist länger als 256 Zeichen.  
  
 - oder -   
  
 Die Konfiguration für diesen <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz enthält ein nicht erkanntes Attribut.</exception>
        <exception cref="T:System.Web.HttpException">Die ASP.NET-Anwendung wird nicht ausgeführt, bei <see cref="F:System.Web.AspNetHostingPermissionLevel.Low" /> Vertrauensstellung oder höher.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public override bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.IsUserInRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der zu suchende Benutzername.</param>
        <param name="roleName">Die Rolle, in der gesucht werden soll.</param>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene Benutzer die angegebene Rolle innehat.</summary>
        <returns>
          <see langword="true" />Wenn der angegebene Benutzername in der angegebenen Rolle ist. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.IsUserInRole%2A> Methode wird aufgerufen, indem Sie die <xref:System.Web.Security.Roles> Klasse und die <xref:System.Security.Principal.IPrincipal.IsInRole%2A> Methode von der <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> -Eigenschaft können Sie bestimmen, ob ein Benutzer eine Rolle angegeben, in der ASP.NET-Anwendung Autorisierungs-Manager-Datenspeicher zugeordnet ist die Konfigurationsdatei ("Web.config").  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, um festzustellen, ob der angemeldete Benutzer in der "Administratoren" ist, bevor der Benutzer zum Anzeigen von Benutzerrollen programmgesteuert. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> ist <see langword="null" />.  
  
 – oder –  
  
 <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" />ein Komma enthält.  
  
 - oder -   
  
 <paramref name="username" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public override void RemoveUsersFromRoles (string[] userNames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveUsersFromRoles(string[] userNames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userNames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="userNames">Ein Zeichenfolgenarray mit Benutzernamen, die aus den angegebenen Rollen entfernt werden sollen.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollennamen, aus denen Benutzernamen entfernt werden sollen.</param>
        <summary>Entfernt die angegebenen Benutzernamen aus den angegebenen Rollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.RemoveUsersFromRoles%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse so entfernen Sie einen oder mehrere Benutzer aus einer oder mehreren Rollen im Richtlinienspeicher Autorisierungs-Manager in der ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegeben. Diese Methode wird aufgerufen, indem Sie die <xref:System.Web.Security.Roles.RemoveUserFromRole%2A>, <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A>, <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A>, und <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> Methoden die <xref:System.Web.Security.Roles> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine oder mehrere Benutzer zu einer Rolle hinzugefügt oder entfernt einen Benutzer aus einer Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Einer der angegebenen Benutzernamen ist <see langword="null" />.  
  
 - oder -   
  
 Einer der angegebenen Rollennamen ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="userNames" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="roleNames" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Einer der angegebenen Benutzernamen ist eine leere Zeichenfolge oder ein Komma enthält.  
  
 - oder -   
  
 Eine der angegebenen Rolle ist eine leere Zeichenfolge oder ein Komma enthält.  
  
 - oder -   
  
 <paramref name="userNames" />enthält ein doppeltes Element.  
  
 - oder -   
  
 <paramref name="roleNames" />enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public override bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.AuthorizationStoreRoleProvider.RoleExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der Rolle, die in den Richtlinienspeicher Autorisierungs-Manager gesucht werden soll.</param>
        <summary>Ruft einen Wert, der angibt, ob der angegebene Rollenname bereits in den Richtlinienspeicher Autorisierungs-Manager vorhanden ist.</summary>
        <returns>
          <see langword="true" />Wenn der Rollenname bereits in den Richtlinienspeicher Autorisierungs-Manager vorhanden ist. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.RoleExists%2A> Methode wird aufgerufen, indem die <xref:System.Web.Security.Roles> Klasse, um zu bestimmen, ob ein Rollenname im Autorisierungs-Manager Datenspeicher in die ASP.NET-Anwendung-Konfigurationsdatei (Web.config) angegebenen vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.RoleExists%2A> Methode, um zu bestimmen, ob ein Rollenname bereits vor dem Erstellen der Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.AuthorizationStoreRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" />ein Komma enthält.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Die konfigurierte <see langword="applicationName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die konfigurierte <see langword="scopeName" /> wurde nicht gefunden.  
  
 - oder -   
  
 Die Autorisierungs-Manager Laufzeit ist nicht auf dem Server installiert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <see langword="connectionStringName" /> Attribut verweist auf eine Verbindungszeichenfolge zu einer Datei, die nicht vorhanden ist.</exception>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.Security.AuthorizationStoreRoleProvider" /> Instanz mit einem dateibasierten Richtlinienspeicher konfiguriert ist, und Lesezugriff auf die Datei ist auf der aktuellen Vertrauensebene nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public string ScopeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Bereichsnamen für den Autorisierungsspeicher.</summary>
        <value>Der Bereichsname für den Autorisierungsspeicher.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaft kann festgelegt werden, mithilfe der `scopeName` Konfigurationsattribut für die Anbieterinstanz in die `providers` Abschnitt des Konfigurationsabschnitts.  
  
> [!CAUTION]
>  Da eine einzelne Rolle Anbieter Standardinstanz, für alle Anforderungen vom verwendet wird ein <xref:System.Web.HttpApplication> -Objekt können mehrere Anforderungen gleichzeitig ausgeführt und versucht, legen Sie die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaftswert. Die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaft ist nicht für mehrere Schreibvorgänge threadsicher sind, und ändern die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaftswert kann zu unerwartetem Verhalten führen, wenn mehrere einer Anwendung Benutzer. Es wird empfohlen, dass Sie keinen Code schreiben, der Benutzern ermöglicht, legen Sie die <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaft es sei denn, Sie müssen. Ein Beispiel für eine Anwendung in dem das Festlegen der <xref:System.Web.Security.AuthorizationStoreRoleProvider.ScopeName%2A> Eigenschaft kann erforderlich sein, sollte eine verwaltende Anwendung, die Daten der Rolle für mehrere Anwendungen verwaltet wird. Eine solche Anwendung sollte einen Einzelbenutzer-Anwendung und nicht um eine Webanwendung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
