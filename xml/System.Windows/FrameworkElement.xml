<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen WPF-Frameworkebene Satz von Eigenschaften, Ereignisse und Methoden für Windows Presentation Foundation (WPF)-Elemente. Diese Klasse stellt den bereitgestellte WPF-Frameworkebene vorgenommene Implementierung, die für die WPF-Kernebenen-APIs erstellt wird, die von definiert sind <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>wird der verbundene Punkt zwischen WPF-Frameworkebene Elementklassen und den WPF-Kernebenen-Berechtigungssatz <xref:System.Windows.UIElement> Presentation-Dienste. Weitere Informationen zu diesen Konzepten finden Sie unter [WPF-Architektur](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement>Erweitert <xref:System.Windows.UIElement> und bietet die folgenden Funktionen:  
  
-   **Layout Systemdefinition**: <xref:System.Windows.FrameworkElement> bestimmte WPF-Frameworkebene Implementierungen für bestimmte stellt Methoden bereit, die als virtuelle Member in definiert wurden <xref:System.Windows.UIElement>. Vor allem Kontrollvorgänge <xref:System.Windows.FrameworkElement> versiegelt bestimmte WPF-Kernebenen-Layout-Außerkraftsetzungen und stellt eine WPF-Frameworkebene-Entsprechung, die abgeleitete Klassen sollten stattdessen überschreiben. Beispielsweise <xref:System.Windows.FrameworkElement> Verschlüssen <xref:System.Windows.UIElement.ArrangeCore%2A> bietet jedoch <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Diese Änderungen widerspiegeln, die Tatsache, dass zu WPF-Frameworkebene besteht eine vollständige Layoutsystem vorhanden, das alle rendern kann <xref:System.Windows.FrameworkElement> abgeleitete Klasse. Bei WPF core Level, bestimmte Elemente, die eine allgemeine Struktur werden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] basierend Layout-Lösung eingerichtet sind, aber das tatsächliche Layoutsystem-Modul ist nicht definiert. Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Der logischen Struktur:** die allgemeinen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Programmiermodell wird häufig als Elementstruktur ausgedrückt. Unterstützung für auszudrücken, die Struktur der Elemente als logische Struktur und die zugehörige Unterstützung für die Definition der Struktur im Markup implementiert wird die <xref:System.Windows.FrameworkElement> Ebene. Beachten Sie jedoch, dass <xref:System.Windows.FrameworkElement> absichtlich ein Inhaltsmodell nicht definieren, und bewirkt, dass diese Verantwortung auf die abgeleitete Klassen. Weitere Informationen finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Lebensdauer-Objektereignisse:** ist es oft hilfreich zu wissen, wann ein Element initialisiert wird (der Konstruktor aufgerufen wird) oder wenn das Element zuerst in eine logische Struktur geladen wird. <xref:System.Windows.FrameworkElement>definiert mehrere Ereignisse im Zusammenhang mit der Lebensdauer eines Objekts, die nützliche Hooks für Code-Behind-Vorgänge, die Elemente bereitstellen, z. B. das Hinzufügen von untergeordneten Elementen einschließen. Weitere Informationen finden Sie unter [Lebensdauer Objektereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Unterstützung für die Datenbindung und dynamische Ressourcenverweise:** die Eigenschaftenebene Unterstützung für die Datenbindung und Ressourcen wird von implementiert die <xref:System.Windows.DependencyProperty> -Klasse und dem Eigenschaftensystem, aber die Möglichkeit Elementwert zu beheben, die Begriffe gespeichert als eine <xref:System.Windows.Expression> (das Programmiermodell, das die Datenbindung und dynamische Ressourcen zugrunde liegt) wird implementiert, indem <xref:System.Windows.FrameworkElement>. Weitere Informationen finden Sie unter [Übersicht über Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md) und [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Stile:** <xref:System.Windows.FrameworkElement> definiert die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Allerdings <xref:System.Windows.FrameworkElement> noch nicht definieren, Unterstützung für Vorlagen oder Decorator-Elementen zu unterstützen. Diese Features werden durch Steuerelementklassen eingeführt, z. B. <xref:System.Windows.Controls.Control> und <xref:System.Windows.Controls.ContentControl>.  
  
-   **Unterstützung für weitere Animationen:** Unterstützung für Animationen zur WPF-Kernebene bereits definiert wurde, aber <xref:System.Windows.FrameworkElement> erweitert diese durch die Implementierung <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> und verwandte Elemente.  
  
 Wie die Klassenhierarchie viele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Klassen ableiten <xref:System.Windows.FrameworkElement>, weder direkt noch über fortgeschrittene Basisklassen wie z. B. <xref:System.Windows.Controls.Panel> oder <xref:System.Windows.Controls.Control>.  
  
 Wenn Sie beabsichtigen, verwenden Sie <xref:System.Windows.FrameworkElement> als eine Basisklasse, möchten Sie möglicherweise zuerst die vorhandenen abgeleiteten Klassen untersuchen. <xref:System.Windows.FrameworkElement>bietet Unterstützung für eine Reihe von grundlegenden Szenarien, aber auch verfügt nicht über eine Reihe von Funktionen, die für ein "Element" in den Sinn der, mit denen Sie erstellen ein grundlegender Baustein wünschenswert sind [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Z. B. eine <xref:System.Windows.FrameworkElement> "true" Inhaltsmodell; ist nicht definiert <xref:System.Windows.FrameworkElement> als eine Basisklasse keine Eigenschaft definieren, erstellen können [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] untergeordnete Elemente. Insbesondere sollten Sie betrachten <xref:System.Windows.Controls.Control> und <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Höhe dieses Elements ab.</summary>
        <value>Die Höhe des Elements, als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert basierend auf andere Höheneingaben und das Layoutsystem. Der Wert wird vom Layoutsystem selbst, basierend auf einem tatsächlichen Renderingdurchlauf festgelegt und kann daher zurückfallen etwas der festgelegte Wert von Eigenschaften wie z. B. <xref:System.Windows.FrameworkElement.Height%2A> , sind die Grundlage für die Eingabe ändern.  
  
 Da <xref:System.Windows.FrameworkElement.ActualHeight%2A> wird ein berechneter Wert sollten Sie berücksichtigen, dass es möglicherweise mehrere oder inkrementelle gemeldet ändert, als Ergebnis verschiedener Vorgänge vom Layoutsystem. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft festlegen können [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], können Sie als Grundlage einer <xref:System.Windows.Trigger> nach dessen Wert in ein Format.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die verschiedenen Eigenschaften für Höhe.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Breite dieses Elements ab.</summary>
        <value>Breite des Elements, als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert basierend auf anderen Breiteneingaben und das Layoutsystem. Der Wert wird vom Layoutsystem selbst, basierend auf einem tatsächlichen Renderingdurchlauf festgelegt und kann daher zurückfallen etwas der festgelegte Wert von Eigenschaften wie z. B. <xref:System.Windows.FrameworkElement.Width%2A> , sind die Grundlage für die Eingabe ändern.  
  
 Da <xref:System.Windows.FrameworkElement.ActualWidth%2A> wird ein berechneter Wert sollten Sie berücksichtigen, dass es möglicherweise mehrere oder inkrementelle gemeldet ändert, als Ergebnis verschiedener Vorgänge vom Layoutsystem. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft festlegen können [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], können Sie als Grundlage einer <xref:System.Windows.Trigger> nach dessen Wert in ein Format.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt verschiedene Breiteneigenschaften.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Untergeordnetes Element hinzugefügt werden.</param>
        <summary>Fügt das angegebene Objekt auf der logischen Struktur dieses Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Sammlungen für Objekte, die logischen untergeordneten Elemente eines Elements darstellen. Auflistung von Wartungstasks für die untergeordnete Element Auflistungen kann in Eigenschaftengetter oder Setter-Klassenbehandlung Changed-Ereignisse, Konstruktoren, oder in den Auflistungstypen selbst ausgeführt werden.  
  
 Für Autoren kein Bearbeiten von der logischen Struktur auf dieser Ebene die empfohlene Vorgehensweise, wenn keine Inhaltsmodelle für verfügbare Basissteuerelementklassen für Ihr Steuerelementszenario geeignet sind. Betrachten Sie die Erstellung von Unterklassen von auf der Ebene der <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, und <xref:System.Windows.Controls.HeaderedItemsControl>. Diese Klassen bieten ein Inhaltsmodell mit besonderer Erzwingung logischen Struktur untergeordneter Elemente über dedizierte [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], sowie Unterstützung für andere Funktionen, die in der Regel erwünscht, in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement z. B. über Vorlagen erstellen. Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>eine Ausnahme kann ausgelöst werden, wenn Sie zu einem Zeitpunkt aufgerufen wird, wenn die logische Struktur von einem anderen Prozess durchlaufen wird.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert eine `Child` Eigenschaft in einer benutzerdefinierten <xref:System.Windows.FrameworkElement> , die eine eigene Implementierung visueller Ebene ist. Der Eigenschaftensetter ist so konzipiert, dass der alte Wert aus der logischen Struktur als auch eine klassenspezifische visuelle Sammlung, wenn der Wert ändert entfernt wird. Der Eigenschaftswert wird zwischengespeichert, und der neue Wert wird dann der logischen Struktur und der benutzerdefinierten visuellen Auflistung hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt bei Bedarf die visuelle Struktur der aktuellen Vorlage und gibt einen Wert zurück, der angibt, ob die visuelle Struktur durch diesen Aufruf neu erstellt wurde.</summary>
        <returns>
          <see langword="true" />Wenn der Struktur visuelle Elemente hinzugefügt wurden; Gibt <see langword="false" /> andernfalls.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen können rufen Sie diese Methode, um zu gewährleisten, dass die visuelle Struktur eines Elements abgeschlossen ist. Dieser Schritt ist möglicherweise erforderlich, wenn der Code die untergeordneten Elemente in der Struktur überprüft werden. Für eine typische Element Logik innerhalb von Anwendungen, Aufrufen von <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> ist nicht erforderlich, da die Vorlagen für Elemente an einer geeigneten Stelle deren Lebensdauer automatisch angewendet werden.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A>wird aufgerufen, für jedes Measure durch das WPF-Frameworkebene Layoutsystem übergeben.  
  
 <xref:System.Windows.FrameworkElement>abgeleitete Klassen können die <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> Klassenhandler der Fälle, in diese Methode explizit aufgerufen wurde, oder vom Layoutsystem benachrichtigt werden. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>wird aufgerufen, nachdem die Vorlage vollständig generiert und an die logische Struktur angefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Implementiert <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (definiert als virtuell in <see cref="T:System.Windows.UIElement" />) und die Implementierung versiegelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist versiegelt. Um die Logik in benutzerdefinierten Element speziell für die anordnungsphase des Elementlayouts, überschreiben die <xref:System.Windows.FrameworkElement> abgeleiteten Klasse überschreiben, muss <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Positioniert beim Überschreiben in einer abgeleiteten Klasse die untergeordneten Elemente und bestimmt eine Größe für eine von <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse.</summary>
        <returns>Die tatsächlich verwendete Größe.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Steuerelementautoren, die die anordnungsphase der Verarbeitung von Layout anpassen möchten, sollten diese Methode überschreiben. Das Implementierungsmuster sollte Aufrufen <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> in jeder sichtbaren untergeordneten Element, und übergeben Sie die endgültige gewünschte Größe für jedes untergeordnete Element als der <paramref name="finalRect" /> Parameter. Übergeordnete Elemente rufen sollten <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für jedes untergeordnete Element ist, andernfalls die untergeordneten Elemente nicht gerendert werden.  
  
 Viele abgeleitete Klassen bieten Implementierungen dieser Methode. Dazu zählen: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Initialisierung für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode für einzelne Elemente aufrufen, wenn Sie diese auf Weise anpassen, die noch nicht verfügbar zu machen oder verbinden das Element mit einer Elementstruktur. Z. B. Sie möglicherweise haben erstellt ein neues <xref:System.Windows.FrameworkElement>, haben, dürfen Sie es noch nicht an eine logische Struktur angefügt haben. Oder die logische Struktur, in dem das Element ein untergeordnetes Element darin ist, möglicherweise nicht zu einem Fenster oder auf der Seite der Anwendung verbunden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Implementieren Sie diese Methode, um eine besondere Behandlung bereitstellen, die vor der Initialisierung des Elements während der Prozess des Ladens Element erfolgen soll.  
  
 Die Implementierung sollte die basisimplementierung aufrufen, da die Implementierung Base (Standard) einige interne Flags Initialisierung des festlegt. Eine mögliche Implementierung ist die Verwendung dieser Methode als Hook in Ihren eigenen Initialisierungsroutinen private Klasse, die von den Konstruktoren nicht bereits aktiviert sind.  
  
 Die grundlegende Implementierung löst eine Ausnahme aus, wenn <see cref="M:System.Windows.FrameworkElement.BeginInit" /> wird aufgerufen, mehr als ein Mal für dasselbe Element vor dem <see cref="M:System.Windows.FrameworkElement.EndInit" /> aufgerufen werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das Storyboard zu beginnen.</param>
        <summary>Startet die Abfolge der Aktionen, die im bereitgestellten Storyboard enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animationsszenarien verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und dann die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation ausgeführt. Die meisten der Aspekte beim Steuerelement eine <xref:System.Windows.Media.Animation.Storyboard> können adressiert werden, indem Eigenschaften, die im Markup bereitgestellt werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder bei Angabe dieses Parameters `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den Zeitraum "Fill" erreicht. Die Animation kann nicht aus diesem Grund neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern der Animation erfordert außerdem, dass das Storyboard haben eine [X: Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md) oder als Verweis im Code zugegriffen werden.  
  
   
  
## Examples  
 Das folgende Beispiel ruft eine <xref:System.Windows.Media.Animation.Storyboard> von Ressourcen und ausgeführt wird, <xref:System.Windows.Media.Animation.Storyboard> Wenn ist ein internes Ereignis Klasse behandelt.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das Storyboard zu beginnen.</param>
        <param name="handoffBehavior">Der Wert der Enumeration, die beschreibt Verhalten verwenden, wenn eine in das Storyboard beschriebene Eigenschaft bereits animiert wird.</param>
        <summary>Startet die Abfolge der Aktionen, die im bereitgestellten Storyboard enthalten, mit den Optionen für was geschehen soll, wenn die Eigenschaft bereits animiert wird angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animationsszenarien verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und dann die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation ausgeführt. Die meisten der Aspekte beim Steuerelement eine <xref:System.Windows.Media.Animation.Storyboard> können adressiert werden, indem Eigenschaften, die im Markup bereitgestellt werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder bei Angabe dieses Parameters `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den Zeitraum "Fill" erreicht. Die Animation kann nicht aus diesem Grund neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern der Animation erfordert außerdem, dass das Storyboard haben eine [X: Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md) oder als Verweis im Code zugegriffen werden.  
  
 -Übergabeverhalten kann angegeben werden, als ein Attribut des <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mit dem Verfassen HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, stellen alle <xref:System.Windows.Media.Animation.Clock> zuvor mit dieser Eigenschaft zugewiesenen Objekte weiter an Systemressourcen beanspruchen, das Timing-System verwendet wird Entfernen Sie die Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mit anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, Sie sollten zusammengesetzte Uhren aus der animierten Eigenschaft nach dem Abschluss entfernen. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Verwenden Sie zum Entfernen aller Uhren aus einer Eigenschaft der <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die Eigenschaft als erster Parameter animierten und `null` als das zweite. Dadurch werden alle Animationsuhren aus der Eigenschaft entfernt.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> , aus einer Liste von Uhren verwenden die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> abgerufen eine <xref:System.Windows.Media.Animation.ClockController>, rufen Sie anschließend die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden, können eine <xref:System.Windows.Media.Animation.ClockController>; das <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen beim Aufrufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, wird die Uhren werden auch getrennt, und Sammlung veralteter Objekte aufgenommen.  
  
 Weitere Informationen zu Uhr Objekten finden Sie unter [Animationen und zeitlichen Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel ruft eine <xref:System.Windows.Media.Animation.Storyboard> von Ressourcen und ausgeführt wird, <xref:System.Windows.Media.Animation.Storyboard> Wenn ist ein internes Ereignis Klasse behandelt.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das Storyboard zu beginnen.</param>
        <param name="handoffBehavior">Der Wert der Enumeration, die beschreibt Verhalten verwenden, wenn eine in das Storyboard beschriebene Eigenschaft bereits animiert wird.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem dieser gestartet wird.</param>
        <summary>Startet die Abfolge der Aktionen enthalten, die in der bereitgestellten Storyboard mit dem angegebenen Zustand für das Steuerelement der Animation, nachdem dieser gestartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animationsszenarien verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und dann die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation ausgeführt. Die meisten der Aspekte beim Steuerelement eine <xref:System.Windows.Media.Animation.Storyboard> können adressiert werden, indem Eigenschaften, die im Markup bereitgestellt werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder bei Angabe dieses Parameters `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den Zeitraum "Fill" erreicht. Die Animation kann nicht aus diesem Grund neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern der Animation erfordert außerdem, dass das Storyboard haben eine [X: Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md) oder als Verweis im Code zugegriffen werden.  
  
 -Übergabeverhalten kann angegeben werden, als ein Attribut des <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mit dem Verfassen HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, stellen alle <xref:System.Windows.Media.Animation.Clock> zuvor mit dieser Eigenschaft zugewiesenen Objekte weiter an Systemressourcen beanspruchen, das Timing-System verwendet wird Entfernen Sie die Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mit anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, Sie sollten zusammengesetzte Uhren aus der animierten Eigenschaft nach dem Abschluss entfernen. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Verwenden Sie zum Entfernen aller Uhren aus einer Eigenschaft der <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die Eigenschaft als erster Parameter animierten und `null` als das zweite. Dadurch werden alle Animationsuhren aus der Eigenschaft entfernt.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> , aus einer Liste von Uhren verwenden die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> abgerufen eine <xref:System.Windows.Media.Animation.ClockController>, rufen Sie anschließend die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden, können eine <xref:System.Windows.Media.Animation.ClockController>; das <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen beim Aufrufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, wird die Uhren werden auch getrennt, und Sammlung veralteter Objekte aufgenommen.  
  
 Weitere Informationen zu Uhr Objekten finden Sie unter [Animationen und zeitlichen Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die <see cref="T:System.Windows.Data.BindingGroup" /> , die für das Element verwendet wird.</summary>
        <value>Die <see cref="T:System.Windows.Data.BindingGroup" /> , die für das Element verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Data.BindingGroup> zum Überprüfen der Werte von mehreren Eigenschaften eines Objekts verwendet werden können. Nehmen wir beispielsweise an, dass eine Anwendung den Benutzer fordert auf eine Adresse eingeben, und dann ein Objekt des Typs füllt `Address`, die über die Eigenschaften verfügt `Street`, `City`, `ZipCode`, und `Country`, mit den Werten, die der Benutzer bereitgestellt. Die Anwendung verfügt über einen Bereich, vier enthält <xref:System.Windows.Controls.TextBox> Steuerelemente, von denen jedes an eine der Eigenschaften des Objekts gebunden ist. Können Sie eine <xref:System.Windows.Controls.ValidationRule> in einem <xref:System.Windows.Data.BindingGroup> zum Überprüfen der `Address` Objekt. Z. B. die <xref:System.Windows.Controls.ValidationRule> können sicherstellen, dass die Postleitzahl für das Land der Adresse gültig ist.  
  
 Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von den übergeordneten Elementen, genauso wie bei jeder anderen vererbbare Eigenschaft.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Festgelegte Metadateneigenschaften **"true"**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 In den folgenden Beispielen sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei Objekten, auf die gleichen Werte festgelegt hat. Im erste Beispiel erstellt zwei <xref:System.Windows.Controls.TextBox> Steuerelemente, von denen jeder mit einer anderen Datenquelle gebunden ist. Die <xref:System.Windows.Controls.StackPanel> verfügt über eine <xref:System.Windows.Data.BindingGroup> , enthält eine <xref:System.Windows.Controls.ValidationRule> , die überprüft, dass die beiden Zeichenfolgen gleich sind.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 Das folgende Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule> , die im vorherigen Beispiel verwendet.  In der <xref:System.Windows.Controls.ValidationRule.Validate%2A> methodenüberschreibung, im Beispiel ruft jede Quellobjekts, aus der <xref:System.Windows.Data.BindingGroup> und überprüft, ob die Eigenschaften der Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Zum Aufrufen der <xref:System.Windows.Controls.ValidationRule>, rufen Sie die <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> Methode.  Im folgenden Beispiel wird <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> tritt das Click-Ereignis der Schaltfläche.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.BindingGroup" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, dieses Element sichtbar, in einem bildlauffähigen Bereiche zu machen, der es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufruf dieser Methode, die Sie Heraufstufen einer <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis, das das aktuelle Element stammt. Dieses Ereignis wird ausgelöst, sodass sie vom verarbeitet werden kann ein <xref:System.Windows.Controls.ScrollViewer>, oder eine abgeleitete oder ähnlichen-Klasse. Erwartet, dass das Ereignis wird durch das übergeordnete Element gekennzeichnet in den Daten für das Ereignis behandelt, und die Quelle des Ereignisses in der Ansicht über die Logik in eingebetteten geschaltet wird, wird die <xref:System.Windows.Controls.ScrollViewer> Steuerelement. Weder die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> -Methode übertragen Informationen zum Erfolg oder Fehler, außer, die sich das Ereignis in der Regel ist markiert behandelt auf Erfolg. Gründen Fehler wie z. B. die Element-Einstellungen zählen <xref:System.Windows.UIElement.Visibility%2A> einige Wert außer wird <xref:System.Windows.Visibility.Visible>.  
  
 Wenn Sie die Signatur verwenden, der keiner `targetRectangle`, klicken Sie dann die gesamte Elementgröße (seine <xref:System.Windows.UIElement.RenderSize%2A>) sichtbar gemacht.  
  
 Durch Aufruf dieser Methode, rufen Sie möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für alle übergeordneten bildlauffähigen Bereiche, die das Element enthält. Wenn dieses Element nicht in einem bildlauffähigen Bereich enthalten ist das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis dennoch ausgelöst, jedoch werden keine Auswirkungen, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler für eine Anwendungsnavigationsereignis, das bei jedem reagiert die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] navigiert ein Fragment enthält. Das Fragment in den Namen der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] nach dem Nummernzeichen (#), und das implementierte Verhalten bewirkt, dass das Element zum Anzeigen im Rahmen eines Bildlaufs. <xref:System.Windows.FrameworkElement.BringIntoView%2A>und <xref:System.Windows.FrameworkElement.RequestBringIntoView> fordern dieses Bildlaufverhalten im Beispiel.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Angegebene Größe des Elements, das auch in die Ansicht eingebunden werden sollten.</param>
        <summary>Versucht, die bereitgestellte Bereichsgröße dieses Elements in in einem bildlauffähigen Bereiche anzuzeigen, in dem es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufruf dieser Methode, die Sie Heraufstufen einer <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis, das das aktuelle Element stammt. Dieses Ereignis wird ausgelöst, sodass sie vom verarbeitet werden kann ein <xref:System.Windows.Controls.ScrollViewer>, oder eine abgeleitete oder ähnlichen-Klasse. Erwartet, dass das Ereignis wird durch das übergeordnete Element gekennzeichnet in den Daten für das Ereignis behandelt, und die Quelle des Ereignisses in der Ansicht über die Logik in eingebetteten geschaltet wird, wird die <xref:System.Windows.Controls.ScrollViewer> Steuerelement. Weder die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> -Methode übertragen Informationen zum Erfolg oder Fehler, außer, die sich das Ereignis in der Regel ist markiert behandelt auf Erfolg. Gründen Fehler wie z. B. die Element-Einstellungen zählen <xref:System.Windows.UIElement.Visibility%2A> einige Wert außer wird <xref:System.Windows.Visibility.Visible>.  
  
 Wenn Sie die Signatur verwenden, der keiner `targetRectangle`, klicken Sie dann die gesamte Elementgröße (seine <xref:System.Windows.UIElement.RenderSize%2A>) sichtbar gemacht.  
  
 Durch Aufruf dieser Methode, rufen Sie möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für alle übergeordneten bildlauffähigen Bereiche, die das Element enthält. Wenn dieses Element nicht in einem bildlauffähigen Bereich enthalten ist das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis dennoch ausgelöst, jedoch werden keine Auswirkungen, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Im folgenden Beispiel ist eine große Grafik in einem eingeschränkten Bildlaufbereich. Eine Schaltfläche auf der Seite verfügt über ein Handler, der die Sicht auf einen bestimmten Bereich der großen Grafik einen Bildlauf durchführt.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Kontextmenüelement ab bzw. legt das Kontextmenüelement fest, das angezeigt wird, wenn das Kontextmenü über die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aus diesem Element angefordert wird.</summary>
        <value>Das Kontextmenü, das diesem Element zugewiesen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu>selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse, und es ist technisch möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben eine <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft. Allerdings wird ein praktisches Beispiel verwirrend Kontext Menü für den Benutzer erstellt und dieses Vorgehen wird nicht empfohlen.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, unmittelbar bevor ein Kontextmenü für das Element geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um schließende unterdrücken sollte Kontextmenüs, die Handler des Ereignisses es als behandelt markiert.  
  
 Verwenden Sie dieses Ereignis als ein <xref:System.Windows.EventTrigger> in einem Format, müssen Sie den zugrunde liegenden Dienst Definition des Ereignisses verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <xref:System.Windows.FrameworkElement> , macht die zugrunde liegenden Dienstereignis keine Zuordnung ist die <xref:System.Windows.FrameworkElement.ContextMenuClosing> Bezeichner, dass Sie als Auslöser verwendet werden können).  
  
 <xref:System.Windows.Controls.ContextMenu>selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse, aber die <xref:System.Windows.FrameworkElement.ContextMenuClosing> Ereignis wird nicht direkt durch ein Kontextmenü ausgelöst. Stattdessen wird das Ereignis aus dem Element ausgelöst, die im Kontextmenü den Befehl als Eigenschaft "besitzt" und wird nur ausgelöst, wenn ein Benutzer versucht, ein Kontextmenü in der Benutzeroberfläche zu schließen. Ist es jedoch möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben eine <xref:System.Windows.FrameworkElement.ContextMenu%2A> -Eigenschaft (ein geschachteltes Kontextmenü). In diesem Fall die <xref:System.Windows.Controls.ContextMenu> wirklich ausführt, Besitzer der geschachtelten <xref:System.Windows.Controls.ContextMenu> und möglicherweise das Ereignis mit der Quelle des Ereignisses wird der geschachtelten Kontextmenü auslösen.  
  
 Die <xref:System.Windows.Controls.ContextMenu> Klasse selbst hat auch ein ähnliches Ereignis (<xref:System.Windows.Controls.ContextMenu.Closed>), aber die <xref:System.Windows.Controls.ContextMenu.Closed> Ereignis bietet Sie die Gelegenheit, um die Aktion abzubrechen.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Kontextmenü für das Element geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum manuellen Öffnen des Kontextmenüs kennzeichnen Handler für die Ereignisse das betreffende Ereignis als behandelt. Andernfalls, den vorhandenen Wert von der <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft wird verwendet, um automatisch ein Kontextmenü geöffnet. Das Ereignis als behandelt markiert wird die Standardaktion tatsächlich abgebrochen, und möglicherweise Gelegenheit, den Wert zurückgesetzt, die <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft, und öffnen Sie die neue <xref:System.Windows.Controls.ContextMenu>. Es ist jedoch ein Problem der zeitlichen Steuerung, die Sie beachten sollten. Um vollständig ersetzen Sie im Kontextmenü den Befehl über eine <xref:System.Windows.FrameworkElement.ContextMenuOpening> Handler auf, die ursprüngliche Kontextmenü darf nicht null / leer sein. Alternativ müssen Sie das Ereignis zu behandeln und dann manuell ein neues Kontextmenü geöffnet. Weitere Informationen finden Sie unter [wie: Behandeln Sie das ContextMenuOpening-Ereignis](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Verwenden Sie dieses Ereignis als ein <xref:System.Windows.EventTrigger> in einem Format müssen Sie das zugrunde liegende angefügte Ereignis verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <xref:System.Windows.FrameworkElement> , macht die zugrunde liegenden Dienstereignis keine Zuordnung ist die <xref:System.Windows.FrameworkElement.ContextMenuOpening> Bezeichner, dass er in Triggern verwenden zu können).  
  
 <xref:System.Windows.Controls.ContextMenu>selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse, aber dieses Ereignis wird nicht aus dem Kontextmenü geöffnet, die als Quelle ausgelöst werden. Das Ereignis wird vom Element ausgelöst, die im Kontextmenü den Befehl als Eigenschaft "besitzt" und wird nur ausgelöst, wenn ein Benutzer versucht, ein Kontextmenü geöffnet, in der Benutzeroberfläche. Es ist möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben eine <xref:System.Windows.FrameworkElement.ContextMenu%2A> -Eigenschaft, aber Sie sollten dieses Szenario vermeiden (Einzelheiten finden Sie in <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 Die <xref:System.Windows.Controls.ContextMenu> Klasse selbst hat auch ein ähnliches Ereignis (<xref:System.Windows.Controls.ContextMenu.Opened>) aber <xref:System.Windows.Controls.ContextMenu.Opened> bietet Sie die Gelegenheit, um die Aktion abzubrechen.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ContextMenu" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</summary>
        <value>Der anzuzeigende Cursor. Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <see langword="null" /> definiert. Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft festlegen, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor basiert auf typkonvertierung für die <xref:System.Windows.Input.Cursor> Klasse, um die Zeichenfolge ergeben. Die bereitgestellte Zeichenfolge ergeben sollten eine <xref:System.Windows.Input.CursorType> Wert. Ausführliche Informationen finden Sie unter <xref:System.Windows.Input.Cursor>.  
  
 Ob der von dieser Eigenschaft festgelegte Cursor werden oder wird nicht angezeigt, wenn der Mauszeiger über diesem Element befindet ist auch abhängig von den Wert der <xref:System.Windows.FrameworkElement.ForceCursor%2A> Eigenschaft. Darüber hinaus wirkt ereignisbezogene Faktoren, z. B. ein aktives ziehen, Mauseingaben aufzufangen, Textbearbeitung-Modi im Steuerelemente usw., den Cursor mit einer höheren Priorität als der Wert sich auch, die Sie in dieser Eigenschaft angeben.  
  
 Wenn Sie das Verhalten der Einstellung dieser Eigenschaft auf den tatsächlichen Standardwert zurücksetzen möchten, legen Sie es auf `null` erneut aus.  
  
 Die `null` Standard wirklich bedeutet, dass Bestimmung des Werts praktische Cursor hier verzögert, und von einer anderen Stelle abgerufen werden soll. Programmgesteuerte Werte aus beliebigen Quellen beschrieben wird, den Standardcursor also visuell über eine [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Anwendung wird ein Pfeil sein. Der vorübergehenden Cursor geändert werden jedoch nicht festgelegt, um die <xref:System.Windows.FrameworkElement.Cursor%2A> Werte der Elemente, wenn sie über übergeben werden. Die <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft wird nur Null-Werte in Fällen, in denen es tatsächlich, z. B. durch Code oder einem Stil festgelegt wurde. Jeder Bewegung der Maus über ein [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung löst eine <xref:System.Windows.UIElement.QueryCursor> Ereignis. Die Ereignis-Blasen und jedes Element entlang der Route erhält die Möglichkeit, die für die Ereignisbehandlung und zum Festlegen des Werts, der den Cursor über die Argumente für dieses Ereignis. Dies ist der Mechanismus, der den sichtbaren Cursor in den meisten Fällen erzeugt. Wenn eine <xref:System.Windows.UIElement.QueryCursor> Handler gibt eine Cursorergebnis zurück, und klicken Sie dann die Tatsache, dass das Ereignis behandelt wird und einen geänderten Wert in den Argumenten hat Vorrang vor den Wert des der <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft auf jeder Ebene, es sei denn, <xref:System.Windows.FrameworkElement.ForceCursor%2A> festgelegt ist.  
  
 Wenn Sie keinen benutzerdefinierten Cursor erstellen, Sie in der Regel legen Sie diese Eigenschaft auf eine statische Eigenschaft-Wert, der die <xref:System.Windows.Input.Cursors> Klasse. Festlegen von <xref:System.Windows.FrameworkElement.Cursor%2A> im Code erfordert einen der folgenden:  
  
-   Rufen Sie die <xref:System.Windows.Input.Cursor> Konstruktor zum Abrufen einer <xref:System.Windows.Input.Cursor> Instanz. Beide Signaturen der <xref:System.Windows.Input.Cursor> Konstruktor verwenden, Streams oder Dateien, die Sie erstellen die <xref:System.Windows.Input.Cursor> Objekt für einen benutzerdefinierten Cursor.  
  
-   Verwenden der <xref:System.Windows.Input.CursorConverter> Klasse und ihre <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> Methode, um einen Cursor durch angeben <xref:System.Windows.Input.CursorType>, oder eine Zeichenfolge, die zum Auswerten kann eine <xref:System.Windows.Input.CursorType>, und die Rückgabe in <xref:System.Windows.Input.Cursor>.  
  
 Festlegen der <xref:System.Windows.Input.Cursor> auf einen benutzerdefinierten Wert ist bei teilweiser Vertrauenswürdigkeit nicht aktiviert. Weitere Informationen zu benutzerdefinierten Cursor finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Grafik Cursor absichtlich festgelegt wird.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Cursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</summary>
        <value>Das Objekt, das als Datenkontext verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Datenkontext* ist ein Konzept, das kann Elemente Informationen von ihren übergeordneten Elementen der Datenquelle zu erben, die für die Bindung als auch andere Merkmale der Bindung, z. B. den Pfad verwendet wird.  
  
 Datenkontext kann direkt festgelegt werden, ein [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Objekt, mit den Bindungen, die als Eigenschaften des betreffenden Objekts bewertet. Alternativ können Sie den Datenkontext festlegen, um eine <xref:System.Windows.Data.DataSourceProvider> Objekt.  
  
 Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte. Wenn untergeordnete ohne andere Werte für Elemente <xref:System.Windows.FrameworkElement.DataContext%2A> über die lokalen Werte oder Formatvorlagen, hergestellt werden, und dann das Eigenschaftensystem den Wert festgelegt wird der <xref:System.Windows.FrameworkElement.DataContext%2A> Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen.  
  
 Alternativ können Sie eine der folgenden Eigenschaften von der <xref:System.Windows.Data.Binding> Klasse, um die Bindungsquelle explizit anzugeben: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, oder <xref:System.Windows.Data.Binding.RelativeSource%2A>. Weitere Informationen finden Sie unter [Vorgehensweise: Angeben der Bindungsquelle](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkElement.DataContext%2A> i. d. r. auf festgelegt ist, als ein <xref:System.Windows.Data.Binding> Deklaration. Sie können Eigenschaftenelementsyntax oder Attributsyntax verwenden. Die Attributsyntax wird im Beispiel auf dieser Seite angezeigt. Sie können auch Code festlegen <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A>ist eine bindbare Eigenschaft, um Szenarien zu ermöglichen, in einem Kontext zu einem anderen gebunden werden kann. Jedoch wenn Sie zum Binden <xref:System.Windows.FrameworkElement.DataContext%2A>, achten Sie darauf, dass Sie keine zirkulären Bindungsverweise erstellen (Binden keine <xref:System.Windows.FrameworkElement.DataContext%2A> auf sich selbst, dies ist möglich, führen Sie aufgrund der Eigenschaft Wert Vererbung von der <xref:System.Windows.FrameworkElement.DataContext%2A> Eigenschaft).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *dataContextObject*  
 Eine direkte eingebettetes Objekt, das als Datenkontext für alle Bindungen innerhalb des übergeordneten Elements dient. Dieses Objekt in der Regel ist eine <xref:System.Windows.Data.Binding> oder ein anderes <xref:System.Windows.Data.BindingBase> abgeleitete Klasse. Alternativ können Sie unformatierten Daten eines beliebigen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Objekttyp vorgesehen für die Bindung mit den tatsächlichen Bindungen später definiert hier platziert werden kann.  
  
 *bindingUsage*  
 Eine Bindungsverwendung, die einen entsprechenden Datenkontext ergibt. Weitere Informationen finden Sie unter [Binding als Markuperweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Eines der folgenden: oder. Diese Verwendung wird verwendet, bei Bezugnahme auf unformatierten Daten als ein Objekt in Ressourcen definiert. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Der Schlüsselbezeichner für das Objekt, das angefordert wird, innerhalb einer <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Datenkontext für eine Bindung fungiert und enthält Informationen, die die spezifischen Werte gebundener Eigenschaften definiert.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Datenkontext für dieses Element geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Erläuterung der Datenkontexten und Datenbindung, finden Sie unter [Übersicht zur Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Wenn die <xref:System.Windows.FrameworkElement.DataContext%2A> für ein Element ändert, alle datengebundenen Eigenschaften für dieses Element sind möglicherweise betroffen. Dies gilt für alle Elemente, die untergeordnete Elemente des aktuellen Elements in der logischen Struktur sind, die den Datenkontext zu erben, und auch das aktuelle Element selbst. Solche vorhandenen Bindungen müssen erneut das neue interpretieren <xref:System.Windows.FrameworkElement.DataContext%2A> und wird neu Auswerten der Bindungsergebnisse. Das Datenbindungsmodul ist nicht deterministisch zur Reihenfolge der erneuten Auswertung relativ zum Auslösen des der <xref:System.Windows.FrameworkElement.DataContextChanged> Ereignis. Der erneuten Auswertung können vor dem Ereignis nach dem Ereignis oder eine beliebige Mischung auftreten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DataContext" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schlüssel ab, der zum Referenzieren der Formatvorlage für dieses Steuerelement verwendet werden soll, wenn Designformatvorlagen verwendet werden oder definiert sind.</summary>
        <value>Der Formatvorlagenschlüssel. Damit er als Teil der Designformatvorlagen-Suche ordnungsgemäß funktioniert, wird erwartet, dass dieser Wert der <see cref="T:System.Type" /> des Steuerelements ist, das formatiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird in der Regel nicht über einen ihrer direkten Eigenschaftenaccessoren festgelegt. Stattdessen überschreiben Sie die typspezifischen Metadaten dieser Abhängigkeitseigenschaft jedes Mal, wenn Sie ein neues erstellen <xref:System.Windows.FrameworkElement> abgeleitete Klasse. Aufrufen, wenn Sie ein Steuerelement ableiten, die <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode für die <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> Bezeichner, der statische Konstruktor des Steuerelements abgeleitet-Klasse (oder entsprechende klasseninitialisierung).  
  
 Ein Steuerelement in der Regel überschreibt den Standardwert dieser Eigenschaft auf einen eigenen Typ sein, aber in einigen Fällen könnte auch verwenden einen Basistyp für den ein Stils im Design "Wörterbücher vorhanden ist. Dies ist nur geeignet, wenn die Steuerelementvorlagen des Basissteuerelements die visuelle Darstellung des abgeleiteten Steuerelements vollständig definieren und beliebige zusätzliche Elemente, die die abgeleiteten Typen verfügbar machen keine zusätzlichen Elemente im Rahmen der Steuerelementvorlage erforderlich sind.  
  
 Wenn Sie ein Element oder Steuerelement Designformatvorlagen absichtlich nicht verwenden möchten, legen Sie die <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> Eigenschaft `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der Abhängigkeitseigenschaft-Metadaten Außerkraftsetzung in den Hinweisen erläutert. Dieser Code definiert eine benutzerdefinierte Steuerelementklasse `NumericUpDown` über eine dedizierte Bibliothek Steuerelementassembly verwendet werden soll. Der veranschaulichte statische Konstruktor verweist auf einige private Initialisierungsfunktion, registriert einen Klassenhandler (ein weiteres gängiges Szenario zum Erstellen von Unterklassen; Siehe [Routingereignisse als bearbeitete sowie die Behandlung von Klasse markieren](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) und schließlich überschreibt die <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Abhängigkeitseigenschaft-Metadaten für die `NumericUpDown` Klasse. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>Gibt immer einen eigenen Typ als beabsichtigten Schlüssel, also die Konvention, die das Design-Stil-System verwendet wird, um den Stil für ein beliebiges ansonsten nicht formatiertes Steuerelement nachzuschlagen zurück. Das vollständige Beispiel definiert auch das tatsächliche Steuerelement Design-Stil, die durch diesen Schlüssel verwiesen wird. finden Sie unter [benutzerdefiniertes NumericUpDown-Steuerelement mit Unterstützung von Design und Automatisierung](http://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  
[!code-csharp[CustomControlNumericUpDown#Close](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#close)]
[!code-vb[CustomControlNumericUpDown#Close](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#close)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, dass der Initialisierungsprozess für das Element abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> zuvor aufgerufen wurde, die Base Implementierung löst die <xref:System.Windows.FrameworkElement.Initialized> Ereignis. Andernfalls gilt: Wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> nicht aufgerufen wurde oder es konnte nicht bestimmt, ob <xref:System.Windows.FrameworkElement.BeginInit%2A> aufgerufen wurde, <xref:System.Windows.FrameworkElement.Initialized> wird nicht ausgelöst, und es wird stattdessen eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.FrameworkElement.EndInit" />wurde aufgerufen, ohne <see cref="M:System.Windows.FrameworkElement.BeginInit" /> für das Element zuvor aufgerufen wurde.</exception>
        <block subset="none" type="overrides">
          <para>Implementieren Sie diese Methode, um eine besondere Behandlung bereitstellen, die erfolgen soll, wenn das Element während der Prozess des Ladens Element initialisiert wird.  
  
 Die Implementierung sollte die basisimplementierung aufrufen, da die Implementierung Base (Standard) einige interne Flags Initialisierung des festlegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des angeforderten Elements.</param>
        <summary>Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</summary>
        <returns>Das angeforderte Element. Dies ist möglich <see langword="null" /> , wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Element untergeordnete Elemente verfügt, werden diese untergeordneten Elemente rekursiv nach dem angeforderten benannten Element durchsucht.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A>innerhalb des aktuellen Elements Namensbereich arbeitet. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner für die angeforderte Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</summary>
        <returns>Die angeforderte Ressource. Wenn keine Ressource mit dem angegebenen Schlüssel gefunden wurde, wird eine Ausnahme ausgelöst. Ein <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> Wert möglicherweise auch bei einer Ausnahme zurückgegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel, die nicht gefunden werden kann aufrufen, wird eine Ausnahme ausgelöst. Wenn Sie nicht möchten, um Ausnahmen zu behandeln, die durch Aufruf von <xref:System.Windows.FrameworkElement.FindResource%2A>, rufen Sie <xref:System.Windows.FrameworkElement.TryFindResource%2A> stattdessen. <xref:System.Windows.FrameworkElement.TryFindResource%2A>Gibt `null` Wenn eine angeforderte Ressource wurde nicht gefunden, und löst keine Ausnahme.  
  
 Wenn die Ressource für das aufrufende Element nicht gefunden wird, ist das übergeordnete Element in der logischen Struktur gesuchte weiter, und klicken Sie dann Anwendung, und klicken Sie dann Designs und schließlich Systemressourcen verfügbar sind. Diese Suchmethodik ist identisch mit die Struktur wie durchsucht wird, wenn eine Ressource durch einen dynamischen Ressourcenverweis in Markup angefordert wurden. Weitere Informationen zu der Ressourcensuche, finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 In der Regel wird Sie sofort Umwandeln einer <xref:System.Windows.FrameworkElement.FindResource%2A> Rückgabewert in den Typ der Eigenschaft, die Sie mit dem zurückgegebenen Ressourcenwert festlegen.  
  
 / / Ressourcenschlüssel sind nicht unbedingt Zeichenfolgen. Formatvorlagen, z. B. für Steuerelemente auf der Designebene an absichtlich gebunden sind, werden die <xref:System.Type> des Steuerelements und der Anwendung oder die Seite Stile für Steuerelemente in der Regel dadurch verwenden dieselbe Schlüssel Konvention. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md) oder [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Im folgenden Beispiel ruft eine benannte Ressource ab und wandelt es in einen geeigneten Typ eine Eigenschaft ausgefüllt werden.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" />wurde nicht gefunden und ein Ereignishandler ist nicht vorhanden, für die <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> Ereignis.  
  
 - oder -   
  
 <paramref name="resourceKey" />wurde nicht gefunden und der <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> Eigenschaft <see langword="false" /> in die <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> Ereignis.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt der Richtung, in die Text und andere [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] -Elemente innerhalb von übergeordneten Elementen, die ihr Layout steuern fließen.</summary>
        <value>Die Richtung, in die Text und andere [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] -Elemente in ihrem übergeordneten Element fließen, als Wert der Enumeration. Der Standardwert ist <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Abhängigkeit Nutzung Eigenschaftensätze der <xref:System.Windows.FrameworkElement.FlowDirection%2A> für dieses Element. Aufgrund der Vererbung von Eigenschaftenwerten, Festlegen von <xref:System.Windows.FrameworkElement.FlowDirection%2A> für ein Element kann potenziell festgelegt <xref:System.Windows.FrameworkElement.FlowDirection%2A> auf alle untergeordneten Elemente, die nicht festgelegt <xref:System.Windows.FrameworkElement.FlowDirection%2A> lokal oder über andere Methoden wie z. B. Stile.  
  
 Diese Eigenschaft wird nicht automatisch als Teil jeder Anwendungsinformationen Kultur festgelegt, da ein Element Inhalte enthalten kann, die nicht unbedingt die allgemeine flussrichtung impliziert durch die kulturinformationen unterliegen soll. Weitere Informationen zu Überlegungen zur Globalisierung, finden Sie unter [Globalisierung für WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Diese Eigenschaft hat ein definiertes [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Eigenschaftenaccessor, damit es als eine Abhängigkeitseigenschaft fungiert. Allerdings ist es auch als registriert angefügt, sodass auch als angefügte Eigenschaft eingesetzt werden können. Die angefügte Registrierung wird hauptsächlich, damit die Vererbung von Eigenschaftenwerten wird unterstützt, aber die Eigenschaft auch als "true" angefügten Eigenschaft verwendet werden kann. Verwendung als angefügte Eigenschaft ist nur relevant, wenn das Objekt, das Sie auf die flussrichtung festlegen möchten hat eine <xref:System.Windows.FrameworkElement> übergeordneten Elements, das Layout, führt selbst keine wird eine <xref:System.Windows.FrameworkElement>, und noch nicht mehr direkt definierten `FlowDirection` Diese Eigenschaft. (Einige des Flusses dokumentieren Klassen wie z. B. <xref:System.Windows.Documents.Block> und <xref:System.Windows.Documents.Inline> definieren Sie ihre eigenen `FlowDirection`, und diese Eigenschaft kann auch die flussrichtung festgelegt. Der Eigenschaftswert wird dann durch den Inhaltshost gelesen ohne Verwendung der angefügten Eigenschaft.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 \<*Objekt* **FlowDirection**= "<xref:System.Windows.FlowDirection>" / >  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Diese Eigenschaft kann auch für Klassen, die nicht festgelegt werden <xref:System.Windows.FrameworkElement> abgeleitete Klassen, durch die folgende [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Verwendung für angefügte Eigenschaft:  
  
 `<`*Objekt* `FrameworkElement.` **FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Diese Eigenschaft ist eine Abhängigkeitseigenschaft und einer angefügten Eigenschaft. finden Sie unter "Hinweise".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen einer Eigenschaft, die die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</summary>
        <value>Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält. Die in der Abhängigkeitseigenschaft deklarierte Standardwert ist eine leere statische <see cref="T:System.Windows.Style" />. Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wirkt sich auf die visuelle Darstellung, aber gibt keine Auskunft über <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> in Metadaten. Dies ist, da die visuelle Darstellung eine ereignisgesteuerte ist möglicherweise nicht zu allen Zeiten gelten und aus diesem Grund nicht in der Regel Visualisierung oder Layout Informationen in den Metadaten melden sollten.  
  
 Grundsätzlich sollte das visuelle Verhalten des Fokus auf ein Steuerelement angewendet kohärente von Steuerelement zu Steuerelement sein. Die sinnvollste zum Erzwingen von Kohärenz besteht darin, den visuellen Stil der Fokus nur ändern, wenn Sie ein vollständiges Design erstellen. Festlegen dieser Eigenschaft auf einzelne Steuerelementtypen und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da sie zu einer verwirrend Benutzeroberfläche hinsichtlich des Tastaturfokus führen kann. Wenn Sie für das Steuerelement spezifische Verhalten, die absichtlich nicht kohärent ist beabsichtigt, wird ein viel besserer Ansatz im Stile für einzelne Eingabestatus-Eigenschaften, z. B. Verwenden von Triggern <xref:System.Windows.UIElement.IsFocused%2A> oder <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, und klicken Sie auf eine Weise dazu, die nicht der Fall ist beeinträchtigen Sie mit den visuellen Stil des vorhandenen Fokus visuell. Weitere Informationen über den Entwurf der <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> sowie die alternativen Eigenschaften zu konzentrieren, finden Sie unter [Formatierung für den Fokus in Steuerelementen und FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eines der folgenden:, oder. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der den angeforderten Stil identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert. Finden Sie unter [Inlinestile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Eine Bindung verwendet oder <xref:System.Windows.Data.Binding> ist auch möglich, aber ungewöhnlich.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob dies <see cref="T:System.Windows.FrameworkElement" /> erzwingen soll die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Rendern des Cursors gemäß Deklaration durch die <see cref="P:System.Windows.FrameworkElement.Cursor" /> Eigenschaft.</summary>
        <value>
          <see langword="true" />Cursor-Präsentation, während er sich über diesem Element erzwungen wird, mit der aktuellen <see cref="P:System.Windows.FrameworkElement.Cursor" /> Einstellungen für den Cursor (einschließlich auf alle untergeordneten Elemente); andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft, um festlegen `true` setzen Sie die Cursor Voreinstellungen in untergeordneten Elementen hergestellt. Dies ist daher im Allgemeinen Anwendung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] sind möglicherweise für den Benutzer verwirrend, insbesondere, wenn untergeordnete Cursor angeben möchten. Festlegen von <xref:System.Windows.FrameworkElement.ForceCursor%2A> Unterklassen oder Compositing Szenarios besser geeignet ist.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Cursor-Wert.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ForceCursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Das Ziel <see cref="T:System.Windows.DependencyProperty" /> zum Abrufen der Bindung aus.</param>
        <summary>Gibt die <see cref="T:System.Windows.Data.BindingExpression" /> , die Bindung für die angegebene Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Windows.Data.BindingExpression" /> , wenn die Zieleigenschaft über eine aktive Bindung verfügt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überprüfen des Rückgabewerts für `null` ist eine Technik können Sie bestimmen, ob eine Eigenschaft eine aktive Bindung verfügt.  
  
 Diese Methode ist genau genommen nur ein Hilfswrapper um die <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> Methode. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A>übergibt die aktuelle Instanz und die `dp` Parameter <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das zurückzugebende Element eine <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> für.</param>
        <summary>Ruft den Wert der <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> angefügte Eigenschaft für den angegebenen <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Die angeforderte Flussrichtung als Wert der Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptzweck dieser Methode wird zur Unterstützung der Syntax für angefügte Eigenschaften der <xref:System.Windows.FrameworkElement.FlowDirection%2A> -Eigenschaft untergeordneten Elemente eines bereitgestellten <xref:System.Windows.FrameworkElement> flussrichtung für die Anordnung in ihrem übergeordneten Element an. Um den Wert abzurufen, auf dem aktuellen <xref:System.Windows.FrameworkElement>, verwenden Sie die direkte [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Die Größe des Teils des Elements, das die visuelle Darstellung durchführt.</param>
        <summary>Gibt eine Geometrie für Freistellungsmaske zurück. Die Maske gilt, wenn das Layoutsystem versucht, ein Element anzuordnen, das größer als der verfügbare Speicherplatz.</summary>
        <returns>Die Clippinggeometrie zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ränder subtrahiert die `layoutSlotSize` im Rahmen des Systemverhalten Layout.  
  
 Ein zurückgegebener null-Verweis gibt an, dass keine Clipping auftreten. Gibt die standardmäßige Implementierung immer `null` Wenn <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false`. Diese Methode überschreibt <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. Die <xref:System.Windows.FrameworkElement> Implementierung verwendet <xref:System.Windows.FrameworkElement.MaxHeight%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A> in den Berechnungen. Mehrere Unterklassen von <xref:System.Windows.FrameworkElement> überschreiben diese Methode erneut. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, überschreibt immer Return `null` da Adorner häufig absichtlich außerhalb der üblichen Grenzen sind. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType>und <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> zurückgeben `null` Wenn <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Gibt die standardmäßige Implementierung immer <see langword="null" /> Wenn <see cref="P:System.Windows.UIElement.ClipToBounds" /> ist <see langword="false" />. Außerkraftsetzungen werden in der Regel auf dieses Verhalten beizubehalten erwartet, allerdings stehen die Ausnahmen, abhängig von der Beziehung und den Zweck der abgeleiteten Klasse und ihre Layoutlogik im Gegensatz zu der Basisklasse.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Der Name des untergeordneten Elements gefunden.</param>
        <summary>Gibt das benannte Element in der visuellen Struktur der instanziierten <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>Das angeforderte Element. Möglicherweise <see langword="null" /> , wenn kein Element mit dem angeforderten Namen vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorlagen in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] besitzen einen Self-Namensbereich. Dies ist daran, dass Vorlagen erneut verwendet und in einer Vorlage definierte Namen nicht eindeutig bleiben, wenn mehrere Instanzen eines Steuerelements die Vorlage instanziiert wird. Rufen Sie die <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Methode, um Verweise auf Objekte zurückzugeben, die aus der Vorlage stammen, nachdem er instanziiert wird. Können Sie keine der <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> Methode, um Elemente in Vorlagen suchen, da <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> verhält sich auf ein allgemeinerer Bereich, und es besteht keine Verbindung zwischen der <xref:System.Windows.Controls.ControlTemplate> -Klasse selbst und die Vorlage instanziiert, sobald es angewendet wird.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>Stellt die gleiche Funktion wie diese Methode. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>Öffentliche anstelle von geschützt ist und richtig Namen Bereichsdefinition Aspekte, die ihm ermöglichen, die Zugriff auf die Vorlage in einem Element und das Suchen, die mit dem Namen Elemente im verwendet. Verwendung <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Wenn Sie ein Element außerhalb des übergeordneten Steuerelements abrufen müssen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist.</summary>
        <returns>Gibt <see langword="null" /> immer eine WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Die Standardeinstellung <xref:System.Windows.FrameworkElement> Implementierung gibt die erwarteten einzelne visuelle übergeordnetes, also das gleiche Ergebnis wie das Abrufen der <xref:System.Windows.FrameworkElement.Parent%2A> Wert. Implementierungen der abgeleiteten Klasse möglicherweise alternative übergeordnete Beziehungen zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des angeforderten untergeordneten Elements in der Auflistung.</param>
        <summary>Überschreibt <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />, und gibt ein untergeordnetes Element am angegebenen Index aus einer Auflistung von untergeordneten Elementen zurück.</summary>
        <returns>Das angeforderte untergeordnete Element. Dies sollte keine zurückgeben <see langword="null" />; der angegebene Index ist von Bereichs liegt, wird eine Ausnahme ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der <xref:System.Windows.FrameworkElement> Implementierung, die einzigen gültigen Index ist 0 (null). Das Inhaltsmodell für <xref:System.Windows.FrameworkElement.GetVisualChild%2A> unterstützt entweder NULL oder ein untergeordnetes Element, aber keine Auflistung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein benutzerdefinierter Adorner deklariert, indem Werte verwendet eine <xref:System.Windows.Media.VisualCollection> , die er verwaltet, der mehrere visuellen untergeordneten Elemente. Diese Werte werden über Außerkraftsetzungen der gemeldete <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Diese Implementierung ist nur gültig für Elemente, die nicht mit eine aussagekräftigere Sammlung der sichtbaren untergeordneten Elemente verfügen. Jedes Element, das eine solche Auflistung verfügt, muss diese Methode überschreiben und ordnen Sie den Index auf einen entsprechenden Index in der Auflistung der untergeordneten Elemente, die durch dieses Element unterstützt wird. Ein Index im Bereich von 0 bis <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (minus eins) sollte ein gültiges Element; zurückgeben anderer Indizes sollten eine außerhalb des Bereichs-Ausnahme auslösen. Ein Beispiel für einen Elementtyp, der eine Auflistung untergeordneter unterstützt und überschreibt <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> ist mehr als einen möglichen untergeordneten zurückzugebenden <see cref="T:System.Windows.Controls.Panel" />.  
  
 Die standardmäßige Implementierung in <see cref="T:System.Windows.FrameworkElement" /> wird nur einen untergeordneten visuellen vorausgesetzt. Jeder Wert für die <paramref name="index" /> als NULL festgelegt, wird eine Ausnahme ausgelöst wird. Mehrere gemeinsame Elemente, z. B. Decorators, Adorner oder Elemente mit spezialisierten Renderern, überschreiben die <see cref="T:System.Windows.FrameworkElement" /> Implementierung (von der Implementierung von intermediate Basisklassen). Einige Implementierungen Erzwingen einer untergeordneten visuellen weiterhin, während der andere eine Auflistung können.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vorgeschlagene Höhe des Elements ab oder legt sie fest.</summary>
        <value>Die Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A>ist eine der drei schreibbaren Eigenschaften von <xref:System.Windows.FrameworkElement> angeben, dass Höheninformationen zu. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Wenn entsteht ein Konflikt zwischen diesen Werten, die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe ist, die erste <xref:System.Windows.FrameworkElement.MinHeight%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und schließlich ist innerhalb der Grenzen, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Wenn dieses Element ein untergeordnetes Element in einem anderen Element ist, wird das Festlegen dieser Eigenschaft auf einen Wert tatsächlich nur jeweils einen vorgeschlagenen Wert. Das Layoutsystem sowie die bestimmten Layoutlogik des übergeordneten Elements wird den Wert als nicht bindende Eingabe während der Layoutprozess verwenden. Praktisch ein <xref:System.Windows.FrameworkElement> ist fast immer das untergeordnete Element des etwas anderes; auch beim Festlegen der <xref:System.Windows.FrameworkElement.Height%2A> auf <xref:System.Windows.Window>. (Für <xref:System.Windows.Window>, dieser Wert wird verwendet, wenn das zugrunde liegende Anwendungsmodell die grundlegende Darstellung Annahmen hergestellt wird, der das Hwnd erstellen, die Anwendung gehostet.)  
  
 Zusätzlich zu den akzeptablen <xref:System.Double> Werte, die diese Eigenschaft kann auch sein <xref:System.Double.NaN?displayProperty=nameWithType>. Dies ist, wie Sie die automatische Größenanpassungsverhalten im Code angeben. In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sie legen den Wert der Zeichenfolge "Für" automatisch"(Groß-/Kleinschreibung beachten) um das automatische Größenanpassungsverhalten zu aktivieren. Das automatische Größenanpassungsverhalten impliziert, dass das Element der verfügbaren Höhe ausgefüllt werden. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte über ihre Design Standardstile, die deaktiviert wird, das automatische Größenanpassungsverhalten bereitstellen, es sei denn, es explizit erneut aktiviert wird.  
  
 Der Rückgabewert dieser Eigenschaft ist immer mit dem jeder Wert, der darauf festgelegt wurde. Im Gegensatz dazu ist der Wert, der die <xref:System.Windows.FrameworkElement.ActualHeight%2A> abweichen. Dies kann folgende Ursachen entweder statisch das Layout die vorgeschlagene Größe aus irgendeinem Grund abgelehnt oder vorübergehend. Das Layoutsystem selbst funktioniert asynchron relativ zu dem Eigenschaftensystem Satz von <xref:System.Windows.FrameworkElement.Height%2A> und möglicherweise nicht verarbeitet, insbesondere die Änderung noch Größe.  
  
 Die Beschränkungen auf der <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
 Zusätzlich zu die Überprüfung ist es eine nicht deterministische obere Grenze für den Wert <xref:System.Windows.FrameworkElement.Height%2A> , die vom Layoutsystem erzwungen wird (Dies ist eine sehr große Anzahl, die größer als <xref:System.Single.MaxValue?displayProperty=nameWithType> jedoch kleiner als <xref:System.Double.MaxValue?displayProperty=nameWithType>). Wenn Sie diese Grenze überschreiten, das Element wird nicht gerendert werden, und keine Ausnahme ausgelöst wird. Stellen Sie keine <xref:System.Windows.FrameworkElement.Height%2A> auf einen Wert, der ist wesentlich größer als die maximale Größe einer möglichen visuelle Anzeige, oder wenn Sie diese nicht deterministisch Obergrenze überschreiten darf.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
 **Auto**  
 Ermöglicht automatisches Anpassen der Größe Verhalten. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Height" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine Einstellung für horizontale Ausrichtung als Wert der Enumeration. Die Standardeinstellung ist <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaften für ein Element explizit festgelegt sind, diese Maße dauern höherer rangfolgenposition während des Layouts und typische Auswirkungen der Einstellung werden abgebrochen <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> auf <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>ist die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaftenaccessor für was in Wirklichkeit eine Abhängigkeitseigenschaft ist. Diese bestimmte Abhängigkeitseigenschaft verfügt relativ häufig Objektwerts offensichtlich "Default" anders untergeordnetes Elementen führen, insbesondere für Steuerelemente festlegen. Dieser Vorgang erfolgt normalerweise in einer von zwei Methoden: die Abhängigkeitseigenschaft wird erneut registriert werden, um eine bestimmte Unterklasse jedoch über unterschiedliche Metadaten zum Festlegen der Standardwerte oder es ist ein Standardformat angewendet wird, der Wert dieser Abhängigkeitseigenschaft unterschiedlich festlegt. Z. B. die offensichtlichen "Default" der <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> für eine <xref:System.Windows.Controls.Label> Steuerelement <xref:System.Windows.HorizontalAlignment.Left>, obwohl <xref:System.Windows.Controls.Label> erbt <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> direkt von <xref:System.Windows.FrameworkElement>. Dies ist, da dieser Wert, in den Standardstil der zurückgesetzt wurde <xref:System.Windows.Controls.Label>, innerhalb der Style-Steuerelementvorlage.  
  
 <xref:System.Windows.Controls.Canvas>verwendet keinen <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> beim Erstellen des Layouts, da <xref:System.Windows.Controls.Canvas> absolute Positionierung basiert.  
  
 Wenn von geerbt <xref:System.Windows.Controls.Label> oder abgeleiteten Klassen, <xref:System.Windows.Controls.Label> definiert den Standardwert dieser Abhängigkeitseigenschaft werden <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Bereichsgrenzen für die Vererbung von Eigenschaftenwerten Schlüsselsuche Ressource und RelativeSource FindAncestor-Suche.</summary>
        <value>Ein Wert aus der Enumeration. Die Standardeinstellung ist <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Grenzen in der Struktur Satz <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> zum absichtlich begrenzen des Bereichs der Vererbungsverhalten in eine Ressourcensuche erzwingen, um den Anwendungsressourcen zu überprüfen oder um zu verhindern, dass eine Suche RelativeSource FindAncestor Abfragen das aktuelle Element oder Weiter. RelativeSource FindAncestor-Suche tritt auf, wenn eine Bindung verwendet ein <xref:System.Windows.Data.RelativeSource> , besitzt die <xref:System.Windows.Data.RelativeSource.Mode%2A> -Eigenschaftensatz auf die <xref:System.Windows.Data.RelativeSourceMode?displayProperty=nameWithType> Wert.  
  
 Wenn die abgeleitete Klasse, um diese Eigenschaft festgelegt werden soll, sollten Sie in den statischen Konstruktor oder einem anderen Initialisierungsroutinen tun.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dies <see cref="T:System.Windows.FrameworkElement" /> initialisiert wird. Dieses Ereignis bei Fällen mit einer Zeitangabe, in dem der Wert von der <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> Eigenschaft ändert sich von <see langword="false" /> (oder nicht definiert) zu <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.FrameworkElement.EndInit%2A> oder <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> Methoden aufgerufen werden. Aufrufen einer dieser Methoden können gekommen, aus dem Anwendungscode oder über die [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Prozessorverhalten bei einem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite verarbeitet wird.  
  
 Gibt an, ob Sie behandeln möchten <xref:System.Windows.FrameworkElement.Loaded> oder <xref:System.Windows.FrameworkElement.Initialized> hängt von Ihren Anforderungen. Wenn Sie nicht benötigen, Lesen von Elementeigenschaften, Eigenschaften zurücksetzen möchten, und brauchen keine Layoutinformationen <xref:System.Windows.FrameworkElement.Initialized> möglicherweise-Ereignis zu reagieren. Wenn Sie alle Eigenschaften des Elements verfügbar sein, und Sie Eigenschaften, die wahrscheinlich das Layout zurücksetzen festlegen <xref:System.Windows.FrameworkElement.Loaded> möglicherweise-Ereignis zu reagieren. Achten Sie auf erneutes eintreten, wenn der Handler setzt alle Eigenschaften zurück, die vom Layoutsystem bedeutet, dass eine neue Layoutdurchlauf erforderlich ist interpretiert werden. (Möglicherweise müssen Sie überprüfen die <xref:System.Windows.FrameworkPropertyMetadata> übergeben von Werten für die Eigenschaft, wenn Sie nicht genau wissen, welche Eigenschaften ein neues Layout erforderlich sind, wenn sie geändert wurden.)  
  
 Weitere Informationen zur Reihenfolge von Objektereignissen für eine <xref:System.Windows.FrameworkElement>, und auch mehrere verwandte Elementklassen zur Anwendungs- und finden Sie unter [Lebensdauer Objektereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Kontext für die Eingabe verwendet, die von diesem <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden. Der Standardwert ist <see langword="null" /> (führt zu einer Standardbehandlung von Befehlen).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte. Wenn untergeordnete ohne andere Werte für Elemente <xref:System.Windows.FrameworkElement.InputScope%2A> über die lokalen Werte oder Formatvorlagen, hergestellt werden, und dann das Eigenschaftensystem den Wert festgelegt wird der <xref:System.Windows.FrameworkElement.InputScope%2A> Wert für das nächste übergeordnete Element mit diesem Wert zugewiesen.  
  
 Obwohl eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax Verwendung aufgelistet ist und syntaktisch zulässig ist, wird durch Festlegen dieser Eigenschaft [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ist nicht üblich.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.InputScope" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob dieses Element initialisiert wurde, entweder während der Verarbeitung durch einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor oder durch explizites seine <see cref="M:System.Windows.FrameworkElement.EndInit" /> aufgerufene Methode.</summary>
        <value>
          <see langword="true" />Wenn das Element, über die oben genannte initialisiert wird [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] -Verarbeitung oder Methodenaufrufe, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist möglicherweise auch `true` , wenn dieses Element innerhalb der logischen Struktur verschoben wurde, dass er ein neues übergeordnetes Element aufweist und deshalb neu geladen werden muss.  
  
 Diese Eigenschaft ist nützlich, wenn Sie außerdem <xref:System.Windows.FrameworkElement.BeginInit%2A> und <xref:System.Windows.FrameworkElement.EndInit%2A>. Elemente in der logischen Struktur, die von geladen ist eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor um zu initialisierenden gewährleistet werden. Elemente nicht in der logischen Struktur werden initialisiert, wenn <xref:System.Windows.FrameworkElement.EndInit%2A> aufgerufen wird. In Ermangelung keine spezifische Behandlung von <xref:System.Windows.FrameworkElement.BeginInit%2A> und <xref:System.Windows.FrameworkElement.EndInit%2A>, dies erfolgt, sobald Sie den Konstruktor initialisierte Ergebnis zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob dieses Element für die Präsentation geladen wurde.</summary>
        <value>
          <see langword="true" />Wenn das aktuelle Element an eine Elementstruktur angefügt wird; <see langword="false" /> , wenn das Element nie an eine geladene Elementstruktur angefügt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus einer neu erstellten <xref:System.Windows.FrameworkElement>, diese Eigenschaft beginnt `false`, und bleibt `true` Nachdem sie, um festgelegt wurde `true`, selbst wenn das Element durch den Code anschließend aus einer verbundenen logischen Struktur entfernt wird. `true`Status wird von der allgemeinen Präsentationslogik festgelegt, wenn Elemente in der Präsentationsmodul geladen werden.  
  
 Geladene Elemente in der Regel sind, gerendert, aber nicht alle <xref:System.Windows.FrameworkElement> abgeleitete Klassen haben, eine Präsentation und andere Eigenschaften wie z. B. <xref:System.Windows.UIElement.Visibility%2A> Präsentation beeinflussen können.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Handler implementiert: eine behandelt die <xref:System.Windows.FrameworkElement.Loaded> -Ereignis für das Stammelement, damit sichergestellt ist, dass das Stammelement für die Seite geladen wird, da dies die Bedeutung des Ereignisses ist. Der andere Handler ist verknüpft, auf ein Benutzersteuerelement, und der Aufrufe <xref:System.Windows.FrameworkElement.IsLoaded%2A> um sicherzustellen, dass das Stammelement geladen werden vollständig. Beide Handler rufen die gleiche Funktion (nicht gezeigt), die untergeordnete Elemente mit neuen Daten aufgefüllt.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Lokalisierungs-/Globalisierungs-Sprachinformationen für das Element angibt, oder legt diesen Wert fest.</summary>
        <value>Die Sprachinformationen für dieses Element. Der Standardwert ist eine <see cref="T:System.Windows.Markup.XmlLanguage" /> mit seiner <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> Wert auf die Zeichenfolge "En-US" festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolgenformate unterliegen dem RFC 3066-Standard. Z. B. USA Englisch ist "En-US". Weitere Informationen zu den Werten und Format finden Sie unter <xref:System.Windows.Markup.XmlLanguage>.  
  
 Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte. Wenn untergeordnete ohne andere Werte für Elemente <xref:System.Windows.FrameworkElement.Language%2A> durch lokale Werte oder Stile erstellt wurden, wird im Eigenschaftensystem den Wert festgelegt die <xref:System.Windows.FrameworkElement.Language%2A> Wert für das nächste übergeordnete Element mit diesem Wert zugewiesen.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]definiert die allgemeine Bedeutung der `xml:lang` Attribut. <xref:System.Windows.FrameworkElement.Language%2A>im Wesentlichen macht die Bedeutung dieses Attributs als Abhängigkeitseigenschaft. <xref:System.Windows.FrameworkElement.Language%2A>programmgesteuert angepasst werden kann, und die Vererbung von Eigenschaftenwerten System in einer Weise, die parallel teilnehmen kann wie die `xml:lang` Attribut kann erben, um den Gültigkeitsbereich des untergeordneten Elements in [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Wenn Sie festlegen, <xref:System.Windows.FrameworkElement.Language%2A>, diesen Wert wird die `xml:lang` und überschreibt alle vorherigen Wert. Weitere Informationen finden Sie unter [XML: lang Behandlung in XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Language" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ermittelt oder definiert eine Graphics-Transformation, die auf dieses Element angewendet werden soll, wenn Layout ausgeführt wird.</summary>
        <value>Die Transformation, die dieses Element verwenden soll. Die Standardeinstellung ist <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Einfluss auf die Ergebnisse des Layouts.  
  
 Festlegen einer Transformation stellt leistungsstarke Funktionen der Skalierung und drehen. Allerdings <xref:System.Windows.FrameworkElement.LayoutTransform%2A> ignoriert <xref:System.Windows.Media.TranslateTransform> Vorgänge. Grund hierfür ist das Verhalten des Layoutsystems für untergeordnete Elemente des ein <xref:System.Windows.FrameworkElement> alle Offsets, die Position eines Elements skalierten oder gedrehten in das Layout und das Koordinatensystem des übergeordneten Elements automatisch korrigiert.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A>kann zur Leistung der Anwendung führen, wenn Sie es in einem Szenario aufrufen, die nicht über einen vollständigen Durchlauf vom Layoutsystem erfordert. Beim Anwenden einer <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf die <xref:System.Windows.Controls.Panel.Children%2A> Auflistung von der <xref:System.Windows.Controls.Panel>, es wird einen neuen Durchlauf vom Layoutsystem ausgelöst und erzwingt, dass alle Objekte auf dem Bildschirm Layoutsystems und neu angeordnet werden. Wenn Sie die vollständige Anwendung aktualisieren [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], diese Funktionalität müssen Sie genau möglicherweise. Wenn Sie nicht über einen vollständigen Layoutdurchlauf benötigen, allerdings verwenden der <xref:System.Windows.UIElement.RenderTransform%2A> -Eigenschaft, die das Layoutsystem wird nicht aufgerufen, und ist daher in der Regel eine bessere Wahl für dieses Szenario.  
  
 Beispielszenarien, in denen <xref:System.Windows.FrameworkElement.LayoutTransform%2A> hilfreich sind: Drehen von Elementen, beispielsweise Menükomponenten, die im aus horizontale, vertikale oder umgekehrt, Skalierung (vergrößern) Elemente bereitstellen usw. Bearbeitungsverhalten Element den Fokus erhält.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Anwenden einer <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf ein Element. Das Beispiel erstellt eine Instanz des <xref:System.Windows.Controls.Button> und hostet es innerhalb eines übergeordneten <xref:System.Windows.Controls.Grid>. Darüber hinaus verwendet der <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Eigenschaft anwenden einer <xref:System.Windows.Media.RotateTransform> auf die <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded>in der Regel wird das letzte Ereignis in ein Elementinitialisierungssequenz ausgelöst werden. Es tritt immer nach <xref:System.Windows.FrameworkElement.Initialized>. Gibt an, ob Sie behandeln möchten <xref:System.Windows.FrameworkElement.Loaded> oder <xref:System.Windows.FrameworkElement.Initialized> hängt von Ihren Anforderungen. Wenn Sie nicht benötigen, Lesen von Elementeigenschaften, Eigenschaften zurücksetzen möchten, und brauchen keine Layoutinformationen <xref:System.Windows.FrameworkElement.Initialized> möglicherweise-Ereignis zu reagieren. Wenn Sie alle Eigenschaften des Elements verfügbar sein, und Sie Eigenschaften, die wahrscheinlich das Layout zurücksetzen festlegen <xref:System.Windows.FrameworkElement.Loaded> möglicherweise-Ereignis zu reagieren. Achten Sie auf erneutes eintreten, wenn der Handler setzt alle Eigenschaften zurück, die vom Layoutsystem bedeutet, dass eine neue Layoutdurchlauf erforderlich ist interpretiert werden. (Möglicherweise müssen Sie überprüfen die <xref:System.Windows.FrameworkPropertyMetadata> übergeben von Werten für die Eigenschaft, wenn Sie nicht genau wissen, welche Eigenschaften ein neues Layout erforderlich sind, wenn sie geändert wurden.)  
  
 Weitere Informationen zur Reihenfolge von Objektereignissen für eine <xref:System.Windows.FrameworkElement>, und auch mehrere verwandte Elementklassen zur Anwendungs- und finden Sie unter [Lebensdauer Objektereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Direkte Routingereignisse führen Sie eine Route nicht ausgeführt, sie sind nur innerhalb des gleichen Elements in dem sie ausgelöst werden. Direkte Routingereignisse unterstützen andere Verhalten Routingereignis: sie unterstützen eine Auflistung zugegriffen werden kann, Handler und dient als ein <xref:System.Windows.EventTrigger> in einem Format.  
  
 <xref:System.Windows.FrameworkElement.Loaded>und <xref:System.Windows.FrameworkElement.Unloaded> möglicherweise sowohl auf Steuerelementen aufgrund der Designänderungen Benutzerinitiierte System ausgelöst werden. Eine Änderung Design bewirkt, dass ein Ungültigkeitserklärung für die Steuerelementvorlage und die enthaltenen visuellen Struktur, die wiederum führt dazu, dass das gesamte Steuerelement entladen und laden. Aus diesem Grund <xref:System.Windows.FrameworkElement.Loaded> kann nicht angenommen werden, dass eintritt nur, wenn eine Seite zuerst über die Seite geladen ist.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Loaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A>können Sie untergeordnete Elemente durchlaufen. Dies ist nützlich für Elemente, die möglicherweise keine Auflistung definierte ist, dedizierte aber dennoch enthält mehr als ein untergeordnetes Element, insbesondere <xref:System.Windows.FrameworkContentElement> untergeordnete Elemente.  
  
 Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den äußeren Rand eines Elements ab oder legt ihn fest.</summary>
        <value>Stellt Randwerte für das Element bereit. Der Standardwert ist eine <see cref="T:System.Windows.Thickness" /> mit allen Eigenschaften gleich 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rand ist die Fläche zwischen diesem Element und andere Elemente, die angrenzende beim Layout erstellt die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Gemeinsame Elemente möglicherweise Peer-Elemente (z. B. andere Elemente in der Auflistung eines gemeinsamen übergeordneten Steuerelements) oder ggf. auch diese des übergeordneten Elements.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A>wird festgelegt, wie eine <xref:System.Windows.Thickness> Struktur anstatt als Zahl, damit der Rand asymmetrisch festgelegt werden kann. Die <xref:System.Windows.Thickness> Struktur selbst unterstützt die Konvertierung, damit Sie einen asymmetrischen angeben können <xref:System.Windows.FrameworkElement.Margin%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] auch Attributsyntax.  
  
 Ein Rand ungleich 0 (null) gilt Bereich außerhalb des Elementlayouts <xref:System.Windows.FrameworkElement.ActualWidth%2A> und <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Ränder sind additiv für gleichgeordnete Elemente in einem Layout; Beispielsweise müsste zwei benachbarte Elemente, die mit einem Rand von 30 für die benachbarten Edge festgelegten 60 Einheiten Leerzeichen dazwischen.  
  
 Elemente, die festgelegten Rändern beschränken die Größe des angegebenen nicht in der Regel <xref:System.Windows.FrameworkElement.Margin%2A> , wenn das Rechteck zugewiesenen Speicherplatz nicht groß genug für den Rand und der Inhaltsbereich des Elements ist. Inhaltsbereich des Elements wird stattdessen beschränkt werden, wenn Layout berechnet wird. Der einzige Fall, in dem Ränder beschränkt werden, ist auch auf, wenn der Inhalt bereits ganz nach 0 (null) eingeschränkt ist.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Links, oben, rechts, unten*  
 Zahl der Werte zwischen 0 und <xref:System.Double.PositiveInfinity> angeben, dass der vier möglichen Dimensionseigenschaften einer <xref:System.Windows.Thickness> Struktur.  
  
 Für die Attributverwendung akzeptiert auch abgekürzte Werte, die in der Reihenfolge angegeben, symmetrisch und logisch gelten. Z. B. `Margin="20"` wird so interpretiert, dass eine <xref:System.Windows.Thickness> mit allen Eigenschaften, die auf 20 festgelegt. `Margin="20,50"`wird so interpretiert, dass eine <xref:System.Windows.Thickness> mit <xref:System.Windows.Thickness.Left%2A> und <xref:System.Windows.Thickness.Right%2A> auf 20 festgelegt und <xref:System.Windows.Thickness.Top%2A> und <xref:System.Windows.Thickness.Bottom%2A> auf 50 festgelegt.  
  
 Die Standardeinheit für eine <xref:System.Windows.Thickness> Measure ist [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Sie können auch andere Einheiten angeben, durch den Typ Einheitenzeichenfolgen Anfügen `cm`, `in`, oder `pt` auf ein Measure.  
  
 Zahlenwerten als [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Attribute müssen keine Dezimaltrennzeichen angeben (0 akzeptabel ist, keinen als 0,0 bereitgestellt wird). Weitere Informationen zu [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Verwendung "," finden Sie unter <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Ein Objektverweis auf eine vorhandene <xref:System.Windows.Thickness>. Dies ist möglicherweise eine `}`, a, oder `}` Verweis. Weitere Informationen zu [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Verwendung "," finden Sie unter <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Margin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Höhe ab bzw. legt diese fest.</summary>
        <value>Die maximale Höhe des Elements im [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert größer gleich 0,0 sein. <see cref="F:System.Double.PositiveInfinity" />ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> angeben, dass Höheninformationen zu. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.Height%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe zuerst <xref:System.Windows.FrameworkElement.MinHeight%2A> dann berücksichtigt werden müssen <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und abschließend, wenn diese innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Die Beschränkungen auf der <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Eine Laufzeitausnahme wird ausgelöst, wenn Sie versuchen, einen ungültigen Wert festzulegen.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert erwähnt anwenden, mit dem Unterschied, dass Sie verwenden müssen [X: statische Markuperweiterung](~/docs/framework/xaml-services/x-static-markup-extension.md) Wenn Sie den Wert explizit festlegen müssen <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Breite ab bzw. legt diese fest.</summary>
        <value>Die maximale Breite des Elements im [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert größer gleich 0,0 sein. <see cref="F:System.Double.PositiveInfinity" />ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> , die Breiteninformationen angeben. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.Width%2A>. Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> dann berücksichtigt werden müssen <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und abschließend, wenn diese innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Die Beschränkungen auf der <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert erwähnt anwenden, mit dem Unterschied, dass Sie verwenden müssen [X: statische Markuperweiterung](~/docs/framework/xaml-services/x-static-markup-extension.md) zum Festlegen des Werts sein <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die das übergeordnete Element an die untergeordneten Elemente übergeben kann.</param>
        <summary>Implementiert das grundlegende Maßübergabe Layout Systemverhalten für <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Die gewünschte Größe dieses Elements im Layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> der WPF-Kernebenen und WPF-Frameworkebene Measure layoutimplementierungen verbinden. Die <xref:System.Windows.FrameworkElement> Implementierung versiegelt die Methode. Um das Measure Pass Layoutverhalten eines beliebigen Elements anzupassen, die auf WPF-Frameworkebene erstellt, außer Kraft setzen <xref:System.Windows.FrameworkElement.MeasureOverride%2A> stattdessen. Anpassen der Maßübergabe Layoutverhalten eines Elements, das absichtlich nicht auf die WPF-Frameworkebene erstellen oder <xref:System.Windows.FrameworkElement>, außer Kraft setzen <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die dieses Element untergeordneten Elementen bereitstellen kann. „Unendlich“ kann als Wert angegeben werden, um festzulegen, dass das Element an die Größe des jeweiligen Inhalts angepasst wird.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse misst für untergeordnete Elemente im Layout benötigte Größe und bestimmt eine Größe für die <see cref="T:System.Windows.FrameworkElement" />-Klasse.</summary>
        <returns>Die für dieses Element beim Layout benötigte Größe, basierend auf der Berechnung der Größen der untergeordneten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie <xref:System.Windows.FrameworkElement.MeasureOverride%2A> , benutzerdefiniertes Layout Größenanpassungsverhalten für das Element zu implementieren, wenn er teilnimmt der [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Layoutsystem. Ihre Implementierung sollten die folgenden Schritte ausführen:  
  
1.  Durchlaufen des Elements bestimmte Auflistung untergeordneter Elemente, die Teil des Layouts Aufruf <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element.  
  
2.  Sofort abrufen <xref:System.Windows.UIElement.DesiredSize%2A> auf dem untergeordneten Element (Dies wird als Eigenschaft nach festgelegt <xref:System.Windows.UIElement.Measure%2A> aufgerufen wird).  
  
3.  Berechnen Sie die net gewünschte Größe des übergeordneten Elements basierend auf die Messung der untergeordneten Elemente.  
  
 Der Rückgabewert der <xref:System.Windows.FrameworkElement.MeasureOverride%2A> sollte die Größe des Elements gewünscht, klicken Sie dann das Measure als Eingabe für das übergeordnete Element des aktuellen Elements wird. Das Layoutsystem wird der gleiche Vorgang fortgesetzt, bis das Stammelement der Seite erreicht ist.  
  
 Während dieses Vorgangs möglicherweise untergeordnete Elemente eines größeren zurückgeben <xref:System.Windows.UIElement.DesiredSize%2A> als die anfängliche Größe `availableSize` um anzugeben, dass das untergeordnete Element mehr Speicherplatz benötigt. Dies könnte in eine eigene Implementierung verarbeitet werden, durch die Einführung eines bildlauffähigen Bereichs, durch Ändern der Größe von des übergeordneten Steuerelements, durch die Einrichtung einige Art und Weise eines gestapelten Bestellung oder eine beliebige Anzahl von Lösungen für messen oder Anordnen von Inhalt.  
  
> [!IMPORTANT]
>  -Elemente sollten Aufrufen <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element während dieses Vorgangs werden soll, andernfalls die untergeordneten Elemente nicht ordnungsgemäß Größe oder angeordnet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Der folgende nicht Kompilieren von Code zeigt dieses Implementierungsmuster.  <c>VisualChildren</c> stellt eine Eigenschaft aufzählbare Auflistung der untergeordneten Elemente, die Ihre eigenen Element definieren, sollten dar. Die Eigenschaft kann beliebig benannt werden. <c>VisualChildren</c> ist ein Platzhaltername für den Rahmen dieses Beispiels <c>VisualChildren</c> ist ein [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] bereitgestellt [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] oder eines Teils ein Benennungsmuster...  
  
 [!code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)]
 [!code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Höhe ab bzw. legt diese fest.</summary>
        <value>Die minimale Höhe des Elements im [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert größer gleich 0,0 sein. Allerdings <see cref="F:System.Double.PositiveInfinity" /> ist nicht gültig ist, noch ist <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> angeben, dass Höheninformationen zu.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe zuerst <xref:System.Windows.FrameworkElement.MinHeight%2A> dann berücksichtigt werden müssen <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und abschließend, wenn diese innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Die Beschränkungen auf der <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert erwähnt anwenden.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Breite ab bzw. legt diese fest.</summary>
        <value>Die Mindestbreite des Elements im [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. Allerdings <see cref="F:System.Double.PositiveInfinity" /> ist nicht gültig, noch ist <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> , die Breiteninformationen angeben.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.Width%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> dann berücksichtigt werden müssen <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und abschließend, wenn diese innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Die Beschränkungen auf der <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert erwähnt anwenden.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Die Richtung, die Fokus verschoben werden, als Wert der Enumeration.</param>
        <summary>Verschiebt den Tastaturfokus von diesem Element und ein anderes Element in einer Richtung bereitgestellten Durchlauf.</summary>
        <returns>Gibt <see langword="true" /> wenn Fokus erfolgreich verschoben wurde. <see langword="false" /> Wenn das Zielelement in Richtung wie angegeben, ist nicht vorhanden oder konnte nicht werden den Tastaturfokus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung überschreibt <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> und versiegelt die Methode.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der mehrere mögliche Schaltflächeneingaben behandelt. Jede Schaltfläche stellt ein mögliches <xref:System.Windows.Input.FocusNavigationDirection>. Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft <xref:System.Windows.FrameworkElement.MoveFocus%2A> auf dieses Element, durch Angabe der entsprechenden <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für den <xref:System.Windows.Input.TraversalRequest> Typparameter bereitgestellt.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Elementnamens. Der Name stellt einen Verweis bereit, sodass Code-Behind, z. B. Ereignishandlercode, auf ein Markupelement verweisen kann, nachdem es während der Verarbeitung durch erstellt wurde eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor.</summary>
        <value>Der Name des Elements. Der Standardwert ist eine leere Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft ist die Angabe einer [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elementname als ein Attribut im Markup.  
  
 Diese Eigenschaft bietet im Wesentlichen eine WPF-Frameworkebene benutzerfreundliche-Eigenschaft zum Festlegen der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X: Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Namen müssen innerhalb einer Namensbereich eindeutig sein. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Abrufen einer <xref:System.Windows.FrameworkElement.Name%2A> bei Erstellung der Elemente im Code wird nicht empfohlen. Wenn Sie den entsprechenden Verweis bereits im Code haben, können Sie nur Methoden aufrufen und Eigenschaften für das Element verweisen und werden nicht im Allgemeinen müssen die <xref:System.Windows.FrameworkElement.Name%2A>. Eine Ausnahme bildet Wenn die <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge eine überladene Bedeutung aufweist, z. B. ist es hilfreich, wenn diese Namen in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Festlegen einer <xref:System.Windows.FrameworkElement.Name%2A> aus Code-Behind-Wenn die ursprüngliche <xref:System.Windows.FrameworkElement.Name%2A> aus Markup festgelegt wurde wird ebenfalls nicht empfohlen, und Ändern der Eigenschaft nach dem Laden der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ändert sich nicht auf den ursprünglichen Objektverweis. Objektverweise werden nur erstellt, wenn die zugrunde liegenden Namescopes während der Analyse explizit erstellt werden. Sie müssen ausdrücklich Aufrufen <xref:System.Windows.FrameworkElement.RegisterName%2A> eine effektive Änderung vornehmen der <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft eines Elements bereits geladen.  
  
 Eine wichtige Fall, in dem das Festlegen <xref:System.Windows.FrameworkElement.Name%2A> aus Code ist wichtig ist, beim Registrieren von Namen für Elemente, für die storyboards berücksichtigt werden sollen, ausgeführt, damit zur Laufzeit auf Sie verwiesen werden kann. Bevor Sie einen Namen registrieren können, müssen u. u. auch instanziieren und Zuweisen einer <xref:System.Windows.NameScope> Instanz. Finden Sie im Beispielabschnitt oder [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Festlegen von <xref:System.Windows.FrameworkElement.Name%2A> aus Code verfügt über eingeschränkten, Anwendungen, aber ein Element abrufen <xref:System.Windows.FrameworkElement.Name%2A> ist eher üblich. Ein bestimmtes Szenario ist, wenn Ihre Anwendung ein Navigationsmodell für Einzelseiten unterstützt, in denen Seiten in der Anwendung zu laden und der Code zur Laufzeit ist nicht notwendigerweise Code-Behind für diese Seite definiert. Die Hilfsprogrammmethode <xref:System.Windows.FrameworkElement.FindName%2A>, die von einem beliebigen verfügbar ist <xref:System.Windows.FrameworkElement>, finde beliebiges Element durch <xref:System.Windows.FrameworkElement.Name%2A> suchen Sie in der logischen Struktur für dieses Element, das rekursiv nach Bedarf. Oder Sie können die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statische Methode der <xref:System.Windows.LogicalTreeHelper>, was auch in Anspruch nimmt eine <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge als Argument.  
  
 In der Regel verwendet Stammelemente (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> z. B.) implementieren die Schnittstelle <xref:System.Windows.Markup.INameScope>. Implementierungen dieser Schnittstelle werden erwartet, um zu erzwingen, dass Namen innerhalb des Bereichs eindeutig sein. Die Stammelemente, die diese Schnittstelle definieren auch definieren die Grenzen des Namensbereich für alle verknüpften [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 Die <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft dient auch als Bezeichner für andere Prozesse. Für die Instanz, die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Automatisierungsmodell verwendet <xref:System.Windows.FrameworkElement.Name%2A> als AutomationId für Clients und Anbietern.  
  
 Die Zeichenfolgenwerte, die zum <xref:System.Windows.FrameworkElement.Name%2A> weisen einige Einschränkungen, wie vom zugrunde liegenden auferlegt [X: Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md) definiert, indem die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Spezifikation. Vor allem Kontrollvorgänge eine <xref:System.Windows.FrameworkElement.Name%2A> muss mit einem Buchstaben oder Unterstrich (_) beginnen und darf nur Buchstaben, Ziffern oder Unterstriche enthalten. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A>ist eine der wenigen Abhängigkeitseigenschaften, die animiert werden können (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> ist `true` in Metadaten), da der Name selbst für die Zielgruppenadressierung einer Animation unabdingbar ist. Datenbindung einer <xref:System.Windows.FrameworkElement.Name%2A> ist technisch zwar möglich, jedoch ist ein äußerst ungewöhnliches Szenario, da ein datengebundenes <xref:System.Windows.FrameworkElement.Name%2A> der beabsichtigten Hauptzweck der Eigenschaft kann nicht verarbeitet werden: Code-Behind einen Verbindungspunkt Bezeichner bereit.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.FrameworkElement.Name%2A> -Eigenschaft im Code, und klicken Sie dann den Namen in das neu erstellte registriert <xref:System.Windows.NameScope> durch Aufrufen von <xref:System.Windows.FrameworkElement.RegisterName%2A>. Das Verfahren, die an dieser Stelle erläutert ist eine Voraussetzung für Animationen mit Storyboards, aus, da Storyboards abzielt erfordern, indem Sie die <xref:System.Windows.FrameworkElement.Name%2A>, und kann nicht als Objektverweis angewendet werden.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Name" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse wird aufgerufen, wenn Anwendungscode oder interne Prozesse rufen <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung.  
  
 Vorlagen sind der Teil eines Elements abgeschlossenen visuelle Struktur, die die Template-Eigenschaft des stammen eine <xref:System.Windows.Style> , die für das Element angewendet wird. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen von <see cref="T:System.Windows.FrameworkElement" /> können diese Methode als eine Benachrichtigung für eine Vielzahl von möglichen Szenarien verwenden:  
  
-   Sie können Ihre eigene Implementierung der Code aufrufen, die den Rest der visuellen Struktur eines Elements erstellt.  
  
-   Sie können Code ausführen, die auf der visuellen Struktur aus angewendeten Vorlagen, wie das Abrufen von Verweisen auf benannte Elemente, die aus einer Vorlage beruht.  
  
-   Sie können Dienste einführen, die nur wenig Sinn, nach dem Abschluss der visuellen Struktur aus Vorlagen vorhanden.  
  
-   Sie können festlegen, Zustände und Eigenschaften von Elementen in der Vorlage, die von anderen Faktoren abhängen. Beispielsweise können Eigenschaftswerte nur erkannt werden, wenn Sie das übergeordnete Element kennen, oder wenn eine bestimmte abgeleitete Klasse eine gemeinsame Vorlage verwendet.  
  
 Implementierer sollten immer die grundlegende Implementierung, bevor Sie ihre eigene Implementierung aufrufen. <see cref="T:System.Windows.FrameworkElement" />selbst besitzt keinen Standard-Implementierung, aber beteiligten Klassen möglicherweise.  
  
 <see cref="T:System.Windows.Controls.Control" />bietet eine ähnliche Überschreibung <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten zum Ereignis.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> Routingereignis beim Durchlauf, erreicht dieser Klasse in seiner Route. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ist zumindest ähneln [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit die Implementierung die Ereignisargumente Quelle durchführen müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen). Unterklassen des <xref:System.Windows.FrameworkElement> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Eine mögliche Szenario besteht darin die Argumente des Ereignisses und das Ereignis absichtlich als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> Routingereignis beim Durchlauf, erreicht dieser Klasse in seiner Route. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ist zumindest ähneln [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit die Implementierung die Ereignisargumente Quelle durchführen müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen). Unterklassen des <xref:System.Windows.FrameworkElement> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Eine mögliche Szenario besteht darin die Argumente des Ereignisses und das Ereignis absichtlich als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.GotFocus" /> Ereignis dieses Element in der Route erreicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu einigen anderen auf * durch den Basiselemente verfügbar gemachten Methoden <xref:System.Windows.FrameworkElement.OnGotFocus%2A> verfügt über eine Standardimplementierung. Insbesondere ist eine Implementierung, die die null-Implementierung in der nächsten Ebene des Basiselements nach unten überschreibt <xref:System.Windows.UIElement.OnGotFocus%2A>. Wenn der Aufruf erfolgte, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> legt entsprechende Fokusverhalten für dieses Element in Fällen, in dem das Ereignis aus dem aktuellen Element aufgrund über den Tastaturfokus stammt. Die <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Handler kennzeichnet nicht die Ereignisargumente als behandelt, selbst wenn den Fokus auf das aktuelle Element festgelegt ist. Wenn die Quelle des Ereignisses ein anderes Element in der Struktur (nicht das aktuelle Element) wurde, wird der Handler keine Aktion ausgeführt.  
  
 Sie können diese Methode, um das Standardverhalten der Fokus auf das Element ändern, aber beachten Sie, dass ändern Fokusverhalten auf diese Weise besser erfüllt werden möglicherweise wird, dass das Element den Fokus erhalten kann überhaupt werden überschreiben (siehe <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie beabsichtigen, markieren Sie das Ereignis behandelt, die in den Argumenten, sollten Sie folgen für die Ereignisbehandlung in anderen übergeordneten Elemente in der Elementstruktur sein. Da dieser Handler auf ein Ereignis mit der eine bubbling-routing agiert, Festlegen des Fokus auf den aktuellen <paramref name="sender" /> pro Ereignis Argumente möglicherweise nicht geeignet. Fokus müssen möglicherweise zu einer zusammengesetzten untergeordneten-Element oder ein übergeordnetes Element, abhängig von der Zusammensetzung bestimmter Steuerelemente führen. Deshalb ist das kennzeichnen Focus-Ereignis als behandelt wird nur empfohlen, ist die Gesamtheit der visuellen Struktur, der das Ereignis über routing ist Teil einer Zusammensetzung eines Steuerelements, die Sie erstellt wurden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.Initialized" />-Ereignis aus. Diese Methode wird immer aufgerufen, wenn <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> intern auf <see langword="true" /> festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf diese bestimmte * Methode ist nicht mit einer Klasse Handler Hook. Noch es genau befolgt die eingerichteten [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] auf * Methode Konvention, dass das übereinstimmende Ereignis unterdrückt werden konnte, indem Sie diese Methode überschreiben und nicht die basisimplementierung aufrufen.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkElement.IsInitialized%2A> Eigenschaft ist schreibgeschützt, damit Sie nicht festlegen können <xref:System.Windows.FrameworkElement.IsInitialized%2A> Initialisierungsverhalten zu erzwingen. Festlegen des Initialisierungszustands soll nur von erfolgen die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung dieser virtuellen Methode löst das Ereignis wie oben beschrieben aus. Bei Überschreibungen sollte die Basisimplementierung aufgerufen werden, um dieses Verhalten beizubehalten. Wenn Sie nicht die basisimplementierung aufrufen, nicht nur Sie löst keine der <see cref="E:System.Windows.FrameworkElement.Initialized" /> Ereignis wie in der Regel der erwartet wird ein <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse, aber Sie werden auch zwei wichtige Stil und das Design Stil Initialisierungsvorgänge, die unterdrückt werden Durch diese Implementierung der Basisklasse implementiert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten, die die geänderte Eigenschaft beschreibt, sowie die alten und neuen Werte.</param>
        <summary>Wird aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkElement" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet. Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient nicht in der Regel eigenschaftenänderungen oder Außerkraftsetzungen aufgewendet erkennen. Sie dient stattdessen für Änderungen des als Muster verwendeten allgemeinen invalidierungstypen verfügbar, wenn bestimmte Informationen über wide Klassifizierungen Eigenschaften bekannt ist.  
  
 Diese Methode wird möglicherweise mehrere Male während der Lebensdauer eines Objekts aufgerufen. Aus diesem Grund können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und Sie dann fügen <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen für die einzelnen Eigenschaften. Allerdings würden Sie diese Methode verwenden, wenn eine <xref:System.Windows.FrameworkElement> enthält eine signifikante Anzahl Wert verknüpft Abhängigkeitseigenschaften, oder wenn es die Logik enthält, wie z. B. Renderingverhalten, die erneut ausgeführt werden, muss mehrere Fälle der Ungültigkeitserklärungen beziehen.  
  
 Beachten Sie, dass ein identisch mit dem Namen `OnPropertyChanged` Methode mit einer anderen Signatur (der Parametertyp ist <xref:System.ComponentModel.PropertyChangedEventArgs>), die auf eine Reihe von Klassen angezeigt werden können. Dass `OnPropertyChanged` für Daten Objekt Benachrichtigungen verwendet wird, und ist Teil des Vertrags für <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Rufen Sie immer die grundlegende Implementierung als erster Vorgang in Ihrer Implementierung. Dies versäumt wird die gesamte erheblich deaktiviert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem, wodurch falsche Werte gemeldet werden. Die spezifische <see cref="T:System.Windows.FrameworkElement" /> Implementierung ist auch für die Verwaltung der richtigen Zustand für eine Vielzahl von Eigenschaften, die die sichtbare Benutzeroberfläche betreffen zuständig. Dazu gehören die visuelle Struktur, die basierend auf Änderungen an zur richtigen Zeit jeweils formatieren wird ungültig gemacht.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Details zu den an der Änderung beteiligten alten und neuen Größen.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> Ereignis unter Verwendung den angegebenen Informationen als Teil der möglichen Ereignisdaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Wenn Sie diese Methode aufrufen, setzen Sie die <xref:System.Windows.FrameworkElement.ActualWidth%2A> -Eigenschaft, die <xref:System.Windows.FrameworkElement.ActualHeight%2A> Eigenschaft oder beides, je nachdem, was als angegeben wird, die in den übergebenen Argumenten geändert und das Ereignis wird immer ausgelöst.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode für typische Layoutszenarien nicht. Das Layoutsystem arbeitet in einem absichtlich asynchrone Methode zum sicherstellen, dass alle möglichen Layout anordnen und Measure Fälle berücksichtigt werden. Das Layoutsystem Methoden überschreiben <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> sind für eine Anpassung erforderlich Layout in der Regel ausreichend. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />als virtuelle wird verfügbar gemacht werden. Sie können außer Kraft setzen <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> auf um Ausnahmefällen zu korrigieren, bei denen eine verhaltensänderung zur Laufzeit verknüpfte Ereignisse, die zusammen mit dem Steuerelement die Eingabe von, Layoutsystem Reaktion ungenaue Layoutinformationen gewähren kann.  
  
 (Es wird geschützt, aber nicht versiegelt), kann Sie weiterhin diese Methode in abgeleiteten Klassen überschreiben. Rufen Sie immer die grundlegende Implementierung, um das Verhalten, die oben genannten beizubehalten, es sei denn, Sie spezifische Gründe für das Deaktivieren der standardmäßige WPF-Frameworkebene Renderingverhalten haben. Wegen eines Fehlers beim Auslösen der <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> Ereignis wird nicht standardmäßige Layoutverhalten verursachen, wenn die standardmäßige WPF-Frameworkebene Layout System-Implementierung zu verwenden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Das alte Format.</param>
        <param name="newStyle">Die neue Formatvorlage an.</param>
        <summary>Wird aufgerufen, wenn das Format des auf diesem Element ändert, wird das Layout ungültig wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat eine Standardimplementierung, die ein internes Flag festlegt, die die Formatvorlage geändert Bedingung angibt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie sollten in der Regel keine diese Methode überschreiben. Ändern Sie in ein Format, das beinhaltet ein Measure oder anordnen Änderung ausgelöst würde bereits einer anderen Render-Zyklus, sofern eine typische Implementierung der <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, oder die Standardwerte. Überschreibungen der <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> kann angemessen sein, wenn Ihre <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> Implementierungen wurden absichtlich optimieren oder teilweise Updates unterstützen jedoch weiterhin Änderungen direkt an den Stilen anwenden möchten. (Die teilupdates wäre Versuch zu vermeiden, dass mehrere inkrementelle aufgerufen <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> und <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> auf all seine untergeordneten Elemente).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten zum Ereignis.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> Routingereignis beim Durchlauf, erreicht dieser Klasse in seiner Route. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ist zumindest ähneln [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit die Implementierung die Ereignisargumente Quelle durchführen müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen). Unterklassen des <xref:System.Windows.FrameworkElement> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Eine mögliche Szenario besteht darin die Argumente des Ereignisses und das Ereignis absichtlich als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten zum Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> Routingereignis beim Durchlauf, erreicht dieser Klasse in seiner Route. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ist zumindest ähneln [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit die Implementierung die Ereignisargumente Quelle durchführen müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen). Unterklassen des <xref:System.Windows.FrameworkElement> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Eine mögliche Szenario besteht darin die Argumente des Ereignisses und absichtlich markiert das Ereignis als behandelt, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das alte übergeordnete Element. Möglicherweise <see langword="null" /> , um anzugeben, dass das Element zuvor kein visuelles übergeordnetes Element besitzt.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element dieses Elements in der visuellen Struktur geändert wird. Überschreibt <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die visuelle Struktur unterscheidet sich möglicherweise von der logischen Struktur da Elemente weggelassen wird, die nicht visuell, z. B. Sammlungen, rendern und einige Elemente auf der Basis ihrer Compositing-Design- und erweitert. Weitere Informationen finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung dieser virtuellen Methode fragt den neuen übergeordneten, löst verschiedene Initialisierungsereignisse aus und legt interne Flags zum Status Initialisierung der <see cref="T:System.Windows.FrameworkElement" /> je nach Bedarf. Zum Schluss ruft er die Implementierungen die aufeinander folgenden Basis gemäß der Deklaration durch <see cref="T:System.Windows.UIElement" />, die wiederum ruft Basistext in <see cref="T:System.Windows.Media.Visual" />. Rufen Sie immer die grundlegende Implementierung, um dieses Verhalten beizubehalten, andernfalls der Element-Struktur-Verhalten für dieses Element wird als ein untergeordnetes Element eines anderen Elements deklariert möglicherweise nicht wie erwartet.  
  
 Ein paar vorhandene [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Klassen überschreiben diese Methode, z. B.: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Das häufigste Szenario wird erzwungen, dass das neue übergeordnete Element eines bestimmten Typs sein muss. Dies kann das umfassen, eine Ausnahme auszulösen, wenn das neue übergeordnete Element einige Typtest fehlgeschlagen ist. In Implementierungen für Listenelemente und Menüelemente, die keine außerhalb einer übergeordneten visuellen bedeutungsvoll sind, die eine passende Sammlung zum Speichern von in besitzt ist eine spezielle Version dieses Szenarios vorhanden. Beachten Sie, dass es sich bei diesen Fällen nicht notwendigerweise Ausnahmen auslösen, da möglicherweise Designer Szenarien, bei denen Elemente, die vorübergehend ohne "normalen" ihren übergeordneten Elementen sind erneute.  
  
 Diese Methode wird auch in bestimmte Elemente, die in der Regel das Stammelement, z. B. überschrieben <see cref="T:System.Windows.Window" />. Ein weiterer Fall ist, Elemente, die das Stammelement in Markup, aber die sind automatisch generieren eine größere Infrastruktur in einer kompilierten logischen Struktur (z. B. <see cref="T:System.Windows.Controls.Page" />). Die <see cref="T:System.Windows.Window" /> und <see cref="T:System.Windows.Controls.Page" /> Implementierungen versiegeln absichtlich die Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob dieses Element Stileigenschaften aus Designformatvorlagen integriert.</summary>
        <value>
          <see langword="true" />Wenn dieses Element nicht Stileigenschaften Design verwendet werden; Alle Stil Ausgangsobjekte Eigenschaften stammen lokale Anwendung Formatvorlagen und Designs Stileigenschaften gelten nicht. <see langword="false" />Wenn die Anwendungsstile werden zuerst angewendet, und klicken Sie dann Designformatvorlagen anwenden für Eigenschaften, die Formatvorlagen der Anwendung nicht ausdrücklich festgelegt wurden. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb der Setter eines Formats, der einen Designstil bereitstellt.  
  
> [!IMPORTANT]
>  Wenn Sie festlegen, <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> auf `true` für ein Steuerelement, Sie werden unterdrückt die Standardsteuerelementvorlage, die von der Designformatvorlagen bereitgestellt. Dieser Steuerelementvorlage enthält in der Regel der Inhalt der Vortragende und andere zusammengesetzter Elemente, die grundlegende bereitstellen [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Funktionalität und die Visualisierung für das Steuerelement. Wenn Sie das Steuerelement weiterhin die gleichen Funktionen wie die Standard-Designformatvorlagen unterstützen soll, müssen Sie einen alternativen Stil mit einer Steuerelementvorlage angeben, die die gleiche Struktur repliziert. Weitere Informationen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das logische übergeordnete Element dieses Elements ab.</summary>
        <value>Das logische übergeordnete Element dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A>möglicherweise `null` in Fällen, in dem ein Element instanziiert wurde, aber nicht an eine logische Struktur, die eine Verbindung zum Stammelement auf Seitenebene oder das Anwendungsobjekt herstellt angefügt ist.  
  
 Beachten Sie, dass sich das logische übergeordnete Element eines Elements möglicherweise je nach Funktionalität Ihrer Anwendung geändert und den Wert dieser Eigenschaft diese Änderung nicht widerspiegelt. In der Regel sollten Sie den Wert abrufen, unmittelbar bevor Sie ihn benötigen.  
  
 Finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) für Weitere Informationen zur logischen Struktur durchlaufen und den Szenarien die Verwendung <xref:System.Windows.FrameworkElement.Parent%2A> als eine Technik des übergeordneten Elements Ermittlung geeignet ist.  
  
 Das Eigenschaftenmodul wird möglicherweise neu berechnen alle Eigenschaftswerte eines Elements, wenn er erneut übergeordnet ist, da einige Eigenschaften Werte in der logischen Struktur erben. Die <xref:System.Windows.FrameworkElement.DataContext%2A> , die gilt für Bindungen können auch ändern, wenn Elemente erneut übergeordnet werden.  
  
 Ändern eines Elements in der Regel nur erfolgt durch die Bearbeitung von Auflistungen, mithilfe von dedizierten hinzufügen oder entfernen-Methoden, oder durch Festlegen von Inhaltseigenschaften von Elementen.  
  
 Das häufigste Szenario für die Verwendung der <xref:System.Windows.FrameworkElement.Parent%2A> Eigenschaft wird zum Abrufen eines Verweises und rufen Sie anschließend auf verschiedenen <xref:System.Windows.FrameworkElement> Eigenschaftswerte aus dem übergeordneten Element. Bei Vorlagen der <xref:System.Windows.FrameworkElement.Parent%2A> der Vorlage schließlich werden `null`. Über diesen Punkt hinaus, und erweitern in der logischen Struktur, in dem die Vorlage tatsächlich angewendet wird, verwenden Sie <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Beachten Sie, dass diese Eigenschaft keine übergeordneten Elemente einer visuellen Struktur gemeldet, wenn diese von der übergeordneten Elemente in der logischen Struktur abweichen. Visuelle Struktur Eltern sind nicht in der Regel wichtig für allgemeine Anwendung Fälle aber möglicherweise die gewünschte übergeordnete Elemente für bestimmte visuelle Ebene Fälle. Siehe <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, Code, der für das übergeordnete Element eines Elements überprüft und verwendet dann Eigenschaftswerte aus dem übergeordneten Element, um Eigenschaften für das untergeordnete Element entsprechend festlegen. In diesem Fall sind dies die Eigenschaften, die Einfluss auf die Renderinggröße.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Das untergeordnete Element, das die Änderung meldet.</param>
        <summary>Unterstützt inkrementelle layoutimplementierungen in spezielle Unterklassen des <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />wird aufgerufen, wenn ein untergeordnetes Element eine Eigenschaft für ungültig, die in den Metadaten erklärt hat als Auswirkungen auf die übergeordnete Measuregruppe markiert ist oder die anordnungsdurchläufe während des Layouts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element ein untergeordnetes Element verfügt, auf dem eine bestimmte Eigenschaft für ungültig erklärt wurde, und die Eigenschaft wurde als gekennzeichnet <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> oder <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> in den Metadaten während der Registrierung, der diese Methode wird aufgerufen. Der Methodenaufruf benachrichtigt das übergeordnete Element, welche bestimmten untergeordneten Elemente neu hinzugefügter sein muss, wenn dieses Element (inkrementell) Teilupdate Layout unterstützt.  
  
 Standardmäßig <xref:System.Windows.FrameworkElement> unterstützt keine inkrementelle Layout und in der <xref:System.Windows.FrameworkElement> Klasse diese Methode hat keine Standardimplementierung. Das Szenario, in dem Sie diese Methode überschreiben erforderlich wäre, ist nicht sehr häufig, da Sie so ändern Sie das Standardverhalten des Layoutsystems erforderlich ist.  
  
 Ein Beispielszenario für die Implementierung möglicherweise auf, wenn eine Klasse Typ Einschränkungen für möglichen untergeordneten Elemente enthielt, der deutlich restriktiver ist als das WPF-Frameworkebene Layoutsystem sind. Aufgrund der Natur dieser benutzerdefinierte Elemente konnte eigenschaftenänderungen absichtlich verschoben werden, wenn Sie ein benutzerdefiniertes Layout-Verhalten implementieren. -Methode überschreibt Measure/anordnen, die versuchen, das untergeordnete Element optimieren Renderings, können z. B. für bestimmte Arten von Änderungen zurückgestellt werden, die normalerweise in einer anderen Layoutdurchlauf bedingt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Die Richtung für die eine Änderung des potenziellen Fokus bestimmt werden soll.</param>
        <summary>Bestimmt das nächste Element, das würde den Fokus erhalten relativ zu diesem Element für eine bereitgestellte Fokus Bewegung Richtung, aber den Fokus nicht tatsächlich verschoben.</summary>
        <returns>Das nächste Element, das konzentrieren würde zu verschieben, wenn Fokus tatsächlich durchlaufen wurden. Gelegten <see langword="null" /> wenn Fokus relativ zu diesem Element für die angegebene Richtung verschoben werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A>ist die entsprechende Methode, die tatsächlich Fokus.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der mehrere mögliche Schaltflächeneingaben jede Schaltfläche ein mögliches darstellt behandelt <xref:System.Windows.Input.FocusNavigationDirection>. Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft <xref:System.Windows.FrameworkElement.PredictFocus%2A> auf dieses Element und gibt die geeignete <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für den <xref:System.Windows.Input.TraversalRequest> Typparameter bereitgestellt. Nicht mehr auf dieses Element als verschoben <xref:System.Windows.FrameworkElement.MoveFocus%2A> führen würde, der Handler ändert sich die physischen Dimensionen des Ziels vorhergesagten Fokus für Zwecke der Visualisierung.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Eines der folgenden Anweisungen im angegebenen der <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Diese Anweisungen sind nicht zulässig für <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (zulässig sind jedoch <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der für die angegebene Name-Objekt-Zuordnung verwendet.</param>
        <param name="scopedElement">Objekt für die Zuordnung.</param>
        <summary>Stellt einen Accessor, der Zugriff auf vereinfacht die <see cref="T:System.Windows.NameScope" /> Registrierungsmethode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.NameScope.RegisterName%2A>. Die Implementierung überprüft aufeinander folgenden übergeordneten Elemente, bis die entsprechende <xref:System.Windows.NameScope> -Implementierung, die gefunden wird, mit einer Suche nach einem Element, das implementiert <xref:System.Windows.Markup.INameScope>. Weitere Informationen zu Namescopes finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Aufrufen von <xref:System.Windows.FrameworkElement.RegisterName%2A> ist erforderlich, um die Animationsstoryboards für Anwendungen, wenn im Code erstellt, ordnungsgemäß zu verknüpfen. Dies ist, da einer der Schlüsselwerte storyboard-Eigenschaften, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, eine Namenssuche zur Laufzeit verwendet, statt einen Verweis auf ein Target-Element erstellen. Dies gilt auch, wenn dieses Element als Verweis aus dem Code zugegriffen werden. Weitere Informationen darüber, warum die Namen für die Storyboardziele registriert werden müssen, finden Sie unter [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das zu entfernende Element.</param>
        <summary>Entfernt das angegebene Objekt aus der logischen Struktur dieses Elements. <see cref="T:System.Windows.FrameworkElement" />aktualisiert die übergeordneten Zeiger der betroffenen logischen Baums, mit der Löschung synchron zu halten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Sammlungen für Objekte, die logischen untergeordneten Element eines Elements darstellen. Dies könnte in Eigenschaftengetter oder Setter, Klassenhandler von `Changed` Ereignisse, Konstruktoren oder in den Auflistungstypen selbst.  
  
 Für Autoren ist die logische Struktur auf dieser Ebene bearbeiten die empfohlene Vorgehensweise, wenn keines der Klasse bereitgestellten Basissteuerelement Inhaltsmodelle geeignet sind. Betrachten Sie die Erstellung von Unterklassen von auf der Ebene der <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, und <xref:System.Windows.Controls.HeaderedItemsControl>. Diese Klassen bieten ein Inhaltsmodell mit besonderer Erzwingung von logischen untergeordneten Element über dedizierte [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], sowie Unterstützung für andere Funktionen, die in der Regel erwünscht, in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement z. B. über Vorlagen erstellen.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert eine `Child` Eigenschaft in einer benutzerdefinierten <xref:System.Windows.FrameworkElement> , die eine eigene Implementierung visueller Ebene ist. Die Eigenschaft-Setter ist so konzipiert, dass der alte Wert aus der logischen Struktur als auch eine klassenspezifische visuelle Sammlung, wenn der Wert ändert entfernt wird. Die Werte werden zwischengespeichert, und der neue Wert wird dann der standardmäßigen WPF Framework Ebene logischen Struktur und der benutzerdefinierten visuellen Auflistung hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> für dieses Element aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis zeigt an, zu einem übergeordneten Element <xref:System.Windows.Controls.ScrollViewer> (oder abgeleitete Klasse), dass das Element, das löst die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis sollte sichtbar gemacht werden innerhalb des bildlauffähigen Bereichs. Die <xref:System.Windows.Controls.ScrollViewer> dann markiert die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis als behandelt, indem die Klasse behandeln des Ereignisses,. Im allgemeinen <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis Daten sollten nicht gekennzeichnet werden, behandelt, durch alle Klassen, die einen Bildlaufbereich durchführt, oder von einer Instanz Handler auf, da auf diese Weise mit dem Ziel des Elements beeinträchtigen würde, die aufgerufen <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das lokal definierte Ressourcenwörterbuch ab oder legt es fest.</summary>
        <value>Das derzeit lokal definierte Ressourcenwörterbuch, in dem mit einem Schlüssel auf jede Ressource zugegriffen werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourcenwörterbücher, die vollständig oder teilweise in definierbaren [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] werden in der Regel als ein Eigenschaftenelement erstellt und sind in der Regel für das Stammelement für die einzelnen Seiten oder für die Anwendung. Platzieren das Ressourcenwörterbuch auf dieser Ebene erleichtert es, aus der einzelnen untergeordneten Elemente auf der Seite (oder eine andere Seite, in die Anwendung Groß-/Kleinschreibung) zu suchen. In den meisten Anwendungsszenarios wird empfohlen, Stile als Objektelemente in einem Ressourcenwörterbuch definiert werden oder als externe Ressourcen definiert werden, damit die gesamte Stilressource eigenständig sein kann (dieser Ansatz hilft separate-Designer Zuständigkeiten von Entwickleraufgaben durch die Trennung von physischen Dateien, die bearbeitet werden müssen).  
  
 Beachten Sie, dass diese Eigenschaft gibt nur das Ressourcenwörterbuch direkt in dieses Element deklariert. Dies ist anders als die eigentliche Ressource Lookup-Prozess, in dem ein untergeordnetes Element in jedem übergeordneten Element, die Suche rekursiv nach oben definierten Ressourcen zugreifen können.  
  
 Ressourcen können auch aus Code innerhalb der Auflistung verwiesen werden, aber beachten Sie, dass Ressourcen in erstellt [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] kann definitiv nicht zugegriffen werden erst nach dem <xref:System.Windows.FrameworkElement.Loaded> wird ausgelöst, indem Sie das Element, das das Wörterbuch deklariert. In der Tat Ressourcen werden asynchron analysiert, und auch das <xref:System.Windows.FrameworkElement.Loaded> Ereignis ist eine Zusicherung, die Sie verweisen können eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Ressource definiert. Aus diesem Grund sollten Sie in der Regel nur auf zugreifen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definierten Ressourcen als Teil des Codes zur Laufzeit oder über andere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Techniken z. B. Stile oder ressourcenerweiterungsparameter für Attributwerte. Zugriff auf Ressourcen über Code entspricht im Wesentlichen um einen Verweis, die von [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Die zugrunde liegende <xref:System.Windows.ResourceDictionary> unterstützt die Methoden zum Hinzufügen, entfernen oder Abfragen von Ressourcen in der Auflistung mithilfe von Code erforderlich. Die <xref:System.Windows.FrameworkElement.Resources%2A> Eigenschaft kann festgelegt werden, unterstützt das Szenario für die Ressourcen-Auflistung, der ein Element kann ein neues oder anderes werden vollständig zu ersetzen <xref:System.Windows.ResourceDictionary>.  
  
 Beachten Sie, dass die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] gezeigte Syntax enthält kein Element für die <xref:System.Windows.ResourceDictionary>. Dies ist ein Beispiel für implizite Auflistungssyntax; Ein Tag, das das Auflistungselement darstellt, kann ausgelassen werden. Die Elemente, die als Elemente der Auflistung hinzugefügt werden, werden stattdessen angegeben. Weitere Informationen zu impliziten Sammlungen und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], finden Sie unter [XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Einen Fall, in dem ein <xref:System.Windows.ResourceDictionary> wird immer noch explizit angegeben, wie ein Element ist, wenn Sie ein zusammengeführtes Wörterbuch einführen, in diesem Fall stehen in der Regel keine untergeordneten Elemente für diesen <xref:System.Windows.ResourceDictionary>. Weitere Informationen finden Sie unter [Ressourcenverzeichnis zusammengeführt](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreResourceElements*  
 Ein oder mehrere Objektelemente, von die jede eine Ressource definiert werden. Jede Ressource Property-Element innerhalb der einzelnen <xref:System.Windows.ResourceDictionary> benötigen Sie einen eindeutigen Wert für die [X: Key-Anweisung](~/docs/framework/xaml-services/x-key-directive.md), die als eindeutiger Schlüssel fungiert, beim Abrufen der Werte aus den <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifiziert die Destination-Eigenschaft an, die die Bindung eingerichtet werden soll.</param>
        <param name="path">Der Name der Quelleigenschaft oder der Pfad der Eigenschaft, die für die Bindung verwendet.</param>
        <summary>Ordnet eine Bindung an dieses Element basierend auf den Namen der bereitgestellten Source-Eigenschaft als eine Qualifikation Pfad mit der Datenquelle an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, wiederum übergibt die aktuelle Instanz als der <xref:System.Windows.DependencyObject>, und erstellt einen neuen <xref:System.Windows.Data.Binding> auf Grundlage der bereitgestellten `path` Parameter. Diese Signatur ist einfacher, wenn Sie eine einfache standardbindung herstellen. Wenn Sie müssen Bindungseigenschaften nicht standardmäßige Bedingungen angeben, oder verwenden möchten eine <xref:System.Windows.Data.MultiBinding> oder <xref:System.Windows.Data.PriorityBinding>, verwenden Sie die <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> Signatur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bindung mit einem bestimmten Pfad.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Eigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="binding">Stellt die Merkmale der Datenbindung dar.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, die die aktuelle Instanz als übergibt die <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, das eine Flussrichtung angibt.</param>
        <param name="value">Ein Wert der Enumeration, der die Richtung angibt.</param>
        <summary>Legt den Wert für die <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> -Eigenschaft für das angegebene Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Syntax für angefügte Eigenschaften der <xref:System.Windows.FrameworkElement.FlowDirection%2A> -Eigenschaft untergeordneten Elemente eines bereitgestellten <xref:System.Windows.FrameworkElement> flussrichtung für die Anordnung in ihrem übergeordneten Element an. Zum Festlegen des Werts auf dem aktuellen <xref:System.Windows.FrameworkElement>, verwenden Sie die direkte [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Die Eigenschaft, an die die Ressource gebunden ist.</param>
        <param name="name">Der Name der Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Namen, und richtet einen Ressourcenverweis, für die angegebene Eigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ressourcenverweis ist vergleichbar mit der Verwendung von einem [DynamicResource Markuperweiterung](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) im Markup. Der Ressourcenverweis erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft für zurückgestellten zur Laufzeit bereitstellt. Der Ausdruck wird erneut ausgewertet werden, immer das Ressourcenwörterbuch geänderte Wert über interne Ereignisse gibt an, oder, wenn das aktuelle Element erneut übergeordnet ist (eine Änderung des übergeordneten würde das Wörterbuch Suche Pfad ändern).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der serialisieren sollen die <see cref="P:System.Windows.FrameworkElement.Resources" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Resources" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl zurück `true` , solange es mindestens eine Ressource in der lokalen ist <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der serialisieren sollen die <see cref="P:System.Windows.FrameworkElement.Style" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Style" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl zurück `true` Wenn die <xref:System.Windows.Style> lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der serialisieren sollen die <see cref="P:System.Windows.FrameworkElement.Triggers" /> Eigenschaft.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Triggers" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `true` Wenn die <xref:System.Windows.FrameworkElement.Triggers%2A> Eigenschaft lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn entweder die <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> oder <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> Eigenschaften ändern Wert für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routingereignisse führen Sie eine Route nicht ausgeführt, sie sind nur innerhalb des gleichen Elements in dem sie ausgelöst werden. Direkte Routingereignisse unterstützen andere Verhalten Routingereignis: sie unterstützen eine Auflistung zugegriffen werden kann, Handler und dient als ein <xref:System.Windows.EventTrigger> in einem Format.  
  
 Das Layoutsystem liest Eigenschaften innerhalb der <xref:System.Windows.SizeChangedEventArgs> Ereignisargumentklasse für dieses Ereignis, um festzustellen, ob die größenveränderung der gemeldeten als signifikant angesehen werden soll. Dies ermöglicht das Layoutsystem oder Ihre steuerelementspezifische layoutimplementierungen zur Vermeidung einer layoutänderung aufgrund von visuell nicht wahrgenommen unterschieden zwischen den alten und neuen Höhe oder Breitenwerte erzwingen. Die dieser Unterschiede möglicherweise aufgrund von runden oder dasselbe Ergebnis Berechnung mit Gleitkomma-Datentypen.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.SizeChanged" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Quellwert für eine vorhandene Eigenschaft binden für dieses Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Data.Binding.SourceUpdated> Ereignis, das ausgelöst wird, von einer <xref:System.Windows.Data.Binding> mit diesem Element verknüpft sind.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von diesem Element beim Rendern verwendeten Stil ab oder legt ihn fest.</summary>
        <value>Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist. Andernfalls <see langword="null" />. Der Standardwert für ein mit den Standardwerten konstruiertes <see cref="T:System.Windows.FrameworkElement" /> ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Steuerelemente wird das aktuelle Format häufig von einem Standardformat als Steuerelement Designumgebung bereitgestellt, oder von Stilen in der Regel auf Steuerelemente des Typs von Ressourcen auf Seiten- oder Anwendungsebene (ein impliziter Stil). Diese Eigenschaft ist nicht festgelegt oder return-Standard (Designformatvorlagen), aber es gibt zurück, entweder eine implizite oder explizite Stil, der auf das Element dient. Bei impliziten oder expliziten Stilen spielt es keine, ob der Stil als Ressource angegeben oder lokal definiert ist.  
  
 Das Festlegen von den Formaten bestehen einige Einschränkungen. Sie können die gesamte zurücksetzen <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft, um ein neues <xref:System.Windows.Style> erzwingt die zu irgendeinem Zeitpunkt ein Layout zurücksetzen. Jedoch so bald wie diesem Format verwendet von einem geladenen Element platziert wird die <xref:System.Windows.Style> angesehen wird, versiegelt. Bei dem Versuch, eine einzelne Eigenschaft eines Stils in Gebrauch ändern (z. B. alle Elemente in der Auflistung der <xref:System.Windows.Style.Setters%2A>) bewirkt, dass eine Ausnahme ausgelöst werden. Ein Format, das im Markup definierte gilt verwendet werden, sobald dies aus einem Ressourcenwörterbuch (für Ressourcen erfolgt) oder die Seite enthalten ist (für Inlineformatvorlagen) geladen ist.  
  
 <xref:System.Windows.FrameworkElement.Style%2A>ist eine Abhängigkeitseigenschaft mit besonderer Rangfolge. Der lokal festgelegten Stil mit der höchsten Priorität in der Regel im Eigenschaftensystem arbeitet. Wenn die <xref:System.Windows.FrameworkElement.Style%2A> null festgelegt ist, wird beim Laden der Eigenschaft wird überprüft, ob impliziten Stilen in lokalen oder Ressourcen, die diesen Typ angeben. Wenn das Format immer noch null nach diesem Schritt ist wird der verwendete Stil für die Darstellung in der Regel, aus den Standardstil (Design stammen), jedoch werden das Standardformat nicht, in zurückgegeben wird der <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaftswert. Finden Sie unter [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) oder [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eines der folgenden:, oder. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der den angeforderten Stil identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert ist, für die meisten Style-Szenarien. Finden Sie unter [Inlinestile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Eine Bindung verwendet oder <xref:System.Windows.Data.Binding> ist auch möglich, aber ungewöhnlich.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Stil in einem Ressourcenwörterbuch definiert.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Style" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten ambient-Eigenschaft.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter der <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />-Methode.</summary>
        <returns>
          <see langword="true" />Wenn <paramref name="propertyName" /> verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.FrameworkElement>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen willkürlichen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann.</summary>
        <value>Den beabsichtigten Wert. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist analog zu Eigenschaften von Tags in anderen [!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)] Programmiermodelle, z. B. [!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)] oder [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]. <xref:System.Windows.FrameworkElement.Tag%2A>Dient als Speicherort für eine bereits vorhandene Eigenschaft können Sie einige grundlegende benutzerdefinierte Informationen zu allen Speichern <xref:System.Windows.FrameworkElement> ohne Unterklasse eines Elements.  
  
 Da diese Eigenschaft ein Objekt akzeptiert, müssen Sie die Verwendung des Elements verwenden, um festzulegen der <xref:System.Windows.FrameworkElement.Tag%2A> Eigenschaft im [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] auf etwas anderes als ein Objekt mit einem bekannten und integrierten Typkonverter, z. B. eine Zeichenfolge. Auf diese Weise verwendete Objekte befinden sich in der Regel nicht in der [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Namespaces und erfordern daher möglicherweise Namespacezuordnung für den externen Namespace um eingeführt werden, als [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elemente. Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace-Zuordnung für WPF-XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) und [XAML und benutzerdefinierte Klassen für WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Tag" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Zielwert für eine Eigenschaftenbindung bei diesem Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Data.Binding.TargetUpdated> Ereignis, das ausgelöst wird, von einer <xref:System.Windows.Data.Binding> mit diesem Element verknüpft sind. Dies bedeutet normalerweise, dass die betreffende Bindung eine bidirektionale Bindung ist und, dass die gebundene Abhängigkeitseigenschaft, die bestätigt der vorhergehende Eigenschaftswert jetzt ungültig entsprechend eine Überprüfung oder der caching-Schema, das die Eigenschaft oder die Datenquelle unterstützt.  
  
 Verwenden Sie die Daten für das Ereignis von der <xref:System.Windows.FrameworkElement.TargetUpdated> Ereignis, um die spezifische Eigenschaft zu bestimmen, die die Aktualisierung des Zielwerts meldet.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab. Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</summary>
        <value>Das Element, dessen <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> verursacht dieses Element erstellt werden soll. Dieser Wert ist häufig <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>Häufig ist `null` für Objekte, die in Anwendungsmarkup oder Code erstellt werden. Dies ist, da Sie diese Objekte nicht direkt, nicht über eine Vorlage erstellen. -Objekt erhalten, indem Durchlaufen der logischen Struktur vom Stamm oder typische Namensverweise verweist, stammen nicht aus einer Vorlage.  
  
 Fälle, in denen <xref:System.Windows.FrameworkElement.TemplatedParent%2A> möglicherweise nicht `null` gehören Vorgänge wie z. B. Ereignisbehandlung für bestimmte Eingabeereignisse Durchlaufen der visuellen Struktur mit Treffertests, <xref:System.Windows.Media.VisualTreeHelper>, oder Arbeiten mit Enumeratoren können die Elemente zurückgegeben werden können, die stammen aus den Vorlagen. Ein weiterer Fall ist, wenn Sie ausdrücklich Aufrufen <xref:System.Windows.FrameworkTemplate.FindName%2A> anhand einer vorhandenen <xref:System.Windows.FrameworkTemplate> und das zurückgegebene Objekt.  
  
 Vorlagen sind eigentlich freigegebene Objekte, in dem der Inhalt der Vorlage nur einmal erstellt werden. Aus diesem Grund, wenn Sie einen Objektverweis auf ein Element, die aus einer Vorlage abrufen, können Sie feststellen, dass die offensichtliche logische Struktur nicht in das Stammverzeichnis Seite erreicht. Um einen solchen Vorlage Verweis auf die Seite logische Struktur eine Verbindung herzustellen, erhalten Sie die <xref:System.Windows.FrameworkElement.TemplatedParent%2A> -Wert und den Vorgang fortzusetzen, um die Navigation durch die Elementstruktur nach Bedarf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das QuickInfo-Objekt, das für dieses Element angezeigt wird, die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Das QuickInfo-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert dieser Eigenschaft vom Typ <xref:System.Windows.Controls.ToolTip>, wird dieser Wert die QuickInfo, die in verwendet werden, die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Wenn der Wert eines anderen Typs ist, wird dieser Wert verwendet werden die *Inhalt* für eine <xref:System.Windows.Controls.ToolTip> bereitgestellt (erstellt), vom System. Weitere Informationen finden Sie unter <xref:System.Windows.Controls.ToolTipService>. Die Dienstklasse stellt angefügte Eigenschaften, die verwendet werden können, weiter anpassen, eine <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *toolTipContent*  
 Eine Zeichenfolge, die den Anzeigetext für wird die <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Ein Objekt, das in Objektelementform, das als Inhalt für die zu verwendende bereitgestellten der <xref:System.Windows.FrameworkElement> . In der Regel wäre dies eine <xref:System.Windows.FrameworkElement> oder ein anderes Element, das Layout für die Zusammensetzung der <xref:System.Windows.FrameworkElement.ToolTip%2A>, letztendlich mit Textinhalt in der Zusammensetzung. Bei dieser Verwendung der <xref:System.Windows.Controls.ToolTip> Element erstellt implizit aus dem analysierten [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], und die *ToolTipObjectContent* Inhalt festgelegt ist, als die <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> Eigenschaft.  
  
 <`ToolTip` .../>  
 Siehe <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Controls.ToolTip> in Code und legt dann die <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft auf einen <xref:System.Windows.Controls.Primitives.StatusBar> Steuerelement.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, unmittelbar bevor eine QuickInfo für das Element geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Markieren der <xref:System.Windows.FrameworkElement.ToolTipClosing> Ereignis als behandelt nicht schließen der QuickInfo abgebrochen. Sobald die QuickInfo angezeigt wird, erfolgt nur als Reaktion auf Benutzerinteraktion mit der Benutzeroberfläche schließen der QuickInfo.  
  
 Dieses Ereignis nicht mit einem <xref:System.Windows.EventTrigger> in einem Format. Dies ist, da die Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst erneut verwendet, die nicht Ereignismethoden für den Servicelevel-Ereignis hinzufügen/entfernen offen.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine QuickInfo für das Element geöffnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass eine QuickInfo angezeigt wird, in der Benutzeroberfläche, die Handler für <xref:System.Windows.FrameworkElement.ToolTipOpening> können kennzeichnen die <xref:System.Windows.Controls.ToolTipEventArgs> Ereignisdaten behandelt. Andernfalls wird die QuickInfo angezeigt, mit dem Wert des der <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft als QuickInfo-Inhalt. Eine andere mögliches Szenario ist, dass Sie einen Handler schreiben, die den Wert zurückgesetzt, die <xref:System.Windows.FrameworkElement.ToolTip%2A> -Eigenschaft für das Element, das die Ereignisquelle wird unmittelbar vor der QuickInfo angezeigt wird.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>wird nicht ausgelöst, wenn der Wert der <xref:System.Windows.FrameworkElement.ToolTip%2A> ist `null` oder auf andere Weise nicht festgelegt. Legen Sie nicht <xref:System.Windows.FrameworkElement.ToolTip%2A> auf `null` während eine QuickInfo geöffnet ist, oder öffnen; Dies hat keine der Auswirkungen der Schließung der QuickInfo angezeigt und wird stattdessen ein unerwünschten visuelle Element in der Benutzeroberfläche erstellt.  
  
 Die <xref:System.Windows.FrameworkElement.ToolTipOpening> Ereignis nicht mit einem <xref:System.Windows.EventTrigger> in einem Format. Dies ist, da die Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst erneut verwendet, die nicht Ereignismethoden für den Servicelevel-Ereignis hinzufügen/entfernen offen.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ToolTip" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der direkt für dieses Element oder in untergeordneten Elementen eingerichteten Trigger ab.</summary>
        <value>Eine stark typisierte Auflistung von <see cref="T:System.Windows.Trigger" /> Objekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Eigenschaft kann nur festgelegt werden, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] über die Auflistungssyntax angezeigt oder den Zugriff auf das Objekt und dessen verschiedene Methoden wie z. B. hinzufügen. Die Eigenschaft auf das Auflistungsobjekt selbst ist schreibgeschützt, die Auflistung an sich ist Lese-/ Schreibzugriff. Die Eigenschaft ist nur für Stammelemente vorhanden. Beim Versuch, ihn finden, oder legen Sie sie an anderer Stelle wird dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Diese Eigenschaft wird nicht aktiviert, Sie Trigger untersucht, die als Teil der Formatvorlagen auf dieses Element vorhanden sein können. Es werden nur die Auflistung von Triggern, die auf die Auflistung, die entweder im Markup oder-Code als solcher hinzugefügt werden gemeldet. Elemente in der Regel keine solchen Elemente, die standardmäßig vorhandene (mithilfe einer Vorlage für die Instanz); Es ist eher üblich für Trigger aus der Steuerelement-Compositing stattdessen im Stile eingerichtet werden kann.  
  
 In Bezug auf Verhalten (und beim Einrichten, welche Auswirkungen stammt aus dem Element deklariert des <xref:System.Windows.FrameworkElement.Triggers%2A> Auflistung), die auslösende Bedingung und die Auswirkung der Trigger für dieses Element möglicherweise oder möglicherweise auf seinen untergeordneten Elementen in der logischen Struktur. Beachten Sie, dass, wenn Sie Lebensdauerereignisse, z. B. verwenden <xref:System.Windows.FrameworkElement.Loaded> um dieser Auflistung abzurufen, das untergeordnete Element Trigger möglicherweise noch nicht vollständig geladen, und die Auflistung kleiner ist als wäre es tatsächlich zur Laufzeit werden könnten.  
  
 Beachten Sie, die die Sammlung der Auslöser für ein Element wird nur unterstützt <xref:System.Windows.EventTrigger>, nicht Eigenschaftsauslöser (<xref:System.Windows.Trigger>). Wenn Sie die von Eigenschaftentriggern erfordern, müssen Sie diese innerhalb eines Stils oder einer Vorlage platzieren und weisen Sie dann Stil oder die Vorlage auf das Element entweder direkt über die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft oder indirekt über eine implizite formatreferenz.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreTriggers*  
 Eine oder mehrere definiert <xref:System.Windows.EventTrigger> Elemente. Jeder dieser Trigger muss gültige Storyboard-Aktionen und Verweise enthalten. Beachten Sie, dass diese Auflistung nur für das Stammelement einer Seite hergestellt werden kann. Weitere Informationen finden Sie unter [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner der zu findenden Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</summary>
        <returns>Die gefundene Ressource oder <see langword="null" /> Wenn keine Ressource mit dem angegebenen <paramref name="key" /> gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource für das aufrufende Element nicht gefunden wird, wird die übergeordnete Ressource-Struktur nach oben in der logischen Struktur durchsucht, auf die gleiche Weise, die die Struktur wäre gesuchte Wenn eine Ressource mit Schlüssel zur Laufzeit angefordert wurden. Gibt die Methode `null` nur, wenn keine Ressource des Schlüssels an einer beliebigen Stelle in der Ressourcenstruktur pro der Struktur zum Zeitpunkt der vorhandenen Bedingungen vorhanden waren, <xref:System.Windows.FrameworkElement.TryFindResource%2A> aufgerufen wird.  
  
 In der Regel würden Sie sofort den Rückgabewert in den Typ der Eigenschaft umgewandelt, den Sie mit den zurückgegebenen Ressourcenwert festgelegt wurden.  
  
 Die <xref:System.Windows.FrameworkElement.FindResource%2A> Methode verhält sich ähnlich, außer dass es eine Ausnahme auslöst, wenn keine Ressource mit dem angegebenen Schlüssel zurückgegeben wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird als einem Schaltflächenhandler, in dem die Schaltfläche Schaltflächenhandler Hintergrund auf eine Ressource definiert Pinsel, indem abgerufen implementiert <xref:System.Windows.FrameworkElement.TryFindResource%2A> auf sich selbst. Dies führt die Elementstruktur und sucht nach der Ressource (die Ressource selbst ist definiert [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wird nicht angezeigt).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routingereignisse führen Sie eine Route nicht ausgeführt, sie sind nur innerhalb des gleichen Elements in dem sie ausgelöst werden. Direkte Routingereignisse unterstützen andere Verhalten Routingereignis: sie unterstützen eine Auflistung zugegriffen werden kann, Handler und dient als ein <xref:System.Windows.EventTrigger> in einem Format.  
  
 <xref:System.Windows.FrameworkElement.Loaded>und <xref:System.Windows.FrameworkElement.Unloaded> möglicherweise sowohl auf Steuerelementen aufgrund der Designänderungen Benutzerinitiierte System ausgelöst werden. Eine Änderung Design bewirkt, dass ein Ungültigkeitserklärung für die Steuerelementvorlage und die enthaltenen visuellen Struktur, die wiederum führt dazu, dass das gesamte Steuerelement entladen und laden. Aus diesem Grund <xref:System.Windows.FrameworkElement.Unloaded> kann nicht angenommen werden, dass nur auftreten, wenn Sie von der Seite.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkElement.Unloaded> Ereignis wird nicht ausgelöst, nachdem eine Anwendung beginnt heruntergefahren. Zum Herunterfahren der Anwendung tritt auf, wenn die Bedingung definiert die <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft auftritt. Setzen Sie Bereinigungscode in einen Handler für das <xref:System.Windows.FrameworkElement.Unloaded> Ereignis, z. B. für eine <xref:System.Windows.Window> oder eine <xref:System.Windows.Controls.UserControl>, es kann nicht aufgerufen werden, da erwartet.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Unloaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Paars Name-Objekt, aus dem aktuellen Bereich zu entfernen.</param>
        <summary>Vereinfacht den Zugriff auf die <see cref="T:System.Windows.NameScope" /> Aufhebung der Registrierung Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen nur zum Aufheben der Registrierung Namen, wenn Sie beabsichtigen, ein anderes Element mit demselben Namen erneut zu registrieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet das Standardformat der aktuellen <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die Layoutglättung auf die Größe und Position dieses Elements während des Layouts angewendet werden.</summary>
        <value>
          <see langword="true" />Wenn die layoutglättung angewendet wird. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> -Eigenschaft für ein Element ist `true`, alle nicht ganzzahligen Pixelwerte, die während der berechnet werden die <xref:System.Windows.UIElement.Measure%2A> und <xref:System.Windows.UIElement.Arrange%2A> übergibt auf ganze Pixelwerte gerundet werden.  
  
 Diese Eigenschaft wird von den untergeordneten Elementen geerbt.  
  
> [!NOTE]
>  Sie sollten festlegen <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> zu `true` für das Stammelement. Das Layoutsystem wird untergeordneten Koordinaten an die übergeordnete Koordinaten hinzugefügt; Deshalb, wenn die übergeordneten Koordinaten nicht auf einer Pixel-Begrenzung befinden, sind die untergeordneten Koordinaten auch nicht an einer Pixelgrenze. Wenn <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> kann nicht im Stammverzeichnis festlegen, legen Sie <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> auf dem untergeordneten Element, um den Effekt zu erzielen, die Sie möchten.  
  
 Zeichnen von Objekten auf Pixelgrenzen eliminiert die halbtransparente Ränder, die durch Anti-Aliasing erstellt werden, wenn ein Rand in der Mitte eines Gerätepixels fällt. Die folgende Abbildung zeigt die Ausgabe einer einzelnen Pixelbreite-Zeile, die in der Mitte eines Gerätepixels liegt. Die Linie auf der linken Seite verwendet keine layoutglättung und Antialiasing. Die Linie auf der rechten Seite wird die layoutglättung verwendet.  
  
 ![Antialiasing &#45; Zeile verglichen mit Einzelpixelzeile. ] (~/add/media/pixelsnaplinecompare.PNG "Zeile mit Antialiasing verglichen mit Pixels-Zeile.")  
  
 Bei Verwendung der layoutglättung und <xref:System.Windows.GridUnitType.Star> Größe anpassen, erstellt das Layoutsystem kleine Variationen in der Spalte oder Zeile Messungen Subpixelrendering zu vermeiden. Beispielsweise verfügt ein Raster eine gesamte Breite von 100 mit 3 Spalten der Größe <xref:System.Windows.GridUnitType.Star>, statt drei Spalten, die gleiche Breite von 33.3 haben, und erstellt das Layoutsystem 2 Spalten mit einer Breite von 33 und eine, die eine von 34 Breite.  
  
> [!NOTE]
>  In .NET 4.6 wurden Änderungen an der layoutglättung um Instanzen von Clipping in Steuerelementen mit Begrenzungen zu reduzieren. Dieses Feature ist standardmäßig aktiviert, wenn das Zielframework .NET Framework 4.6 oder höher ist. Anwendungen, die auf frühere Versionen des Frameworks abzielen können in das neue Verhalten übernehmen, indem Sie die folgende Einstellung in eine Datei "App.config" hinzufügen: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` die Einstellung wird nur wirksam, wenn die Anwendung auf .NET Framework 4.6 ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht den Effekt, der <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> Eigenschaft in einer einzelnen Pixelbreite Zeile hat. Die Linie auf der linken Seite verwendet keine layoutglättung und die Zeile auf der rechten Seite verwendet layoutglättung. Wenn Sie das Fenster langsam verkleinern, können Sie dem Unterschied, layoutglättung macht sehen.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vertikalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine vertikale Ausrichtungseinstellung. Die Standardeinstellung ist <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaften für ein Element explizit festgelegt sind, diese Werte während des Layouts stets Vorrang und "Abbrechen" die regulären Auswirkungen der Einstellung dieser Eigenschaft auf <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>ist die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaftenaccessor für was in Wirklichkeit eine Abhängigkeitseigenschaft ist. Diese bestimmte Abhängigkeitseigenschaft verfügt relativ häufig Objektwerts offensichtlich "Default" anders in abgeleitete Elementklassen, insbesondere Steuerelemente festlegen. Dieser Vorgang erfolgt normalerweise in einer von zwei Methoden: die Abhängigkeitseigenschaft wird erneut registriert werden, zu einer bestimmten abgeleiteten Klasse, aber unterschiedliche Metadaten für die Standardeinstellungen werden; oder es ist ein Standardformat angewendet wird, der Wert dieser Abhängigkeitseigenschaft unterschiedlich festlegt. Z. B. die offensichtlichen "Default" der <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> für eine <xref:System.Windows.Controls.ComboBoxItem> Steuerelement <xref:System.Windows.VerticalAlignment.Center>, obwohl <xref:System.Windows.Controls.ComboBoxItem> erbt <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> direkt von <xref:System.Windows.FrameworkElement>. Dies ist, da dieser Wert, in den Standardstil der zurückgesetzt wurde <xref:System.Windows.Controls.ComboBoxItem>, innerhalb der Style-Steuerelementvorlage.  
  
 <xref:System.Windows.Controls.Canvas>verwendet keinen <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> beim Erstellen des Layouts, da <xref:System.Windows.Controls.Canvas> absolute Positionierung basiert.  
  
 Wenn von geerbt <xref:System.Windows.Controls.ComboBoxItem> oder abgeleiteten Klassen, <xref:System.Windows.Controls.ComboBoxItem> definiert den Standardwert dieser Eigenschaft werden <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der sichtbaren untergeordneten Elemente innerhalb dieses Elements ab.</summary>
        <value>Die Anzahl der sichtbaren untergeordneten Elemente für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.FrameworkElement> Implementierung von <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> gibt immer 0 (null) oder 1 zurück. Klassen, die eine Auflistung der untergeordneten visuellen aufrechterhalten werden, die mehr als müssen sowohl diese Eigenschaft überschreiben und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Diese Eigenschaft wird im Allgemeinen verwendet, um zu bestimmen, die oberen Grenzen der aktuellen untergeordneten Sammlung zum Zweck der Implementieren der Außerkraftsetzungen Layout (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein benutzerdefinierter Adorner deklariert, indem Werte verwendet eine <xref:System.Windows.Media.VisualCollection> , der mehreren visuellen untergeordneten Elemente verwaltet und diese Berichte Werte außer Kraft, der <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Ihre Klasse mehrere untergeordneten visuellen in eine Auflistung untergeordneter Elemente unterstützt, überschreiben Sie diese Eigenschaft, um die Anzahl der Elemente in der Auflistung zurück. Dies ist erforderlich, selbst wenn das Auflistungsobjekt selbst zurückgibt. Elementlayoutlogik auf WPF-Frameworkebene wird davon ausgegangen, dass alle Elemente über eine gültige Anzahl zurückgibt, deren <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> Eigenschaft.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Elements ab bzw. legt diese fest.</summary>
        <value>Die Breite des Elements im [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein. Informationen zur Obergrenze finden Sie unter „Hinweise“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> , die Breiteninformationen angeben.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> dann berücksichtigt werden müssen <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und abschließend, wenn diese innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Der Rückgabewert dieser Eigenschaft ist immer mit dem jeder Wert, der darauf festgelegt wurde. Im Gegensatz dazu ist der Wert, der die <xref:System.Windows.FrameworkElement.ActualWidth%2A> abweichen. Das Layout kann die vorgeschlagene Größe aus irgendeinem Grund abgelehnt haben. Das Layoutsystem selbst kann auch asynchron relativ zu den System-Eigenschaftensatz der <xref:System.Windows.FrameworkElement.Width%2A> und möglicherweise nicht verarbeitet, insbesondere die Änderung noch Größe.  
  
 Zusätzlich zu den akzeptablen <xref:System.Double> Werte, die diese Eigenschaft kann auch sein <xref:System.Double.NaN?displayProperty=nameWithType>. Dies ist wie der automatische Größenanpassungsverhalten angeben. In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sie legen den Wert der Zeichenfolge "Für" automatisch"(Groß-/Kleinschreibung beachten) um das automatische Größenanpassungsverhalten zu aktivieren. Das automatische Größenanpassungsverhalten impliziert, dass das Element die verfügbare Breite ausgefüllt werden. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte in den Standardarten, die deaktiviert wird, das automatische Größenanpassungsverhalten bereitstellen, es sei denn, es explizit erneut aktiviert wird.  
  
 Zusätzlich zu die Überprüfung ist es eine nicht deterministische obere Grenze für den Wert <xref:System.Windows.FrameworkElement.Width%2A> , die vom Layoutsystem erzwungen wird (Dies ist eine sehr große Anzahl, die größer als <xref:System.Single.MaxValue?displayProperty=nameWithType> jedoch kleiner als <xref:System.Double.MaxValue?displayProperty=nameWithType>). Wenn Sie diese Grenze überschreiten, das Element wird nicht gerendert werden, und keine Ausnahme ausgelöst wird. Stellen Sie keine <xref:System.Windows.FrameworkElement.Width%2A> auf einen Wert, der ist wesentlich größer als die maximale Größe einer möglichen visuelle Anzeige, oder wenn Sie diese nicht deterministisch Obergrenze überschreiten darf.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Für die Instanz den Wert `1` akzeptabel ist.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einem der folgenden Deklaration Einheitenzeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px`(Standard)[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in`ist Zoll. 1 In == 96px  
  
 `cm`ist Zentimeter an. 1cm==(96/2.54) px  
  
 `pt`ist die Punkte. 1pt==(96/72) px  
  
 `Auto`  
 Ermöglicht automatisches Anpassen der Größe Verhalten. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Width" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
