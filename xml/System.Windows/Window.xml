<Type Name="Window" FullName="System.Windows.Window">
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Bietet die Möglichkeit zum Erstellen, konfigurieren, anzeigen und Verwalten der Lebensdauer von Fenstern und Dialogfeldern.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ort der Interaktion zwischen einem Benutzer und eine eigenständige Anwendung ist ein Fenster. Ein [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Fenster besteht aus zwei unterschiedlichen Bereichen:  
  
-   Ein nicht-Clientbereich, hostet die Windows-Zusatzelemente, z. B. ein Symbol, Titel, Systemmenü, Minimieren-Schaltfläche, Schaltfläche, Schaltfläche "Wiederherstellen", Schaltfläche "Schließen" und einen Rahmen zu maximieren.  
  
-   Ein Client-Bereich, der anwendungsspezifischen Inhalt hostet.  
  
 Standardfensters ist in der folgenden Abbildung gezeigt:  
  
 ![Fensterelemente](~/add/media/windowoverviewfigure1.PNG "Fensterelemente")  
  
 <xref:System.Windows.Window>Kapselt die Möglichkeit zu erstellen, konfigurieren, anzeigen und Verwalten der Lebensdauer von Fenstern und Dialogfeldern, und stellt die folgenden wichtige Dienste bereit:  
  
 **Verwaltung der Objektlebensdauer**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Fensterverwaltung**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Aussehen und Verhalten**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>,<xref:System.Windows.Window.WindowStyle%2A>  
  
 **Dialogfelder**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Darüber hinaus <xref:System.Windows.Application> spezielle Unterstützung für die Verwaltung aller Fenster in einer Anwendung macht:  
  
-   Dienstanwendung verwaltet eine Liste aller Fenster angezeigt, die zurzeit in der Anwendung instanziiert werden. Diese Liste wird verfügbar gemacht, indem die <xref:System.Windows.Application.Windows%2A> Eigenschaft.  
  
-   Standardmäßig <xref:System.Windows.Application.MainWindow%2A> wird automatisch mit einem Verweis auf das erste festgelegt <xref:System.Windows.Window> , die in einer Anwendung instanziiert wird. Diese und dem Fenster das Hauptanwendungsfenster macht.  
  
 Ein <xref:System.Windows.Window> mit Markup, Markup und CodeBehind oder Code implementiert werden können.  
  
 <xref:System.Windows.Window>wird hauptsächlich verwendet, um Fenster und Dialogfelder für eigenständige Anwendungen anzuzeigen. Für Anwendungen, die Navigation auf der Fenster-Ebene, z. B. Assistenten, erfordern Sie können jedoch <xref:System.Windows.Navigation.NavigationWindow> stattdessen; <xref:System.Windows.Navigation.NavigationWindow> leitet sich von <xref:System.Windows.Window> und erweitert sie mit Unterstützung für die Navigation im Webbrowserstil.  
  
> [!NOTE]
>  Inseln navigierbar Inhalte können integriert werden, in andere Inhalte und Container, die mit <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window>muss `UnmanagedCode` Sicherheitsberechtigung instanziiert werden. Dies hat folgenden Konsequenzen:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-bereitgestellten eigenständige Anwendungen fordert berechtigungserweiterung beim Start von Zonen "Internet" oder "Lokales Intranet.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]die fordern etwas kleiner als die uneingeschränkte Berechtigungen nicht Windows oder Dialogfelder instanziieren können.  
  
 Informationen zur Bereitstellung einer eigenständigen Anwendung und Überlegungen zur Sicherheit finden Sie unter [WPF-Sicherheitsstrategie – Plattformsicherheit](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Ein <xref:System.Windows.Window> ist eine <xref:System.Windows.Controls.ContentControl>, was bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. B. eine Zeichenfolge, ein Bild oder ein Bereich) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse. Darüber hinaus <xref:System.Windows.Window> ein Stammelement und aus diesem Grund darf nicht Teil einer anderen Elementinhalt.  
  
> [!NOTE]
>  Die <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften für eine <xref:System.Windows.Window> über einen Stil nicht ausgeglichen werden zur Laufzeit.  
  
## <a name="customizing-the-window-control"></a>Anpassen des Window-Steuerelements  
 Zum Anwenden der gleichen eigenschafteneinstellungen mit mehreren <xref:System.Windows.Window> -Steuerelemente verwenden die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Sie können den Standardwert ändern <xref:System.Windows.Controls.ControlTemplate> auf dem Steuerelement ein einzigartiges aussehen zu verleihen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate>, finden Sie unter [Anpassen der Darstellung von einem vorhandenen Steuerelement durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Um anzuzeigen, die Teile und Zustände, die spezifisch für die <xref:System.Windows.Window>, finden Sie unter [Fensterstile und Vorlagen](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat für das Steuerelement festgelegt werden.  Wenn eine Eigenschaft von einem Standardformat festgelegt ist, kann die Eigenschaft von seinem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt, welche desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Standard-WPF-Designs](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Festlegen einer visuellen Eigenschaft haben nur Auswirkungen, wenn diese Eigenschaft sowohl in vorhanden ist <xref:System.Windows.Window> Steuerelement die Standardvorlage und festgelegt ist, mit ein. Sie finden eine Liste der Eigenschaften visueller Elemente im Abschnitt "Ändern der visuellen Struktur eines Steuerelements" [Anpassen der Darstellung von einem vorhandenen Steuerelement durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein standard-Fenster wird nur mit Markup definiert:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Das folgende Beispiel zeigt, wie ein Standardfenster mit definiert wurde nur code:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Das folgende Beispiel zeigt, wie ein standard-Fenster wird mit einer Kombination von Markup und CodeBehind definiert.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Window" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor initialisiert die <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften mit ihren Standardwerten <xref:System.Windows.Window> Werte.  
  
 Erstellt ein Fenster innerhalb eine <xref:System.AppDomain> mit dem ein <xref:System.Windows.Application> -Objekt, fügt der Konstruktor der <xref:System.Windows.Window> Objekt, das den Satz von <xref:System.Windows.Application>-verwaltete Windows über die <xref:System.Windows.Application.Windows%2A> Eigenschaft von der <xref:System.Windows.Application> Objekt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung für dieses Objekt unsichere systemeigene Methoden aufrufen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, das Fenster im Vordergrund angezeigt, und aktiviert.</summary>
        <returns>
          <see langword="true" />Wenn die <see cref="T:System.Windows.Window" /> wurde erfolgreich aktiviert wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln, die bestimmen, ob das Fenster aktiviert ist, sind identisch mit denen von verwendet die [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` Funktion ("User32.dll").  
  
 Wenn das Fenster, in aktiviert ist eine [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] Anwendung, die nicht die benutzeranwendung Vordergrund ist <xref:System.Windows.Application.Activated> Ereignis wird ausgelöst.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster zu aktivieren. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster das Fenster im Vordergrund steht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster aktiviert ist (wird das Fenster im Vordergrund) Wenn:  
  
-   Das Fenster wird zuerst geöffnet werden.  
  
-   Ein Benutzer wechselt zu einem Fenster, indem Sie sie auswählen, mit der Maus, und drücken ALT + TAB, oder im Task Manager.  
  
-   Ein Benutzer klickt auf die Schaltfläche auf der Taskleiste des Fensters.  
  
 Windows, die erkennen, wenn es sich bei Aktivierung müssen können behandeln die <xref:System.Windows.Window.Activated> Ereignis.  
  
 Nachdem ein Fenster erstmals aktiviert ist, kann es deaktiviert und erneut mehrere Male während seiner Lebensdauer aktiviert. Wenn das Verhalten einer Anwendungsverzeichnis oder der Zustand von Aktivierungszustand abhängig ist, können Sie überprüfen <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungsstatus befindet sich im.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob der Clientbereich eines Fensters Transparenz unterstützt.</summary>
        <value>
          <see langword="true" />Wenn das Fenster Transparenz unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft eines Fensters festgelegt ist, um eine transparente Farbe, mit <xref:System.Windows.Media.Brushes.Transparent%2A> beispielsweise bleibt das Fenster nicht transparent. Dies bedeutet, dass alle ausgeführten Anwendungen "das Fenster beneath" und auf dem Desktop nicht angezeigt werden. So aktivieren Sie diese Art von Transparenz, <xref:System.Windows.Window.AllowsTransparency%2A> muss festgelegt werden, um `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A>ist vorhanden, um die Erstellung von nicht rechteckigen Fenstern zu erleichtern und folglich beim <xref:System.Windows.Window.AllowsTransparency%2A> festgelegt ist, um `true`, ein Fenster <xref:System.Windows.Window.WindowStyle%2A> Eigenschaft muss festgelegt werden, um <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein Fenster mit einem <see cref="P:System.Windows.Window.WindowStyle" /> Wert von anderem außer <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.AllowsTransparency" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Ein <see cref="T:System.Windows.Size" /> , die die endgültige Größe, die Fenster verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen wiedergibt.</param>
        <summary>Überschreiben Sie diese Methode zum Anordnen von sowie die Größe eines Fensters und seine untergeordneten Elemente.</summary>
        <returns>Ein <see cref="T:System.Windows.Size" /> , wiedergibt, dass die tatsächliche Größe, die verwendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A>wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert des <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> auf festgelegt ist <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Manuell schließt eine <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Window> kann geschlossen werden, verwenden eine von mehreren, bekannte, vom System bereitgestellte Mechanismen in der Titelleiste befindet:  
  
-   ALT + F4.  
  
-   Systemmenü &#124; **Schließen**.  
  
-   **Schließen** Schaltfläche.  
  
 Ein <xref:System.Windows.Window> kann geschlossen werden mit einer von mehreren bekannten Mechanismen im Clientbereich, die von Entwicklern, einschließlich bereitgestellt werden:  
  
-   **Datei** &#124; **Beenden** auf ein Hauptfenster.  
  
-   **Datei** &#124; **Schließen** oder ein **schließen** auf ein untergeordnetes Fenster auf die Schaltfläche.  
  
> [!NOTE]
>  **OK** und **"Abbrechen"** Schaltflächen in einem Dialogfeld werden auch von Entwicklern bereitgestellt, obwohl wird wahrscheinlich Satz <xref:System.Windows.Window.DialogResult%2A>, die automatisch geschlossen wird, ein Fenster, das durch den Aufruf geöffnet wurde <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Diese Mechanismen erfordern Sie explizit aufrufen <xref:System.Windows.Window.Close%2A> um ein Fenster zu schließen.  
  
> [!NOTE]
>  Wenn ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, und mit einer <xref:System.Windows.Controls.Button> mit seiner <xref:System.Windows.Controls.Button.IsCancel%2A> -Eigenschaft auf "true" festgelegt wird automatisch geschlossen, wenn die Schaltfläche geklickt oder die ESC-Taste gedrückt wird. Wenn das Fenster geöffnet wurde mit <xref:System.Windows.Window.Show%2A>, allerdings <xref:System.Windows.Window.Close%2A> muss explizit aufgerufen werden, z. B. <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für das <xref:System.Windows.Controls.Button>.  
  
 Schließen eines Fensters bewirkt, dass die <xref:System.Windows.Window.Closing> Ereignis ausgelöst wurde. Wenn die <xref:System.Windows.Window.Closing> Ereignis wird nicht abgebrochen, geschieht Folgendes:  
  
-   Die <xref:System.Windows.Window> wird daraus <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (wenn ein <xref:System.Windows.Application> Objekt vorhanden ist).  
  
-   Die <xref:System.Windows.Window> wird vom Besitzer entfernt <xref:System.Windows.Window> , wenn die Besitzer contosoit Beziehung hergestellt wurde vor der Besitzer <xref:System.Windows.Window> angezeigt wurde und nach der Besitzer <xref:System.Windows.Window> geöffnet wurde.  
  
-   Das <xref:System.Windows.Window.Closed>-Ereignis wird ausgelöst.  
  
-   Nicht verwaltete Ressourcen erstellt, indem die <xref:System.Windows.Window> verworfen werden.  
  
-   Wenn <xref:System.Windows.Window.ShowDialog%2A> wurde aufgerufen, um das Anzeigen der <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> zurückgibt.  
  
 Schließen einer <xref:System.Windows.Window> bewirkt, dass alle Fenster, die er besitzt, um die geschlossen werden. Darüber hinaus schließen eine <xref:System.Windows.Window> kann dazu führen, dass eine Anwendung beendet wird, je nachdem, wie der <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> festgelegt wird.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine **Datei** &#124; **Beenden** Menü wird behandelt, um explizit aufrufen <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Fenster zu schließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem dieses Ereignis ausgelöst wird, kann nicht schließen ein Fensters verhindert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" />festgelegt ist, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, oder <see cref="M:System.Windows.Window.Hide" /> aufgerufen wird, während ein Fenster geschlossen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, direkt nachdem <see cref="M:System.Windows.Window.Close" /> wird aufgerufen, und behandelt werden können, um das Schließen des Fensters "Abbrechen".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing>kann behandelt werden, um zu erkennen, wenn ein Fenster geschlossen wird (z. B. wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird). Darüber hinaus <xref:System.Windows.Window.Closing> können verwendet werden, um zu verhindern, dass ein Fenster schließen. Zum Schließen ein Fensters zu verhindern, legen Sie die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> Argument für `true`.  
  
 Die <xref:System.Windows.Window.Closing> Ereignis wird ausgelöst, wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird, wenn ein Fenster Schaltfläche "Schließen" geklickt wird oder wenn der Benutzer drückt, ALT + F4.  
  
 Wenn ein Besitzer Fenster geöffnet wurde, dessen Besitzer Fenster mit <xref:System.Windows.Window.Show%2A>, und der Besitzer Fenster geschlossen ist, wird des zugehörige Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst. Wenn der Besitzer eines Fensters geschlossen wird (finden Sie unter <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> nicht für das zugehörige Fenster ausgelöst wird.  
  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, die <xref:System.Windows.Window.Closing> Ereignis für jedes Fenster wird ausgelöst. Jedoch wenn <xref:System.Windows.Window.Closing> wird abgebrochen, Abbruch wird ignoriert.  
  
 Wenn eine Sitzung beendet, da ein Benutzer abmeldet oder Herunterfahren <xref:System.Windows.Window.Closing> wird nicht ausgelöst; behandeln <xref:System.Windows.Application.SessionEnding> um Code zu implementieren, das Schließen der Anwendung abbricht.  
  
 Wenn Sie anzeigen oder Ausblenden eines Fensters während der Lebensdauer einer Anwendung mehrmals möchten und nicht das Fenster jedes Mal neu instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> Ereignis, brechen Sie ihn ab, und rufen die <xref:System.Windows.Window.Hide%2A> Methode. Rufen Sie Sie dann <xref:System.Windows.Window.Show%2A> in der gleichen Instanz aus, um es erneut zu öffnen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Window> , der bestimmt, ob zum Schließen ein Benutzereingriff erforderlich.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
[!code-xaml[WindowClosingSnippets#WindowClosingXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml2)]  
  
 [!code-csharp[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs#windowclosingcodebehind1)]
 [!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb#windowclosingcodebehind1)]  
[!code-csharp[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs#windowclosingcodebehind2)]
[!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb#windowclosingcodebehind2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" />festgelegt ist, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, oder <see cref="M:System.Windows.Window.Close" /> aufgerufen wird, während ein Fenster geschlossen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt nach dem Rendern des Inhalts eines Fensters auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Fenster um keinen Inhalt hat, wird dieses Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster zum Hintergrundfenster wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster ist deaktiviert (wird zu einem Hintergrundfenster) Wenn:  
  
-   Ein Benutzer wechselt zu einem anderen Fenster in der aktuellen Anwendung.  
  
-   Ein Benutzer wechselt zum Fenster in einer anderen Anwendung mithilfe der Tastenkombination ALT + TAB oder mithilfe von Task-Manager.  
  
-   Ein Benutzer klickt auf die Taskleistenschaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Windows, die erkennen, wenn die Deaktivierung durch behandeln müssen die <xref:System.Windows.Window.Deactivated> Ereignis.  
  
 Nachdem ein Fenster zunächst deaktiviert ist, kann Sie erneut aktiviert und oft während seiner Lebensdauer deaktiviert werden. Wenn das Verhalten einer Anwendungsverzeichnis oder der Zustand von Aktivierungszustand abhängig ist, können Sie überprüfen <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungsstatus befindet sich im.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Wert der Dialogfeld-Ergebnis, das den Wert, der von zurückgegeben wird die <see cref="M:System.Windows.Window.ShowDialog" /> Methode.</summary>
        <value>Ein <see cref="T:System.Nullable`1" /> Wert vom Typ <see cref="T:System.Boolean" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A>kann verwendet werden, aus dem Code, der ein Dialogfeld, um zu bestimmen, ob ein Benutzer akzeptiert ergab (`true`) oder abgebrochen wurde (`false`) des Dialogfelds "". Wenn ein Dialogfeld akzeptiert wurde, bedeutet dies, um den Code, der zum Abrufen von Daten, die vom Benutzer gesammelt wurden und verarbeiten sie das Dialogfeld geöffnet. Wenn ein Dialogfeld abgebrochen wurde, allerdings bedeutet dies, dass das Aufrufen von Code beendet werden soll, weitere Verarbeitung.  
  
 Wird standardmäßig ein Dialogfeld abgebrochen wird, wenn ein Benutzer eine der folgenden ist:  
  
-   PressesALT + F4.  
  
-   Klickt der **schließen** Schaltfläche.  
  
-   Wählt **schließen** aus dem Systemmenü.  
  
 In all diesen Fällen <xref:System.Windows.Window.DialogResult%2A> ist `false` standardmäßig.  
  
 Ein Dialogfeld, in der Regel stellt eine spezielle Schaltfläche, um ein Dialogfeld "Abbrechen", die die Schaltfläche "", deren <xref:System.Windows.Controls.Button.IsCancel%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche, die auf diese Weise konfiguriert wird ein Fenster automatisch geschlossen, wenn entweder es gedrückt wird oder wenn die ESC-Taste gedrückt wird. In diesen Fällen <xref:System.Windows.Window.DialogResult%2A> bleibt `false`.  
  
 Ein Dialogfeld in der Regel auch eine Bestätigungsschaltfläche, die die Schaltfläche "" enthält, deren <xref:System.Windows.Controls.Button.IsDefault%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche, die diese Art konfigurierten löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis aus, wenn sie oder die EINGABETASTE gedrückt wird. Jedoch wird nicht automatisch das Dialogfeld schließen, noch wird festgelegt <xref:System.Windows.Window.DialogResult%2A> auf `true`. Müssen Sie manuell dieser Schreiben von Code in der Regel aus der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für die Standardschaltfläche.  
  
 <xref:System.Windows.Window.DialogResult%2A>ist `null` das Dialogfeld wird angezeigt, wenn jedoch weder akzeptiert noch abgebrochen.  
  
 Nachdem ein Dialogfeld wird, und geschlossen Sie erhalten das Dialogergebnis über den Rückgabewert von <xref:System.Windows.Window.ShowDialog%2A> -Methode, oder durch Überprüfen der <xref:System.Windows.Window.DialogResult%2A> Eigenschaft.  
  
 <xref:System.Windows.Window.DialogResult%2A>kann nur festgelegt werden, wenn eine <xref:System.Windows.Window> geöffnet wird, durch Aufrufen seiner <xref:System.Windows.Window.ShowDialog%2A> Methode.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Schaltfläche "OK" und eine Schaltfläche "Abbrechen", um die entsprechende zurückzugeben konfigurieren <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" />wird festgelegt, bevor ein Fenster, durch den Aufruf geöffnet wird <see cref="M:System.Windows.Window.ShowDialog" />.  
  
 - oder -   
  
 <see cref="P:System.Windows.Window.DialogResult" />wird festgelegt, ein Fenster, das durch Aufrufen von <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem sich die DPI-Auflösung des Bildschirms geändert hat, auf dem das Fenster angezeigt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see cref="T:System.Windows.RoutedEvent" /> für den Fall, dass der DPI-Wert des Bildschirms, der das Fenster anzeigt, geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht einem Fenster über einen verfügbar gemachten Bereich des Clientbereichs des Fensters durch eine Maus mit die linke Maustaste gedrückt gezogen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die linke Maustaste gedrückt werden muss, heruntergefahren, wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird. Eine Möglichkeit zum erkennen, wenn die linke Maustaste gedrückt wird, zu behandeln ist die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis.  
  
 Wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird, wird die linke Maustaste über einen verfügbar gemachten Bereich des Clientbereichs des Fensters gedrückt werden muss.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> Aufrufen <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die linke Maustaste gedrückt wird nicht nach unten.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster ziehen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Das Dependency-Objekt.</param>
        <summary>Gibt einen Verweis auf die <see cref="T:System.Windows.Window" /> Objekt, das die Struktur die hostet, anhand derer das Dependency-Objekt befindet.</summary>
        <returns>Ein <see cref="T:System.Windows.Window" /> Verweis auf das Hostfenster.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Macht ein Fenster unsichtbar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird nicht geschlossen, wenn es ausgeblendet ist, und weder die <xref:System.Windows.Window.Closing> noch <xref:System.Windows.Window.Closed> Ereignis wird ausgelöst. Stattdessen des Fensters <xref:System.Windows.UIElement.Visibility%2A> -Eigenschaftensatz auf <xref:System.Windows.Visibility?displayProperty=nameWithType>.  
  
 Wenn ein Fenster der Anwendungsverzeichnis wird <xref:System.Windows.Application.MainWindow%2A> und die Anwendung <xref:System.Windows.Application.ShutdownMode%2A> ist <xref:System.Windows.ShutdownMode.OnMainWindowClose>, die Anwendung wird nicht heruntergefahren. Andererseits die Anwendung wird nicht heruntergefahren, wenn ein Fenster das einzige Fenster ist und Modus Herunterfahren der Anwendung <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Wenn Sie anzeigen oder Ausblenden eines Fensters während der Lebensdauer einer Anwendung mehrmals, und nicht das Fenster jedes Mal erneut instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> Ereignis, brechen Sie ihn ab, und rufen die <xref:System.Windows.Window.Hide%2A> Methode. Rufen Sie Sie dann <xref:System.Windows.Window.Show%2A> in der gleichen Instanz aus, um es erneut zu öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" />für ein Fenster, die geschlossen werden aufgerufen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, oder legt ihn fest Symbol eines Fensters.</summary>
        <value>Ein <see cref="T:System.Windows.Media.ImageSource" /> Objekt, das das Symbol darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)]eigenständige Anwendungen sind zwei Symbole:  
  
-   Eine Assembly-Symbol, das mithilfe des Parameters der `<ApplicationIcon>` Datei Eigenschaft im Projekt der Anwendung zu erstellen. Dieses Symbol wird als das Desktopsymbol für eine Assembly verwendet.  
  
    > [!NOTE]
    >  Beim Debuggen in Visual Studio möglicherweise das Symbol nicht aufgrund der Hostprozess angezeigt. Wenn Sie die ausführbare Datei ausführen, wird das Symbol angezeigt. Weitere Informationen finden Sie unter [Hostprozess (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Ein Symbol pro Fenster, das durch Festlegen von angegebenen <xref:System.Windows.Window.Icon%2A>. Für jedes Fenster wird dieses Symbol in der Titelleiste der Taskleistenschaltfläche und in die Tastenkombination ALT + TAB Auswahl-Liste Anwendungseintrag verwendet.  
  
 Ein [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster wird immer ein Symbol angezeigt. Wenn nicht bereitgestellt durch Festlegen von <xref:System.Windows.Window.Icon%2A>, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] wählt ein Symbol, um anzuzeigen, anhand der folgenden Regeln:  
  
1.  Verwenden Sie das Symbol "Assembly", falls angegeben.  
  
2.  Wenn das Symbol "Assembly" nicht angegeben ist, verwenden Sie den Standardnamen [!INCLUDE[TLA#tla_win](~/includes/tlasharptla-win-md.md)] Symbol.  
  
 Bei Verwendung von <xref:System.Windows.Window.Icon%2A> um ein benutzerdefiniertes Fenstersymbol angeben, können Sie das Standardsymbol für die Anwendung wiederherstellen, indem festlegen <xref:System.Windows.Window.Icon%2A> auf `null`.  
  
 Ein einzelnes Symbol in einer Vielzahl von Möglichkeiten genutzt werden [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)], einschließlich der in der Titelleiste eines Fensters, auf der Taskleiste für ein Fenster angezeigt wird die Tastenkombination ALT + TAB Auswahlliste Datei. Jedes davon wird gezeigt, das Symbol mit einer anderen Größe: ein 16 x 16 Pixel-Symbol wird in der Titelleiste eines Fensters und in der Taskleiste angezeigt, während ein 32 x 32 Pixel großes Symbol in der Dateiliste Auswahl ALT + TAB angezeigt wird. Einige Anwendungen wie [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], geben Sie einen **Ansicht** Menü, mit dem Sie die Größe des Symbols zu wählen, Sie anzeigen möchten.  
  
 Um die verschiedenen Anzeigegrößen erfüllen, eine Symboldatei mindestens eine tatsächliche Symbole besteht, in denen jeweils eine Version des Symbols darstellt, die eine bestimmte Größe und Farbe Tiefe ausgerichtet ist. Beispielsweise kann ein Symbol nur besitzen ein einzelnes 16 x 16 Pixelsymbol mit 16 Farben während eine andere 16 x 16 Pixel und 32 x 32 Pixel großes Symbole mit 16 Farben und 256 Farben enthalten kann.  
  
 Wenn in einer Symboldatei Symbole für alle möglichen Größen und Farbtiefen vorhanden <xref:System.Windows.Window> wird das entsprechende Symbol verwenden. Wenn eine Symboldatei nur eine Teilmenge aller möglichen Symbole enthält <xref:System.Windows.Window> das nächste Symbol "am besten geeignete" sinkender Größen und Farbtiefe verwendet.  
  
 Das Ergebnis ist, dass ein Symbol wird immer durch verwendet, <xref:System.Windows.Window>, obwohl das Symbol verwendet nicht die erforderliche Größe und die Farbtiefe Ziel verwenden kann. Beispielsweise kann ein Pixelsymbol 16 x 16 mit 16 Farben für die Anzeige als ein 32 x 32 Pixel großes Symbol mit 256 Farben verwendet werden. Dies kann dazu führen, dass unerwünschte visuelle Effekte wie geglättet, jedoch möglicherweise vermieden werden, indem Sie die Symbole für alle entsprechenden Größe und Farbe Tiefen erstellen.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IconProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie ein Symbol "Fenster" festgelegt wird.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Festlegen des Symbols. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Icon" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob das Fenster aktiv ist.</summary>
        <value>
          <see langword="true" />Wenn das Fenster aktiv ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein aktiven Fensters wird der aktuelle Vordergrundfenster des Benutzers und den Fokus hat, was durch die aktive Darstellung der Titelleiste angezeigt wird. Ein aktives Fenster werden auch die oberste alle Fenster auf oberster Ebene, die nicht explizit festlegen der <xref:System.Windows.Window.Topmost%2A> Eigenschaft.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IsActiveProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.IsActive" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Position des linken Rand des Fensters, in Bezug auf dem Desktop.</summary>
        <value>Die Position des linken Fensterrands in logischen Einheiten (1/96 Zoll).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert wird oder minimiert, dieser Wert darstellt, die der linke Rand der Wiederherstellung von Wiederherstellungspunkten für die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Left%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch die Systemstandardwert angeben, durch Festlegen von <xref:System.Windows.Window.Left%2A> auf <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.LeftProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Left" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich die Position des Fensters ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position des Fensters wird geändert, wenn:  
  
-   Ein Benutzer verschiebt ein Fenster durch ziehen es mit der Titelleiste des Fensters.  
  
-   Ein Fenster verschoben wird, nachdem <xref:System.Windows.Window.DragMove%2A> aufgerufen wird.  
  
-   Entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> Eigenschaft programmgesteuert festgelegt ist.  
  
-   Die **verschieben** Menüelement Systemmenü des Fensters ausgewählt ist.  
  
-   Die <xref:System.Windows.Window.WindowState%2A> -Eigenschaft geändert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für ein Fenster logischen untergeordneten Elemente ab.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" /> die logischen untergeordneten Elemente eines Fensters.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Ein <see cref="T:System.Windows.Size" /> , die verfügbare Größe, die in diesem Fenster auf das untergeordnete Element setzen kann wiedergibt. Unendlich kann als Wert zugewiesen werden, um anzugeben, dass die Größe des Fensters des jeweiligen Inhalts angepasst wird.</param>
        <summary>Überschreiben Sie diese Methode, um die Größe eines Fensters zu ermitteln.</summary>
        <returns>Ein <see cref="T:System.Windows.Size" /> , die Größe, die dieses Fenster muss während des Layouts bestimmt, basierend auf der Berechnung des children's Größen wiedergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A>wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert des <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> auf festgelegt ist <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Activated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnActivated%2A> wird das <xref:System.Windows.Window.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnActivated%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnActivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Activated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Closed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosed%2A> wird das <xref:System.Windows.Window.Closed>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnClosed%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnClosed%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closed> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Closing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosing%2A> wird das <xref:System.Windows.Window.Closing>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnClosing%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnClosing%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closing> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Ein Verweis auf den Stamm der Struktur der alten.</param>
        <param name="newContent">Ein Verweis auf den Stamm der Struktur der neuen.</param>
        <summary>Wird aufgerufen, wenn die <see cref="P:System.Windows.Controls.ContentControl.Content" /> -Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.ContentRendered" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnContentRendered%2A> wird das <xref:System.Windows.Window.ContentRendered>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnContentRendered%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnContentRendered%2A> in der Basisklasse Wenn <xref:System.Windows.Window.ContentRendered> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt und gibt eine <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> für dieses Objekt <see cref="T:System.Windows.Window" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> für dieses Objekt <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Deactivated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnDeactivated%2A> wird das <xref:System.Windows.Window.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnDeactivated%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnDeactivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Deactivated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Die vorherige DPI-Größeneinstellung.</param>
        <param name="newDpi">Die neue DPI-Größeneinstellung.</param>
        <summary>Wird aufgerufen, wenn sich der DPI-Wert ändert, mit dem dieses Fenster gerendert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.LocationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnLocationChanged%2A> wird das <xref:System.Windows.Window.LocationChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnLocationChanged%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnLocationChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.LocationChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses, die das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.SourceInitialized" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnSourceInitialized%2A> wird das <xref:System.Windows.Window.SourceInitialized>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnSourceInitialized%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnSourceInitialized%2A> in der Basisklasse Wenn <xref:System.Windows.Window.SourceInitialized> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.StateChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnStateChanged%2A> wird das <xref:System.Windows.Window.StateChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnStateChanged%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnStateChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.StateChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das vorherige übergeordnete Element. Legen Sie auf null, wenn die <see cref="T:System.Windows.DependencyObject" /> verfügte nicht über eine vorherige übergeordnete Element.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element des Fensters geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Windows, die Besitzer dieses Fenster ist.</summary>
        <value>Ein <see cref="T:System.Windows.WindowCollection" /> enthält Verweise auf die der Besitzer dieses Fenster ist Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein im Besitz befindlichen Fenster ist eine, deren <xref:System.Windows.Window.Owner%2A> Eigenschaftensatz mit einem Verweis auf ein anderes Fenster, das als das besitzende Fenster bezeichnet wird. Um alle Fenster suchen, die einem Besitzerfenster gehören, können Sie auflisten <xref:System.Windows.WindowCollection> der zurückgegeben wird, indem die <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie auflisten <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die <see cref="T:System.Windows.Window" /> , besitzt dies <see cref="T:System.Windows.Window" />.</summary>
        <value>Ein <see cref="T:System.Windows.Window" /> -Objekt, das den Besitzer dieses darstellt <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein untergeordnetes Fenster durch Aufrufen von einem übergeordneten Fenster geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, eine implizite Beziehung zwischen übergeordneten und untergeordneten Fenster eingerichtet. Diese Beziehung erzwingt bestimmte Verhaltensweisen, z. B. in Bezug auf Maximieren, minimieren und wiederherstellen.  
  
 Wenn ein untergeordnetes Fenster durch Aufruf von einem übergeordneten Fenster erstellt wurde <xref:System.Windows.Window.Show%2A>, das untergeordnete Fenster verfügt jedoch nicht über eine Beziehung mit dem übergeordneten Fenster. Dies bedeutet Folgendes:  
  
-   Einen Verweis auf das übergeordnete Fenster keine untergeordneten Fenster.  
  
-   Das Verhalten des untergeordneten Fensters ist nicht das Verhalten des übergeordneten Fensters abhängig; entweder Fenster deckt die andere oder minimiert, maximiert und unabhängig voneinander wiederhergestellt.  
  
 Ermöglicht das Erstellen eine Beziehung zwischen einem untergeordneten Fenster und ein übergeordnetes Fenster, <xref:System.Windows.Window> unterstützt das Konzept des Besitzes. Besitz wird eingerichtet, wenn die <xref:System.Windows.Window.Owner%2A> Eigenschaft eines Fensters (das im Besitz befindlichen Fenster) mit einem Verweis auf ein anderes Fenster (das Besitzerfenster) festgelegt ist.  
  
 Sobald diese Beziehung hergestellt wurde, werden die folgenden Verhalten gezeigt:  
  
-   Wenn ein Besitzerfenster minimiert wird, werden auch alle seine zugehörige Fenster minimiert.  
  
-   Wenn ein Fenster im Besitz befindlichen minimiert wird, ist der Besitzer nicht minimiert.  
  
-   Wenn ein Besitzerfenster maximiert ist, werden das besitzende Fenster und die zugehörige Windows wiederhergestellt.  
  
-   Ein Besitzerfenster kann nie eine zugehörige Fenster abdecken.  
  
-   Im Besitz von Fenstern, die nicht mit geöffnet wurden <xref:System.Windows.Window.ShowDialog%2A> sind nicht modal. Die Benutzer kann weiterhin das besitzende Fenster interagieren.  
  
-   Wenn Sie ein Besitzerfenster schließen, werden die im Besitz befindlichen Windows ebenfalls geschlossen.  
  
-   Wenn ein Besitzer Fenster geöffnet wurde, dessen Besitzer Fenster mit <xref:System.Windows.Window.Show%2A>, und der Besitzer Fenster geschlossen ist, wird des zugehörige Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst.  
  
 Wenn Sie ein untergeordnetes Fenster öffnen, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, Sie sollten auch festlegen, die <xref:System.Windows.Window.Owner%2A> Eigenschaft des untergeordneten Fensters. Wenn Sie dies nicht tun, wird nicht Ihre Benutzer untergeordnetes Fenster und übergeordneten Fenster durch Drücken der Taskleistenschaltfläche wiederherstellen können. Drücken die Taskleistenschaltfläche, wird eine Liste von Windows, einschließlich der untergeordneten und übergeordneten Fenster, um Wählen Sie stattdessen ergeben; nur das ausgewählte Fenster wird wiederhergestellt.  
  
> [!IMPORTANT]
>  Sie sollten auch festlegen, die <xref:System.Windows.Window.Owner%2A> -Eigenschaft für ein Fenster, die durch den Aufruf geöffnet ist <xref:System.Windows.Window.ShowDialog%2A> , das richtige Verhalten mit sicherzustellen.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Besitzer contosoit Beziehung hergestellt wird.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Fenster versucht, sich selbst zu besitzen  
  
 - oder -   
  
 Zwei Windows versuchen, die miteinander besitzen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Window.Owner" /> Eigenschaft wird festgelegt, auf einen sichtbaren Fenster angezeigt, mit<see cref="M:System.Windows.Window.ShowDialog" />  
  
 - oder -   
  
 Die <see cref="P:System.Windows.Window.Owner" /> Eigenschaftensatz ist ein Fenster, das zuvor nicht angezeigt.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Größenänderungsmodus.</summary>
        <value>Ein <see cref="T:System.Windows.ResizeMode" /> Wert, der den Größenänderungsmodus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt vier Optionen aus:  
  
-   **False**. Der Benutzer kann nicht die Fenstergröße ändern. Die Maximieren und minimieren Felder werden nicht angezeigt.  
  
-   **CanMinimize**. Der Benutzer kann nur das Fenster minimieren und Wiederherstellen über die Taskleiste aus. Die Felder minimieren und Maximieren werden angezeigt, aber nur das Kästchen zum Minimieren aktiviert ist.  
  
-   **CanResize**. Der Benutzer kann die vollständige Größe des Fensters Felder minimieren und Maximieren und Größenänderungsoptionen verwenden, um das Fenster. Die Felder minimieren und Maximieren sind angezeigt und aktiviert. (Standard).  
  
-   **CanResizeWithGrip**. Diese Option hat die gleiche Funktionalität wie <xref:System.Windows.ResizeMode.CanResize>, aber der unteren rechten Ecke des Fensters "Resize Ziehpunkts" hinzugefügt.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ResizeModeProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ResizeMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe und Position eines Fensters vor dem Minimieren oder maximiert.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" /> , die gibt die Größe und Position eines Fensters vor dem Minimieren oder maximieren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Rechteck für die Wiederherstellung ist die Region, die vom Fenster belegt wird, bevor es minimiert oder maximiert wurde. Sie können <xref:System.Windows.Window.RestoreBounds%2A> die letzte Größe und Position eines Fensters zu speichern, bevor eine Anwendung geschlossen wird, und diese Werte das nächste Mal eine Anwendung gestartet wird, um ein Fenster der Art und Weise wiederherzustellen, ein Benutzer sie abrufen.  
  
 Wenn Sie Abfragen <xref:System.Windows.Window.RestoreBounds%2A> bevor das Fenster angezeigt wird oder nachdem er geschlossen wurde, <xref:System.Windows.Rect.Empty%2A> wird zurückgegeben.  
  
> [!NOTE]
>  Diese Eigenschaft kann nicht abgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Window.RestoreBounds%2A> und isolierten Speicher, um sicherzustellen, dass die Größe und Position eines Fensters sind die gleiche wie beim vorherigen Mal Fenster gezeigt wurde.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Berechtigung zum Abfragen der Größe und Position eines Fensters für das umgebende Rechteck. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster, und gibt zurück, ohne warten auf das neu geöffnete Fenster zu schließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> Klasse instanziiert wird, ist jedoch nicht standardmäßig angezeigt. <xref:System.Windows.Window.Show%2A>Zeigt ein Fenster, und gibt sofort zurück, ohne zu warten, für das Fenster geschlossen werden. Daher wird das geöffnete Fenster nicht Benutzer verhindert Interaktion mit anderen Fenstern in der Anwendung. Diese Art von Fenster bezeichnet ist ein *nicht modalen* Fenster. Allgemeine Beispiele für nicht modale Fenster sind Eigenschaftenfenster, Toolboxen und Paletten. Um ein Benutzer auf die Interaktion mit einem bestimmten Fenster beschränken möchten, muss das Fenster geöffnet werden durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ein Fenster, das durch Aufrufen von <xref:System.Windows.Window.Show%2A> wird nicht automatisch eine Beziehung mit dem Fenster, das sie geöffnet haben, insbesondere das geöffnete Fenster weiß nicht, welches Fenster öffnen. Diese Beziehung mit hergestellt werden kann die <xref:System.Windows.Window.Owner%2A> Eigenschaft und verwalteten mithilfe der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
 Aufrufen <xref:System.Windows.Window.Show%2A> erzielt wird das gleiche Endergebnis als Einstellung <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft von der <xref:System.Windows.Window> -Objekt <xref:System.Windows.Visibility.Visible>. Allerdings besteht ein Unterschied zwischen den beiden hinsichtlich der zeitlichen Steuerung.  
  
 Aufrufen von <xref:System.Windows.Window.Show%2A> ist ein synchroner Vorgang, der erst nach zurückgibt der <xref:System.Windows.FrameworkElement.Loaded> auf das untergeordnete Fenster-Ereignis ausgelöst wurde:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Festlegen von <xref:System.Windows.UIElement.Visibility%2A>, jedoch ist ein asynchroner Vorgang, der sofort zurückgibt:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Beim Festlegen von <xref:System.Windows.UIElement.Visibility%2A>, alle Fensterereignisse, die Sie registrieren, bevor Sie festlegen, <xref:System.Windows.UIElement.Visibility%2A> kann nicht ausgelöst werden, erst nach der Methode, in dem Sie festlegen <xref:System.Windows.UIElement.Visibility%2A> Ausführung abgeschlossen hat.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie ein nicht modales Fenster zu öffnen.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" />für ein Fenster, die geschlossen werden aufgerufen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob ein Fenster aktiviert ist, wenn Sie zuerst angezeigt.</summary>
        <value>
          <see langword="true" />Wenn ein Fenster aktiviert wird, wenn Sie zuerst angezeigt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Fenster mit seiner <xref:System.Windows.Window.ShowActivated%2A> -Eigenschaftensatz auf `false` ist geöffnet, wird das Fenster nicht aktiviert und die zugehörige <xref:System.Windows.Window.Activated> Ereignis wird nicht ausgelöst, bis ein Benutzer das Fenster manuell durch Auswahl aktiviert. Nachdem das Fenster ausgewählt ist, aktiviert und normalerweise deaktiviert.  
  
 Um zu verhindern, dass ein Fenster wird aktiviert, wenn er geöffnet wird, die <xref:System.Windows.Window.ShowActivated%2A> Eigenschaft muss festgelegt werden, um `false` , bevor das Fenster angezeigt wird (durch Aufrufen von <xref:System.Windows.Window.Show%2A>); Einstellung <xref:System.Windows.Window.ShowActivated%2A> auf `false` ein Fenster angezeigt wird, hat keine Auswirkungen, die nach.  
  
 Festlegen von <xref:System.Windows.Window.ShowActivated%2A> auf `false` für ein Fenster, das durch den Aufruf modal, geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, keine tatsächlichen Auswirkungen hat. Obwohl das modale Fenster nicht aktiviert wird, wird mit modale Fenster verhindert, dass den Benutzer andere Anwendungsfenster aktivieren.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Markup verwendet wird, so konfigurieren Sie ein Fenster geöffnet werden, ohne aktiviert wird.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Das folgende Beispiel zeigt, wie Code verwenden, so konfigurieren Sie ein Fenster geöffnet werden, ohne dass es aktiviert wird.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ShowActivated" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster, und gibt nur, wenn das neu geöffnete Fenster geschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> Wert vom Typ <see cref="T:System.Boolean" /> , der angibt, ob die Aktivität übergeben wurde, akzeptiert (<see langword="true" />) oder abgebrochen wurde (<see langword="false" />). Der Rückgabewert ist der Wert, der die <see cref="P:System.Windows.Window.DialogResult" /> Eigenschaft vor dem Schließen eines Fensters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Window> Klasse instanziiert wird, ist jedoch nicht standardmäßig angezeigt. <xref:System.Windows.Window.ShowDialog%2A>Zeigt das Fenster deaktiviert alle anderen Fenster in der Anwendung und gibt nur, wenn das Fenster geschlossen wird. Diese Art von Fenster wird als bezeichnet eine *modale* Fenster.  
  
 Modale Fenster werden in erster Linie als Dialogfelder verwendet. Ein Dialogfeld ist eine besondere Art von Fenster, die Anwendungen für die Interaktion mit Benutzern die Ausführung von Aufgaben wie das Öffnen von Dateien oder Drucken von Dokumenten verwenden. Dialogfelder Benutzern häufig zu akzeptieren, oder brechen Sie den Task für den sie vor dem Schließen des Dialogfelds angezeigt wurden. <xref:System.Windows.Window.ShowDialog%2A>Gibt eine <xref:System.Nullable%601> <xref:System.Boolean> Wert, der angibt, ob die Aktivität bestätigt oder abgebrochen wurde. Der Rückgabewert ist der Wert, der die <xref:System.Windows.Window.DialogResult%2A> Eigenschaft vor dem Schließen eines Fensters. Weitere Informationen finden Sie unter <xref:System.Windows.Window.DialogResult%2A>.  
  
 Ein Fenster, das durch Aufrufen von der <xref:System.Windows.Window.ShowDialog%2A> Methode muss nicht automatisch eine Beziehung mit dem Fenster, die es geöffnet; insbesondere das geöffnete Fenster weiß nicht, welches Fenster öffnen. Diese Beziehung mit hergestellt werden kann die <xref:System.Windows.Window.Owner%2A> Eigenschaft und verwalteten mithilfe der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft. Zur Unterstützung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Automation (finden Sie unter [Übersicht über die Benutzeroberflächenautomatisierung](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> muss festgelegt werden, für ein Fenster geöffnet, die durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster (ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>) geschlossen wird, die zuvor aktivierten Fenster erneut aktiviert. Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster verfügt über kein Besitzerfenster (finden Sie unter <xref:System.Windows.Window.Owner%2A>), das besitzende Fenster wird nicht erneut aktiviert, wenn der modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster wird geschlossen, es sei denn, sie Fenster zuvor aktiviert war.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie ein modales Fenster geöffnet.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" />für ein Fenster, die geschlossen werden aufgerufen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster zu aktivieren. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob das Fenster mit eine Taskleistenschaltfläche verfügt.</summary>
        <value>
          <see langword="true" />Wenn das Fenster mit einer Taskleistenschaltfläche verfügt über; andernfalls <see langword="false" />. Gilt nicht für das Fenster in einem Browser gehostet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.ShowInTaskbar%2A> festgelegt ist, um `true`, das Fenster wird auch in der Auswahlliste der Tastenkombination ALT + TAB-Anwendung angezeigt.  
  
 Das Symbol, das für die Taskleistenschaltfläche und die Tastenkombination ALT + TAB Anwendungsauswahlliste verwendet wird, ist der Wert von der <xref:System.Windows.Window.Icon%2A> Eigenschaft.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ShowInTaskbar" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab (bzw. legt diesen fest), der angibt, ob ein Fenster seine Größe automatisch an die Größe seines Inhalts anpasst.</summary>
        <value>Ein <see cref="T:System.Windows.SizeToContent" />-Wert. Die Standardeinstellung ist <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.WidthAndHeight>, Einstellung <xref:System.Windows.FrameworkElement.Height%2A> oder <xref:System.Windows.FrameworkElement.Width%2A> hat keine Auswirkungen; beide Eigenschaften können festgelegt werden, aber die Werte, die sie festgelegt werden nicht an das Fenster angewendet.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.Height>, wobei <xref:System.Windows.FrameworkElement.Height%2A> ändert sich nicht auf die Höhe des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.Width>, wobei <xref:System.Windows.FrameworkElement.Width%2A> ändert sich nicht auf die Breite des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> verfügt über einen Wert außer <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A>wird automatisch festgelegt, um <xref:System.Windows.SizeToContent.Manual> , wenn ein Benutzer durch den Ziehpunkt auf der Größe oder Ziehen des Rahmens Größe des Fensters ändern.  
  
-   Wenn die Größe des Inhalts auf eine Weise ändert, die das Fenster selbst, ändern Sie die Größe wird <xref:System.Windows.FrameworkElement.SizeChanged> ausgelöst wird.  
  
 Wenn ein Fenster sicherheitstransparent ist (finden Sie unter <xref:System.Windows.Window.AllowsTransparency%2A>), sollten Sie die Einstellung <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.WidthAndHeight> sicherzustellen, dass das Fenster nicht größer als die sichtbaren Inhalt.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.SizeToContentProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Festlegen der <xref:System.Windows.Window.SizeToContent%2A> -Eigenschaft im Code angeben, wie die Fenstergröße an ihren Inhalt.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.SizeToContent" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Ereignis wird ausgelöst, um die Interoperation mit unterstützen [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Siehe <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn des Fensters <see cref="P:System.Windows.Window.WindowState" /> -Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die [!INCLUDE[win7](~/includes/win7-md.md)] Taskleistenminiaturansicht für die <see cref="T:System.Windows.Window" />.</summary>
        <value>Die [!INCLUDE[win7](~/includes/win7-md.md)] Taskleistenminiaturansicht für die <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung der [!INCLUDE[win7](~/includes/win7-md.md)] Taskleiste Miniaturansichten, finden Sie unter der <xref:System.Windows.Shell.TaskbarItemInfo> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.TaskbarItemInfo" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Titel eines Fensters.</summary>
        <value>Ein <see cref="T:System.String" /> , enthält das Window-Titel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Titel des eine <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, oder [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], kann auch festgelegt werden, mithilfe von <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TitleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Title" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Position des oberen Rand des Fensters, in Bezug auf dem Desktop.</summary>
        <value>Die Position des oberen Bereich des Fensters in logischen Einheiten (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert wird oder minimiert, dieser Wert stellt den obere Rand der Wiederherstellung von Wiederherstellungspunkten für die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Top%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch die Systemstandardwert angeben, durch Festlegen von <xref:System.Windows.Window.Top%2A> auf <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob ein Fenster der obersten Z-Reihenfolge angezeigt wird.</summary>
        <value>
          <see langword="true" />Wenn das Fenster auf oberster Ebene handelt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster, dessen <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true` über alle Fenster angezeigt, deren <xref:System.Windows.Window.Topmost%2A> Eigenschaften werden festgelegt, um `false`.  
  
 In der Gruppe, von denen Windows <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true`, das Fenster, das derzeit aktiviert ist das oberste Fenster ist. Ebenso für die Gruppe von Fenstern, die über <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `false`.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopmostProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Topmost" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Top" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Position des Fensters beim ersten anzeigen.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStartupLocation" /> Wert, der die obere linke Position eines Fensters beim ersten Anzeigen angibt. Die Standardeinstellung ist <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.Windows.WindowStartupLocation> auf <xref:System.Windows.WindowStartupLocation.Manual> bewirkt, dass ein Fenster entsprechend dem positioniert werden seine <xref:System.Windows.Window.Left%2A> und <xref:System.Windows.Window.Top%2A> Eigenschaftswerte. Wenn entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> Eigenschaften nicht angegeben wird, deren Werte werden durch bestimmt [!INCLUDE[TLA2#tla_mswin](~/includes/tla2sharptla-mswin-md.md)].  
  
 Festlegen von <xref:System.Windows.WindowStartupLocation.CenterScreen> bewirkt, dass ein Fenster in der Mitte des Bildschirms positioniert werden, die den Cursor enthält.  
  
 Festlegen von <xref:System.Windows.WindowStartupLocation> auf <xref:System.Windows.WindowStartupLocation.CenterOwner> bewirkt, dass ein Fenster in der Mitte des Besitzerfensters positioniert sein (finden Sie unter <xref:System.Windows.Window.Owner%2A>) angegeben. Das besitzende Fenster kann es sich um einen anderen WPF-Fenster oder in einem nicht-WPF-Fenster sein.  
  
> [!NOTE]
>  Weitere Informationen zu WPF-Fenstern mit nicht-WPF-Fenstern finden Sie unter [WPF und Win32 Interoperation](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) und <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Wenn ein Besitzerfenster nicht angegeben ist, richtet sich die Position des Fensters auf die gleiche Weise wie wenn <xref:System.Windows.WindowStartupLocation> auf festgelegt ist <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder rufen Sie den Wert dieser Eigenschaft ein, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob ein Fenster wiederhergestellt, minimiert oder maximiert wird.</summary>
        <value>Ein <see cref="T:System.Windows.WindowState" /> , der bestimmt, ob ein Fenster wiederhergestellt, minimiert oder maximiert wird. Die Standardeinstellung ist <see cref="F:System.Windows.WindowState.Normal" /> (wiederhergestellt).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor ein Fenster minimiert oder maximiert ist, seiner Größe und Position befinden sich <xref:System.Windows.Window.RestoreBounds%2A>. Wenn ein Fenster später wiederhergestellt wird, werden seine Größe und Position Werte mit den Werten aus wiederhergestellt <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Wenn die <xref:System.Windows.Window.WindowState%2A> Eigenschaft geändert wird, <xref:System.Windows.Window.StateChanged> ausgelöst wird.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStateProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.WindowState" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, oder legt ihn fest Rahmenart eines Fensters.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStyle" /> , die Rahmenart eines Fensters angibt. Die Standardeinstellung ist <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A>kann eine von der <xref:System.Windows.WindowStyle> -Enumerationswerte fest, einschließlich <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (Standard), und <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 Die folgende Abbildung zeigt die Fensterstile auf [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero Design, mit aktiviertem transparentem Glaseffekt):  
  
 ![Fensterstile](~/add/media/windowoverviewfigure6.PNG "Fensterstile")  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStyleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.WindowStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
