<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Abschnitt fortlaufenden Texts in einem <see cref="T:System.Windows.Automation.TextPattern" />-Container dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Automation.Text.TextPatternRange> darstellen kann, eine Einfügemarke, eine Teilmenge oder aller der Text in einem <xref:System.Windows.Automation.TextPattern> Container.  
  
 Ein <xref:System.Windows.Automation.Text.TextPatternRange> werden ungültig, wenn eines der folgenden Ereignisse eintritt: der Text in der <xref:System.Windows.Automation.TextPattern> Container Änderungen aufgrund einiger Benutzeraktivität oder die <xref:System.Windows.Automation.ValuePattern.SetValue%2A> Methode <xref:System.Windows.Automation.ValuePattern> wird verwendet, um den Wert des Texts in der programmgesteuertzuändern<xref:System.Windows.Automation.TextPattern> Container.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt Elemente zur Auflistung markierter Textbereiche in einem Textcontainer hinzu, der mehrere, nicht zusammenhängende Auswahlbereiche unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einfügemarke wird in den Bereich der neuen Auswahl verschoben.  
  
 Bietet einen degenerierten Textbereich verschiebt die Einfügemarke an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn der Textanbieter mehrere, nicht unterstützt nicht zusammenhängende Auswahlbereiche (z. B. <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> benötigen Sie einen Wert von <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen neuen <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> ab, der mit dem ursprünglichen <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identisch ist und dessen sämtliche Eigenschaften erbt.</summary>
        <returns>Der neue Textbereich. Ein NULL-Verweis (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]) wird niemals zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alternativ erstellen Sie ein neues <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> aus der <xref:System.Windows.Automation.TextPattern> und verschieben Sie die beiden Endpunkte mit den Endpunkten des ursprünglichen Textbereichs entsprechen.  
  
 Der neue Bereich kann unabhängig vom Original bearbeitet werden.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Ein Textbereich für den Vergleich.</param>
        <summary>Gibt einen <see cref="T:System.Boolean" />-Wert zurück, der angibt, ob der Textabschnitt (<see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt bis <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt) mit einem anderen Textabschnitt identisch ist.</summary>
        <returns>
          <see langword="true" />, wenn beide Textabschnitte identisch sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn die verglichenen Bereich nicht vom gleichen Textanbieter stammt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt oder der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Aufrufers.</param>
        <param name="targetRange">Der Zielbereich für den Vergleich.</param>
        <param name="targetEndpoint">Der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt oder der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Ziels.</param>
        <summary>Gibt ein <see cref="T:System.Int32" /> zurück, das angibt, ob zwei Textbereiche identische Endpunkte besitzen.</summary>
        <returns>Gibt einen negativen Wert zurück, wenn der Endpunkt des Aufrufers im Text vor dem Zielendpunkt liegt.  
  
 Gibt 0 (null) zurück, wenn der Endpunkt des Aufrufers an derselben Position wie der Zielendpunkt liegt.  
  
 Gibt einen positiven Wert zurück, wenn der Endpunkt des Aufrufers im Text nach dem Zielendpunkt liegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Vergleichen der Start- und Enddatum Endpunkte des Textbereichs dieselbe können Sie ermitteln, wenn ein Textbereich degenerierte ist oder wenn die Endpunkte in der Reihenfolge der logischen Textfluss sind.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Falls ein Bereich ein null-Verweis ist (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</exception>
        <exception cref="T:System.ArgumentException">Falls ein Bereich von einem anderen Container ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Die Texteinheit.</param>
        <summary>Erweitert den Textbereich auf die angegebene <see cref="T:System.Windows.Automation.Text.TextUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Bereich bereits eine genaue Anzahl der angegebenen Einheiten ist bleibt unverändert.  
  
 In der Reihenfolge für die <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> Methode erfolgreich ausgeführt wird eine Sequenz von Aktionen im Hintergrund ausgeführt.  
  
1.  Der Textbereich ist normalisiert; im Textbereich enthalten ist, also auf einen degenerierten Bereich am reduziert die <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> Endpunkt, wodurch die <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [http://www.microsoft.com](http://www.microsoft.com) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Der Bereich wird um die angeforderte Anzahl von <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>-Grenzen nach vorne oder nach hinten im `unit` verschoben.  
  
4.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Diese Schritte sind notwendig, da sie häufig eine Bildschirmsprachausgabe, eine vollständige Wort, Satz oder gesamte Absatz an der Einfügemarke oder virtuellen Cursorposition zu lesen ist.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A>berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A>orientiert sich an den nächsten größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, in die kleinste Einheit zum größten ist unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Das zu suchende Attribut.</param>
        <param name="value">Der zu suchende Attributwert. Dieser Wert mit dem für das Attribut angegebenen Typ übereinstimmen.</param>
        <param name="backward">
          <see langword="true" />, wenn statt dem ersten der letzte vorhandene Textbereich zurückgegeben werden soll, andernfalls <see langword="false" />.</param>
        <summary>Gibt den Teil des Textbereichs zurück, der den angegebenen Attributwert aufweist.</summary>
        <returns>Ein Textbereich mit einem entsprechenden Attribut und Attributwert, andernfalls NULL (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen ausgeblendeten und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
> [!NOTE]
>  Verwendung <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> um das gesamte Dokument zu suchen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Die zu suchende Textzeichenfolge.</param>
        <param name="backward">
          <see langword="true" />, wenn statt dem ersten der letzte vorhandene Textbereich zurückgegeben werden soll, andernfalls <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Gibt den Teil des Textbereichs zurück, der den angegebenen Text enthält.</summary>
        <returns>Ein Textbereich, der mit dem angegebenen Text übereinstimmt, andernfalls NULL (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen ausgeblendeten und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
> [!NOTE]
>  Verwendung <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> um das gesamte Dokument zu suchen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das Textattribut.</param>
        <summary>Gibt den Wert des angegebenen Attributs für den gesamten Textbereich zurück.</summary>
        <returns>Gibt den Wert des angegebenen Attributs zurück. Zum Beispiel gibt „GetAttributeValue(TextPattern.FontNameAttribute)“ eine Zeichenfolge zurück, die den Schriftartnamen für den Textbereich darstellt, sofern dieser eindeutig ist, während „GetAttributeValue(TextPattern.IsItalicAttribute)“ einen booleschen Wert zurückgibt.  
  
 Gibt <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> zurück, wenn sich der Wert des angegebenen Attributs im Verlauf des Textbereichs ändert.  
  
 Gibt <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> zurück, wenn das angegebene Attribut vom Anbieter oder Steuerelement nicht unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen ausgeblendeten und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn das angegebene Attribut nicht gültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft für jede vollständig oder teilweise sichtbare Textzeile in einem Textbereich eine Auflistung von umgebenden Rechtecken ab.</summary>
        <returns>Ein Array von umgebenden Rechtecken für jede vollständige oder unvollständige Textzeile in einem Textbereich.  
  
 Ein leeres Array für einen degenerierten Textbereich.  
  
 Ein leeres Array für einen Textbereich mit Bildschirmkoordinaten, die vollständig außerhalb des Bildschirms liegen, sich durch einen Bildlauf außerhalb des sichtbaren Bereichs befinden oder von einem überlappenden Fenster verdeckt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Auflistung aller eingebetteten Objekte ab, die innerhalb des Textbereichs liegen.</summary>
        <returns>Eine Auflistung aller untergeordneten Objekte, die innerhalb des Bereichs liegen. Untergeordnete Elemente, die sich mit dem Bereich überlappen, von diesem jedoch nicht vollständig umschlossen sind, werden in der Auflistung ebenfalls aufgeführt.  
  
 Gibt eine leere Auflistung zurück, wenn keine untergeordneten Objekte vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das innerste <see cref="T:System.Windows.Automation.AutomationElement" /> zurück, das den Textbereich einschließt.</summary>
        <returns>Das innerste Element, das den Aufrufer einschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der einschließende <xref:System.Windows.Automation.AutomationElement>, i. d. r. der Textanbieter, das den Textbereich bereitstellt. Wenn der Textanbieter jedoch untergeordnete Elemente unterstützt, z. B. Tabellen oder Links, kann das umschließende Element ein Nachfolgerelement des Textanbieters darstellen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Die maximale Länge der zurückzugebenden Zeichenfolge. Verwendung <c>-1</c> , wenn keine Grenze erforderlich ist.</param>
        <summary>Gibt den reinen Text des Textbereichs zurück.</summary>
        <returns>Der reine Text des Textbereichs, möglicherweise an der angegebenen <paramref name="maxLength" /> abgeschnitten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A>berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit.  
  
 Wenn `maxLength` ist größer als die Länge des Textabschnitts des Aufrufers, wird die zurückgegebene Zeichenfolge den reinen Text des Textbereichs aufweisen.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A>wird nicht durch die Reihenfolge der Endpunkte in den Textfluss beeinflusst. Es wird immer der Text zwischen die Start- und Endpunkte des Textbereichs in der logischen Textflusses zurückgegeben.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wenn <paramref name="maxLength" /> ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Die Grenze der Texteinheit.</param>
        <param name="count">Die Anzahl von Texteinheiten, um die der Textbereich verschoben werden soll. Bei einem positiven Wert wird der Textbereich vorwärts verschoben, bei einem negativen Wert wird der Textbereich rückwärts verschoben. Der Wert 0 (null) hat keine Auswirkungen.</param>
        <summary>Verschiebt den Textbereich um die festgelegte Anzahl von Texteinheiten.</summary>
        <returns>Die Anzahl von Einheiten, um die der Textbereich tatsächlich verschoben wurde. Diese kann unterhalb der angeforderten Anzahl liegen, wenn einer der neuen Textbereichsendpunkte größer oder kleiner als der jeweilige <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />-Endpunkt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Inhalt eines Textbereichs durchlaufen werden muss, ist eine Reihe von Hintergrundschritten erforderlich, um die <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> -Methode erfolgreich auszuführen.  
  
1.  Der Textbereich ist normalisiert. Dies bedeutet, dass dieser auf einen degenerierten Bereich am <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> -Endpunkt reduziert ist, wodurch der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig wird. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [http://www.microsoft.com](http://www.microsoft.com) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Der Bereich wird um die angeforderte Anzahl von <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>-Grenzen nach vorne oder nach hinten im `unit` verschoben.  
  
4.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
 Der Textinhalt (oder innere Text) eines Textcontainers und ein eingebettetes Objekt, z. B. ein Link oder eine Tabellenzelle, werden in der Steuerelementansicht und der Inhaltsansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Struktur als einzelner, kontinuierlicher Textstream verfügbar gemacht, Objektgrenzen werden dabei ignoriert.  Wenn ein Benutzeroberflächenautomatisierungs-Client den Text abruft, um ihn zu lesen, zu interpretieren oder zu analysieren, sollte der Textbereich auf bestimmte Fälle überprüft werden, z. B. auf Tabellen mit Textinhalt oder andere eingebettete Objekte. Dies geschieht durch Aufrufen von <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> zum Abrufen einer <xref:System.Windows.Automation.AutomationElement> für jedes Objekt und dem anschließenden Aufrufen eingebettete <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> abzurufenden einen Textbereich für jedes Element; Dies wird rekursiv ausgeführt, bis der gesamte Textinhalt abgerufen wurde.  
  
 ![Von eingebetteten Objekten umfasste Textbereiche. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Von eingebetteten Objekten umfasste Textbereiche.")  
Beispiel für einen Textstream mit eingebetteten Objekten und deren Bereichsabschnitten  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>orientiert sich an den nächsten größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, in die kleinste Einheit zum größten ist unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  Der Text wird nicht in irgendeiner Weise geändert werden, wie der Textbereich lediglich einen anderen Teil des Texts umfasst.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der zu verschiebende Endpunkt.</param>
        <param name="targetRange">Ein anderer Bereich vom gleichen Textanbieter.</param>
        <param name="targetEndpoint">Ein Endpunkt des anderen Bereichs.</param>
        <summary>Verschiebt einen Endpunkt eines Textbereichs an den angegebenen Endpunkt eines zweiten Textbereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Endpunkt wird ebenfalls verschoben, wodurch ein degenerierter Bereich, und stellen Sie sicher, die richtige Reihenfolge der Endpunkte der verschobene Endpunkt überschreitet den anderen Endpunkt im gleichen Textbereich enthalten (d. h. <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ist immer kleiner oder gleich <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der zu verschiebende Endpunkt.</param>
        <param name="unit">Die zu verschiebende Texteinheit.</param>
        <param name="count">Die Anzahl der Einheiten, um die verschoben werden sollen. Eine positive Anzahl verschiebt den Endpunkt vorwärts. Eine negative Anzahl verschiebt diesen rückwärts. Der Anzahl 0 (null) hat keine Auswirkungen.</param>
        <summary>Verschiebt einen Endpunkt des Textbereichs um die festgelegte Anzahl von <see cref="T:System.Windows.Automation.Text.TextUnit" />-Einheiten innerhalb des Dokumentbereichs.</summary>
        <returns>Die Anzahl von Einheiten, um die der Endpunkt tatsächlich verschoben wurde. Diese kann kleiner als die angeforderte Anzahl sein, wenn beim Verschieben des Endpunkts der Anfang bzw. das Ende des Dokuments erreicht wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Inhalt eines Textbereichs durchlaufen werden muss, ist eine Reihe von Hintergrundschritten erforderlich, um die <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> -Methode erfolgreich auszuführen.  
  
1.  Der Textbereich ist normalisiert. Dies bedeutet, dass dieser auf einen degenerierten Bereich am <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> -Endpunkt reduziert ist, wodurch der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig wird. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [http://www.microsoft.com](http://www.microsoft.com) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
 Der Textinhalt (oder innere Text) eines Textcontainers und ein eingebettetes Objekt, z. B. ein Link oder eine Tabellenzelle, werden in der Steuerelementansicht und der Inhaltsansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Struktur als einzelner, kontinuierlicher Textstream verfügbar gemacht, Objektgrenzen werden dabei ignoriert.  Wenn ein Benutzeroberflächenautomatisierungs-Client den Text abruft, um ihn zu lesen, zu interpretieren oder zu analysieren, sollte der Textbereich auf bestimmte Fälle überprüft werden, z. B. auf Tabellen mit Textinhalt oder andere eingebettete Objekte. Dies geschieht durch Aufrufen von <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> zum Abrufen einer <xref:System.Windows.Automation.AutomationElement> für jedes Objekt und dem anschließenden Aufrufen eingebettete <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> abzurufenden einen Textbereich für jedes Element; Dies wird rekursiv ausgeführt, bis der gesamte Textinhalt abgerufen wurde.  
  
 ![Von eingebetteten Objekten umfasste Textbereiche. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Von eingebetteten Objekten umfasste Textbereiche.")  
Beispiel für einen Textstream mit eingebetteten Objekten und deren Bereichsabschnitten  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A>orientiert sich an den nächsten größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, in die kleinste Einheit zum größten ist unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt einen markierten Textabschnitt, der dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt und dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des aufrufenden Textbereichs entspricht, aus einer vorhandenen Auflistung markierter Textbereiche in einem Textcontainer, der mehrere, nicht zusammenhängende Auswahlbereiche unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einfügemarke wird in den Bereich der entfernten Markierung verschoben.  
  
 Bietet einen degenerierten Textbereich wird die Einfügemarke verschieben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn der Textanbieter mehrere, nicht unterstützt nicht zusammenhängende Auswahlbereiche (z. B. <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> benötigen Sie einen Wert von <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" />, wenn im Textsteuerelement ein Bildlauf so durchgeführt werden soll, dass der Textbereich am oberen Rand des Anzeigebereichs ausgerichtet ist, <see langword="false" />, wenn der Bereich am unteren Rand des Anzeigebereichs ausgerichtet werden soll.</param>
        <summary>Bewirkt, dass im Textsteuerelement ein vertikaler Bildlauf durchgeführt wird, bis der Textbereich im Anzeigebereich sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A>berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit. Wenn der Textbereich ausgeblendet ist, wird nur dann, wenn der ausgeblendete Text einen Anker im Sichtbereich im Textsteuerelement ein Bildlauf durchgeführt.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn Bildläufe vom Steuerelement nicht unterstützt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Markiert Text im Textsteuerelement entsprechend dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt und dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Textbereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein degenerierten Textbereich bereitgestellt wird, wechselt die Einfügemarke in die <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> Endpunkt des Textbereichs.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tritt auf, wenn die Textauswahl nicht vom Textsteuerelement unterstützt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Automation.TextPattern" /> ab, das dem Textbereich zugeordnet ist.</summary>
        <value>Der Textanbieter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
