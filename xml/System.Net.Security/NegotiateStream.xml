<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Stream, der die Negotiate Security-Protokoll zum Authentifizieren des Clients und optional die Server in der Kommunikation zwischen Client und Server verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.Security.NegotiateStream> Klasse zur Authentifizierung und zum Schutz von Informationen zwischen einem Client und einem Server übertragen. Mit <xref:System.Net.Security.NegotiateStream>, können Sie wie folgt vorgehen.  
  
-   Senden Sie die Anmeldeinformationen des Clients an den Server für den Identitätswechsel oder Delegierung.  
  
-   Fordern Sie Server-Authentifizierung.  
  
-   Verschlüsseln und/oder Signieren von Daten vor der Übertragung.  
  
 Authentifizierung muss vor der Übermittlung von Daten ausgeführt werden. Clients die Authentifizierung mithilfe von synchronen anfordern <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> -Methoden, die blockiert werden, bis die Authentifizierung abgeschlossen wurde, oder den asynchronen <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> -Methoden, die während des Wartens auf das Beenden der Authentifizierung nicht blockieren. Server anfordern Authentifizierung mithilfe von synchronen <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden. Der Client und optional den Server wird mithilfe des Negotiate-Sicherheitsprotokolls authentifiziert. Auf Windows 95-und Windows 98-Systemen ist Windows NT LAN Manager (NTLM) das Protokoll für die Authentifizierung verwendet. Auf anderen Plattformen wird das Kerberos wird Protokoll für die Authentifizierung verwendet, wenn sowohl Client als auch Server unterstützen. Andernfalls wird NTLM verwendet. Eine ausführliche Beschreibung dieser Protokolle finden Sie unter der Platform SDK-Dokumentation auf MSDN zur msdn.microsoft.com/library/. Die <xref:System.Net.Security.NegotiateStream> -Klasse führt die Authentifizierung über die Security Support Provider Interface (SSPI).  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> von Eigenschaften, um zu bestimmen, welche Sicherheitsdienste verwendet werden die <xref:System.Net.Security.NegotiateStream> auf Ihre Daten während der Übertragung zu schützen. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist. Sie erhalten Informationen über die remote-Client oder Server mit der <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> Eigenschaft.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Senden von Daten mit den synchronen <xref:System.Net.Security.NegotiateStream.Write%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> Methoden. Empfangen von Daten, die mit der synchronen <xref:System.Net.Security.NegotiateStream.Read%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methoden. Wenn Sicherheitsdienste, z. B. Verschlüsselung oder Signierung aktiviert sind, werden diese automatisch angewendet auf Ihre Daten durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Die <xref:System.Net.Security.NegotiateStream> überträgt Daten mithilfe eines Datenstroms, die Sie angeben, für die Erstellung der <xref:System.Net.Security.NegotiateStream>. Wenn Sie diese zugrunde liegenden Stream bereitstellen, haben Sie die Option zur Angabe, ob das Schließen der <xref:System.Net.Security.NegotiateStream> schließt auch die zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Clientseite eine Client / Server-Verbindung, verwendet die <xref:System.Net.Security.NegotiateStream>. Der Client authentifiziert und sendet eine Nachricht asynchron an den Server.  
  
 [!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
 [!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, das serverseitige eine Client / Server-Verbindung, verwendet die <xref:System.Net.Security.NegotiateStream> zum Authentifizieren des Clients und Lesen einer Nachricht vom Client gesendet.  
  
 [!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
 [!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass die <xref:System.Net.Security.NegotiateStream> schließt den Stream, den Sie angeben, verwenden die <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> Konstruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.NegotiateStream" /> für das Senden und Empfangen von Daten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.NegotiateStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">
          <see langword="true" />um anzugeben, dass das Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> hat keine Auswirkungen auf <c>Innerstream</c>; <see langword="false" /> , um anzugeben, dass das Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> schließt außerdem <c>InnerStream</c>.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.NegotiateStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" /> und streamen Closure-Verhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.NegotiateStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
 [!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der angegebene-Clientanmeldeinformationen verwendet, im Authentifizierungsprozess sorgt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet den angegebenen Clientanmeldeinformationen und die kanalbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" />ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsprozess wird die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und die kanalbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" />ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen wird.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen wird. Der angegebene-Clientanmeldeinformationen verwendet, im Authentifizierungsprozess sorgt.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen wird. Der Authentifizierungsvorgang verwendet den angegebenen Clientanmeldeinformationen und die kanalbindung.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen wird. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" />ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Von Clients zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen wird. Der Authentifizierungsprozess wird die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und die kanalbindung verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" />ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verarbeitet die Serverseite der eine Authentifizierung für eine Client / Server-Verbindung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden wird blockiert, während die Authentifizierung ausgeführt wird. Um die Anwendung blockiert, während des Wartens auf das Beenden der Authentifizierung zu verhindern, verwenden Sie die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebene erweiterte Schutzrichtlinie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> wird, um die Identität des Servers einzurichten.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie versuchen, R-Authentifizierung.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und erweiterte Schutzrichtlinie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie versuchen, R-Authentifizierung.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen. Der Authentifizierungsvorgang verwendet die angegebene erweiterte Schutzrichtlinie.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> wird, um die Identität des Servers einzurichten.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie versuchen, R-Authentifizierung.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <summary>Wird vom Server zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und erweiterte Schutzrichtlinie.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie versuchen, R-Authentifizierung.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang zum Authentifizieren von der Clientseite der ein Client / Server-Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird aufgerufen, von Clients, um einen asynchronen Vorgang zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung zu beginnen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode um eine asynchrone Authentifizierung für den Client zu starten.  
  
 [!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
 [!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird aufgerufen, von Clients, um einen asynchronen Vorgang zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung zu beginnen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird aufgerufen, von Clients, um einen asynchronen Vorgang zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung zu beginnen. Der Authentifizierungsprozess wird verwendet, die angegebenen Anmeldeinformationen und die kanalbindung. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird aufgerufen, von Clients, um einen asynchronen Vorgang zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung zu beginnen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="binding">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="targetName">Der Name SPN (Service Principal), die den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="allowedImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird aufgerufen, von Clients, um einen asynchronen Vorgang zum Authentifizieren des Clients und optional die Server in einem Client / Server-Verbindung zu beginnen. Den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und die kanalbindung verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Den Stream können keine Authentifizierung wie der Client wiederholt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die Serverseite der Authentifizieren einer Client / Server-Verbindung zu behandeln.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während die Authentifizierung ausgeführt wird. Blockieren während des Wartens auf der Authentifizierung abzuschließen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebene erweiterte Schutzrichtlinie. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen und die Authentifizierungsoptionen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> , wird verwendet, um die Identität des Clients herzustellen.</param>
        <param name="policy">Die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , die für erweiterten Schutz verwendet wird.</param>
        <param name="requiredProtectionLevel">Eines der <see cref="T:System.Net.Security.ProtectionLevel" /> Werte, der die Sicherheitsdienste für den Stream.</param>
        <param name="requiredImpersonationLevel">Eines der <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Werte, der angibt, wie der Server die Anmeldeinformationen des Clients den Zugriff auf Ressourcen verwenden kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen. Der Authentifizierungsvorgang verwendet die angegebenen Anmeldeinformationen, die Authentifizierungsoptionen und erweiterte Schutzrichtlinie. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte Schutzrichtlinie übergeben der <paramref name="policy" /> Parameter sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" />muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für Authentifizierungsversuch wie der Client verwendet. Den Stream können keine Authentifizierung wie der Server wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <paramref name="policy" /> Parametersatz wurde um <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, die Bytes empfängt, aus dem Stream lesen.</param>
        <param name="offset">Die nullbasierte Position im <c>Puffer</c> ab dem aus diesem Stream gelesenen Daten gespeichert.</param>
        <param name="count">Die maximale Anzahl von Bytes, die aus dem Datenstrom gelesen werden soll.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die beim Abschluss des Lesevorgangs aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Lesevorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Startet einen asynchronen Lesevorgang, der Daten aus dem Stream liest und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, wird der Lesevorgang liest die Daten aus den zugrunde liegenden Stream, überprüft die Integrität der Daten und wird vom Client entschlüsselt. Wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, wird diese Methode einen asynchronen Lesevorgang im zugrunde liegenden Stream gestartet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndRead%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Lesevorgänge nicht unterstützt. Wenn Sie versuchen, einen Lesevorgang gestartet werden, während eine andere Vorgang bereits ausgeführt wird, für den gleichen Stream lesen eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Lesevorgang ab. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 <paramref name="offset" />plus <paramref name="count" /> ist größer als die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.  
  
 \- oder –  
  
 Verschlüsselung wird verwendet, aber die Daten konnten nicht entschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die in den Stream zu schreibenden Bytes angibt.</param>
        <param name="offset">Die nullbasierte Position im <c>Puffer</c> ab dem Lesen von Bytes in den Stream geschrieben werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zum Auslesen <c>Puffer</c>.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Schreibvorgang abgeschlossen ist.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt mit Informationen zu den Schreibvorgang. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang, der schreibt <see cref="T:System.Byte" />s aus dem angegebenen Puffer in den Stream.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert und überträgt ihn mit dem zugrunde liegenden Stream. Wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, wird diese Methode einen asynchronen Schreibvorgang auf den zugrunde liegenden Stream gestartet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndWrite%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Schreibvorgang für den gleichen Stream bereits ausgeführt wird eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Schreibvorgang ab.  
  
 [!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
 [!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
  
 Die folgende Methode wird aufgerufen, wenn der Vorgang abgeschlossen ist.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 <paramref name="offset" />plus die Anzahl ist größer als die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
 \- oder –  
  
 Verschlüsselung wird verwendet, aber die Daten konnten nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream gelesen werden kann.</summary>
        <value>
          <see langword="true" />Wenn Authentifizierung aufgetreten ist und der zugrunde liegende Stream gelesen wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanRead%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream durchsucht werden.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten nicht versuchen, die Position der Satz der <xref:System.Net.Security.NegotiateStream> Objekt oder die zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream Timeouts unterstützt.</summary>
        <value>
          <see langword="true" />Wenn der zugrunde liegende Stream Timeouts unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream geschrieben werden kann.</summary>
        <value>
          <see langword="true" />Wenn die Authentifizierung erfolgt ist, und der zugrunde liegende Stream beschreibbar ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanWrite%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Security.NegotiateStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Net.Security.NegotiateStream> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</param>
        <summary>Beendet einen ausstehenden asynchronen Client-Authentifizierung-Vorgang, die durch einen Aufruf gestartet wurde <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Clientauthentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
        <summary>Beendet einen ausstehenden asynchronen Client-Authentifizierung-Vorgang, die durch einen Aufruf gestartet wurde <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Dieses Objekt können Sie die Authentifizierung wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Authentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz<see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet einen asynchronen Lesevorgang, die durch einen Aufruf des Starts <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zu lesen, aus dem zugrunde liegenden Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass das Beenden eines asynchronen Lesevorgang. Ein Beispiel für den Vorgang zu starten, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">AsyncResult wurde nicht erstellt, durch den Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz<see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet einen asynchronen Schreibvorgang, der mit einem Aufruf von gestartet wurde <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Methode, die aufgerufen wird, um den asynchronen Schreibvorgang abgeschlossen wird. Ein Beispiel für den Vorgang zu starten, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">AsyncResult wurde nicht erstellt, durch den Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass alle gepufferten Daten an das zugrunde liegende Gerät geschrieben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.Flush%2A> auf den zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Stream.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, wie der Server die Anmeldeinformationen des Clients verwenden kann.</summary>
        <value>Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen eine erfolgreiche Authentifizierung vor dem Aufrufen dieser Methode. Clients geben die Identitätswechselebene beim Anrufen von einer der Authentifizierung anfordern der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Wenn Sie eine ohne Angabe Authentifizierung einer <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> wird verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die Authentifizierung erfolgreich war.</summary>
        <value>
          <see langword="true" />Wenn eine erfolgreicher Authentifizierung erfolgt ist andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Authentifizieren Sie Clients durch Aufrufen der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Server-Authentifizierung durch Aufrufen der <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies <see cref="T:System.Net.Security.NegotiateStream" /> datenverschlüsselung verwendet.</summary>
        <value>
          <see langword="true" />Wenn die Daten vor der Übertragung über das Netzwerk verschlüsselt und entschlüsselt erreicht Wenn den Remoteendpunkt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschlüsselung trägt zum Schutz von Daten auf des Datenschutzes; Es wird nämlich sichergestellt, dass während Daten während der Übertragung werden sie von Drittanbietern gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob sowohl der Client als auch Server authentifiziert wurden.</summary>
        <value>
          <see langword="true" />Wenn der Server authentifiziert wurden. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegenseitiger Authentifizierung wird vom Client angegeben, wenn der Client den Server für die Anmeldeinformationen für die Authentifizierung wünscht. Standardmäßig fordern die Clients gegenseitigen Authentifizierung.  
  
 Das Aushandlungsprotokoll wählt NTLM oder Kerberos je nach der vom Client und Server unterstützten Sicherheitsprotokolle an. NTLM unterstützt keine gegenseitigen Authentifizierung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies die lokale Seite der Verbindung verwendeten <see cref="T:System.Net.Security.NegotiateStream" /> wie der Server authentifiziert wurde.</summary>
        <value>
          <see langword="true" />Wenn der lokale Endpunkt als die Serverseite der die authentifizierte Verbindung erfolgreich authentifiziert wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung fehlgeschlagen oder ist nicht erfolgt ist, gibt diese Eigenschaft `false`.  
  
 Rufen Sie zur Authentifizierung wie der Server die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die mit diesem Stream gesendeten Daten signiert wurde.</summary>
        <value>
          <see langword="true" />Wenn die Daten vor der Übertragung signiert ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signieren von Daten schützt die Integrität der Daten; nämlich leichter den Empfänger zu bestimmen, ob die Daten bei der Übertragung manipuliert wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des zugrunde liegenden Stream ab.</summary>
        <value>Ein <see cref="T:System.Int64" /> , der die Länge des zugrunde liegenden Streams angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.Length%2A> Eigenschaft auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die aktuelle Position in den zugrunde liegenden Stream.</summary>
        <value>Ein <see cref="T:System.Int64" /> , die die aktuelle Position in den zugrunde liegenden Stream angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.Position%2A> Eigenschaft auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Durch Festlegen dieser Eigenschaft wird nicht unterstützt.  
  
 \- oder –  
  
 Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, die Bytes empfängt, aus dem Stream lesen.</param>
        <param name="offset">Ein <see cref="T:System.Int32" /> , enthält die nullbasierte Position im <c>Puffer</c> ab dem aus diesem Stream gelesenen Daten gespeichert.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> , die die maximale Anzahl der aus dem Stream gelesenen Bytes enthält.</param>
        <summary>Liest Daten aus diesen Datenstrom und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zu lesen, aus dem zugrunde liegenden Stream. Wenn es keine weiteren Daten ist gelesen werden, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode liest ein Maximum von `count` Bytes aus dem aktuellen stream und speichert sie in `buffer` beginnend `offset`.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang asynchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Lesen aus einer <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Ein <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> Vorgang wird bereits ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die ein Lesevorgang warten Daten blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor ein Lesevorgang fehlschlägt angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.ReadTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Beim Festlegen dieser Eigenschaft die <xref:System.IO.Stream.ReadTimeout%2A> Wert auf den zugrunde liegenden Stream mit dem angegebenen Wert festgelegt ist.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> , damit Lesevorgänge Vorgänge Timeoutgrenze nicht standardmäßig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen über die Identität der Remotepartei Freigabe dieser authentifizierten Stream ab.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IIdentity" /> Objekt, das die Identität des Remoteendpunkts beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vom Client zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.GenericIdentity> , enthält der Name (SPN) des Servers und das Authentifizierungsprotokoll verwendet. Wenn durch den Server zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.WindowsIdentity> , die den Client beschreibt. Wenn die <xref:System.Security.Principal.WindowsIdentity> ist nicht verfügbar ist, wird Clientinformationen zurückgegeben, mit dem Server in einem <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Wert wird ignoriert.</param>
        <param name="origin">Dieser Wert wird ignoriert.</param>
        <summary>Löst <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht. Geerbt wird, aber wird nicht von <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Unterstützt keine Suchvorgänge auf <see cref="T:System.Net.Security.NegotiateStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Int64" /> Wert, der die Länge des Streams angibt.</param>
        <summary>Legt die Länge des zugrunde liegenden Streams fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes in den Stream geschrieben bereitstellt.</param>
        <param name="offset">Ein <see cref="T:System.Int32" /> , enthält die nullbasierte Position im <c>Puffer</c> ab dem Lesen von Bytes in den Stream geschrieben werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> mit der Anzahl von Bytes zum Auslesen <c>Puffer</c>.</param>
        <summary>Schreiben Sie die angegebene Anzahl von <see cref="T:System.Byte" />s in den zugrunde liegenden Stream unter Verwendung des angegebenen Puffers und Offset.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert und überträgt ihn mit dem zugrunde liegenden Stream. Diese Methode wird aufgerufen, wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, <xref:System.IO.Stream.Write%2A> auf den zugrunde liegenden Stream.  
  
 Diese Methode blockiert, während der Schreibvorgang abgeschlossen wird. Um zu verhindern, blockiert, während der Vorgang abgeschlossen ist, verwenden die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Schreibvorgang für den gleichen Stream bereits ausgeführt wird eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Schreiben in eine <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 <paramref name="offset" />plus die Anzahl ist größer als die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
 \- oder –  
  
 Verschlüsselung wird verwendet, aber die Daten konnten nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die Ausführung eines Schreibvorgangs auf Daten zu warten, blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor ein Schreibvorgang fehlschlägt angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.WriteTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Für Mengenoperationen, den angegebene Wert fest, der <xref:System.IO.Stream.WriteTimeout%2A> Wert auf den zugrunde liegenden Stream.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> so schreiben, der Vorgänge Timeoutgrenze nicht standardmäßig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
