<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen für die Client/Server-Kommunikation verwendeten Datenstrom bereit, der das Sicherheitsprotokoll Secure Socket Layer (SSL) zur Authentifizierung des Servers und optional des Clients verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der SSL-Protokolle Vertraulichkeit und Integrität, die Meldungen mit übertragen geprüft bieten eine <xref:System.Net.Security.SslStream>. Eine SSL-Verbindung, z. B. von <xref:System.Net.Security.SslStream>, sollten werden verwendet, wenn Kommunikation vertraulichen Informationen zwischen einem Client und einem Server. Mithilfe einer <xref:System.Net.Security.SslStream> hilft zu verhindern, dass Benutzer lesen und manipulieren Informationen, während es bei der Übertragung im Netzwerk befindet.  
  
 Ein <xref:System.Net.Security.SslStream> Instanz überträgt Daten mit einem Stream, den Sie angeben, für die Erstellung der <xref:System.Net.Security.SslStream>. Wenn Sie diese zugrunde liegenden Stream bereitstellen, haben Sie die Option zur Angabe, ob das Schließen der <xref:System.Net.Security.SslStream> schließt auch die zugrunde liegenden Stream. In der Regel die <xref:System.Net.Security.SslStream> Klasse wird verwendet, mit der <xref:System.Net.Sockets.TcpClient> und <xref:System.Net.Sockets.TcpListener> Klassen. Die <xref:System.Net.Sockets.TcpClient.GetStream%2A> Methode bietet eine <xref:System.Net.Sockets.NetworkStream> geeignet für die Verwendung mit der <xref:System.Net.Security.SslStream> Klasse.  
  
 Nach dem Erstellen einer <xref:System.Net.Security.SslStream>, den Server und optional der Client authentifiziert werden müssen. Der Server muss ein X509 bereitgestellt, Zertifikat, stellt seine Identitätsnachweis her und kann anfordern, dass der Client dies auch tun. Authentifizierung muss erfolgen, bevor übertragen Informationen mithilfe einer <xref:System.Net.Security.SslStream>. Clients initiieren die Authentifizierung mit den synchronen <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> -Methoden, die blockiert werden, bis die Authentifizierung abgeschlossen wurde, oder den asynchronen <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> -Methoden, die Wartezeit für die Authentifizierung abgeschlossen nicht blockieren. Server initiieren die Authentifizierung mit den synchronen <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden. Sowohl Client als auch Server müssen die Authentifizierung initiiert werden.  
  
 Die Authentifizierung erfolgt über die Security Support Provider (SSPI)-Channel-Anbieters. Der Client erhält die Gelegenheit zur Validierung des Serverzertifikats durch Angabe steuern eine <xref:System.Net.Security.RemoteCertificateValidationCallback> delegate beim Erstellen einer <xref:System.Net.Security.SslStream>. Der Server kann auch steuern Überprüfung durch Angabe einer <xref:System.Net.Security.RemoteCertificateValidationCallback> delegieren. Die Methode, die der Delegat verweist umfasst der Remoteanbieter Zertifikat und ggf. aufgetretenen Fehlern SSPI, die bei der Überprüfung des Zertifikats. Beachten Sie, dass der Server über einen Delegaten an, der Delegat-Methode so aufgerufen wird, unabhängig davon, ob der Server die Clientauthentifizierung angefordert. Wenn der Server nicht die Clientauthentifizierung angefordert hat, empfängt Delegatmethode des Servers ein null-Zertifikat und ein leeres Array vom Zertifikatfehler.  
  
 Wenn der Server die Clientauthentifizierung erforderlich ist, muss der Client eine oder mehrere Zertifikate für die Authentifizierung angeben. Wenn der Client mehr als ein Zertifikat verfügt, kann der Client Bereitstellen einer <xref:System.Net.Security.LocalCertificateSelectionCallback> Delegat, der das richtige Zertifikat für den Server auswählen. Die Zertifikate des Clients müssen in der aktuellen Zertifikatspeicher des Benutzers "My" befinden. Die Clientauthentifizierung über Zertifikate wird nicht unterstützt, für die <xref:System.Security.Authentication.SslProtocols.Ssl2> -Protokoll (SSL-Version 2).  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und die <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Wenn der Authentifizierungsprozess, auch bekannt als SSL-Handshake, erfolgreich ist, wird die Identität des Servers (und optional den Client) hergestellt und die <xref:System.Net.Security.SslStream> kann von Client und Server für den Austausch von Nachrichten verwendet werden. Vor dem Senden oder Empfangen von Informationen, Client und Server sollte überprüfen Sie die Sicherheitsdienste und gebotenen Ebenen der <xref:System.Net.Security.SslStream> zu bestimmen, ob die Anforderungen für die Integrität und Vertraulichkeit Protokoll, Algorithmen und Stärken ausgewählt zu erfüllen. Wenn die aktuellen Einstellungen nicht ausreichen, sollte der Stream geschlossen werden. Sehen Sie sich die Sicherheitsdienste gebotenen der <xref:System.Net.Security.SslStream> mithilfe der <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften. Die folgende Tabelle zeigt die Elemente, die die kryptografischen zurückgegeben, für die Authentifizierung, Verschlüsselung und Signierung von Daten verwendet.  
  
|Element|Mitglieder|  
|-------------|-------------|  
|Das Sicherheitsprotokoll verwendet, um den Server und optional den Client zu authentifizieren.|Die <xref:System.Net.Security.SslStream.SslProtocol%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.SslProtocols> Enumeration.|  
|Der Algorithmus für den Schlüsselaustausch.|Die <xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.ExchangeAlgorithmType> Enumeration.|  
|Algorithmus für die Integrität.|Die <xref:System.Net.Security.SslStream.HashAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.HashAlgorithmType> Enumeration.|  
|Algorithmus für die Vertraulichkeit.|Die <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.CipherAlgorithmType> Enumeration.|  
|Die Stärken der ausgewählten Algorithmen.|Die <xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>, und <xref:System.Net.Security.SslStream.CipherStrength%2A> Eigenschaften.|  
  
 Nach einer erfolgreichen Authentifizierung können Sie Daten mithilfe von synchronen senden <xref:System.Net.Security.SslStream.Write%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginWrite%2A> Methoden. Möglicherweise erhalten Sie Daten mithilfe von synchronen <xref:System.Net.Security.SslStream.Read%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginRead%2A> Methoden.  
  
 Wenn Sie angegeben haben, um die <xref:System.Net.Security.SslStream.%23ctor%2A> , dass der zugrunde liegende Stream geöffnet bleiben werden sollte, Sie sind verantwortlich für Stream schließen, wenn Sie fertig sind verwenden.  
  
> [!NOTE]
>  Wenn die Anwendung erstellt wird, die die <xref:System.Net.Security.SslStream> -Objekt mit den Anmeldeinformationen eines Standardbenutzers ausgeführt wird, die Anwendung wird nicht in der Lage, Zugriff auf die Zertifikate im Speicher lokalen Computers installiert werden, es sei denn, die Berechtigung wurde dem Benutzer explizit erteilt.  
  
 <xref:System.Net.Security.SslStream>setzt voraus, dass ein Timeout sowie alle anderen <xref:System.IO.IOException> bei einer ausgelöst wird, vom inneren Datenstrom wird als schwerwiegend behandelt durch den Aufrufer. Wiederverwenden von einem <xref:System.Net.Security.SslStream> -Instanz nach ein Timeout Garbage zurückgegeben wird. Eine Anwendung sollte <xref:System.IO.Stream.Close%2A> die <xref:System.Net.Security.SslStream> und löst eine Ausnahme in diesen Fällen.  
  
 .NET Framework 4.6 umfasst eine neue Sicherheitsfunktion, die unsichere Verschlüsselungssammlungen und Hashalgorithmen für Verbindungen blockiert. Anwendungen verwenden TLS/SSL über APIs wie z. B. "HttpClient", HttpWebRequest-Anforderung, FTPClient, SmtpClient, SslStream usw. und .NET Framework 4.6 abzielt erhalten die sicherere Verhalten in der Standardeinstellung.  
  
 Möglicherweise möchten Entwickler dieses Verhalten abzuwählen, um die Interoperabilität mit ihrer vorhandenen SSL3-Diensten oder TLS mit RC4-Dienste zu verwalten. [In diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie Ihren Code ändern, damit das neue Verhalten deaktiviert ist.  
  
 Die .NET Framework-4.7 fügt neue Überladungen für die Methoden, die SslStreams zu, die die TLS-Protokollversion, die als Systemstandard im definierte verwenden authentifizieren, sondern geben Sie eine TLS-Version nicht [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Verwenden Sie diese Methoden in Ihrer app als eine Möglichkeit, die Standardwerte später als TLS Version best-Practice-Änderungen im Laufe der Zeit ändern können ohne die Notwendigkeit zum Erstellen und bereitzustellen, die app.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Net.Sockets.TcpListener> , verwendet die <xref:System.Net.Security.SslStream> Klasse für die Kommunikation mit Clients.  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Net.Sockets.TcpClient> , verwendet die <xref:System.Net.Security.SslStream> Klasse für die Kommunikation mit einem Server.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.SslStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass die <xref:System.Net.Security.SslStream> schließt den Stream, den Sie angeben, verwenden die <xref:System.Net.Security.SslStream.%23ctor%2A> Konstruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.SslStream" />-Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" />ist nicht lesbar.  
  
 - oder -   
  
 <paramref name="innerStream" />ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" /> und streamen Closure-Verhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" />ist nicht lesbar.  
  
 - oder -   
  
 <paramref name="innerStream" />ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />, Streamen Closure-Verhalten und ein Zertifikat Überprüfung Delegaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Die `userCertificateValidationCallback` des Delegaten `certificateErrors` Argument enthält alle Windows-Fehlercodes, die vom Kanal Security Support Provider Interface (SSPI) zurückgegeben. Der Rückgabewert der Methode aufgerufen, indem die `userCertificateValidationCallback` Delegaten bestimmt, ob die Authentifizierung erfolgreich ist.  
  
 Das Sicherheitsprotokoll und Kryptografiealgorithmen sind bereits ausgewählt, wenn die `userCertificateValidationCallback` des Delegaten-Methode aufgerufen wird. Sie können die Methode verwenden, um festzustellen, ob die ausgewählten kryptografische Algorithmen und die Vorteile für Ihre Anwendung ausreichen. Wenn nicht, der Methodenrückgabewert `false` um zu verhindern, dass die <xref:System.Net.Security.SslStream> erstellt werden.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element des <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Security.SslStream> und den Clientteil der Authentifizierung initiiert.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" />ist nicht lesbar.  
  
 - oder -   
  
 <paramref name="innerStream" />ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <param name="userCertificateSelectionCallback">Ein <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegaten verantwortlich für die Auswahl des Zertifikats für die Authentifizierung verwendet.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />, Streamen Closure-Verhalten, Zertifikat Überprüfung Delegaten und Zertifikat Auswahl Delegaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Die `userCertificateValidationCallback` des Delegaten `certificateErrors` Argument enthält alle Windows-Fehlercodes, die vom Kanal Security Support Provider Interface (SSPI) zurückgegeben. Der Rückgabewert der Methode aufgerufen, indem die `userCertificateValidationCallback` Delegaten bestimmt, ob die Authentifizierung erfolgreich ist.  
  
 Das Sicherheitsprotokoll und Kryptografiealgorithmen sind bereits ausgewählt, wenn die `userCertificateValidationCallback` des Delegaten-Methode aufgerufen wird. Sie können die Methode verwenden, um festzustellen, ob die ausgewählten kryptografische Algorithmen und die Vorteile für Ihre Anwendung ausreichen. Wenn nicht, der Methodenrückgabewert `false` um zu verhindern, dass die <xref:System.Net.Security.SslStream> erstellt werden.  
  
 Die `userCertificateSelectionCallback` Delegat ist hilfreich, wenn Ihre Anwendung verfügt über mehrere Zertifikate und ein Zertifikat muss dynamisch auswählen. Zertifikate im Speicher "MY" werden an die Methode wird aufgerufen, durch den Delegaten übergeben.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element der P:System.Net.HttpWebRequest.ClientCertificates (sofern vorhanden) oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn P:System.Net.HttpWebRequest.ClientCertificates ist leer.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.SslStream> Klasse.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" />ist nicht lesbar.  
  
 - oder -   
  
 <paramref name="innerStream" />ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <param name="userCertificateSelectionCallback">Ein <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegaten verantwortlich für die Auswahl des Zertifikats für die Authentifizierung verwendet.</param>
        <param name="encryptionPolicy">Der zu verwendende <see cref="T:System.Net.Security.EncryptionPolicy" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen<see cref="T:System.IO.Stream" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die `encryptionPolicy` Parametersatz auf <xref:System.Net.Security.EncryptionPolicy?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" />ist nicht lesbar.  
  
 - oder -   
  
 <paramref name="innerStream" />ist nicht beschreibbar.  
  
 - oder -   
  
 <paramref name="encryptionPolicy" /> ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene Zertifikatsammlung und das SSL-Standardprotokoll des Systems.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene zertifikatauflistung und die SSL-Protokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene Zertifikatsammlung und das SSL-Standardprotokoll des Systems.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene zertifikatauflistung und die SSL-Protokoll.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das Zertifikat zur Authentifizierung des Servers verwendet.</param>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in eine Client / Server-Verbindung mit dem angegebenen Zertifikat aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Clientauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client-Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Standardsicherheitsprotokolls des Systems zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Clientauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Clientauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das Zertifikat zur Authentifizierung des Servers verwendet.</param>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in eine Client / Server-Verbindung mit dem angegebenen Zertifikat als asynchronen Vorgang aufgerufen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Clientauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls als asynchronen Vorgang zu authentifizieren.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls als asynchronen Vorgang zu authentifizieren.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen Vorgang zum Authentifizieren von der Clientseite der ein Client / Server-Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird von Clients beginnen einen asynchronen Vorgang zum Authentifizieren des Servers und optional dem Client aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft.  
  
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird von Clients aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate und des Standardsicherheitsprotokolls des Systems zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird von Clients beginnen einen asynchronen Vorgang zum Authentifizieren des Servers und optional den Client mithilfe der angegebenen Zertifikate und Sicherheitsprotokoll aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die Serverseite der Authentifizieren einer Client / Server-Verbindung zu behandeln.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Clientauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird von Servern aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate, Anforderungen und des Standardsicherheitsprotokolls des Systems zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Wird von Servern aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 - oder -   
  
 Eine Serverauthentifizierung mit diesem <see cref="T:System.Net.Security.SslStream" /> wurde bereits zuvor versucht.  
  
 - oder -   
  
 Die Authentifizierung läuft bereits.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, die Bytes empfängt, aus dem Stream lesen.</param>
        <param name="offset">Die nullbasierte Position im <c>Puffer</c> ab dem aus diesem Stream gelesenen Daten gespeichert.</param>
        <param name="count">Die maximale Anzahl von Bytes, die aus dem Datenstrom gelesen werden soll.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die beim Abschluss des Lesevorgangs aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Lesevorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Startet einen asynchronen Lesevorgang, der Daten aus dem Stream liest und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung und Signierung aktiviert sind, wird der Lesevorgang liest die Daten aus den zugrunde liegenden Stream, überprüft die Integrität der Daten und/oder entschlüsselt. Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.SslStream.EndRead%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.SslStream.Read%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Lesevorgänge nicht unterstützt.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Lesevorgang ab.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 Die folgende Methode wird aufgerufen, wenn nach des Lesevorgangs Abschluss.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="offset" />+ Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.  
  
 - oder -   
  
 Verschlüsselung wird verwendet, aber die Daten konnten nicht entschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die in den Stream zu schreibenden Bytes angibt.</param>
        <param name="offset">Die nullbasierte Position im <c>Puffer</c> ab dem Lesen von Bytes in den Stream geschrieben werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zum Auslesen <c>Puffer</c>.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Schreibvorgang abgeschlossen ist.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zu den Schreibvorgang enthält. Dieses Objekt wird zum Übergeben der <c>AsyncCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang, der schreibt <see cref="T:System.Byte" />s aus dem angegebenen Puffer in den Stream.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="offset" />+ Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream gelesen werden kann.</summary>
        <value>
          <see langword="true" />Wenn Authentifizierung aufgetreten ist und der zugrunde liegende Stream gelesen wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanRead%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream durchsucht werden.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Versuchen Sie nicht die Position des festzulegenden der <xref:System.Net.Security.SslStream> Objekt oder die zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream Timeouts unterstützt.</summary>
        <value>
          <see langword="true" />Wenn der zugrunde liegende Stream Timeouts unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanTimeout%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream geschrieben werden kann.</summary>
        <value>
          <see langword="true" />Wenn die Authentifizierung erfolgt ist, und der zugrunde liegende Stream beschreibbar ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanWrite%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die Zertifikatsperrliste, während der Überprüfung des Zertifikats überprüft wird.</summary>
        <value>
          <see langword="true" />, wenn die Zertifikatsperrliste überprüft wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zertifikatsperrliste enthält Zertifikate, die vom Aussteller gesperrt wurden. Überprüfen die Liste negativ wirkt sich auf die Leistung jedoch erhöht die anwendungssicherheit.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, den Bulk-Verschlüsselungsalgorithmus verwendet, die von diesem identifiziert <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.CipherAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wert <xref:System.Security.Authentication.CipherAlgorithmType.Null> ist erforderlich, damit die <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> Eigenschaft bei der <xref:System.Net.Security.EncryptionPolicy.NoEncryption> Enumerationswert dient zum Erstellen einer <xref:System.Net.Security.SslStream> Instanz.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)]und [!INCLUDE[winxp](~/includes/winxp-md.md)] unterstützen nicht die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert. Auch wenn die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert dient zum Erstellen der <xref:System.Net.Security.SslStream> -Instanz, die <xref:System.Net.Security.EncryptionPolicy> -Eigenschaft <xref:System.Security.Authentication.CipherAlgorithmType.None>. Die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert wird nur zurückgegeben, unter Windows Vista und höher.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> Eigenschaft wurde zugegriffen, vor dem Fehler beim Abschluss den Authentifizierungsprozess abgebrochen oder im Authentifizierungsprozess sorgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des von diesem verwendeten Verschlüsselungsalgorithmus identifiziert <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der die Stärke des Algorithmus in Bits angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
 Diese Eigenschaft gibt einen der folgenden Werte zurück:  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Security.SslStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Net.Security.SslStream> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</param>
        <summary>Beendet ein ausstehende asynchrone Server-Authentifizierung-Vorgang gestartet wird, mit einem vorherigen Aufruf von <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Serverauthentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Beendet ein ausstehende asynchrone Client-Authentifizierung-Vorgang gestartet wird, mit einem vorherigen Aufruf von <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Clientauthentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz<see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet ein asynchroner Lesevorgang, mit einem vorherigen Aufruf von gestartet <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zu lesen, aus dem zugrunde liegenden Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.Read%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass das Beenden eines asynchronen Lesevorgang.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz<see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet ein asynchronen Schreibvorgang, mit einem vorherigen Aufruf von gestartet <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Eine Anwendung kann nicht auf diese Methode aufrufen, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.Write%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Schreibvorgang beendet.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass alle gepufferten Daten an das zugrunde liegende Gerät geschrieben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.Flush%2A> auf den zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Algorithmus zum Generieren von Nachrichtenauthentifizierungscodes (MACs) an.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.HashAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachrichtenauthentifizierungsalgorithmen generieren nachrichtenhashes und Signaturen zum Erkennen von Manipulationen und Fälschung von Nachrichten verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> Eigenschaft wurde zugegriffen, vor dem Fehler beim Abschluss den Authentifizierungsprozess abgebrochen oder im Authentifizierungsprozess sorgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des Hashalgorithmus, der von dieser Instanz verwendeten identifiziert.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Stärke der <see cref="T:System.Security.Authentication.HashAlgorithmType" /> -Algorithmus in Bits. Gültige Werte sind 128 oder 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die Authentifizierung erfolgreich war.</summary>
        <value>
          <see langword="true" />Wenn eine erfolgreicher Authentifizierung erfolgt ist andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Authentifizieren Sie Clients durch Aufrufen der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> Methoden. Server-Authentifizierung durch Aufrufen der <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies <see cref="T:System.Net.Security.SslStream" /> datenverschlüsselung verwendet.</summary>
        <value>
          <see langword="true" />Wenn die Daten vor der Übertragung über das Netzwerk verschlüsselt und entschlüsselt erreicht Wenn den Remoteendpunkt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Verschlüsselung hilft, den Schutz der Daten, d. h. ist es hilfreich, stellen Sie sicher, dass während Daten übertragen werden, es von Dritten gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob sowohl Client als auch Server authentifiziert wurden.</summary>
        <value>
          <see langword="true" />Wenn der Server authentifiziert wurden. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegenseitiger Authentifizierung wird vom Server angegeben, wenn der Server den Client ein Zertifikat zur Authentifizierung bereitstellen möchte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies die lokale Seite der Verbindung verwendeten <see cref="T:System.Net.Security.SslStream" /> wie der Server authentifiziert wurde.</summary>
        <value>
          <see langword="true" />Wenn der lokale Endpunkt als die Serverseite der die authentifizierte Verbindung erfolgreich authentifiziert wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung fehlgeschlagen oder ist nicht erfolgt ist, gibt diese Eigenschaft `false`.  
  
 Rufen Sie zur Authentifizierung wie der Server die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die mit diesem Stream gesendeten Daten signiert wurde.</summary>
        <value>
          <see langword="true" />Wenn die Daten vor der Übertragung signiert ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datensignatur hilft Ihnen bei der die Integrität der Daten zu schützen, hilft es nämlich den Empfänger zu bestimmen, ob die Daten bei der Übertragung manipuliert wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, die von diesem verwendeten Schlüsselaustauschalgorithmus <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist <xref:System.Security.Authentication.ExchangeAlgorithmType.None> bis zur Authentifizierung.  
  
 Der Schlüsselaustauschalgorithmus schützt Informationen, die zum Generieren von gemeinsam verwendeten Schlüssel verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des von dieser Instanz verwendeten Algorithmus für den Schlüsselaustausch identifiziert.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Stärke der <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> -Algorithmus in Bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
 In allgemeinen Szenarien ist der Wert dieser Eigenschaft eine der folgenden:  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des zugrunde liegenden Stream ab.</summary>
        <value>Ein <see cref="T:System.Int64" />.  
  
 Die Länge des zugrunde liegenden Stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.Length%2A> auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, löst diese Methode in der Regel eine Ausnahme aus. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zertifikat zur Authentifizierung des lokalen Endpunkts ab.</summary>
        <value>Ein X509Certificate-Objekt, das für die Authentifizierung bereitgestellte Zertifikat darstellt, oder <see langword="null" /> , wenn kein Zertifikat angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das von dieser Eigenschaft zurückgegebene Zertifikat.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die aktuelle Position in den zugrunde liegenden Stream.</summary>
        <value>Ein <see cref="T:System.Int64" />.  
  
 Die aktuelle Position in den zugrunde liegenden Stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.Position%2A> auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, löst diese Methode in der Regel eine Ausnahme aus. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Durch Festlegen dieser Eigenschaft wird nicht unterstützt.  
  
 - oder -   
  
 Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes empfängt, die aus diesem Stream gelesene.</param>
        <param name="offset">Ein <see cref="T:System.Int32" /> , enthält die nullbasierte Position im <c>Puffer</c> ab dem aus diesem Stream gelesenen Daten gespeichert.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> , die die maximale Anzahl der aus diesem Stream gelesenen Bytes enthält.</param>
        <summary>Liest Daten aus diesen Datenstrom und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der die Anzahl der gelesenen Bytes angibt. Wenn es keine weiteren Daten ist gelesen werden, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode liest ein Maximum von `count` Bytes aus dem Stream und speichert sie in `buffer` beginnend `offset`. Sie können nicht mehrere gleichzeitige Lesevorgänge ausführen.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang asynchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Lesen aus einer <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="offset" />+ Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang. Überprüfen Sie die innere Ausnahme, falls vorhanden, um die Ursache des Fehlers zu bestimmen.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die ein Lesevorgang warten Daten blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor ein synchroner Vorgang fehl lesen angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.ReadTimeout%2A> auf den zugrunde liegenden Stream. Beim Festlegen dieser Eigenschaft die <xref:System.IO.Stream.ReadTimeout%2A> Wert auf den zugrunde liegenden Stream mit dem angegebenen Wert festgelegt ist.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.ReadTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> standardmäßig, sodass Lesevorgänge verfügen nicht über ein Timeout.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zertifikat, mit den Remoteendpunkt zu authentifizieren.</summary>
        <value>Ein X509Certificate-Objekt, das für die Authentifizierung bereitgestellte Zertifikat darstellt, oder <see langword="null" /> , wenn kein Zertifikat angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das von dieser Eigenschaft zurückgegebene Zertifikat.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Wert wird ignoriert.</param>
        <param name="origin">Dieser Wert wird ignoriert.</param>
        <summary>Löst eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht. Geerbt wird, aber wird nicht von der <xref:System.Net.Security.SslStream> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Unterstützt keine Suchvorgänge durch <see cref="T:System.Net.Security.SslStream" /> Objekte.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Int64" /> Wert, der die Länge des Streams angibt.</param>
        <summary>Legt die Länge des zugrunde liegenden Streams fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> auf den zugrunde liegenden Stream angegeben, wenn dies <xref:System.Net.Security.SslStream> erstellt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt diesen SslStream herunter.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der das Sicherheitsprotokoll verwendet, um diese Verbindung authentifizieren angibt.</summary>
        <value>Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die unterstützten Sicherheitsprotokolle werden angegeben. wenn die <xref:System.Net.Security.SslStream> wird erstellt. Wenn kein Sicherheitsprotokoll an den Konstruktor übergeben wurde, die Instanz wird mit erstellt <xref:System.Security.Authentication.SslProtocols.Default>. Das tatsächliche Protokoll für die Authentifizierung aktiviert ist, basierend auf den vom Client und Server unterstützten Protokolle.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Sicherheitseigenschaften des angegebenen Datenstroms.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Net.TransportContext" /> für die Authentifizierung mit erweitertem Schutz verwendet.</summary>
        <value>Die <see cref="T:System.Net.TransportContext" /> Objekt, das für den erweiterten Schutz verwendet Kanalbindungstoken (CBT) enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes in den Stream geschrieben bereitstellt.</param>
        <summary>Schreibt die angegebenen Daten zu diesem Datenstrom.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, während der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, während der Vorgang abgeschlossen ist, verwenden die <xref:System.Net.Security.SslStream.BeginWrite%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Schreiben in eine authentifizierte <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes in den Stream geschrieben bereitstellt.</param>
        <param name="offset">Ein <see cref="T:System.Int32" /> , enthält die nullbasierte Position im <c>Puffer</c> ab dem Lesen von Bytes in den Stream geschrieben werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> , enthält die Anzahl der Bytes zum Auslesen <c>Puffer</c>.</param>
        <summary>Schreiben Sie die angegebene Anzahl von <see cref="T:System.Byte" />s in den zugrunde liegenden Stream unter Verwendung des angegebenen Puffers und Offset.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, während der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, während der Vorgang abgeschlossen abgeschlossen ist, verwenden Sie die <xref:System.Net.Security.SslStream.BeginWrite%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="offset" />+ Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die Ausführung eines Schreibvorgangs auf Daten zu warten, blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor Sie ein synchronen Schreibvorgang fehlschlägt angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.WriteTimeout%2A> auf den zugrunde liegenden Stream. Für Mengenoperationen, den angegebene Wert fest, der <xref:System.IO.Stream.WriteTimeout%2A> Wert auf den zugrunde liegenden Stream.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.WriteTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> standardmäßig, sodass Schreibvorgänge nicht zu einem Timeout verfügen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
