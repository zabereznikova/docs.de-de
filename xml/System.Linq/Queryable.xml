<Type Name="Queryable" FullName="System.Linq.Queryable">
  <TypeSignature Language="C#" Value="public static class Queryable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Queryable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Queryable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Queryable</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet eine Reihe von <see langword="static" /> (<see langword="Shared" /> in Visual Basic) Methoden zum Abfragen von Datenstrukturen, die implementieren <see cref="T:System.Linq.IQueryable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Satz von Methoden deklariert werden, der <xref:System.Linq.Queryable> -Klasse stellt eine Implementierung der Standardabfrageoperatoren zum Abfragen von implementiert Datenquellen, <xref:System.Linq.IQueryable%601>. Die Standardabfrageoperatoren sind allgemeine Methoden, die Folgen der [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] Muster und ermöglichen es Ihnen, Durchlauf, Filter- und projektionsvorgänge Vorgänge in einer express. NET-basierte Programmiersprache Ihrer Wahl.  
  
 Der Großteil der Methoden in dieser Klasse werden als Erweiterungsmethoden, die Erweiterung definiert die <xref:System.Linq.IQueryable%601> Typ. Dies bedeutet, sie können aufgerufen werden, wie eine Instanzmethode für jedes Objekt, das implementiert <xref:System.Linq.IQueryable%601>. Diese Methoden, mit denen erweitert <xref:System.Linq.IQueryable%601> nicht direkt Abfragen durchführen. Stattdessen wird ihre Funktionalität zum Erstellen einer <xref:System.Linq.Expressions.Expression> Objekt, das einer Ausdrucksbaumstruktur dar, das die kumulierte Abfrage darstellt. Die Methoden übergeben dann die neue Ausdrucksbaumstruktur entweder die <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode oder die <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> die Eingabemethode <xref:System.Linq.IQueryable%601>. Die Methode, die aufgerufen wird, hängt davon ab, ob die <xref:System.Linq.Queryable> Methodenrückgabe Singleton-Wert, in diesem Fall <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> aufgerufen wird, oder aufzählbare Ergebnisse in diesem Fall hat <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> aufgerufen wird.  
  
 Die tatsächliche Ausführung der Abfrage auf die Zieldaten erfolgt durch eine Klasse, die implementiert <xref:System.Linq.IQueryable%601>. Die Annahme eines beliebigen <xref:System.Linq.IQueryable%601> Implementierung ist, die das Ergebnis der Ausführung einer Ausdrucksbaumstruktur dar, die von der Erstellung einer <xref:System.Linq.Queryable> Standardabfrageoperator-Operator-Methode entspricht das Ergebnis des Aufrufs der entsprechenden Methode der <xref:System.Linq.Enumerable> Klasse, wenn die Datenquelle wäre ein <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Zusätzlich zu den Standardabfrageoperator-Methoden, die Vorgänge an <xref:System.Linq.IQueryable%601> Objekte, die diese Klasse enthält auch eine Methode <xref:System.Linq.Queryable.AsQueryable%2A>, welche Typen <xref:System.Collections.IEnumerable> als Objekte <xref:System.Linq.IQueryable> Objekte.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TSource,TSource&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TSource,TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="func">Eine Akkumulatorfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten, die die angegebene Funktion ist `func`, angewendet wird, um jeden Wert in der Quellsequenz und der akkumulierte Wert zurückgegeben. Der erste Wert in `source` wird für den akkumulierten Wert der erste Parameter im entspricht Wert als Ausgangswert verwendet `func`.  
  
 Um allgemeine Aggregationsvorgänge zu vereinfachen, enthält der Satz von Standardabfrageoperatoren auch zwei zählen Methoden, <xref:System.Linq.Queryable.Count%2A> und <xref:System.Linq.Queryable.LongCount%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>, und <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> zum Erstellen eines Satzes aus einem Array von Zeichenfolgen.  
  
 [!code-csharp[System.Linq.Queryable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#1)]
 [!code-vb[System.Linq.Queryable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten, die die angegebene Funktion ist `func`, angewendet wird, um jeden Wert in der Quellsequenz und der akkumulierte Wert zurückgegeben. Die `seed` Parameter wird für den akkumulierten Wert der erste Parameter im entspricht Wert als Ausgangswert verwendet `func`.  
  
 Um allgemeine Aggregationsvorgänge zu vereinfachen, enthält der Satz von Standardabfrageoperatoren auch zwei zählen Methoden, <xref:System.Linq.Queryable.Count%2A> und <xref:System.Linq.Queryable.LongCount%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>, und <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> eine Akkumulatorfunktion angewendet, wenn ein Startwert für die Funktion bereitgestellt wird.  
  
 [!code-csharp[System.Linq.Queryable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#2)]
 [!code-vb[System.Linq.Queryable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TAccumulate, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion für jedes Element aufgerufen werden soll.</param>
        <param name="selector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten, die die angegebene Funktion ist `func`, angewendet wird, um jeden Wert in der Quellsequenz und der akkumulierte Wert zurückgegeben. Die `seed` Parameter wird für den akkumulierten Wert der erste Parameter im entspricht Wert als Ausgangswert verwendet `func`. Der letzte akkumulierte Wert übergeben wird, um `selector` um den Ergebniswert zu erhalten.  
  
 Um allgemeine Aggregationsvorgänge zu vereinfachen, enthält der Satz von Standardabfrageoperatoren auch zwei zählen Methoden, <xref:System.Linq.Queryable.Count%2A> und <xref:System.Linq.Queryable.LongCount%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>, und <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> eine Akkumulatorfunktion und eine Ergebnisauswahl angewendet.  
  
 [!code-csharp[System.Linq.Queryable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#3)]
 [!code-vb[System.Linq.Queryable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente auf eine Bedingung zu testen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns>
          <see langword="true" />Wenn jedes Element der Quellsequenz den Test im angegebenen Prädikat besteht, oder wenn die Sequenz leer ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung von der `source` Typ des Parameters. Das erwartete Verhalten bestimmt wird, wenn alle Elemente im `source` erfüllen die Bedingung in `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> zu bestimmen, ob alle Elemente in einer Sequenz eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#4)]
 [!code-vb[System.Linq.Queryable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#4)]  
  
 Der boolesche Wert, der die <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methodenrückgabe wird im Prädikat in der Regel verwendet eine `where` -Klausel (`Where` -Klausel in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) oder ein direkter Aufruf der <xref:System.Linq.Queryable.Where%2A> Methode. Das folgende Beispiel zeigt diese Verwendung von der `All` Methode.  
  
 [!code-csharp[System.Linq.Queryable#134](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#134)]
 [!code-vb[System.Linq.Queryable#134](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#134)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz zur Überprüfung des leer.</param>
        <summary>Bestimmt, ob eine Sequenz Elemente enthält.</summary>
        <returns>
          <see langword="true" />Wenn die Quellsequenz Elemente enthält. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten bestimmt wird, wenn `source` irgendwelche Elemente enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> zu bestimmen, ob eine Sequenz Elemente enthält.  
  
 [!code-csharp[System.Linq.Queryable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#5)]
 [!code-vb[System.Linq.Queryable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#5)]  
  
 Der boolesche Wert, der die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methodenrückgabe wird im Prädikat in der Regel verwendet eine `where` -Klausel (`Where` -Klausel in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) oder ein direkter Aufruf der <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode. Das folgende Beispiel zeigt diese Verwendung von der `Any` Methode.  
  
 [!code-csharp[System.Linq.Queryable#135](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#135)]
 [!code-vb[System.Linq.Queryable#135](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#135)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente auf eine Bedingung zu testen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns>
          <see langword="true" />Wenn Elemente in der Quellsequenz den Test im angegebenen Prädikat erfolgreich überprüft; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten bestimmt wird, wenn keines der Elemente des `source` von angegebene Bedingung erfüllen `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> zu bestimmen, ob ein Element in einer Sequenz eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#6)]
 [!code-vb[System.Linq.Queryable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Append``1(System.Linq.IQueryable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable AsQueryable (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable AsQueryable(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine zu konvertierende Sequenz.</param>
        <summary>Konvertiert eine <see cref="T:System.Collections.IEnumerable" /> auf eine <see cref="T:System.Linq.IQueryable" />.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable" /> , die die Eingabesequenz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%28System.Collections.IEnumerable%29> direkt zurückgegeben. Zurückgegeben, andernfalls ein <xref:System.Linq.IQueryable%601> , Abfragen ausführt, durch Aufrufen der entsprechenden Abfrage Standardabfrageoperator-Methoden in <xref:System.Linq.Enumerable> statt in <xref:System.Linq.Queryable>.  
  
 Diese Methode setzt voraus, dass `source` implementiert <xref:System.Collections.Generic.IEnumerable%601> für einige `T`. Zur Laufzeit ist das Ergebnis vom Typ <xref:System.Linq.IQueryable%601> für dieselbe `T`. Diese Methode ist in dynamischen Szenarios nützlich, wenn Sie den Typ des nicht statisch kennen `T`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />implementiert nicht <see cref="T:System.Collections.Generic.IEnumerable`1" /> für einige <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TElement&gt; AsQueryable&lt;TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TElement&gt; AsQueryable&lt;TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine zu konvertierende Sequenz.</param>
        <summary>Konvertiert eine generische <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf einen generischen <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Eingabesequenz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> direkt zurückgegeben. Zurückgegeben, andernfalls ein <xref:System.Linq.IQueryable%601> , Abfragen ausführt, durch Aufrufen der entsprechenden Abfrage Standardabfrageoperator-Methoden in <xref:System.Linq.Enumerable> statt in <xref:System.Linq.Queryable>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Konvertieren einer <xref:System.Collections.Generic.IEnumerable%601> auf eine <xref:System.Linq.IQueryable%601>.  
  
 [!code-csharp[System.Linq.Queryable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#125)]
 [!code-vb[System.Linq.Queryable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#125)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> selbst. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt einer Sequenz von Werten oder <see langword="null" /> Wenn die <paramref name="source" /> Sequenz ist leer oder enthält nur <see langword="null" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt einer Sequenz von Werten oder <see langword="null" /> Wenn die <paramref name="source" /> Sequenz ist leer oder enthält nur <see langword="null" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt einer Sequenz von Werten oder <see langword="null" /> Wenn die <paramref name="source" /> Sequenz ist leer oder enthält nur <see langword="null" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf die <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt einer Sequenz von Werten oder <see langword="null" /> Wenn die <paramref name="source" /> Sequenz ist leer oder enthält nur <see langword="null" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt einer Sequenz von Werten oder <see langword="null" /> Wenn die <paramref name="source" /> Sequenz ist leer oder enthält nur <see langword="null" /> Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf die <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, den Durchschnitt der Werte in berechnet `source` nach dem Aufrufen `selector` auf jedem Wert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> zum Berechnen des Durchschnitts <xref:System.String> Länge in einer Sequenz von Werten des Typs <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, konvertiert die Elemente eines <c>Quelle</c> an.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable" /> , die die zu konvertierenden Elemente enthält.</param>
        <summary>Konvertiert die Elemente einer <see cref="T:System.Linq.IQueryable" /> in den angegebenen Typ.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" />, die jedes in den angegebenen Typ konvertierte Element der Quellsequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass er die Werte in konvertiert `source` Eingabe `TResult`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> um Objekte in einer Sequenz in den Typ konvertieren <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#19)]
 [!code-vb[System.Linq.Queryable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ein Element in der Sequenz kann nicht Typ umgewandelt werden <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Die erste zu verkettende Sequenz.</param>
        <param name="source2">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei Sequenzen.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die verketteten Elemente der zwei Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Das erwartete Verhalten ist, die die Elemente in `source2` verkettet werden, die von `source1` zum Erstellen einer neuen Sequenz.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> um zwei Sequenzen zu verketten.  
  
 [!code-csharp[System.Linq.Queryable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#20)]
 [!code-vb[System.Linq.Queryable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> in der zu suchende <c>Element</c>.</param>
        <param name="item">Das Objekt in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt, ob eine Sequenz ein angegebenes Element enthält, mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>
          <see langword="true" />Wenn die Eingabesequenz ein Element, die den angegebenen Wert verfügt enthält; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten bestimmt wird, wenn `source` enthält `item`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> zu bestimmen, ob eine Sequenz ein bestimmtes Element enthält.  
  
 [!code-csharp[System.Linq.Queryable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#21)]
 [!code-vb[System.Linq.Queryable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> in der zu suchende <c>Element</c>.</param>
        <param name="item">Das Objekt in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Bestimmt, ob eine Sequenz ein angegebenes Element enthält, mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" />Wenn die Eingabesequenz ein Element, die den angegebenen Wert verfügt enthält; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten bestimmt wird, wenn `source` enthält `item` mit `comparer` zum Vergleichen von Werten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> , die die zu zählende Elemente enthält.</param>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Anzahl der Elemente im gezählt `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> zum zählen der Elemente in einer Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#22)]
 [!code-vb[System.Linq.Queryable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente im <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Linq.IQueryable`1" /> , die die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt die Anzahl der Elemente in der angegebenen Sequenz, die eine Bedingung erfüllt.</summary>
        <returns>Die Anzahl der Elemente in der Sequenz, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Anzahl der Elemente im gezählt `source` , die die angegebene Bedingung erfüllen `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , die Elemente in einer Sequenz zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#23)]
 [!code-vb[System.Linq.Queryable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente im <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> einen Standardwert für wird zurückgegeben, wenn leer.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz, oder Standardwert des Typparameters in einer singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält <see langword="default" />(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist; andernfalls, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten gibt es zurück `source` , wenn er nicht leer ist. Andernfalls gibt es eine <xref:System.Linq.IQueryable%601> enthält `default(TSource)`.  
  
   
  
## Examples  
 Die folgenden Codebeispiele veranschaulichen <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> um einen Standardwert anzugeben, für den Fall, dass die Quellsequenz leer ist.  
  
 [!code-csharp[System.Linq.Queryable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#24)]
 [!code-vb[System.Linq.Queryable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> für den angegebenen Wert wird zurückgegeben, wenn leer.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den angegebenen Wert in einer singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält <paramref name="defaultValue" /> Wenn <paramref name="source" /> leer ist; andernfalls, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten gibt es zurück `source` , wenn er nicht leer ist. Andernfalls gibt es eine <xref:System.Linq.IQueryable%601> enthält `defaultValue`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt eine Situation, in denen es sinnvoll ist, rufen Sie <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> in einer [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] Abfrage. Ein Default-Wert übergeben wird, um <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> in diesem Beispiel.  
  
 [!code-csharp[System.Linq.Queryable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#25)]
 [!code-vb[System.Linq.Queryable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> um Duplikate zu entfernen.</param>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten zurück.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält unterschiedliche Elemente aus <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass eine ungeordnete Sequenz der eindeutigen Elemente in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> unterschiedliche Elemente aus einer Sequenz zurückgegeben.  
  
 [!code-csharp[System.Linq.Queryable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#27)]
 [!code-vb[System.Linq.Queryable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> um Duplikate zu entfernen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält unterschiedliche Elemente aus <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass eine ungeordnete Sequenz der eindeutigen Elemente in zurückgegeben `source` mit `comparer` zum Vergleichen von Werten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element am angegebenen Index in einer Sequenz zurück.</summary>
        <returns>Das Element an der angegebenen Position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das Element an der Position zurückgegeben `index` in `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> um ein Element an einer bestimmten Position in einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#28)]
 [!code-vb[System.Linq.Queryable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns>
          <c>standardmäßige</c>(<paramref name="TSource" />) Wenn <paramref name="index" /> liegt außerhalb des Bereichs der <paramref name="source" />ist, andernfalls das Element an der angegebenen Position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das Element an der Position zurückgegeben `index` in `source`, oder `default(TSource)` Wenn `index` liegt außerhalb des Bereichs der `source`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung von <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29>. Dieses Beispiel verwendet einen Wert für `index` ist außerhalb der Begrenzungen der Quellsequenz.  
  
 [!code-csharp[System.Linq.Queryable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#29)]
 [!code-vb[System.Linq.Queryable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente, die auch in <c>Quelle2</c> zurückgegeben werden.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in der ersten Sequenz auftreten, erscheint nicht in der zurückgegebenen Sequenz.</param>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Differenzmenge von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der`source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Es wird erwartet, die alle Elemente im `source1` werden zurückgegeben, außer denen, die auch in `source2`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> die Elemente, die nur in der ersten Quellsequenz zurückgegeben.  
  
 [!code-csharp[System.Linq.Queryable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#34)]
 [!code-vb[System.Linq.Queryable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente, die auch in <c>Quelle2</c> zurückgegeben werden.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in der ersten Sequenz auftreten, erscheint nicht in der zurückgegebenen Sequenz.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen unter Verwendung des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Differenzmenge von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der`source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Es wird erwartet, die alle Elemente im `source1` werden zurückgegeben, außer denen, die auch in `source2`, und `comparer` wird verwendet, um Werte zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> um das erste Element der zurückzugeben.</param>
        <summary>Gibt das erste Element einer Sequenz zurück.</summary>
        <returns>Das erste Element im <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das erste Element im zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf das erste Element in einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#35)]
 [!code-vb[System.Linq.Queryable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element einer Sequenz, die eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element im <paramref name="source" /> , die den Test wird im übergibt <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das erste Element im zurückgegeben `source` , die die angegebene Bedingung erfüllt `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> um das erste Element einer Sequenz zurückzugeben, die eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#36)]
 [!code-vb[System.Linq.Queryable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.IQueryable`1" /> um das erste Element der zurückzugeben.</param>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>
          <c>standardmäßige</c>(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist, andernfalls das erste Element im <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das erste Element im zurückgegeben `source`, oder ein Standardwert, wenn `source` ist leer.  
  
 Die <xref:System.Linq.Queryable.FirstOrDefault%2A> Methode bietet eine Möglichkeit zum Angeben der Standardwert wird zurückgegeben, wenn keine `source` ist leer. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf eine leere Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#37)]
 [!code-vb[System.Linq.Queryable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#37)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf das erste Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von numerischen Monate leer ist. Da der Standardwert für eine ganze Zahl 0 (null) das keine Monat entspricht ist, muss der Standardwert stattdessen mit 1 angegeben. Die erste Ergebnisvariable wird nach Abschluss der Abfrage das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird durch Aufrufen von <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Queryable#131](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#131)]
 [!code-vb[System.Linq.Queryable#131](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#131)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element einer Sequenz, die eine angegebene Bedingung bzw. ein Standardwert, wenn kein solches Element gefunden wird.</summary>
        <returns>
          <c>standardmäßige</c>(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist oder wenn kein Element vom angegebenen Test besteht <paramref name="predicate" />ist, andernfalls das erste Element im <paramref name="source" /> , die vom angegebene übergibt <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das erste Element im zurückgegeben `source` erfüllt die Bedingung in `predicate`, oder einen Standardwert, wenn kein Element die Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> durch die Übergabe in einem Prädikat. In der zweiten Abfrage ist gibt es kein Element in der Sequenz, die die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#38)]
 [!code-vb[System.Linq.Queryable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> in c# oder <c>IQueryable (Of IGrouping (Of TKey, TSource))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> Objekt enthält eine Sequenz von Objekten und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` durch ein Schlüssel-Wert, der durch den Aufruf abgerufen wird `keySelector` für jedes Element.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> zum Gruppieren der Elemente einer Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#14)]
 [!code-vb[System.Linq.Queryable#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> in c# oder <c>IQueryable (Of IGrouping (Of TKey, TSource))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> eine Sequenz von Objekten und einen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` von Schlüssel-Wert. Der Schlüsselwert wird durch den Aufruf ermittelt `keySelector` für jedes Element und Schlüsselwerte verglichen werden, mithilfe von `comparer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion.</summary>
        <returns>Ein <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> in c# oder <c>IQueryable (Of IGrouping (Of TKey, TElement))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> enthält eine Sequenz von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` durch ein Schlüssel-Wert, der durch den Aufruf abgerufen wird `keySelector` für jedes Element. Er ruft `elementSelector` für jedes Element, ein Ergebniselement abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> zum Gruppieren der Elemente einer Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#39)]
 [!code-vb[System.Linq.Queryable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz ein, und die Elemente für jede Gruppe mithilfe einer angegebenen Funktion projiziert. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Ein <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> in c# oder <c>IQueryable (Of IGrouping (Of TKey, TElement))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> enthält eine Sequenz von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` durch ein Schlüssel-Wert, der durch den Aufruf abgerufen wird `keySelector` für jedes Element. Schlüsselwerte werden verglichen mit `comparer`. Die `elementSelector` Parameter wird aufgerufen, für jedes Element, ein Ergebniselement abzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Ein <c>T:System.Linq.IQueryable'1</c> , die ein Type-Argument der hat <paramref name="TResult" /> und, in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` durch ein Schlüssel-Wert, der durch den Aufruf abgerufen wird `keySelector` für jedes Element. Die `resultSelector` Parameter wird verwendet, um aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> zum Gruppieren der Elemente einer Sequenz und eine Sequenz von Ergebnissen vom Typ projizieren `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#15)]
 [!code-vb[System.Linq.Queryable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Ein <c>T:System.Linq.IQueryable'1</c> , die ein Type-Argument der hat <paramref name="TResult" /> und, in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` anhand von Schlüsselwerten, die durch den Aufruf abgerufen werden `keySelector` für jedes Element. Die `comparer` Parameter zum Vergleichen von Schlüsseln verwendet wird und die `resultSelector` Parameter wird verwendet, um aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="resultSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Ein <c>T:System.Linq.IQueryable'1</c> , die ein Type-Argument der hat <paramref name="TResult" /> und, in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` anhand von Schlüsselwerten, die durch den Aufruf abgerufen werden `keySelector` für jedes Element. Die `elementSelector` Parameter wird verwendet, um die Elemente der Gruppe "Jeder", Projekt und die `resultSelector` Parameter wird verwendet, um aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> zum Gruppieren der Elemente einer Sequenz und eine Sequenz von Ergebnissen vom Typ projizieren `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#130)]
 [!code-vb[System.Linq.Queryable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellt im zurückgegebenen <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Ein <c>T:System.Linq.IQueryable'1</c> , die ein Type-Argument der hat <paramref name="TResult" /> und, in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente gruppiert `source` anhand von Schlüsselwerten, die durch den Aufruf abgerufen werden `keySelector` für jedes Element. Die `comparer` Parameter wird verwendet, um Schlüsselwerte verglichen werden soll. Die `elementSelector` Parameter wird verwendet, um die Elemente der Gruppe "Jeder", Projekt und die `resultSelector` Parameter wird verwendet, um aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> oder <paramref name="resultSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , enthält die Elemente des Typs <paramref name="TResult" /> durch Ausführen eines Group Joins von zwei Sequenzen ermittelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `outer` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> richtet sich nach der Implementierung des Typs von der `outer` Parameter. Es wird erwartet, die die `outerKeySelector` und `innerKeySelector` Funktionen dienen zum Extrahieren der Schlüssel aus `outer` und `inner`bzw.. Diese Schlüssel werden Gleichheit entsprechend jedes Element im `outer` mit keinem oder mehreren Elementen aus `inner`. Die `resultSelector` Funktion wird aufgerufen, um ein Ergebnisobjekt aus jeder Gruppe korrelierter Elemente zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> zum Ausführen eines Group Joins von zwei Sequenzen.  
  
 [!code-csharp[System.Linq.Queryable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#40)]
 [!code-vb[System.Linq.Queryable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein Vergleich zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , enthält die Elemente des Typs <paramref name="TResult" /> durch Ausführen eines Group Joins von zwei Sequenzen ermittelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `outer` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> richtet sich nach der Implementierung des Typs von der `outer` Parameter. Es wird erwartet, die die `outerKeySelector` und `innerKeySelector` Funktionen dienen zum Extrahieren der Schlüssel aus `outer` und `inner`bzw.. Diese Schlüssel auf Gleichheit verglichen werden, mithilfe von `comparer`. Das Ergebnis der Vergleiche wird verwendet, um jedes Element im `outer` mit keinem oder mehreren Elementen aus `inner`. Die `resultSelector` Funktion wird aufgerufen, um ein Ergebnisobjekt aus jeder Gruppe korrelierter Elemente zu projizieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente, die auch in <c>Quelle2</c> werden zurückgegeben.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden, werden zurückgegeben.</param>
        <summary>Erzeugt die Schnittmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Schnittmenge von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Es wird erwartet, die alle Elemente im `source1` , sind auch in `source2` zurückgegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> um die Elemente, die angezeigt werden in zwei Sequenzen zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#41)]
 [!code-vb[System.Linq.Queryable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> , deren unterschiedliche Elemente, die auch in <c>Quelle2</c> werden zurückgegeben.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente, die auch in der ersten Sequenz werden zurückgegeben.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Schnittmenge von zwei Sequenzen unter Verwendung des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Schnittmenge von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Es wird erwartet, die alle Elemente im `source1` , sind auch in `source2` zurückgegeben werden. Die `comparer` Parameter zum Vergleichen von Elementen verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf übereinstimmenden Schlüsseln. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , die Elemente des Typs hat <paramref name="TResult" /> durch Ausführen eines inner Joins von zwei Sequenzen ermittelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `outer` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> richtet sich nach der Implementierung des Typs von der `outer` Parameter. Das erwartete Verhalten ist, die einen inneren Join. Die `outerKeySelector` und `innerKeySelector` Funktionen dienen zum Extrahieren der Schlüssel von `outer` und `inner`zugeordnet. Diese Schlüssel werden zum Abgleichen von Elementen aus jeder Sequenz Gleichheit. Für jedes Element in ein Paar von Elementen gespeichert `inner` , entspricht ein Element in `outer`. Die `resultSelector` Funktion wird aufgerufen, um das Projekt ein Ergebnisobjekt aus jedem Paar von übereinstimmenden Elementen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> eine innere Verknüpfung zweier Sequenzen basierend auf einem gemeinsamen Schlüssel ausführen.  
  
 [!code-csharp[System.Linq.Queryable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#42)]
 [!code-vb[System.Linq.Queryable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf übereinstimmenden Schlüsseln. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , die Elemente des Typs hat <paramref name="TResult" /> durch Ausführen eines inner Joins von zwei Sequenzen ermittelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `outer` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> richtet sich nach der Implementierung des Typs von der `outer` Parameter. Das erwartete Verhalten ist, die einen inneren Join. Die `outerKeySelector` und `innerKeySelector` Funktionen dienen zum Extrahieren der Schlüssel von `outer` und `inner`zugeordnet. Diese Schlüssel auf Gleichheit verglichen werden, mithilfe von `comparer`. Das Ergebnis der Vergleiche wird verwendet, erstellen Sie ein übereinstimmendes Paar für jedes Element im `inner` , entspricht ein Element in `outer`. Die `resultSelector` Funktion wird aufgerufen, um das Projekt ein Ergebnisobjekt aus jedem Paar von übereinstimmenden Elementen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> das letzte Element zurückgegeben.</param>
        <summary>Gibt das letzte Element in einer Sequenz zurück.</summary>
        <returns>Der Wert der letzten Position im <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das letzte Element im zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf das letzte Element eines Arrays zurück.  
  
 [!code-csharp[System.Linq.Queryable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#43)]
 [!code-vb[System.Linq.Queryable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element im <paramref name="source" /> , die vom angegebene übergibt <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das letzte Element im zurückgegeben `source` , die die angegebene Bedingung erfüllt `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> auf das letzte Element eines Arrays zurück, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#44)]
 [!code-vb[System.Linq.Queryable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> das letzte Element zurückgegeben.</param>
        <summary>Gibt das letzte Element in einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>
          <c>standardmäßige</c>(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist, andernfalls das letzte Element im <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das letzte Element im zurückgegeben `source`, oder ein Standardwert, wenn `source` ist leer.  
  
 Die <xref:System.Linq.Queryable.LastOrDefault%2A> Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf ein leeres Array.  
  
 [!code-csharp[System.Linq.Queryable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#45)]
 [!code-vb[System.Linq.Queryable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#45)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf das letzte Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von numerischen Tage des Monats leer ist. Da der Standardwert für eine ganze Zahl 0 (null) das nicht zu einem beliebigen Tag des Monats entspricht ist, muss der Standardwert stattdessen mit 1 angegeben. Die erste Ergebnisvariable wird nach Abschluss der Abfrage das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird durch Aufrufen von <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Queryable#132](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#132)]
 [!code-vb[System.Linq.Queryable#132](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#132)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz, das eine Bedingung erfüllt, oder einen Standardwert zurück, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>
          <c>standardmäßige</c>(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist oder keine Elemente in der Prädikatfunktion; den Test erfolgreich ist, andernfalls das letzte Element der <paramref name="source" /> , die der Test der Prädikatfunktion erfolgreich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass das letzte Element im zurückgegeben `source` , die die angegebene Bedingung erfüllt `predicate`. Es gibt einen Standardwert zurück, wenn es kein solches Element im ist `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> durch die Übergabe in einem Prädikat. Im zweiten Aufruf der Methode ist gibt es kein Element in der Sequenz, die die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#46)]
 [!code-vb[System.Linq.Queryable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Linq.IQueryable`1" /> , die die zu zählende Elemente enthält.</param>
        <summary>Gibt eine <see cref="T:System.Int64" /> , die die Gesamtanzahl von Elementen in einer Sequenz darstellt.</summary>
        <returns>Die Anzahl von Elementen in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Anzahl der Elemente im gezählt `source` und gibt eine <xref:System.Int64>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> zum zählen der Elemente in einem Array.  
  
 [!code-csharp[System.Linq.Queryable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#47)]
 [!code-vb[System.Linq.Queryable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Linq.IQueryable`1" /> , die die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine <see cref="T:System.Int64" /> stellt die Anzahl von Elementen in einer Sequenz, die eine Bedingung erfüllen.</summary>
        <returns>Die Anzahl der Elemente im <paramref name="source" /> , die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Anzahl der Elemente im gezählt `source` , die die angegebene Bedingung erfüllen `predicate` und gibt ein <xref:System.Int64>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#48)]
 [!code-vb[System.Linq.Queryable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der übereinstimmenden Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die maximal zu bestimmen.</param>
        <summary>Gibt den größten Wert in einem generischen <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass den maximalen Wert in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Queryable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#52)]
 [!code-vb[System.Linq.Queryable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des von der Funktion dargestellte zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die maximal zu bestimmen.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Projektionsfunktion für jedes Element einer generischen <see cref="T:System.Linq.IQueryable`1" /> und gibt den resultierenden Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element in `source` und gibt den Höchstwert zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!code-csharp[System.Linq.Queryable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#58)]
 [!code-vb[System.Linq.Queryable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die das Minimum zu bestimmen.</param>
        <summary>Gibt den kleinsten Wert einer generischen <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, den kleinsten Wert in gibt `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Queryable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#60)]
 [!code-vb[System.Linq.Queryable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des von der Funktion dargestellte zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die das Minimum zu bestimmen.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Projektionsfunktion für jedes Element einer generischen <see cref="T:System.Linq.IQueryable`1" /> und gibt den resultierenden Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element im `source` und gibt den Mindestwert zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!code-csharp[System.Linq.Queryable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#68)]
 [!code-vb[System.Linq.Queryable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable" /> , deren Elemente gefiltert.</param>
        <summary>Filtert die Elemente einer <see cref="T:System.Linq.IQueryable" /> anhand eines angegebenen Typs.</summary>
        <returns>Eine Auflistung mit den Elementen von <paramref name="source" /> deren Typ <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OfType` Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt `OfType` sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, `OfType` richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass dadurch herausgefiltert werden alle Elemente in `source` , die nicht vom Typ sind `TResult`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit `OfType` Elemente herausfiltern, die nicht vom Typ <xref:System.Reflection.PropertyInfo> aus einer Liste von Elementen des Typs <xref:System.Reflection.MemberInfo>.  
  
 [!code-csharp[System.Linq.Queryable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#69)]
 [!code-vb[System.Linq.Queryable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion, die von dargestellte zurückgegeben <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Elemente eines sortiert `source` anhand des Schlüssels, der durch den Aufruf ermittelt `keySelector` für jedes Element der `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> die Elemente einer Sequenz sortiert.  
  
 [!code-csharp[System.Linq.Queryable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#70)]
 [!code-vb[System.Linq.Queryable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion, die von dargestellte zurückgegeben <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Elemente eines sortiert `source` anhand des Schlüssels, der durch den Aufruf ermittelt `keySelector` für jedes Element der `source`. Die `comparer` Parameter zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion, die von dargestellte zurückgegeben <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Elemente eines sortiert `source` in absteigender Reihenfolge anhand des Schlüssels, der durch den Aufruf `keySelector` für jedes Element der `source`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion, die von dargestellte zurückgegeben <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass die Elemente eines sortiert `source` in absteigender Reihenfolge anhand des Schlüssels, der durch den Aufruf `keySelector` für jedes Element der `source`. Die `comparer` Parameter zum Vergleichen von Schlüsseln verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> zum Sortieren der Elemente einer Sequenz in absteigender Reihenfolge mit einem benutzerdefinierten Vergleich.  
  
 [!code-csharp[System.Linq.Queryable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#71)]
 [!code-vb[System.Linq.Queryable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Prepend``1(System.Linq.IQueryable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer Sequenz.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente entsprechen denen der Eingabesequenz in umgekehrter Reihenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, die Reihenfolge der Elemente im kehrt `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> die Reihenfolge der Elemente in einem Array Reihenfolge umgekehrt werden soll.  
  
 [!code-csharp[System.Linq.Queryable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#74)]
 [!code-vb[System.Linq.Queryable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des von der Funktion dargestellte zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Formular durch Einbinden der Index des Elements an.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs einer Projektionsfunktion auf jedes Element der <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> hängen von der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` , in einer anderen Form zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> projizieren auf eine Sequenz von Werten und der Index jedes Elements im projizierten Format verwenden.  
  
 [!code-csharp[System.Linq.Queryable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#76)]
 [!code-vb[System.Linq.Queryable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des von der Funktion dargestellte zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs einer Projektionsfunktion auf jedes Element der <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` , in einer anderen Form zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Projekt über eine Sequenz von Werten.  
  
 [!code-csharp[System.Linq.Queryable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#75)]
 [!code-vb[System.Linq.Queryable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz, die von der Funktion dargestellte zurückgegebenen <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs einer 1: n-Projektionsfunktion auf jedes Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` es in eine enumerable-Form projizieren. Anschließend wird die enumerable-Ergebnisse in einer einzelnen eindimensionalen Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> eine 1: n-Projektion über einem Array ausgeführt.  
  
 [!code-csharp[System.Linq.Queryable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#77)]
 [!code-vb[System.Linq.Queryable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz, die von der Funktion dargestellte zurückgegebenen <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll. der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen. Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs einer 1: n-Projektionsfunktion auf jedes Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` es in eine enumerable-Form projizieren. Jedes auflistbare Ergebnis umfasst den Index des Quellelements. Anschließend wird die enumerable-Ergebnisse in einer einzelnen eindimensionalen Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> eine 1: n-Projektion über ein Array ausführen und den Index jedes Quellelements verwenden.  
  
 [!code-csharp[System.Linq.Queryable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#78)]
 [!code-vb[System.Linq.Queryable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente erfasst, von der Funktion dargestellte <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Projektionsfunktion auf jedes Element der Eingabesequenz angewendet werden soll.</param>
        <param name="resultSelector">Eine Projektionsfunktion auf jedes Element jeder intermediate Sequenz angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und ruft ein Ergebnis für jedes Element Ergebnisauswahlfunktion auf. Die resultierenden Werte aus einzelnen intermediate Sequenz sind in einer einzelnen eindimensionalen Sequenz zusammengefasst und zurückgegeben.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Projektionsfunktion <paramref name="collectionSelector" /> für jedes Element der <paramref name="source" /> und anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden <paramref name="source" /> Element zu einem Ergebniselement .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `collectionSelector` für jedes Element der `source` es in eine enumerable-Form projizieren. Und dann die Funktion szenariobeschreibungen `resultSelector` für jedes Element in jeder intermediate Sequenz aufgerufen wird. Die resultierenden Werte werden in einer einzelnen eindimensionalen Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> eine 1: n-Projektion über einem Array ausgeführt. In diesem Beispiel verwendet eine Ergebnisauswahlfunktion, um das Quellelement beizubehalten, die jeder intermediate Sequenz im Bereich für den letzten Aufruf von entspricht `Select`.  
  
 [!code-csharp[System.Linq.Queryable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#124)]
 [!code-vb[System.Linq.Queryable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente erfasst, von der Funktion dargestellte <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Projektionsfunktion auf jedes Element der Eingabesequenz angewendet werden soll. der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Projektionsfunktion auf jedes Element jeder intermediate Sequenz angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die den Index des Quellelements, die er produziert integriert. Eine Ergebnisauswahlfunktion für jedes Element jeder intermediate Sequenz aufgerufen wird, und die erhaltenen Werte werden in einer einzelnen eindimensionalen Sequenz zusammengefasst und zurückgegeben.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Projektionsfunktion <paramref name="collectionSelector" /> für jedes Element der <paramref name="source" /> und anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden <paramref name="source" /> Element zu einem Ergebniselement .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `collectionSelector` für jedes Element der `source` es in eine enumerable-Form projizieren. Jedes auflistbare Ergebnis umfasst die der Index des Quellelements. Und dann die Funktion szenariobeschreibungen `resultSelector` für jedes Element in jeder intermediate Sequenz aufgerufen wird. Die resultierenden Werte werden in einer einzelnen eindimensionalen Sequenz verkettet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente mit denen von Vergleichen <c>Quelle2</c>.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, mit denen von der ersten Sequenz verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Elementen.</summary>
        <returns>
          <see langword="true" />Wenn die zwei Quellsequenzen von gleicher Länge sind und die entsprechenden Elemente gleich verglichen werden soll. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Das erwartete Verhalten ist, dass er ermittelt, ob die zwei Quellsequenzen gleich sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> zu bestimmen, ob zwei Sequenzen gleich sind. In diesem Beispiel wird sind die Sequenzen gleich.  
  
 [!code-csharp[System.Linq.Queryable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#32)]
 [!code-vb[System.Linq.Queryable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#32)]  
  
 Im folgenden Codebeispiel wird vergleicht zwei Sequenzen, die nicht gleich sind.  
  
 [!code-csharp[System.Linq.Queryable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#33)]
 [!code-vb[System.Linq.Queryable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> , dessen Elemente mit denen von Vergleichen <c>Quelle2</c>.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, mit denen von der ersten Sequenz verglichen werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, indem ein angegebener <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Elementen.</summary>
        <returns>
          <see langword="true" />Wenn die zwei Quellsequenzen von gleicher Länge sind und die entsprechenden Elemente gleich verglichen werden soll. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Das erwartete Verhalten bestimmt wird, ob zwei Sequenzen gleich sind, indem mit `comparer` zum Vergleichen von Elementen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> deren einzige Element zurückgegeben.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass es das einzige Element im zurückgibt `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> das einzige Element eines Arrays auswählen.  
  
 [!code-csharp[System.Linq.Queryable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#79)]
 [!code-vb[System.Linq.Queryable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />verfügt über mehr als ein Element aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> zurückzugebenden ein einzelnes Element aus.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das die Bedingung in <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass es das einzige Element im zurückgibt `source` , die die angegebene Bedingung erfüllt `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> das einzige Element eines Arrays auswählen, die eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#81)]
 [!code-vb[System.Linq.Queryable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Mehr als ein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> deren einzige Element zurückgegeben.</param>
        <summary>Gibt das einzige Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehr als ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz, oder <c>Standard</c>(<paramref name="TSource" />) Wenn die Sequenz keine Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass es das einzige Element im zurückgibt `source`, oder ein Standardwert, wenn `source` ist leer.  
  
 Die <xref:System.Linq.Queryable.SingleOrDefault%2A> Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> das einzige Element eines Arrays auswählen. Die zweite Abfrage veranschaulicht, dass <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> gibt einen Standardwert zurück, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Queryable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#83)]
 [!code-vb[System.Linq.Queryable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#83)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> um das Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von Seitenzahlen leer ist. Da der Standardwert für eine ganze Zahl 0 (null), die nicht in der Regel eine gültige Seitenzahl ist, muss der Standardwert stattdessen mit 1 angegeben. Die erste Ergebnisvariable wird nach Abschluss der Abfrage das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird durch Aufrufen von <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Queryable#133](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#133)]
 [!code-vb[System.Linq.Queryable#133](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#133)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />verfügt über mehr als ein Element aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> zurückzugebenden ein einzelnes Element aus.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz, das eine angegebene Bedingung erfüllt, oder einen Standardwert zurück, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Das einzige Element der Eingabesequenz, das die Bedingung in <paramref name="predicate" />, oder <c>Standard</c>(<paramref name="TSource" />), wenn kein solches Element gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass es das einzige Element im zurückgibt `source` , die die angegebene Bedingung erfüllt `predicate`, oder einen Standardwert, wenn kein solches Element vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> das einzige Element eines Arrays auswählen, die eine Bedingung erfüllt. Die zweite Abfrage veranschaulicht, dass <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> gibt einen Standardwert zurück, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#85)]
 [!code-vb[System.Linq.Queryable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mehr als ein Element erfüllt die Bedingung in <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Überspringt eine festgelegte Anzahl von Elementen in einer Sequenz und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält Elemente, die nach dem angegebenen Index in der Eingabesequenz auftreten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass es das erste überspringt `count` Elemente im `source` und gibt die übrigen Elemente zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> auf eine angegebene Anzahl von Elementen in einem sortierten Array übersprungen und die übrigen Elemente zurück.  
  
 [!code-csharp[System.Linq.Queryable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#87)]
 [!code-vb[System.Linq.Queryable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung "true ist", und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält Elemente aus <paramref name="source" /> ab dem ersten Element in der linearen Reihe, die nicht vom angegebenen Test bestehen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist er bezieht sich `predicate` auf jedes Element in `source` bis zu einem Element für die `predicate` "false" zurückgegeben. Dieses Element und alle übrigen Elemente werden zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Elemente eines Arrays zu überspringen, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Queryable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#88)]
 [!code-vb[System.Linq.Queryable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="predicate">Eine Funktion auf jedes Element auf eine Bedingung zu testen. der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung "true ist", und gibt dann die übrigen Elemente zurück. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält Elemente aus <paramref name="source" /> ab dem ersten Element in der linearen Reihe, die nicht vom angegebenen Test bestehen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist er bezieht sich `predicate` auf jedes Element in `source` bis zu einem Element für die `predicate` "false" zurückgegeben. Dieses Element und alle übrigen Elemente werden zurückgegeben. Der Index jedes Quellelements wird bereitgestellt, als das zweite Argument `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Elemente eines Arrays zu überspringen, solange eine Bedingung, die abhängig von der Index des Elements "true" ist.  
  
 [!code-csharp[System.Linq.Queryable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#89)]
 [!code-vb[System.Linq.Queryable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Decimal" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Double" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Int32" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Int64" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Single" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Summe der Werte in zurückgegeben `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> richtet sich nach der Implementierung des Typs des er `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <c>TSource</c>.</param>
        <param name="selector">Eine Projektionsfunktion auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Projektionsfunktion auf jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, ruft es die `selector` für jedes Element der `source` und gibt die Summe der resultierenden Werte zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen vom Anfang einer Sequenz zurück.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , enthält die angegebene Anzahl von Elementen vom Beginn des <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die ersten `count` Elemente vom Beginn des `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Elemente vom Anfang einer Sequenz zurückgegeben.  
  
 [!code-csharp[System.Linq.Queryable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#99)]
 [!code-vb[System.Linq.Queryable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung "true" ist.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , die Elemente aus der Eingabesequenz auftreten, die vor dem Element, an dem der Test gemäß, enthält <paramref name="predicate" /> nicht mehr erfolgreich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten, dass es angewendet wird `predicate` auf jedes Element in `source` bis zu einem Element für die `predicate` gibt `false`. Es gibt alle Elemente zurück, bis zu diesem Zeitpunkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Elemente vom Anfang einer Sequenz zurückgegeben werden, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Queryable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#100)]
 [!code-vb[System.Linq.Queryable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion auf jedes Element auf eine Bedingung zu testen. der zweite Parameter der Funktion stellt den Index des Elements in der Quellsequenz dar.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung "true" ist. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , die Elemente aus der Eingabesequenz auftreten, die vor dem Element, an dem der Test gemäß, enthält <paramref name="predicate" /> nicht mehr erfolgreich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten, dass es angewendet wird `predicate` auf jedes Element in `source` bis zu einem Element für die `predicate` gibt `false`. Es gibt alle Elemente zurück, bis zu diesem Zeitpunkt. Der Index jedes Quellelements wird bereitgestellt, als das zweite Argument `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> zurückzugebenden Elemente vom Anfang einer Sequenz, solange eine Bedingung, die für den Index des Elements wird "true" ist.  
  
 [!code-csharp[System.Linq.Queryable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#101)]
 [!code-vb[System.Linq.Queryable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellte zurückgegebenen <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass sie eine sekundäre Sortierung der Elemente des führt `source` anhand des Schlüssels, der durch den Aufruf ermittelt `keySelector` für jedes Element der `source`. Alle zuvor festgelegten Sortierreihenfolgen beibehalten werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> um eine nachfolgende Sortierung der Elemente in einer Sequenz durchführen.  
  
 [!code-csharp[System.Linq.Queryable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#102)]
 [!code-vb[System.Linq.Queryable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellte zurückgegebenen <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass sie eine sekundäre Sortierung der Elemente des führt `source` anhand des Schlüssels, der durch den Aufruf ermittelt `keySelector` für jedes Element der `source`. Alle zuvor festgelegten Sortierreihenfolgen beibehalten werden. Die `comparer` Parameter wird verwendet, um Schlüsselwerte verglichen werden soll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der Funktion dargestellte zurückgegebenen <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass sie eine sekundäre Sortierung der Elemente des führt `source` in absteigender Reihenfolge anhand des Schlüssels, der durch den Aufruf `keySelector` für jedes Element der `source`. Alle zuvor festgelegten Sortierreihenfolgen beibehalten werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von zurückgegeben wird das <c>KeySelector</c> Funktion.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Eine Auflistung, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter. Das Ergebnis des Aufrufs <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Typ umgewandelt wird <xref:System.Linq.IOrderedQueryable%601> und zurückgegeben.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Das erwartete Verhalten ist, dass sie eine sekundäre Sortierung der Elemente des führt `source` in absteigender Reihenfolge anhand des Schlüssels, der durch den Aufruf `keySelector` für jedes Element der `source`. Alle zuvor festgelegten Sortierreihenfolgen beibehalten werden. Die `comparer` Parameter wird verwendet, um Schlüsselwerte verglichen werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> um eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge mit einem benutzerdefinierten Vergleich durchführen.  
  
 [!code-csharp[System.Linq.Queryable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#103)]
 [!code-vb[System.Linq.Queryable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente die erste Menge für den union-Operation darstellen.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die union-Operation darstellen.</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Das erwartete Verhalten ist, die die Vereinigungsmenge der Elemente im `source1` und `source2` wird zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> um die Vereinigungsmenge von zwei Sequenzen zu erhalten.  
  
 [!code-csharp[System.Linq.Queryable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#109)]
 [!code-vb[System.Linq.Queryable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente die erste Menge für den union-Operation darstellen.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die union-Operation darstellen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" /> , die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> richtet sich nach der Implementierung des Typs von der `source1` Parameter. Das erwartete Verhalten ist, die die Vereinigungsmenge der Elemente im `source1` und `source2` wird zurückgegeben. Die `comparer` Parameter wird verwendet, um Werte zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> zu filtern.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält Elemente aus der Eingabesequenz, die die angegebene Bedingung erfüllen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente von zurückgegeben `source` , die die angegebene Bedingung erfüllen `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> um eine Sequenz zu filtern.  
  
 [!code-csharp[System.Linq.Queryable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#110)]
 [!code-vb[System.Linq.Queryable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" /> zu filtern.</param>
        <param name="predicate">Eine Funktion auf jedes Element auf eine Bedingung zu testen. der zweite Parameter der Funktion stellt den Index des Elements in der Quellsequenz dar.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> enthält Elemente aus der Eingabesequenz, die die angegebene Bedingung erfüllen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter vom Typ <xref:System.Linq.Expressions.Expression%601> , deren Typargument ist eines der <xref:System.Func%602> Typen. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben, und es wird kompiliert werden, um eine <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source` Parameter.  
  
 Das Abfrageverhalten aufgrund der Ausführung einer Ausdrucksbaumstruktur dar, das Aufrufen von darstellt, <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> richtet sich nach der Implementierung des Typs von der `source` Parameter. Es wird erwartet, dass die Elemente von zurückgegeben `source` , die die angegebene Bedingung erfüllen `predicate`. Der Index jedes Quellelements wird bereitgestellt, als das zweite Argument `predicate`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> zum Filtern einer Sequenz basierend auf ein Prädikat, das den Index der einzelnen Elemente enthält.  
  
 [!code-csharp[System.Linq.Queryable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#111)]
 [!code-vb[System.Linq.Queryable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2, System.Linq.Expressions.Expression&lt;Func&lt;TFirst,TSecond,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TFirst,TSecond,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Ergebnissequenz.</typeparam>
        <param name="source1">Die erste Sequenz zusammenführen.</param>
        <param name="source2">Die zweite Sequenz, die zusammengeführt werden soll.</param>
        <param name="resultSelector">Eine Funktion, die angibt, wie die Elemente von zwei Sequenzen zusammengeführt.</param>
        <summary>Führt zwei Sequenzen unter Verwendung der angegebenen Prädikatfunktion zusammen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> , zusammengeführte Elemente von zwei Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Zip%2A> Methode generiert eine <xref:System.Linq.Expressions.MethodCallExpression> , Aufruf darstellt <xref:System.Linq.Queryable.Zip%2A> sich selbst als konstruierte generische Methode. Übergibt dann die <xref:System.Linq.Expressions.MethodCallExpression> auf der <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode der <xref:System.Linq.IQueryProvider> dargestellte der <xref:System.Linq.IQueryable.Provider%2A> Eigenschaft von der `source1` Parameter.  
  
 Die Methode führt jedes Element der ersten Sequenz mit einem Element mit dem gleichen Index in der zweiten Sequenz zusammen. Wenn die Sequenzen nicht die gleiche Anzahl von Elementen verfügen, führt die Methode Sequenzen zusammen, bis das Ende eines dieser Elemente erreicht. Z. B. wenn eine Sequenz verfügt über drei Elemente und die andere vier hat, müssen die resultierende Sequenz nur drei Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Queryable.Zip%2A> Methode, um zwei Sequenzen zusammenzuführen.  
  
 [!code-csharp[System.Linq.Queryable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#200)]
 [!code-vb[System.Linq.Queryable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
