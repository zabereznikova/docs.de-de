<Type Name="ParallelEnumerable" FullName="System.Linq.ParallelEnumerable">
  <TypeSignature Language="C#" Value="public static class ParallelEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ParallelEnumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Satz von Methoden zum Abfragen von Objekten bereit, die ParallelQuery{TSource} implementieren. Dies ist die parallele Entsprechung von <see cref="T:System.Linq.Enumerable" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.ParallelQuery{``0},System.Func{``0,``0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="func" /> oder <paramref name="resultSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TAccumulate&gt; seedFactory, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TAccumulate&gt; seedFactory, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seedFactory" Type="System.Func&lt;TAccumulate&gt;" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seedFactory">Eine Funktion, die den Anfangsakkumulatorwert zurückgibt.</param>
        <param name="updateAccumulatorFunc">Eine Akkumulatorfunktion, die für jedes Element in einer Partition aufgerufen werden soll.</param>
        <param name="combineAccumulatorsFunc">Eine Akkumulatorfunktion, die für das zurückgegebene Akkumulatorergebnis jeder Partition aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Diese Überladung ist in der sequenziellen Implementierung nicht verfügbar.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist spezifisch für parallelisierte Abfragen. Eine parallelisierte Abfrage möglicherweise Daten Quellsequenz in mehrere Untersequenzen (Partitionen) partitionieren. Die `updateAccumulatorFunc` für jedes Element innerhalb von Partitionen aufgerufen wird. Jede Partition ergibt dann ein einzelnes akkumulierte Ergebnis. Die `combineAccumulatorsFunc` wird aufgerufen, auf die Ergebnisse der einzelnen Partitionen, um ein einzelnes Element zu erhalten. Dieses Element wird dann von transformiert die `resultSelector` Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="seedFactory" /> oder <paramref name="updateAccumulatorFunc" /> oder <paramref name="combineAccumulatorsFunc" /> oder <paramref name="resultSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="updateAccumulatorFunc">Eine Akkumulatorfunktion, die für jedes Element in einer Partition aufgerufen werden soll.</param>
        <param name="combineAccumulatorsFunc">Eine Akkumulatorfunktion, die für das zurückgegebene Akkumulatorergebnis jeder Partition aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Diese Überladung ist in der sequenziellen Implementierung nicht verfügbar.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist spezifisch für eine parallelisierte Abfragen verarbeitet werden. Eine parallelisierte Abfrage möglicherweise Daten Quellsequenz in mehrere Untersequenzen (Partitionen) partitionieren. Die `updateAccumulatorFunc` für jedes Element innerhalb von Partitionen aufgerufen wird. Jede Partition ergibt dann ein einzelnes akkumulierte Ergebnis. Die `combineAccumulatorsFunc` wird aufgerufen, auf die Ergebnisse der einzelnen Partitionen, um ein einzelnes Element zu erhalten. Dieses Element wird dann von transformiert die `resultSelector` Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="updateAccumulatorFunc" /> oder <paramref name="combineAccumulatorsFunc" /> oder <paramref name="resultSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.All``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, auf deren Elemente das Prädikat angewendet werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt parallel, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns>TRUE, wenn jedes Element der Quellsequenz im angegebenen Prädikat erfolgreich überprüft wird oder wenn die Sequenz leer ist, andernfalls FALSE.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, für die überprüft werden soll, ob sie leer ist.</param>
        <summary>Bestimmt, ob eine parallele Sequenz Elemente enthält.</summary>
        <returns>True, wenn die Quellsequenz Elemente enthält, andernfalls false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der Methode bewirkt, dass eine vollständig gepuffert Zusammenführung ausgeführt werden, bevor das Ergebnis zurückgegeben wird. Der Merge-Verhalten kann beeinträchtigt oder dazu führen, dass ein Speicherausnahmefehler in großen aufzählbare Elemente bereit. Um die Merge-Verhalten zu vermeiden, verwenden Sie die Überladung der Namenseinträge, die einen Func-Parameter akzeptiert, andernfalls wird verwenden Sie eine alternative Methode wie z. B. "FirstOrDefault".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, auf deren Elemente das Prädikat angewendet werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt parallel, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns>TRUE, wenn Elemente der Quellsequenz im angegebenen Prädikat erfolgreich überprüft werden, andernfalls FALSE.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, die in <see cref="T:System.Collections.Generic.IEnumerable`1" /> umgewandelt werden soll.</param>
        <summary>Konvertiert ein <see cref="T:System.Linq.ParallelQuery`1" /> in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, um die sequenzielle Auswertung der Abfrage zu erzwingen.</summary>
        <returns>Die als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisierte Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsOrdered (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsOrdered(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered(System.Linq.ParallelQuery)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht die Behandlung einer Datenquelle als sortierte Datenquelle, indem die Standardeinstellung "unsortiert" überschrieben wird. AsOrdered kann nur für nicht generische Sequenzen aufgerufen werden, die von AsParallel, ParallelEnumerable.Range und ParallelEnumerable.Repeat zurückgegeben werden.</summary>
        <returns>Die Quellsequenz, die die ursprüngliche Reihenfolge in den nachfolgenden Abfrageoperatoren beibehält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwischen Leistung und Beibehalten der Reihenfolge, in der parallelen Verarbeitung ist eine natürliche Spannung vorhanden. Standardmäßig verhält sich eine parallelisierte Abfrage wie die Sortierung der Ergebnisse ist willkürlich, es sei denn, AsOrdered übernommen wird, oder ein expliziter OrderBy-Operator in der Abfrage vorhanden ist. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Wird ausgelöst, wenn <paramref name="source" /> enthält keine Elemente.  
  
 - oder -   
  
 Wenn AsOrdered in der Mitte einer Abfrage aufgerufen wird. Es ist zulässig, sofort nach der aufgerufen werden <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />, <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" /> oder <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsOrdered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsOrdered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht die Behandlung einer Datenquelle als sortierte Datenquelle, indem die Standardeinstellung "unsortiert" überschrieben wird. AsOrdered kann nur für generische Sequenzen aufgerufen werden, die von AsParallel, ParallelEnumerable.Range und ParallelEnumerable.Repeat zurückgegeben werden.</summary>
        <returns>Die Quellsequenz, die die ursprüngliche Reihenfolge in den nachfolgenden Abfrageoperatoren beibehält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwischen Leistung und Beibehalten der Reihenfolge, in der parallelen Verarbeitung ist eine natürliche Spannung vorhanden. Standardmäßig verhält sich eine parallelisierte Abfrage wie die Sortierung der Ergebnisse ist willkürlich, es sei denn, AsOrdered übernommen wird, oder ein expliziter OrderBy-Operator in der Abfrage vorhanden ist. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Wird ausgelöst, wenn <paramref name="source" /> enthält keine Elemente.  
  
 - oder -   
  
 Wenn <paramref name="source" /> ist keine von AsParallel, ParallelEnumerable.Range und ParallelEnumerable.Repeat.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AsParallel">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für PLINQ die Abfrage gebunden. Weitere Informationen finden Sie unter [Parallel LINQ (PLINQ) (Paralleles LINQ (PLINQ))](~/docs/standard/parallel-programming/parallel-linq-plinq.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AsParallel">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsParallel (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsParallel(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das in ein <see cref="T:System.Linq.ParallelQuery" /> konvertiert werden soll.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <returns>Die Quelle als ParallelQuery, die an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.ParallelEnumerable.Cast%2A> -Operator kann verwendet werden, eine ParallelQuery in eine ParallelQuery(T) konvertiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Concurrent.Partitioner&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Concurrent.Partitioner{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein Partitionierer für die Eingabesequenz.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage mit einem benutzerdefinierten Partitionierer, der für die Aufteilung der Eingabesequenz in Partitionen zuständig ist, als Quelle.</summary>
        <returns>Die <paramref name="source" /> als ParallelQuery, die an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Quelle Partitionierer GetOrderedPartitions die Methode wird verwendet, wenn Sortierung aktiviert ist, während der Partitionierer GetPartitions verwendet wird, wenn die Sortierung nicht ist aktiviert (Standard). Die Quelle Partitionierer GetDynamicPartitions und GetDynamicOrderedPartitions des werden nicht verwendet. Weitere Informationen und Beispiele finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das in ein <see cref="T:System.Linq.ParallelQuery`1" /> konvertiert werden soll.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <returns>Die Quelle als <see cref="T:System.Linq.ParallelQuery`1" />, das an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsSequential&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsSequential&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsSequential&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsSequential``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.ParallelQuery`1" />, das in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> konvertiert werden soll.</param>
        <summary>Konvertiert ein <see cref="T:System.Linq.ParallelQuery`1" /> in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, um die sequenzielle Auswertung der Abfrage zu erzwingen.</summary>
        <returns>Die Quelle als <see cref="T:System.Collections.Generic.IEnumerable`1" />, das an sequenzielle Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md) und [wie: Sortieren von Steuerelement in einer PLINQ-Abfrage](~/docs/standard/parallel-programming/how-to-control-ordering-in-a-plinq-query.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsUnordered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsUnordered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsUnordered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsUnordered``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht es, eine Zwischenabfrage so zu behandeln, als würde keine Reihenfolge zwischen den Elementen vorausgesetzt.</summary>
        <returns>Die Quellsequenz mit beliebiger Reihenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 AsUnordered kann Leistungsvorteile bieten, wenn Sortierung in einem Teil einer Abfrage nicht erforderlich ist. Standardmäßig behandelt PLINQ eine Eingabesequenz als ungeordnete, wenn OrderBy oder AsOrdered angegeben wird. Wenn Sortierung aktiviert wurde und nicht mehr erforderlich ist, jedoch dann AsUnordered deaktivieren in der Mitte der Abfrage verwendet werden kann, und kann dies die Leistungsvorteile. Der AsUnordered-Operator selbst wird nicht die Quellsequenz zufällige; die Reihenfolge Anforderung für nachfolgende Operatoren einfach entfernt. Wenn die Quelle sortiert ist, möglicherweise nachfolgende Operatoren, Sortierung, wenn es effizienter, zu diesem Zweck wird beibehalten. AsUnordered kann an einer beliebigen Stelle in der Abfrage aufgerufen werden. Er muss nicht sofort nach AsParallel aufgerufen werden. Weitere Informationen finden Sie unter [Grundlagen zur Beschleunigung in PLINQ](~/docs/standard/parallel-programming/understanding-speedup-in-plinq.md) und [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Die Quellsequenz.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Gibt den Durchschnittswert der Sequenz von Werten zurück.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet werden soll. Der Durchschnitt der Sequenz von Werten.<paramref name="source" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">(Als interne Ausnahme wird ausgelöst, eine <see cref="T:System.AggregateException" />). Die <paramref name="selector" /> Funktion gibt einen Wert größer als "MaxValue" für den Typ des Elements zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.ParallelQuery)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, konvertiert die Elemente eines <c>Quelle</c> an.</typeparam>
        <param name="source">Die Sequenz, die die zu konvertierenden Elemente enthält.</param>
        <summary>Konvertiert die Elemente einer ParallelQuery in den angegebenen Typ.</summary>
        <returns>Eine Sequenz, die jedes in den angegebenen Typ konvertierte Element der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quellsequenz konnte nicht konvertiert werden, um <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Concat-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Concat mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Concat-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Die erste zu verkettende Sequenz.</param>
        <param name="second">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei parallele Sequenzen.</summary>
        <returns>Eine Sequenz, die die verketteten Elemente der zwei Eingabesequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt parallel mithilfe des Standardgleichheitsvergleichs, ob eine Sequenz ein angegebenes Element enthält.</summary>
        <returns>True, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein Gleichheitsvergleich zum Vergleichen von Werten.</param>
        <summary>Bestimmt parallel mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, ob eine Sequenz ein angegebenes Element enthält.</summary>
        <returns>True, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt die Anzahl von Elementen in einer parallelen Sequenz zurück.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int32.MaxValue" />. (In diesem Fall wird der "InnerException" <see cref="T:System.OverflowException" />) – oder – eine oder mehrere Ausnahmen, die während der Auswertung der Abfrage aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Zahl zurück, die die Anzahl von Elementen in der angegebenen parallelen Sequenz angibt, die eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int32.MaxValue" />. (In diesem Fall wird der "InnerException" <see cref="T:System.OverflowException" />) – oder – eine oder mehrere Ausnahmen, die während der Auswertung der Abfrage aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, für die ein Standardwert zurückgegeben werden soll, wenn sie leer ist.</param>
        <summary>Gibt die Elemente der angegebenen parallelen Sequenz oder den Standardwert des Typparameters in einer Singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Eine Sequenz, die default(TSource) enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, für die der angegebene Wert zurückgegeben werden soll, wenn sie leer ist.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen parallelen Sequenz zurück, oder den angegebenen Wert in einer Singletonauflistung, wenn die Sequenz leer ist.</summary>
        <returns>Eine Sequenz, die defaultValue enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <summary>Gibt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten unterschiedliche Elemente aus einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten unterschiedliche Elemente aus einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer parallelen Sequenz zurück.</summary>
        <returns>Das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 oder größer als oder gleich der Anzahl der Elemente im <paramref name="source" />.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer parallelen Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns>default(TSource), wenn der Index außerhalb der Begrenzungen der Quellsequenz liegt, andernfalls das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Der Typ, der dem Typparameter der zurückgegebenen generischen Sequenz zugewiesen werden soll.</typeparam>
        <summary>Gibt ein leeres ParallelQuery{TResult} mit dem angegebenen Typargument zurück.</summary>
        <returns>Eine leere Sequenz, deren Typargument <paramref name="TResult" /> ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Except-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung zu unterbinden, außer mit einer linken Datenquelle des Typs <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde Except-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren auch in der ersten Sequenz enthaltenen Elemente aus der zurückgegebenen Sequenz entfernt werden.</param>
        <summary>Erzeugt die Differenz zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Except-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung zu unterbinden, außer mit einer linken Datenquelle des Typs <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde Except-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren auch in der ersten Sequenz enthaltenen Elemente aus der zurückgegebenen Sequenz entfernt werden.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" />zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten die Differenzmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren erstes Element zurückgegeben werden soll.</param>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück.</summary>
        <returns>Das erste Element in der angegebenen Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element in einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element im <paramref name="source" /> erfüllt die Bedingung in <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren erstes Element zurückgegeben werden soll.</param>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>default(TSource), wenn <paramref name="source" /> leer ist, andernfalls das erste Element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element der parallelen Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>default(TSource), wenn <paramref name="source" /> leer ist oder die vom Prädikat angegebene Überprüfung für kein Element erfolgreich ausgeführt wird, andernfalls das erste Element in <paramref name="source" />, für das die vom Prädikat angegebene Überprüfung erfolgreich ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForAll&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Action&lt;TSource&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForAll&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.ParallelQuery{``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Linq.ParallelQuery`1" /> , dessen Elemente durch verarbeitet werden <c>Aktion</c>.</param>
        <param name="action">Eine Aktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Ruft parallel die angegebene Aktion für jedes Element in der <paramref name="source" /> auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine effiziente Möglichkeit, die Ausgabe eine parallelisierte Abfrage verarbeitet werden, da es keinen am Ende einen Merge-Schritt benötigt. Weitere Informationen finden Sie unter [Zusammenführungsoptionen in PLINQ](~/docs/standard/parallel-programming/merge-options-in-plinq.md) oder [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md). Da diese Methode ein Nebeneffekt erzeugt, können sie beobachten Sie die tatsächliche Reihenfolge der Ausführung in einer parallelen Abfrage verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>&gt;.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.OrderedParallelQuery`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.OrderedParallelQuery`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in der IGrouping.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einer IGrouping zugeordnet wird.</param>
        <param name="comparer">Ein IComparer{TSource} zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer Schlüsselauswahlfunktion. Die Schlüssel werden mithilfe eines Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine Folge von Gruppen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion auf jedes Quellelement einem Element in einer IGrouping zugeordnet&lt;TKey, TElement&gt;.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem IGrouping{Key, TElement} zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese GroupJoin-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von GroupJoin mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde GroupJoin-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese GroupJoin-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von GroupJoin mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde GroupJoin-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Intersect-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Intersect mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Intersect-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <summary>Erzeugt die Schnittmenge zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Intersect-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Intersect mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Intersect-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen IEqualityComparer{T} zum Vergleichen von Werten die Schnittmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Join-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Join mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls, der Join-Operator erscheint die parallele Implementierung gebunden werden, würde aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Join-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung der Join mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls, der Join-Operator erscheint die parallele Implementierung gebunden werden, würde aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der das letzte Element zurückgegeben werden soll.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück.</summary>
        <returns>Der Wert an der letzten Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element im <paramref name="source" /> erfüllt die Bedingung in <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>default(), wenn die Quellsequenz leer ist, andernfalls das letzte Element in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>default(), wenn die Sequenz leer ist oder keine Elemente von der Prädikatfunktion erfolgreich überprüft werden, andernfalls das letzte Element, das von der Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt eine Int64 zurück, die die Gesamtanzahl von Elementen in einer parallelen Sequenz darstellt.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Das berechnete Ergebnis ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Int64 zurück, die die Anzahl von Elementen in einer parallelen Sequenz darstellt, die eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Das berechnete Ergebnis ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in der Quellsequenz.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält und <paramref name="TSource" /> ist ein NULL-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.ParallelQuery)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Die Sequenz, deren Elemente gefiltert werden sollen.</param>
        <summary>Filtert die Elemente einer ParallelQuery anhand eines angegebenen Typs.</summary>
        <returns>Eine Sequenz, die Elemente des Typs aus der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Um eine stabile Sortierung zu erzielen, ändern Sie eine Abfrage des Formulars: sortiert Var = Quelle. Select((e,i) = > new {E = e, I = i}). OrderBy((v) = > v.e). ThenBy (V = > v.i entstanden ist). Select((v) = > v.e);  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in aufsteigender Reihenfolge.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="KeySelector" /> ist ein null-Verweis (Nothing in Visual Basic)...</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Wert der ersten ganzen Zahl in der Sequenz.</param>
        <param name="count">Die Anzahl der aufeinander folgenden ganzen Zahlen, die generiert werden sollen.</param>
        <summary>Generiert eine parallele Sequenz von ganzen Zahlen in einem angegebenen Bereich.</summary>
        <returns>Ein IEnumerable&lt;Int32&gt; in c# oder IEnumerable (Of Int32) in Visual Basic, das einen Bereich sequenzieller ganzer Zahlen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />ist kleiner als 0 - oder - <paramref name="start" />  +  <paramref name="count" /> -1 ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Werts, der in der Ergebnissequenz wiederholt werden soll.</typeparam>
        <param name="element">Der zu wiederholende Wert.</param>
        <param name="count">Die gewünschte Anzahl der Wiederholungen des Werts in der generierten Sequenz.</param>
        <summary>Generiert eine parallele Sequenz, die einen wiederholten Wert enthält.</summary>
        <returns>Eine Sequenz, die einen wiederholten Wert enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer parallelen Sequenz um.</summary>
        <returns>Eine Sequenz , deren Elemente den Elementen der Eingabesequenz in umgekehrter Reihenfolge entsprechen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert parallel jedes Element einer Sequenz in ein neues Format, indem der Index des Elements integriert wird.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der Transformationsfunktion für jedes Element von <paramref name="source" /> ist, basierend auf dem für <paramref name="selector" /> bereitgestellten Index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Eine oder mehrere Ausnahmen sind während der Auswertung der Abfrage aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt. Diese Bedingung könnte im Streamingmodus auftreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert parallel jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis des Aufrufs einer Transformationsfunktion für jedes Element von <paramref name="source" /> sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz parallel in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzelnen Sequenz zusammen.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformierenfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz parallel in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzelnen Sequenz zusammen. Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformierenfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Zwischenelemente erhobene <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der Ergebnissequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformationsfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformationsfunktion <paramref name="collectionSelector" /> für jedes Element von <paramref name="source" /> auf der Basis des für <paramref name="collectionSelector" /> angegebenen Indexes und die anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Zwischenelemente erhobene <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der zurückzugebende Elementtyp.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformationsfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf. Der Index jedes Quellelements wird im projizierten Zwischenformat des jeweiligen Elements verwendet.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformationsfunktion <paramref name="collectionSelector" /> für jedes Element von <paramref name="source" /> auf der Basis des für <paramref name="collectionSelector" /> angegebenen Indexes und die anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese SequenceEqual-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von SequenceEqual mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der SequenceEqual-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wird ausgelöst, jedes Mal, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, die mit einer zweiten Sequenz verglichen werden soll.</param>
        <param name="second">Eine Sequenz, die mit der ersten Eingabesequenz verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei parallele Sequenzen gleich sind, indem die Elemente mithilfe des Standardgleichheitsvergleichs für ihren Typ verglichen werden.</summary>
        <returns>True, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente durch den Standardgleichheitsvergleich für ihren Typ als gleich bestimmt werden, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese SequenceEqual-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von SequenceEqual mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der SequenceEqual-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit binden sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wird ausgelöst, jedes Mal, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, die den Vergleich <c>zweiten</c>.</param>
        <param name="second">Eine Sequenz, die mit der ersten Eingabesequenz verglichen werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt, ob zwei parallele Sequenzen gleich sind, indem ihre Elemente mithilfe eines angegebenen IEqualityComparer{T} verglichen werden.</summary>
        <returns>True, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente durch den Standardgleichheitsvergleich für ihren Typ als gleich bestimmt werden, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element. -oder-die Eingabesequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das eine Bedingung erfüllt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Eine oder mehrere Ausnahmen sind während der Auswertung der Abfrage aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />. -oder- Mehrere Elemente erfüllen die Bedingung in <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente in der Sequenz vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz oder default(), wenn die Sequenz keine Elemente enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt, oder einen Standardwert, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Gibt das einzige Element der Eingabesequenz zurück, das die Bedingung erfüllt, oder default(), wenn ein solches Element nicht gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />ist leer oder mehrere Elemente zurückgegeben werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Umgeht eine festgelegte Anzahl von Elementen in einer parallelen Sequenz und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die nach dem angegebenen Index in der Eingabesequenz auftreten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anzahl > Quelle. Count(), werden keine Elemente zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Anzahl ist größer als<see cref="F:System.Int32.MaxValue" /></exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer parallelen Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, für das die vom Prädikat angegebene Überprüfung nicht erfolgreich ausgeführt wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer parallelen Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, für das die vom Prädikat angegebene Überprüfung nicht erfolgreich ausgeführt wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. -oder-eine oder mehrere Ausnahmen, die während der Auswertung der Abfrage aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in der Quellsequenz.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. -oder-eine oder mehrere Ausnahmen, die während der Auswertung der Abfrage aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen ab dem Anfang einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die die festgelegte Anzahl von Elementen ab dem Anfang der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer parallelen Sequenz zurück, solange eine angegebene Bedingung true ist.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Gibt Elemente aus einer parallelen Sequenz zurück, solange eine angegebene Bedingung true ist. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von dieser Abfrage aufgelistet.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Führt parallel mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Eine Sequenz, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Führt parallel mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch.</summary>
        <returns>Eine Sequenz, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist im Gegensatz zu sequenziellen Implementierung keine stabile Sortierung. Siehe die Hinweise für <xref:System.Linq.ParallelEnumerable.OrderBy%2A> eine Methode zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Array erstellt werden soll.</param>
        <summary>Erstellt ein Array aus einem <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Ein Array, das die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" />erzeugt einen Schlüssel, der null-Verweis (Nothing in Visual Basic) ist. -"oder" - <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt eine <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" />erzeugt einen Schlüssel, der null-Verweis (Nothing in Visual Basic) ist. -"oder" - <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformierenfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" />erzeugt einen Schlüssel, der null-Verweis (Nothing in Visual Basic) ist. -"oder" - <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" />erzeugt einen Schlüssel, der null-Verweis (Nothing in Visual Basic) ist. -"oder" - <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.List`1" /> erstellt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.List`1" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1" /> , die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder ein null-Verweis (Nothing in Visual Basic) ist.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformierenfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Eine Suche&lt;(der &lt;(TKey, TElement&gt;)&gt;), die Werte des Typs TElement ausgewählt, die aus der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Union-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Union mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Union-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit binden sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <summary>Erzeugt die Vereinigungsmenge zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>Eine Sequenz, die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Union-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Union mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Union-Operator erscheint die parallele Implementierung gebunden werden, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe eines angegebenen IEqualityComparer{T} die Vereinigungsmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine zu filternde Sequenz.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert parallel eine Sequenz von Werten nach einem Prädikat.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine zu filternde Sequenz.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert parallel eine Sequenz von Werten nach einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithCancellation&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithCancellation&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithCancellation&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithCancellation``1(System.Linq.ParallelQuery{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="cancellationToken">Ein Abbruchtoken.</param>
        <summary>Legt das <see cref="T:System.Threading.CancellationToken" /> fest, das der Abfrage zugeordnet werden soll.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend dem registrierten Abbruchtoken.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" /> zugeordneten der <paramref name="cancellationToken" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="WithCancellation" />wird mehrmals in der Abfrage verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithDegreeOfParallelism&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithDegreeOfParallelism&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int degreeOfParallelism);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithDegreeOfParallelism&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 degreeOfParallelism) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithDegreeOfParallelism``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="degreeOfParallelism" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine ParallelQuery, für die der Grenzwert für den Grad der Parallelität festgelegt werden soll.</param>
        <param name="degreeOfParallelism">Der Grad der Parallelität für die Abfrage. Der Standardwert ist Math.Min(<see cref="P:System.Environment.ProcessorCount" />, <see langword="MAX_SUPPORTED_DOP" />), wobei <see langword="MAX_SUPPORTED_DOP" /> gleich 512 ist.</param>
        <summary>Legt den Grad der Parallelität für eine Abfrage fest. Der Grad der Parallelität ist die maximale Anzahl gleichzeitig ausgeführter Aufgaben, die zum Verarbeiten der Abfrage verwendet werden.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle mit festgelegtem Grenzwert für den Grad der Parallelität darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="degreeOfParallelism" />ist kleiner als 1 oder größer als 511.</exception>
        <exception cref="T:System.InvalidOperationException">WithDegreeOfParallelism wird mehrmals in der Abfrage verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithExecutionMode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithExecutionMode&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelExecutionMode executionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithExecutionMode&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelExecutionMode executionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithExecutionMode``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelExecutionMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="executionMode" Type="System.Linq.ParallelExecutionMode" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="executionMode">Der Modus, in dem die Abfrage ausgeführt werden soll.</param>
        <summary>Legt den Ausführungsmodus der Abfrage fest.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend dem registrierten Ausführungsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Ausführungsmodus angibt, ob PLINQ versucht, auf die sequenzielle Ausführung zurückgreift, wenn es bestimmte Abfrageformen erkennt. Weitere Informationen und Beispiele finden Sie unter [Vorgehensweise: Angeben des Ausführungsmodus in PLINQ](~/docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="executionMode" /> ist kein gültiger <see cref="T:System.Linq.ParallelExecutionMode" />-Wert.</exception>
        <exception cref="T:System.InvalidOperationException">WithExecutionMode wird mehrmals in der Abfrage verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithMergeOptions&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithMergeOptions&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithMergeOptions&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelMergeOptions mergeOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithMergeOptions``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelMergeOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="mergeOptions" Type="System.Linq.ParallelMergeOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="mergeOptions">Die Mergeoptionen, die für diese Abfrage festgelegt werden sollen.</param>
        <summary>Legt die Mergeoptionen für diese Abfrage fest. Diese Optionen geben an, wie die Abfrage die Ausgabe puffert.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend den registrierten Mergeoptionen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mergeOptions" /> ist kein gültiger <see cref="T:System.Linq.ParallelMergeOptions" />-Wert.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="WithMergeOptions" />wird mehrmals in der Abfrage verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TSecond">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Zip-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist vorhanden, um die Verwendung von Zip mit einer linken Datenquelle des Typs zu unterbinden, <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle des Typs <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Zip-Operator erscheint Binden an das parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn diese Methode aufgerufen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Linq.ParallelQuery&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Rückgabeelemente.</typeparam>
        <param name="first">Die erste Sequenz, die gezippt werden soll.</param>
        <param name="second">Die zweite Sequenz, die gezippt werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Führt parallel zwei Sequenzen unter Verwendung der angegebenen Prädikatfunktion zusammen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch paarweises Ausführen von <paramref name="resultSelector" /> für zwei Sequenzen ermittelt werden. Wenn die Sequenzlängen ungleich sind, wird auf die Länge der kürzeren Sequenz gekürzt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" />oder <paramref name="second" /> oder <paramref name="resultSelector" /> ist ein null-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
